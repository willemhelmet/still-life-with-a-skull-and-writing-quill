(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const l of r.addedNodes)l.tagName==="LINK"&&l.rel==="modulepreload"&&n(l)}).observe(document,{childList:!0,subtree:!0});function e(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function n(i){if(i.ep)return;i.ep=!0;const r=e(i);fetch(i.href,r)}})();function uS(s){return s&&s.__esModule&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s}var U_={exports:{}},Ng={};var l1;function vQ(){if(l1)return Ng;l1=1;var s=Symbol.for("react.transitional.element"),t=Symbol.for("react.fragment");function e(n,i,r){var l=null;if(r!==void 0&&(l=""+r),i.key!==void 0&&(l=""+i.key),"key"in i){r={};for(var u in i)u!=="key"&&(r[u]=i[u])}else r=i;return i=r.ref,{$$typeof:s,type:n,key:l,ref:i!==void 0?i:null,props:r}}return Ng.Fragment=t,Ng.jsx=e,Ng.jsxs=e,Ng}var c1;function EQ(){return c1||(c1=1,U_.exports=vQ()),U_.exports}var pn=EQ(),L_={exports:{}},on={};var u1;function _Q(){if(u1)return on;u1=1;var s=Symbol.for("react.transitional.element"),t=Symbol.for("react.portal"),e=Symbol.for("react.fragment"),n=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),r=Symbol.for("react.consumer"),l=Symbol.for("react.context"),u=Symbol.for("react.forward_ref"),A=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),m=Symbol.for("react.lazy"),g=Symbol.for("react.activity"),y=Symbol.iterator;function v(V){return V===null||typeof V!="object"?null:(V=y&&V[y]||V["@@iterator"],typeof V=="function"?V:null)}var C={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},I=Object.assign,S={};function E(V,st,xt){this.props=V,this.context=st,this.refs=S,this.updater=xt||C}E.prototype.isReactComponent={},E.prototype.setState=function(V,st){if(typeof V!="object"&&typeof V!="function"&&V!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,V,st,"setState")},E.prototype.forceUpdate=function(V){this.updater.enqueueForceUpdate(this,V,"forceUpdate")};function B(){}B.prototype=E.prototype;function w(V,st,xt){this.props=V,this.context=st,this.refs=S,this.updater=xt||C}var Q=w.prototype=new B;Q.constructor=w,I(Q,E.prototype),Q.isPureReactComponent=!0;var R=Array.isArray;function D(){}var U={H:null,A:null,T:null,S:null},P=Object.prototype.hasOwnProperty;function z(V,st,xt){var j=xt.ref;return{$$typeof:s,type:V,key:st,ref:j!==void 0?j:null,props:xt}}function L(V,st){return z(V.type,st,V.props)}function k(V){return typeof V=="object"&&V!==null&&V.$$typeof===s}function Y(V){var st={"=":"=0",":":"=2"};return"$"+V.replace(/[=:]/g,function(xt){return st[xt]})}var W=/\/+/g;function K(V,st){return typeof V=="object"&&V!==null&&V.key!=null?Y(""+V.key):st.toString(36)}function nt(V){switch(V.status){case"fulfilled":return V.value;case"rejected":throw V.reason;default:switch(typeof V.status=="string"?V.then(D,D):(V.status="pending",V.then(function(st){V.status==="pending"&&(V.status="fulfilled",V.value=st)},function(st){V.status==="pending"&&(V.status="rejected",V.reason=st)})),V.status){case"fulfilled":return V.value;case"rejected":throw V.reason}}throw V}function H(V,st,xt,j,Rt){var dt=typeof V;(dt==="undefined"||dt==="boolean")&&(V=null);var pt=!1;if(V===null)pt=!0;else switch(dt){case"bigint":case"string":case"number":pt=!0;break;case"object":switch(V.$$typeof){case s:case t:pt=!0;break;case m:return pt=V._init,H(pt(V._payload),st,xt,j,Rt)}}if(pt)return Rt=Rt(V),pt=j===""?"."+K(V,0):j,R(Rt)?(xt="",pt!=null&&(xt=pt.replace(W,"$&/")+"/"),H(Rt,st,xt,"",function(ce){return ce})):Rt!=null&&(k(Rt)&&(Rt=L(Rt,xt+(Rt.key==null||V&&V.key===Rt.key?"":(""+Rt.key).replace(W,"$&/")+"/")+pt)),st.push(Rt)),1;pt=0;var qt=j===""?".":j+":";if(R(V))for(var Wt=0;Wt<V.length;Wt++)j=V[Wt],dt=qt+K(j,Wt),pt+=H(j,st,xt,dt,Rt);else if(Wt=v(V),typeof Wt=="function")for(V=Wt.call(V),Wt=0;!(j=V.next()).done;)j=j.value,dt=qt+K(j,Wt++),pt+=H(j,st,xt,dt,Rt);else if(dt==="object"){if(typeof V.then=="function")return H(nt(V),st,xt,j,Rt);throw st=String(V),Error("Objects are not valid as a React child (found: "+(st==="[object Object]"?"object with keys {"+Object.keys(V).join(", ")+"}":st)+"). If you meant to render a collection of children, use an array instead.")}return pt}function tt(V,st,xt){if(V==null)return V;var j=[],Rt=0;return H(V,j,"","",function(dt){return st.call(xt,dt,Rt++)}),j}function it(V){if(V._status===-1){var st=V._result;st=st(),st.then(function(xt){(V._status===0||V._status===-1)&&(V._status=1,V._result=xt)},function(xt){(V._status===0||V._status===-1)&&(V._status=2,V._result=xt)}),V._status===-1&&(V._status=0,V._result=st)}if(V._status===1)return V._result.default;throw V._result}var ot=typeof reportError=="function"?reportError:function(V){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var st=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof V=="object"&&V!==null&&typeof V.message=="string"?String(V.message):String(V),error:V});if(!window.dispatchEvent(st))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",V);return}console.error(V)},At={map:tt,forEach:function(V,st,xt){tt(V,function(){st.apply(this,arguments)},xt)},count:function(V){var st=0;return tt(V,function(){st++}),st},toArray:function(V){return tt(V,function(st){return st})||[]},only:function(V){if(!k(V))throw Error("React.Children.only expected to receive a single React element child.");return V}};return on.Activity=g,on.Children=At,on.Component=E,on.Fragment=e,on.Profiler=i,on.PureComponent=w,on.StrictMode=n,on.Suspense=A,on.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=U,on.__COMPILER_RUNTIME={__proto__:null,c:function(V){return U.H.useMemoCache(V)}},on.cache=function(V){return function(){return V.apply(null,arguments)}},on.cacheSignal=function(){return null},on.cloneElement=function(V,st,xt){if(V==null)throw Error("The argument must be a React element, but you passed "+V+".");var j=I({},V.props),Rt=V.key;if(st!=null)for(dt in st.key!==void 0&&(Rt=""+st.key),st)!P.call(st,dt)||dt==="key"||dt==="__self"||dt==="__source"||dt==="ref"&&st.ref===void 0||(j[dt]=st[dt]);var dt=arguments.length-2;if(dt===1)j.children=xt;else if(1<dt){for(var pt=Array(dt),qt=0;qt<dt;qt++)pt[qt]=arguments[qt+2];j.children=pt}return z(V.type,Rt,j)},on.createContext=function(V){return V={$$typeof:l,_currentValue:V,_currentValue2:V,_threadCount:0,Provider:null,Consumer:null},V.Provider=V,V.Consumer={$$typeof:r,_context:V},V},on.createElement=function(V,st,xt){var j,Rt={},dt=null;if(st!=null)for(j in st.key!==void 0&&(dt=""+st.key),st)P.call(st,j)&&j!=="key"&&j!=="__self"&&j!=="__source"&&(Rt[j]=st[j]);var pt=arguments.length-2;if(pt===1)Rt.children=xt;else if(1<pt){for(var qt=Array(pt),Wt=0;Wt<pt;Wt++)qt[Wt]=arguments[Wt+2];Rt.children=qt}if(V&&V.defaultProps)for(j in pt=V.defaultProps,pt)Rt[j]===void 0&&(Rt[j]=pt[j]);return z(V,dt,Rt)},on.createRef=function(){return{current:null}},on.forwardRef=function(V){return{$$typeof:u,render:V}},on.isValidElement=k,on.lazy=function(V){return{$$typeof:m,_payload:{_status:-1,_result:V},_init:it}},on.memo=function(V,st){return{$$typeof:d,type:V,compare:st===void 0?null:st}},on.startTransition=function(V){var st=U.T,xt={};U.T=xt;try{var j=V(),Rt=U.S;Rt!==null&&Rt(xt,j),typeof j=="object"&&j!==null&&typeof j.then=="function"&&j.then(D,ot)}catch(dt){ot(dt)}finally{st!==null&&xt.types!==null&&(st.types=xt.types),U.T=st}},on.unstable_useCacheRefresh=function(){return U.H.useCacheRefresh()},on.use=function(V){return U.H.use(V)},on.useActionState=function(V,st,xt){return U.H.useActionState(V,st,xt)},on.useCallback=function(V,st){return U.H.useCallback(V,st)},on.useContext=function(V){return U.H.useContext(V)},on.useDebugValue=function(){},on.useDeferredValue=function(V,st){return U.H.useDeferredValue(V,st)},on.useEffect=function(V,st){return U.H.useEffect(V,st)},on.useEffectEvent=function(V){return U.H.useEffectEvent(V)},on.useId=function(){return U.H.useId()},on.useImperativeHandle=function(V,st,xt){return U.H.useImperativeHandle(V,st,xt)},on.useInsertionEffect=function(V,st){return U.H.useInsertionEffect(V,st)},on.useLayoutEffect=function(V,st){return U.H.useLayoutEffect(V,st)},on.useMemo=function(V,st){return U.H.useMemo(V,st)},on.useOptimistic=function(V,st){return U.H.useOptimistic(V,st)},on.useReducer=function(V,st,xt){return U.H.useReducer(V,st,xt)},on.useRef=function(V){return U.H.useRef(V)},on.useState=function(V){return U.H.useState(V)},on.useSyncExternalStore=function(V,st,xt){return U.H.useSyncExternalStore(V,st,xt)},on.useTransition=function(){return U.H.useTransition()},on.version="19.2.3",on}var h1;function ap(){return h1||(h1=1,L_.exports=_Q()),L_.exports}var et=ap();const Xe=uS(et);var z_={exports:{}},Ug={},O_={exports:{}},F_={};var f1;function CQ(){return f1||(f1=1,(function(s){function t(H,tt){var it=H.length;H.push(tt);t:for(;0<it;){var ot=it-1>>>1,At=H[ot];if(0<i(At,tt))H[ot]=tt,H[it]=At,it=ot;else break t}}function e(H){return H.length===0?null:H[0]}function n(H){if(H.length===0)return null;var tt=H[0],it=H.pop();if(it!==tt){H[0]=it;t:for(var ot=0,At=H.length,V=At>>>1;ot<V;){var st=2*(ot+1)-1,xt=H[st],j=st+1,Rt=H[j];if(0>i(xt,it))j<At&&0>i(Rt,xt)?(H[ot]=Rt,H[j]=it,ot=j):(H[ot]=xt,H[st]=it,ot=st);else if(j<At&&0>i(Rt,it))H[ot]=Rt,H[j]=it,ot=j;else break t}}return tt}function i(H,tt){var it=H.sortIndex-tt.sortIndex;return it!==0?it:H.id-tt.id}if(s.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var r=performance;s.unstable_now=function(){return r.now()}}else{var l=Date,u=l.now();s.unstable_now=function(){return l.now()-u}}var A=[],d=[],m=1,g=null,y=3,v=!1,C=!1,I=!1,S=!1,E=typeof setTimeout=="function"?setTimeout:null,B=typeof clearTimeout=="function"?clearTimeout:null,w=typeof setImmediate<"u"?setImmediate:null;function Q(H){for(var tt=e(d);tt!==null;){if(tt.callback===null)n(d);else if(tt.startTime<=H)n(d),tt.sortIndex=tt.expirationTime,t(A,tt);else break;tt=e(d)}}function R(H){if(I=!1,Q(H),!C)if(e(A)!==null)C=!0,D||(D=!0,Y());else{var tt=e(d);tt!==null&&nt(R,tt.startTime-H)}}var D=!1,U=-1,P=5,z=-1;function L(){return S?!0:!(s.unstable_now()-z<P)}function k(){if(S=!1,D){var H=s.unstable_now();z=H;var tt=!0;try{t:{C=!1,I&&(I=!1,B(U),U=-1),v=!0;var it=y;try{e:{for(Q(H),g=e(A);g!==null&&!(g.expirationTime>H&&L());){var ot=g.callback;if(typeof ot=="function"){g.callback=null,y=g.priorityLevel;var At=ot(g.expirationTime<=H);if(H=s.unstable_now(),typeof At=="function"){g.callback=At,Q(H),tt=!0;break e}g===e(A)&&n(A),Q(H)}else n(A);g=e(A)}if(g!==null)tt=!0;else{var V=e(d);V!==null&&nt(R,V.startTime-H),tt=!1}}break t}finally{g=null,y=it,v=!1}tt=void 0}}finally{tt?Y():D=!1}}}var Y;if(typeof w=="function")Y=function(){w(k)};else if(typeof MessageChannel<"u"){var W=new MessageChannel,K=W.port2;W.port1.onmessage=k,Y=function(){K.postMessage(null)}}else Y=function(){E(k,0)};function nt(H,tt){U=E(function(){H(s.unstable_now())},tt)}s.unstable_IdlePriority=5,s.unstable_ImmediatePriority=1,s.unstable_LowPriority=4,s.unstable_NormalPriority=3,s.unstable_Profiling=null,s.unstable_UserBlockingPriority=2,s.unstable_cancelCallback=function(H){H.callback=null},s.unstable_forceFrameRate=function(H){0>H||125<H?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):P=0<H?Math.floor(1e3/H):5},s.unstable_getCurrentPriorityLevel=function(){return y},s.unstable_next=function(H){switch(y){case 1:case 2:case 3:var tt=3;break;default:tt=y}var it=y;y=tt;try{return H()}finally{y=it}},s.unstable_requestPaint=function(){S=!0},s.unstable_runWithPriority=function(H,tt){switch(H){case 1:case 2:case 3:case 4:case 5:break;default:H=3}var it=y;y=H;try{return tt()}finally{y=it}},s.unstable_scheduleCallback=function(H,tt,it){var ot=s.unstable_now();switch(typeof it=="object"&&it!==null?(it=it.delay,it=typeof it=="number"&&0<it?ot+it:ot):it=ot,H){case 1:var At=-1;break;case 2:At=250;break;case 5:At=1073741823;break;case 4:At=1e4;break;default:At=5e3}return At=it+At,H={id:m++,callback:tt,priorityLevel:H,startTime:it,expirationTime:At,sortIndex:-1},it>ot?(H.sortIndex=it,t(d,H),e(A)===null&&H===e(d)&&(I?(B(U),U=-1):I=!0,nt(R,it-ot))):(H.sortIndex=At,t(A,H),C||v||(C=!0,D||(D=!0,Y()))),H},s.unstable_shouldYield=L,s.unstable_wrapCallback=function(H){var tt=y;return function(){var it=y;y=tt;try{return H.apply(this,arguments)}finally{y=it}}}})(F_)),F_}var A1;function bQ(){return A1||(A1=1,O_.exports=CQ()),O_.exports}var P_={exports:{}},pa={};var d1;function SQ(){if(d1)return pa;d1=1;var s=ap();function t(A){var d="https://react.dev/errors/"+A;if(1<arguments.length){d+="?args[]="+encodeURIComponent(arguments[1]);for(var m=2;m<arguments.length;m++)d+="&args[]="+encodeURIComponent(arguments[m])}return"Minified React error #"+A+"; visit "+d+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function e(){}var n={d:{f:e,r:function(){throw Error(t(522))},D:e,C:e,L:e,m:e,X:e,S:e,M:e},p:0,findDOMNode:null},i=Symbol.for("react.portal");function r(A,d,m){var g=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:i,key:g==null?null:""+g,children:A,containerInfo:d,implementation:m}}var l=s.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function u(A,d){if(A==="font")return"";if(typeof d=="string")return d==="use-credentials"?d:""}return pa.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=n,pa.createPortal=function(A,d){var m=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!d||d.nodeType!==1&&d.nodeType!==9&&d.nodeType!==11)throw Error(t(299));return r(A,d,null,m)},pa.flushSync=function(A){var d=l.T,m=n.p;try{if(l.T=null,n.p=2,A)return A()}finally{l.T=d,n.p=m,n.d.f()}},pa.preconnect=function(A,d){typeof A=="string"&&(d?(d=d.crossOrigin,d=typeof d=="string"?d==="use-credentials"?d:"":void 0):d=null,n.d.C(A,d))},pa.prefetchDNS=function(A){typeof A=="string"&&n.d.D(A)},pa.preinit=function(A,d){if(typeof A=="string"&&d&&typeof d.as=="string"){var m=d.as,g=u(m,d.crossOrigin),y=typeof d.integrity=="string"?d.integrity:void 0,v=typeof d.fetchPriority=="string"?d.fetchPriority:void 0;m==="style"?n.d.S(A,typeof d.precedence=="string"?d.precedence:void 0,{crossOrigin:g,integrity:y,fetchPriority:v}):m==="script"&&n.d.X(A,{crossOrigin:g,integrity:y,fetchPriority:v,nonce:typeof d.nonce=="string"?d.nonce:void 0})}},pa.preinitModule=function(A,d){if(typeof A=="string")if(typeof d=="object"&&d!==null){if(d.as==null||d.as==="script"){var m=u(d.as,d.crossOrigin);n.d.M(A,{crossOrigin:m,integrity:typeof d.integrity=="string"?d.integrity:void 0,nonce:typeof d.nonce=="string"?d.nonce:void 0})}}else d==null&&n.d.M(A)},pa.preload=function(A,d){if(typeof A=="string"&&typeof d=="object"&&d!==null&&typeof d.as=="string"){var m=d.as,g=u(m,d.crossOrigin);n.d.L(A,m,{crossOrigin:g,integrity:typeof d.integrity=="string"?d.integrity:void 0,nonce:typeof d.nonce=="string"?d.nonce:void 0,type:typeof d.type=="string"?d.type:void 0,fetchPriority:typeof d.fetchPriority=="string"?d.fetchPriority:void 0,referrerPolicy:typeof d.referrerPolicy=="string"?d.referrerPolicy:void 0,imageSrcSet:typeof d.imageSrcSet=="string"?d.imageSrcSet:void 0,imageSizes:typeof d.imageSizes=="string"?d.imageSizes:void 0,media:typeof d.media=="string"?d.media:void 0})}},pa.preloadModule=function(A,d){if(typeof A=="string")if(d){var m=u(d.as,d.crossOrigin);n.d.m(A,{as:typeof d.as=="string"&&d.as!=="script"?d.as:void 0,crossOrigin:m,integrity:typeof d.integrity=="string"?d.integrity:void 0})}else n.d.m(A)},pa.requestFormReset=function(A){n.d.r(A)},pa.unstable_batchedUpdates=function(A,d){return A(d)},pa.useFormState=function(A,d,m){return l.H.useFormState(A,d,m)},pa.useFormStatus=function(){return l.H.useHostTransitionStatus()},pa.version="19.2.3",pa}var p1;function IQ(){if(p1)return P_.exports;p1=1;function s(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(s)}catch(t){console.error(t)}}return s(),P_.exports=SQ(),P_.exports}var g1;function BQ(){if(g1)return Ug;g1=1;var s=bQ(),t=ap(),e=IQ();function n(a){var o="https://react.dev/errors/"+a;if(1<arguments.length){o+="?args[]="+encodeURIComponent(arguments[1]);for(var f=2;f<arguments.length;f++)o+="&args[]="+encodeURIComponent(arguments[f])}return"Minified React error #"+a+"; visit "+o+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function i(a){return!(!a||a.nodeType!==1&&a.nodeType!==9&&a.nodeType!==11)}function r(a){var o=a,f=a;if(a.alternate)for(;o.return;)o=o.return;else{a=o;do o=a,(o.flags&4098)!==0&&(f=o.return),a=o.return;while(a)}return o.tag===3?f:null}function l(a){if(a.tag===13){var o=a.memoizedState;if(o===null&&(a=a.alternate,a!==null&&(o=a.memoizedState)),o!==null)return o.dehydrated}return null}function u(a){if(a.tag===31){var o=a.memoizedState;if(o===null&&(a=a.alternate,a!==null&&(o=a.memoizedState)),o!==null)return o.dehydrated}return null}function A(a){if(r(a)!==a)throw Error(n(188))}function d(a){var o=a.alternate;if(!o){if(o=r(a),o===null)throw Error(n(188));return o!==a?null:a}for(var f=a,p=o;;){var _=f.return;if(_===null)break;var M=_.alternate;if(M===null){if(p=_.return,p!==null){f=p;continue}break}if(_.child===M.child){for(M=_.child;M;){if(M===f)return A(_),a;if(M===p)return A(_),o;M=M.sibling}throw Error(n(188))}if(f.return!==p.return)f=_,p=M;else{for(var O=!1,X=_.child;X;){if(X===f){O=!0,f=_,p=M;break}if(X===p){O=!0,p=_,f=M;break}X=X.sibling}if(!O){for(X=M.child;X;){if(X===f){O=!0,f=M,p=_;break}if(X===p){O=!0,p=M,f=_;break}X=X.sibling}if(!O)throw Error(n(189))}}if(f.alternate!==p)throw Error(n(190))}if(f.tag!==3)throw Error(n(188));return f.stateNode.current===f?a:o}function m(a){var o=a.tag;if(o===5||o===26||o===27||o===6)return a;for(a=a.child;a!==null;){if(o=m(a),o!==null)return o;a=a.sibling}return null}var g=Object.assign,y=Symbol.for("react.element"),v=Symbol.for("react.transitional.element"),C=Symbol.for("react.portal"),I=Symbol.for("react.fragment"),S=Symbol.for("react.strict_mode"),E=Symbol.for("react.profiler"),B=Symbol.for("react.consumer"),w=Symbol.for("react.context"),Q=Symbol.for("react.forward_ref"),R=Symbol.for("react.suspense"),D=Symbol.for("react.suspense_list"),U=Symbol.for("react.memo"),P=Symbol.for("react.lazy"),z=Symbol.for("react.activity"),L=Symbol.for("react.memo_cache_sentinel"),k=Symbol.iterator;function Y(a){return a===null||typeof a!="object"?null:(a=k&&a[k]||a["@@iterator"],typeof a=="function"?a:null)}var W=Symbol.for("react.client.reference");function K(a){if(a==null)return null;if(typeof a=="function")return a.$$typeof===W?null:a.displayName||a.name||null;if(typeof a=="string")return a;switch(a){case I:return"Fragment";case E:return"Profiler";case S:return"StrictMode";case R:return"Suspense";case D:return"SuspenseList";case z:return"Activity"}if(typeof a=="object")switch(a.$$typeof){case C:return"Portal";case w:return a.displayName||"Context";case B:return(a._context.displayName||"Context")+".Consumer";case Q:var o=a.render;return a=a.displayName,a||(a=o.displayName||o.name||"",a=a!==""?"ForwardRef("+a+")":"ForwardRef"),a;case U:return o=a.displayName||null,o!==null?o:K(a.type)||"Memo";case P:o=a._payload,a=a._init;try{return K(a(o))}catch{}}return null}var nt=Array.isArray,H=t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,tt=e.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,it={pending:!1,data:null,method:null,action:null},ot=[],At=-1;function V(a){return{current:a}}function st(a){0>At||(a.current=ot[At],ot[At]=null,At--)}function xt(a,o){At++,ot[At]=a.current,a.current=o}var j=V(null),Rt=V(null),dt=V(null),pt=V(null);function qt(a,o){switch(xt(dt,o),xt(Rt,a),xt(j,null),o.nodeType){case 9:case 11:a=(a=o.documentElement)&&(a=a.namespaceURI)?QI(a):0;break;default:if(a=o.tagName,o=o.namespaceURI)o=QI(o),a=DI(o,a);else switch(a){case"svg":a=1;break;case"math":a=2;break;default:a=0}}st(j),xt(j,a)}function Wt(){st(j),st(Rt),st(dt)}function ce(a){a.memoizedState!==null&&xt(pt,a);var o=j.current,f=DI(o,a.type);o!==f&&(xt(Rt,a),xt(j,f))}function Ie(a){Rt.current===a&&(st(j),st(Rt)),pt.current===a&&(st(pt),Tg._currentValue=it)}var He,be;function zt(a){if(He===void 0)try{throw Error()}catch(f){var o=f.stack.trim().match(/\n( *(at )?)/);He=o&&o[1]||"",be=-1<f.stack.indexOf(`
    at`)?" (<anonymous>)":-1<f.stack.indexOf("@")?"@unknown:0:0":""}return`
`+He+a+be}var Z=!1;function Ot(a,o){if(!a||Z)return"";Z=!0;var f=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var p={DetermineComponentFrameRoot:function(){try{if(o){var Yt=function(){throw Error()};if(Object.defineProperty(Yt.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Yt,[])}catch(wt){var St=wt}Reflect.construct(a,[],Yt)}else{try{Yt.call()}catch(wt){St=wt}a.call(Yt.prototype)}}else{try{throw Error()}catch(wt){St=wt}(Yt=a())&&typeof Yt.catch=="function"&&Yt.catch(function(){})}}catch(wt){if(wt&&St&&typeof wt.stack=="string")return[wt.stack,St.stack]}return[null,null]}};p.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var _=Object.getOwnPropertyDescriptor(p.DetermineComponentFrameRoot,"name");_&&_.configurable&&Object.defineProperty(p.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var M=p.DetermineComponentFrameRoot(),O=M[0],X=M[1];if(O&&X){var rt=O.split(`
`),_t=X.split(`
`);for(_=p=0;p<rt.length&&!rt[p].includes("DetermineComponentFrameRoot");)p++;for(;_<_t.length&&!_t[_].includes("DetermineComponentFrameRoot");)_++;if(p===rt.length||_===_t.length)for(p=rt.length-1,_=_t.length-1;1<=p&&0<=_&&rt[p]!==_t[_];)_--;for(;1<=p&&0<=_;p--,_--)if(rt[p]!==_t[_]){if(p!==1||_!==1)do if(p--,_--,0>_||rt[p]!==_t[_]){var Nt=`
`+rt[p].replace(" at new "," at ");return a.displayName&&Nt.includes("<anonymous>")&&(Nt=Nt.replace("<anonymous>",a.displayName)),Nt}while(1<=p&&0<=_);break}}}finally{Z=!1,Error.prepareStackTrace=f}return(f=a?a.displayName||a.name:"")?zt(f):""}function Vt(a,o){switch(a.tag){case 26:case 27:case 5:return zt(a.type);case 16:return zt("Lazy");case 13:return a.child!==o&&o!==null?zt("Suspense Fallback"):zt("Suspense");case 19:return zt("SuspenseList");case 0:case 15:return Ot(a.type,!1);case 11:return Ot(a.type.render,!1);case 1:return Ot(a.type,!0);case 31:return zt("Activity");default:return""}}function Pt(a){try{var o="",f=null;do o+=Vt(a,f),f=a,a=a.return;while(a);return o}catch(p){return`
Error generating stack: `+p.message+`
`+p.stack}}var kt=Object.prototype.hasOwnProperty,Zt=s.unstable_scheduleCallback,$t=s.unstable_cancelCallback,fe=s.unstable_shouldYield,$=s.unstable_requestPaint,G=s.unstable_now,ft=s.unstable_getCurrentPriorityLevel,Tt=s.unstable_ImmediatePriority,Ht=s.unstable_UserBlockingPriority,Bt=s.unstable_NormalPriority,Se=s.unstable_LowPriority,ae=s.unstable_IdlePriority,we=s.log,Ee=s.unstable_setDisableYieldValue,Gt=null,Jt=null;function Be(a){if(typeof we=="function"&&Ee(a),Jt&&typeof Jt.setStrictMode=="function")try{Jt.setStrictMode(Gt,a)}catch{}}var ve=Math.clz32?Math.clz32:lt,te=Math.log,Ue=Math.LN2;function lt(a){return a>>>=0,a===0?32:31-(te(a)/Ue|0)|0}var re=256,ee=262144,ie=4194304;function Xt(a){var o=a&42;if(o!==0)return o;switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return a&261888;case 262144:case 524288:case 1048576:case 2097152:return a&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return a&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return a}}function Lt(a,o,f){var p=a.pendingLanes;if(p===0)return 0;var _=0,M=a.suspendedLanes,O=a.pingedLanes;a=a.warmLanes;var X=p&134217727;return X!==0?(p=X&~M,p!==0?_=Xt(p):(O&=X,O!==0?_=Xt(O):f||(f=X&~a,f!==0&&(_=Xt(f))))):(X=p&~M,X!==0?_=Xt(X):O!==0?_=Xt(O):f||(f=p&~a,f!==0&&(_=Xt(f)))),_===0?0:o!==0&&o!==_&&(o&M)===0&&(M=_&-_,f=o&-o,M>=f||M===32&&(f&4194048)!==0)?o:_}function Ae(a,o){return(a.pendingLanes&~(a.suspendedLanes&~a.pingedLanes)&o)===0}function Oe(a,o){switch(a){case 1:case 2:case 4:case 8:case 64:return o+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return o+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function In(){var a=ie;return ie<<=1,(ie&62914560)===0&&(ie=4194304),a}function ln(a){for(var o=[],f=0;31>f;f++)o.push(a);return o}function Ei(a,o){a.pendingLanes|=o,o!==268435456&&(a.suspendedLanes=0,a.pingedLanes=0,a.warmLanes=0)}function $i(a,o,f,p,_,M){var O=a.pendingLanes;a.pendingLanes=f,a.suspendedLanes=0,a.pingedLanes=0,a.warmLanes=0,a.expiredLanes&=f,a.entangledLanes&=f,a.errorRecoveryDisabledLanes&=f,a.shellSuspendCounter=0;var X=a.entanglements,rt=a.expirationTimes,_t=a.hiddenUpdates;for(f=O&~f;0<f;){var Nt=31-ve(f),Yt=1<<Nt;X[Nt]=0,rt[Nt]=-1;var St=_t[Nt];if(St!==null)for(_t[Nt]=null,Nt=0;Nt<St.length;Nt++){var wt=St[Nt];wt!==null&&(wt.lane&=-536870913)}f&=~Yt}p!==0&&Mo(a,p,0),M!==0&&_===0&&a.tag!==0&&(a.suspendedLanes|=M&~(O&~o))}function Mo(a,o,f){a.pendingLanes|=o,a.suspendedLanes&=~o;var p=31-ve(o);a.entangledLanes|=o,a.entanglements[p]=a.entanglements[p]|1073741824|f&261930}function br(a,o){var f=a.entangledLanes|=o;for(a=a.entanglements;f;){var p=31-ve(f),_=1<<p;_&o|a[p]&o&&(a[p]|=o),f&=~_}}function qr(a,o){var f=o&-o;return f=(f&42)!==0?1:ei(f),(f&(a.suspendedLanes|o))!==0?0:f}function ei(a){switch(a){case 2:a=1;break;case 8:a=4;break;case 32:a=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:a=128;break;case 268435456:a=134217728;break;default:a=0}return a}function Sa(a){return a&=-a,2<a?8<a?(a&134217727)!==0?32:268435456:8:2}function gs(){var a=tt.p;return a!==0?a:(a=window.event,a===void 0?32:e1(a.type))}function Qs(a,o){var f=tt.p;try{return tt.p=a,o()}finally{tt.p=f}}var Fi=Math.random().toString(36).slice(2),an="__reactFiber$"+Fi,_i="__reactProps$"+Fi,Ys="__reactContainer$"+Fi,Xr="__reactEvents$"+Fi,ou="__reactListeners$"+Fi,xh="__reactHandles$"+Fi,Sr="__reactResources$"+Fi,ia="__reactMarker$"+Fi;function Ir(a){delete a[an],delete a[_i],delete a[Xr],delete a[ou],delete a[xh]}function pi(a){var o=a[an];if(o)return o;for(var f=a.parentNode;f;){if(o=f[Ys]||f[an]){if(f=o.alternate,o.child!==null||f!==null&&f.child!==null)for(a=FI(a);a!==null;){if(f=a[an])return f;a=FI(a)}return o}a=f,f=a.parentNode}return null}function q(a){if(a=a[an]||a[Ys]){var o=a.tag;if(o===5||o===6||o===13||o===31||o===26||o===27||o===3)return a}return null}function ut(a){var o=a.tag;if(o===5||o===26||o===27||o===6)return a.stateNode;throw Error(n(33))}function Ct(a){var o=a[Sr];return o||(o=a[Sr]={hoistableStyles:new Map,hoistableScripts:new Map}),o}function vt(a){a[ia]=!0}var ht=new Set,Kt={};function se(a,o){me(a,o),me(a+"Capture",o)}function me(a,o){for(Kt[a]=o,a=0;a<o.length;a++)ht.add(o[a])}var ye=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),Te={},_e={};function Qe(a){return kt.call(_e,a)?!0:kt.call(Te,a)?!1:ye.test(a)?_e[a]=!0:(Te[a]=!0,!1)}function je(a,o,f){if(Qe(o))if(f===null)a.removeAttribute(o);else{switch(typeof f){case"undefined":case"function":case"symbol":a.removeAttribute(o);return;case"boolean":var p=o.toLowerCase().slice(0,5);if(p!=="data-"&&p!=="aria-"){a.removeAttribute(o);return}}a.setAttribute(o,""+f)}}function En(a,o,f){if(f===null)a.removeAttribute(o);else{switch(typeof f){case"undefined":case"function":case"symbol":case"boolean":a.removeAttribute(o);return}a.setAttribute(o,""+f)}}function Ke(a,o,f,p){if(p===null)a.removeAttribute(f);else{switch(typeof p){case"undefined":case"function":case"symbol":case"boolean":a.removeAttribute(f);return}a.setAttributeNS(o,f,""+p)}}function cn(a){switch(typeof a){case"bigint":case"boolean":case"number":case"string":case"undefined":return a;case"object":return a;default:return""}}function Un(a){var o=a.type;return(a=a.nodeName)&&a.toLowerCase()==="input"&&(o==="checkbox"||o==="radio")}function De(a,o,f){var p=Object.getOwnPropertyDescriptor(a.constructor.prototype,o);if(!a.hasOwnProperty(o)&&typeof p<"u"&&typeof p.get=="function"&&typeof p.set=="function"){var _=p.get,M=p.set;return Object.defineProperty(a,o,{configurable:!0,get:function(){return _.call(this)},set:function(O){f=""+O,M.call(this,O)}}),Object.defineProperty(a,o,{enumerable:p.enumerable}),{getValue:function(){return f},setValue:function(O){f=""+O},stopTracking:function(){a._valueTracker=null,delete a[o]}}}}function Ln(a){if(!a._valueTracker){var o=Un(a)?"checked":"value";a._valueTracker=De(a,o,""+a[o])}}function mn(a){if(!a)return!1;var o=a._valueTracker;if(!o)return!0;var f=o.getValue(),p="";return a&&(p=Un(a)?a.checked?"true":"false":a.value),a=p,a!==f?(o.setValue(a),!0):!1}function ri(a){if(a=a||(typeof document<"u"?document:void 0),typeof a>"u")return null;try{return a.activeElement||a.body}catch{return a.body}}var Ia=/[\n"\\]/g;function Vn(a){return a.replace(Ia,function(o){return"\\"+o.charCodeAt(0).toString(16)+" "})}function Ba(a,o,f,p,_,M,O,X){a.name="",O!=null&&typeof O!="function"&&typeof O!="symbol"&&typeof O!="boolean"?a.type=O:a.removeAttribute("type"),o!=null?O==="number"?(o===0&&a.value===""||a.value!=o)&&(a.value=""+cn(o)):a.value!==""+cn(o)&&(a.value=""+cn(o)):O!=="submit"&&O!=="reset"||a.removeAttribute("value"),o!=null?oi(a,O,cn(o)):f!=null?oi(a,O,cn(f)):p!=null&&a.removeAttribute("value"),_==null&&M!=null&&(a.defaultChecked=!!M),_!=null&&(a.checked=_&&typeof _!="function"&&typeof _!="symbol"),X!=null&&typeof X!="function"&&typeof X!="symbol"&&typeof X!="boolean"?a.name=""+cn(X):a.removeAttribute("name")}function Xn(a,o,f,p,_,M,O,X){if(M!=null&&typeof M!="function"&&typeof M!="symbol"&&typeof M!="boolean"&&(a.type=M),o!=null||f!=null){if(!(M!=="submit"&&M!=="reset"||o!=null)){Ln(a);return}f=f!=null?""+cn(f):"",o=o!=null?""+cn(o):f,X||o===a.value||(a.value=o),a.defaultValue=o}p=p??_,p=typeof p!="function"&&typeof p!="symbol"&&!!p,a.checked=X?a.checked:!!p,a.defaultChecked=!!p,O!=null&&typeof O!="function"&&typeof O!="symbol"&&typeof O!="boolean"&&(a.name=O),Ln(a)}function oi(a,o,f){o==="number"&&ri(a.ownerDocument)===a||a.defaultValue===""+f||(a.defaultValue=""+f)}function Ci(a,o,f,p){if(a=a.options,o){o={};for(var _=0;_<f.length;_++)o["$"+f[_]]=!0;for(f=0;f<a.length;f++)_=o.hasOwnProperty("$"+a[f].value),a[f].selected!==_&&(a[f].selected=_),_&&p&&(a[f].defaultSelected=!0)}else{for(f=""+cn(f),o=null,_=0;_<a.length;_++){if(a[_].value===f){a[_].selected=!0,p&&(a[_].defaultSelected=!0);return}o!==null||a[_].disabled||(o=a[_])}o!==null&&(o.selected=!0)}}function Qi(a,o,f){if(o!=null&&(o=""+cn(o),o!==a.value&&(a.value=o),f==null)){a.defaultValue!==o&&(a.defaultValue=o);return}a.defaultValue=f!=null?""+cn(f):""}function bi(a,o,f,p){if(o==null){if(p!=null){if(f!=null)throw Error(n(92));if(nt(p)){if(1<p.length)throw Error(n(93));p=p[0]}f=p}f==null&&(f=""),o=f}f=cn(o),a.defaultValue=f,p=a.textContent,p===f&&p!==""&&p!==null&&(a.value=p),Ln(a)}function Ma(a,o){if(o){var f=a.firstChild;if(f&&f===a.lastChild&&f.nodeType===3){f.nodeValue=o;return}}a.textContent=o}var ms=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function Jr(a,o,f){var p=o.indexOf("--")===0;f==null||typeof f=="boolean"||f===""?p?a.setProperty(o,""):o==="float"?a.cssFloat="":a[o]="":p?a.setProperty(o,f):typeof f!="number"||f===0||ms.has(o)?o==="float"?a.cssFloat=f:a[o]=(""+f).trim():a[o]=f+"px"}function ml(a,o,f){if(o!=null&&typeof o!="object")throw Error(n(62));if(a=a.style,f!=null){for(var p in f)!f.hasOwnProperty(p)||o!=null&&o.hasOwnProperty(p)||(p.indexOf("--")===0?a.setProperty(p,""):p==="float"?a.cssFloat="":a[p]="");for(var _ in o)p=o[_],o.hasOwnProperty(_)&&f[_]!==p&&Jr(a,_,p)}else for(var M in o)o.hasOwnProperty(M)&&Jr(a,M,o[M])}function Zr(a){if(a.indexOf("-")===-1)return!1;switch(a){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var vh=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),iA=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function uc(a){return iA.test(""+a)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":a}function nr(){}var hc=null;function lu(a){return a=a.target||a.srcElement||window,a.correspondingUseElement&&(a=a.correspondingUseElement),a.nodeType===3?a.parentNode:a}var Br=null,Wr=null;function fc(a){var o=q(a);if(o&&(a=o.stateNode)){var f=a[_i]||null;t:switch(a=o.stateNode,o.type){case"input":if(Ba(a,f.value,f.defaultValue,f.defaultValue,f.checked,f.defaultChecked,f.type,f.name),o=f.name,f.type==="radio"&&o!=null){for(f=a;f.parentNode;)f=f.parentNode;for(f=f.querySelectorAll('input[name="'+Vn(""+o)+'"][type="radio"]'),o=0;o<f.length;o++){var p=f[o];if(p!==a&&p.form===a.form){var _=p[_i]||null;if(!_)throw Error(n(90));Ba(p,_.value,_.defaultValue,_.defaultValue,_.checked,_.defaultChecked,_.type,_.name)}}for(o=0;o<f.length;o++)p=f[o],p.form===a.form&&mn(p)}break t;case"textarea":Qi(a,f.value,f.defaultValue);break t;case"select":o=f.value,o!=null&&Ci(a,!!f.multiple,o,!1)}}}var cu=!1;function Eh(a,o,f){if(cu)return a(o,f);cu=!0;try{var p=a(o);return p}finally{if(cu=!1,(Br!==null||Wr!==null)&&(J(),Br&&(o=Br,a=Wr,Wr=Br=null,fc(o),a)))for(o=0;o<a.length;o++)fc(a[o])}}function wo(a,o){var f=a.stateNode;if(f===null)return null;var p=f[_i]||null;if(p===null)return null;f=p[o];t:switch(o){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(p=!p.disabled)||(a=a.type,p=!(a==="button"||a==="input"||a==="select"||a==="textarea")),a=!p;break t;default:a=!1}if(a)return null;if(f&&typeof f!="function")throw Error(n(231,o,typeof f));return f}var ir=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Ac=!1;if(ir)try{var yl={};Object.defineProperty(yl,"passive",{get:function(){Ac=!0}}),window.addEventListener("test",yl,yl),window.removeEventListener("test",yl,yl)}catch{Ac=!1}var Mr=null,dc=null,jr=null;function ue(){if(jr)return jr;var a,o=dc,f=o.length,p,_="value"in Mr?Mr.value:Mr.textContent,M=_.length;for(a=0;a<f&&o[a]===_[a];a++);var O=f-a;for(p=1;p<=O&&o[f-p]===_[M-p];p++);return jr=_.slice(a,1<p?1-p:void 0)}function $e(a){var o=a.keyCode;return"charCode"in a?(a=a.charCode,a===0&&o===13&&(a=13)):a=o,a===10&&(a=13),32<=a||a===13?a:0}function bn(){return!0}function fn(){return!1}function rn(a){function o(f,p,_,M,O){this._reactName=f,this._targetInst=_,this.type=p,this.nativeEvent=M,this.target=O,this.currentTarget=null;for(var X in a)a.hasOwnProperty(X)&&(f=a[X],this[X]=f?f(M):M[X]);return this.isDefaultPrevented=(M.defaultPrevented!=null?M.defaultPrevented:M.returnValue===!1)?bn:fn,this.isPropagationStopped=fn,this}return g(o.prototype,{preventDefault:function(){this.defaultPrevented=!0;var f=this.nativeEvent;f&&(f.preventDefault?f.preventDefault():typeof f.returnValue!="unknown"&&(f.returnValue=!1),this.isDefaultPrevented=bn)},stopPropagation:function(){var f=this.nativeEvent;f&&(f.stopPropagation?f.stopPropagation():typeof f.cancelBubble!="unknown"&&(f.cancelBubble=!0),this.isPropagationStopped=bn)},persist:function(){},isPersistent:bn}),o}var _n={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Hn=rn(_n),li=g({},_n,{view:0,detail:0}),Ds=rn(li),Kr,wa,To,xl=g({},li,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:bh,button:0,buttons:0,relatedTarget:function(a){return a.relatedTarget===void 0?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){return"movementX"in a?a.movementX:(a!==To&&(To&&a.type==="mousemove"?(Kr=a.screenX-To.screenX,wa=a.screenY-To.screenY):wa=Kr=0,To=a),Kr)},movementY:function(a){return"movementY"in a?a.movementY:wa}}),_h=rn(xl),ys=g({},xl,{dataTransfer:0}),x0=rn(ys),v0=g({},li,{relatedTarget:0}),sA=rn(v0),E0=g({},_n,{animationName:0,elapsedTime:0,pseudoElement:0}),_0=rn(E0),Ch=g({},_n,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dp=rn(Ch),C0=g({},_n,{data:0}),pp=rn(C0),b0={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},gp={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},mp={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function S0(a){var o=this.nativeEvent;return o.getModifierState?o.getModifierState(a):(a=mp[a])?!!o[a]:!1}function bh(){return S0}var yp=g({},li,{key:function(a){if(a.key){var o=b0[a.key]||a.key;if(o!=="Unidentified")return o}return a.type==="keypress"?(a=$e(a),a===13?"Enter":String.fromCharCode(a)):a.type==="keydown"||a.type==="keyup"?gp[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:bh,charCode:function(a){return a.type==="keypress"?$e(a):0},keyCode:function(a){return a.type==="keydown"||a.type==="keyup"?a.keyCode:0},which:function(a){return a.type==="keypress"?$e(a):a.type==="keydown"||a.type==="keyup"?a.keyCode:0}}),xp=rn(yp),I0=g({},xl,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),aA=rn(I0),B0=g({},li,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:bh}),Qo=rn(B0),vp=g({},_n,{propertyName:0,elapsedTime:0,pseudoElement:0}),t_=rn(vp),M0=g({},xl,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),vl=rn(M0),Do=g({},_n,{newState:0,oldState:0}),Ep=rn(Do),_p=[9,13,27,32],pc=ir&&"CompositionEvent"in window,El=null;ir&&"documentMode"in document&&(El=document.documentMode);var gc=ir&&"TextEvent"in window&&!El,xs=ir&&(!pc||El&&8<El&&11>=El),Sh=" ",Cp=!1;function rA(a,o){switch(a){case"keyup":return _p.indexOf(o.keyCode)!==-1;case"keydown":return o.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function uu(a){return a=a.detail,typeof a=="object"&&"data"in a?a.data:null}var _l=!1;function oA(a,o){switch(a){case"compositionend":return uu(o);case"keypress":return o.which!==32?null:(Cp=!0,Sh);case"textInput":return a=o.data,a===Sh&&Cp?null:a;default:return null}}function w0(a,o){if(_l)return a==="compositionend"||!pc&&rA(a,o)?(a=ue(),jr=dc=Mr=null,_l=!1,a):null;switch(a){case"paste":return null;case"keypress":if(!(o.ctrlKey||o.altKey||o.metaKey)||o.ctrlKey&&o.altKey){if(o.char&&1<o.char.length)return o.char;if(o.which)return String.fromCharCode(o.which)}return null;case"compositionend":return xs&&o.locale!=="ko"?null:o.data;default:return null}}var Ta={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function bp(a){var o=a&&a.nodeName&&a.nodeName.toLowerCase();return o==="input"?!!Ta[a.type]:o==="textarea"}function lA(a,o,f,p){Br?Wr?Wr.push(p):Wr=[p]:Br=p,o=vy(o,"onChange"),0<o.length&&(f=new Hn("onChange","change",null,f,p),a.push({event:f,listeners:o}))}var hu=null,fu=null;function Sp(a){SI(a,0)}function Au(a){var o=ut(a);if(mn(o))return a}function Ip(a,o){if(a==="change")return o}var Ih=!1;if(ir){var mc;if(ir){var gi="oninput"in document;if(!gi){var T0=document.createElement("div");T0.setAttribute("oninput","return;"),gi=typeof T0.oninput=="function"}mc=gi}else mc=!1;Ih=mc&&(!document.documentMode||9<document.documentMode)}function Q0(){hu&&(hu.detachEvent("onpropertychange",Bp),fu=hu=null)}function Bp(a){if(a.propertyName==="value"&&Au(fu)){var o=[];lA(o,fu,a,lu(a)),Eh(Sp,o)}}function Bh(a,o,f){a==="focusin"?(Q0(),hu=o,fu=f,hu.attachEvent("onpropertychange",Bp)):a==="focusout"&&Q0()}function Cl(a){if(a==="selectionchange"||a==="keyup"||a==="keydown")return Au(fu)}function D0(a,o){if(a==="click")return Au(o)}function R0(a,o){if(a==="input"||a==="change")return Au(o)}function yc(a,o){return a===o&&(a!==0||1/a===1/o)||a!==a&&o!==o}var mi=typeof Object.is=="function"?Object.is:yc;function du(a,o){if(mi(a,o))return!0;if(typeof a!="object"||a===null||typeof o!="object"||o===null)return!1;var f=Object.keys(a),p=Object.keys(o);if(f.length!==p.length)return!1;for(p=0;p<f.length;p++){var _=f[p];if(!kt.call(o,_)||!mi(a[_],o[_]))return!1}return!0}function Mp(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function wp(a,o){var f=Mp(a);a=0;for(var p;f;){if(f.nodeType===3){if(p=a+f.textContent.length,a<=o&&p>=o)return{node:f,offset:o-a};a=p}t:{for(;f;){if(f.nextSibling){f=f.nextSibling;break t}f=f.parentNode}f=void 0}f=Mp(f)}}function cA(a,o){return a&&o?a===o?!0:a&&a.nodeType===3?!1:o&&o.nodeType===3?cA(a,o.parentNode):"contains"in a?a.contains(o):a.compareDocumentPosition?!!(a.compareDocumentPosition(o)&16):!1:!1}function uA(a){a=a!=null&&a.ownerDocument!=null&&a.ownerDocument.defaultView!=null?a.ownerDocument.defaultView:window;for(var o=ri(a.document);o instanceof a.HTMLIFrameElement;){try{var f=typeof o.contentWindow.location.href=="string"}catch{f=!1}if(f)a=o.contentWindow;else break;o=ri(a.document)}return o}function pu(a){var o=a&&a.nodeName&&a.nodeName.toLowerCase();return o&&(o==="input"&&(a.type==="text"||a.type==="search"||a.type==="tel"||a.type==="url"||a.type==="password")||o==="textarea"||a.contentEditable==="true")}var N0=ir&&"documentMode"in document&&11>=document.documentMode,gu=null,hA=null,mu=null,Qa=!1;function fA(a,o,f){var p=f.window===f?f.document:f.nodeType===9?f:f.ownerDocument;Qa||gu==null||gu!==ri(p)||(p=gu,"selectionStart"in p&&pu(p)?p={start:p.selectionStart,end:p.selectionEnd}:(p=(p.ownerDocument&&p.ownerDocument.defaultView||window).getSelection(),p={anchorNode:p.anchorNode,anchorOffset:p.anchorOffset,focusNode:p.focusNode,focusOffset:p.focusOffset}),mu&&du(mu,p)||(mu=p,p=vy(hA,"onSelect"),0<p.length&&(o=new Hn("onSelect","select",null,o,f),a.push({event:o,listeners:p}),o.target=gu)))}function bl(a,o){var f={};return f[a.toLowerCase()]=o.toLowerCase(),f["Webkit"+a]="webkit"+o,f["Moz"+a]="moz"+o,f}var yu={animationend:bl("Animation","AnimationEnd"),animationiteration:bl("Animation","AnimationIteration"),animationstart:bl("Animation","AnimationStart"),transitionrun:bl("Transition","TransitionRun"),transitionstart:bl("Transition","TransitionStart"),transitioncancel:bl("Transition","TransitionCancel"),transitionend:bl("Transition","TransitionEnd")},Mh={},qs={};ir&&(qs=document.createElement("div").style,"AnimationEvent"in window||(delete yu.animationend.animation,delete yu.animationiteration.animation,delete yu.animationstart.animation),"TransitionEvent"in window||delete yu.transitionend.transition);function Sl(a){if(Mh[a])return Mh[a];if(!yu[a])return a;var o=yu[a],f;for(f in o)if(o.hasOwnProperty(f)&&f in qs)return Mh[a]=o[f];return a}var sa=Sl("animationend"),Tp=Sl("animationiteration"),$r=Sl("animationstart"),xu=Sl("transitionrun"),Il=Sl("transitionstart"),Qp=Sl("transitioncancel"),AA=Sl("transitionend"),Ro=new Map,dA="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");dA.push("scrollEnd");function Rs(a,o){Ro.set(a,o),se(o,[a])}var Bl=typeof reportError=="function"?reportError:function(a){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var o=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof a=="object"&&a!==null&&typeof a.message=="string"?String(a.message):String(a),error:a});if(!window.dispatchEvent(o))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",a);return}console.error(a)},os=[],xc=0,pA=0;function Ml(){for(var a=xc,o=pA=xc=0;o<a;){var f=os[o];os[o++]=null;var p=os[o];os[o++]=null;var _=os[o];os[o++]=null;var M=os[o];if(os[o++]=null,p!==null&&_!==null){var O=p.pending;O===null?_.next=_:(_.next=O.next,O.next=_),p.pending=_}M!==0&&gA(f,_,M)}}function wh(a,o,f,p){os[xc++]=a,os[xc++]=o,os[xc++]=f,os[xc++]=p,pA|=p,a.lanes|=p,a=a.alternate,a!==null&&(a.lanes|=p)}function vu(a,o,f,p){return wh(a,o,f,p),Eu(a)}function wl(a,o){return wh(a,null,null,o),Eu(a)}function gA(a,o,f){a.lanes|=f;var p=a.alternate;p!==null&&(p.lanes|=f);for(var _=!1,M=a.return;M!==null;)M.childLanes|=f,p=M.alternate,p!==null&&(p.childLanes|=f),M.tag===22&&(a=M.stateNode,a===null||a._visibility&1||(_=!0)),a=M,M=M.return;return a.tag===3?(M=a.stateNode,_&&o!==null&&(_=31-ve(f),a=M.hiddenUpdates,p=a[_],p===null?a[_]=[o]:p.push(o),o.lane=f|536870912),M):null}function Eu(a){if(50<Lc)throw Lc=0,zc=null,Error(n(185));for(var o=a.return;o!==null;)a=o,o=a.return;return a.tag===3?a.stateNode:null}var Tl={};function U0(a,o,f,p){this.tag=a,this.key=f,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=o,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=p,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Xs(a,o,f,p){return new U0(a,o,f,p)}function Js(a){return a=a.prototype,!(!a||!a.isReactComponent)}function to(a,o){var f=a.alternate;return f===null?(f=Xs(a.tag,o,a.key,a.mode),f.elementType=a.elementType,f.type=a.type,f.stateNode=a.stateNode,f.alternate=a,a.alternate=f):(f.pendingProps=o,f.type=a.type,f.flags=0,f.subtreeFlags=0,f.deletions=null),f.flags=a.flags&65011712,f.childLanes=a.childLanes,f.lanes=a.lanes,f.child=a.child,f.memoizedProps=a.memoizedProps,f.memoizedState=a.memoizedState,f.updateQueue=a.updateQueue,o=a.dependencies,f.dependencies=o===null?null:{lanes:o.lanes,firstContext:o.firstContext},f.sibling=a.sibling,f.index=a.index,f.ref=a.ref,f.refCleanup=a.refCleanup,f}function Ns(a,o){a.flags&=65011714;var f=a.alternate;return f===null?(a.childLanes=0,a.lanes=o,a.child=null,a.subtreeFlags=0,a.memoizedProps=null,a.memoizedState=null,a.updateQueue=null,a.dependencies=null,a.stateNode=null):(a.childLanes=f.childLanes,a.lanes=f.lanes,a.child=f.child,a.subtreeFlags=0,a.deletions=null,a.memoizedProps=f.memoizedProps,a.memoizedState=f.memoizedState,a.updateQueue=f.updateQueue,a.type=f.type,o=f.dependencies,a.dependencies=o===null?null:{lanes:o.lanes,firstContext:o.firstContext}),a}function Th(a,o,f,p,_,M){var O=0;if(p=a,typeof a=="function")Js(a)&&(O=1);else if(typeof a=="string")O=lQ(a,f,j.current)?26:a==="html"||a==="head"||a==="body"?27:5;else t:switch(a){case z:return a=Xs(31,f,o,_),a.elementType=z,a.lanes=M,a;case I:return No(f.children,_,M,o);case S:O=8,_|=24;break;case E:return a=Xs(12,f,o,_|2),a.elementType=E,a.lanes=M,a;case R:return a=Xs(13,f,o,_),a.elementType=R,a.lanes=M,a;case D:return a=Xs(19,f,o,_),a.elementType=D,a.lanes=M,a;default:if(typeof a=="object"&&a!==null)switch(a.$$typeof){case w:O=10;break t;case B:O=9;break t;case Q:O=11;break t;case U:O=14;break t;case P:O=16,p=null;break t}O=29,f=Error(n(130,a===null?"null":typeof a,"")),p=null}return o=Xs(O,f,o,_),o.elementType=a,o.type=p,o.lanes=M,o}function No(a,o,f,p){return a=Xs(7,a,p,o),a.lanes=f,a}function mA(a,o,f){return a=Xs(6,a,null,o),a.lanes=f,a}function L0(a){var o=Xs(18,null,null,0);return o.stateNode=a,o}function wr(a,o,f){return o=Xs(4,a.children!==null?a.children:[],a.key,o),o.lanes=f,o.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation},o}var Dp=new WeakMap;function aa(a,o){if(typeof a=="object"&&a!==null){var f=Dp.get(a);return f!==void 0?f:(o={value:a,source:o,stack:Pt(o)},Dp.set(a,o),o)}return{value:a,source:o,stack:Pt(o)}}var Tr=[],vc=0,Qh=null,_u=0,Da=[],ra=0,eo=null,no=1,io="";function Uo(a,o){Tr[vc++]=_u,Tr[vc++]=Qh,Qh=a,_u=o}function Rp(a,o,f){Da[ra++]=no,Da[ra++]=io,Da[ra++]=eo,eo=a;var p=no;a=io;var _=32-ve(p)-1;p&=~(1<<_),f+=1;var M=32-ve(o)+_;if(30<M){var O=_-_%5;M=(p&(1<<O)-1).toString(32),p>>=O,_-=O,no=1<<32-ve(o)+_|f<<_|p,io=M+a}else no=1<<M|f<<_|p,io=a}function yA(a){a.return!==null&&(Uo(a,1),Rp(a,1,0))}function Ql(a){for(;a===Qh;)Qh=Tr[--vc],Tr[vc]=null,_u=Tr[--vc],Tr[vc]=null;for(;a===eo;)eo=Da[--ra],Da[ra]=null,io=Da[--ra],Da[ra]=null,no=Da[--ra],Da[ra]=null}function Dh(a,o){Da[ra++]=no,Da[ra++]=io,Da[ra++]=eo,no=o.id,io=o.overflow,eo=a}var ls=null,hi=null,wn=!1,Lo=null,cs=!1,xA=Error(n(519));function Bn(a){var o=Error(n(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw Rh(aa(o,a)),xA}function vA(a){var o=a.stateNode,f=a.type,p=a.memoizedProps;switch(o[an]=a,o[_i]=p,f){case"dialog":Tn("cancel",o),Tn("close",o);break;case"iframe":case"object":case"embed":Tn("load",o);break;case"video":case"audio":for(f=0;f<Sg.length;f++)Tn(Sg[f],o);break;case"source":Tn("error",o);break;case"img":case"image":case"link":Tn("error",o),Tn("load",o);break;case"details":Tn("toggle",o);break;case"input":Tn("invalid",o),Xn(o,p.value,p.defaultValue,p.checked,p.defaultChecked,p.type,p.name,!0);break;case"select":Tn("invalid",o);break;case"textarea":Tn("invalid",o),bi(o,p.value,p.defaultValue,p.children)}f=p.children,typeof f!="string"&&typeof f!="number"&&typeof f!="bigint"||o.textContent===""+f||p.suppressHydrationWarning===!0||wI(o.textContent,f)?(p.popover!=null&&(Tn("beforetoggle",o),Tn("toggle",o)),p.onScroll!=null&&Tn("scroll",o),p.onScrollEnd!=null&&Tn("scrollend",o),p.onClick!=null&&(o.onclick=nr),o=!0):o=!1,o||Bn(a,!0)}function z0(a){for(ls=a.return;ls;)switch(ls.tag){case 5:case 31:case 13:cs=!1;return;case 27:case 3:cs=!0;return;default:ls=ls.return}}function Ec(a){if(a!==ls)return!1;if(!wn)return z0(a),wn=!0,!1;var o=a.tag,f;if((f=o!==3&&o!==27)&&((f=o===5)&&(f=a.type,f=!(f!=="form"&&f!=="button")||v_(a.type,a.memoizedProps)),f=!f),f&&hi&&Bn(a),z0(a),o===13){if(a=a.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(n(317));hi=OI(a)}else if(o===31){if(a=a.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(n(317));hi=OI(a)}else o===27?(o=hi,Gu(a.type)?(a=S_,S_=null,hi=a):hi=o):hi=ls?po(a.stateNode.nextSibling):null;return!0}function _c(){hi=ls=null,wn=!1}function Np(){var a=Lo;return a!==null&&(Ps===null?Ps=a:Ps.push.apply(Ps,a),Lo=null),a}function Rh(a){Lo===null?Lo=[a]:Lo.push(a)}var Up=V(null),zo=null,Us=null;function Oo(a,o,f){xt(Up,o._currentValue),o._currentValue=f}function sr(a){a._currentValue=Up.current,st(Up)}function Fo(a,o,f){for(;a!==null;){var p=a.alternate;if((a.childLanes&o)!==o?(a.childLanes|=o,p!==null&&(p.childLanes|=o)):p!==null&&(p.childLanes&o)!==o&&(p.childLanes|=o),a===f)break;a=a.return}}function EA(a,o,f,p){var _=a.child;for(_!==null&&(_.return=a);_!==null;){var M=_.dependencies;if(M!==null){var O=_.child;M=M.firstContext;t:for(;M!==null;){var X=M;M=_;for(var rt=0;rt<o.length;rt++)if(X.context===o[rt]){M.lanes|=f,X=M.alternate,X!==null&&(X.lanes|=f),Fo(M.return,f,a),p||(O=null);break t}M=X.next}}else if(_.tag===18){if(O=_.return,O===null)throw Error(n(341));O.lanes|=f,M=O.alternate,M!==null&&(M.lanes|=f),Fo(O,f,a),O=null}else O=_.child;if(O!==null)O.return=_;else for(O=_;O!==null;){if(O===a){O=null;break}if(_=O.sibling,_!==null){_.return=O.return,O=_;break}O=O.return}_=O}}function Dl(a,o,f,p){a=null;for(var _=o,M=!1;_!==null;){if(!M){if((_.flags&524288)!==0)M=!0;else if((_.flags&262144)!==0)break}if(_.tag===10){var O=_.alternate;if(O===null)throw Error(n(387));if(O=O.memoizedProps,O!==null){var X=_.type;mi(_.pendingProps.value,O.value)||(a!==null?a.push(X):a=[X])}}else if(_===pt.current){if(O=_.alternate,O===null)throw Error(n(387));O.memoizedState.memoizedState!==_.memoizedState.memoizedState&&(a!==null?a.push(Tg):a=[Tg])}_=_.return}a!==null&&EA(o,a,f,p),o.flags|=262144}function Cu(a){for(a=a.firstContext;a!==null;){if(!mi(a.context._currentValue,a.memoizedValue))return!0;a=a.next}return!1}function Cc(a){zo=a,Us=null,a=a.dependencies,a!==null&&(a.firstContext=null)}function us(a){return Lp(zo,a)}function Nh(a,o){return zo===null&&Cc(a),Lp(a,o)}function Lp(a,o){var f=o._currentValue;if(o={context:o,memoizedValue:f,next:null},Us===null){if(a===null)throw Error(n(308));Us=o,a.dependencies={lanes:0,firstContext:o},a.flags|=524288}else Us=Us.next=o;return f}var O0=typeof AbortController<"u"?AbortController:function(){var a=[],o=this.signal={aborted:!1,addEventListener:function(f,p){a.push(p)}};this.abort=function(){o.aborted=!0,a.forEach(function(f){return f()})}},F0=s.unstable_scheduleCallback,zp=s.unstable_NormalPriority,Le={$$typeof:w,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Op(){return{controller:new O0,data:new Map,refCount:0}}function vs(a){a.refCount--,a.refCount===0&&F0(zp,function(){a.controller.abort()})}var bc=null,Fp=0,Po=0,Qr=null;function bu(a,o){if(bc===null){var f=bc=[];Fp=0,Po=h_(),Qr={status:"pending",value:void 0,then:function(p){f.push(p)}}}return Fp++,o.then(Pp,Pp),o}function Pp(){if(--Fp===0&&bc!==null){Qr!==null&&(Qr.status="fulfilled");var a=bc;bc=null,Po=0,Qr=null;for(var o=0;o<a.length;o++)(0,a[o])()}}function Gp(a,o){var f=[],p={status:"pending",value:null,reason:null,then:function(_){f.push(_)}};return a.then(function(){p.status="fulfilled",p.value=o;for(var _=0;_<f.length;_++)(0,f[_])(o)},function(_){for(p.status="rejected",p.reason=_,_=0;_<f.length;_++)(0,f[_])(void 0)}),p}var P0=H.S;H.S=function(a,o){Ou=G(),typeof o=="object"&&o!==null&&typeof o.then=="function"&&bu(a,o),P0!==null&&P0(a,o)};var Rl=V(null);function so(){var a=Rl.current;return a!==null?a:Zn.pooledCache}function Su(a,o){o===null?xt(Rl,Rl.current):xt(Rl,o.pool)}function _A(){var a=so();return a===null?null:{parent:Le._currentValue,pool:a}}var Nl=Error(n(460)),Uh=Error(n(474)),Dr=Error(n(542)),Lh={then:function(){}};function G0(a){return a=a.status,a==="fulfilled"||a==="rejected"}function kp(a,o,f){switch(f=a[f],f===void 0?a.push(o):f!==o&&(o.then(nr,nr),o=f),o.status){case"fulfilled":return o.value;case"rejected":throw a=o.reason,Hp(a),a;default:if(typeof o.status=="string")o.then(nr,nr);else{if(a=Zn,a!==null&&100<a.shellSuspendCounter)throw Error(n(482));a=o,a.status="pending",a.then(function(p){if(o.status==="pending"){var _=o;_.status="fulfilled",_.value=p}},function(p){if(o.status==="pending"){var _=o;_.status="rejected",_.reason=p}})}switch(o.status){case"fulfilled":return o.value;case"rejected":throw a=o.reason,Hp(a),a}throw ke=o,Nl}}function Sc(a){try{var o=a._init;return o(a._payload)}catch(f){throw f!==null&&typeof f=="object"&&typeof f.then=="function"?(ke=f,Nl):f}}var ke=null;function CA(){if(ke===null)throw Error(n(459));var a=ke;return ke=null,a}function Hp(a){if(a===Nl||a===Dr)throw Error(n(483))}var Ul=null,Ll=0;function bA(a){var o=Ll;return Ll+=1,Ul===null&&(Ul=[]),kp(Ul,a,o)}function zh(a,o){o=o.props.ref,a.ref=o!==void 0?o:null}function Oh(a,o){throw o.$$typeof===y?Error(n(525)):(a=Object.prototype.toString.call(o),Error(n(31,a==="[object Object]"?"object with keys {"+Object.keys(o).join(", ")+"}":a)))}function Iu(a){function o(mt,ct){if(a){var Et=mt.deletions;Et===null?(mt.deletions=[ct],mt.flags|=16):Et.push(ct)}}function f(mt,ct){if(!a)return null;for(;ct!==null;)o(mt,ct),ct=ct.sibling;return null}function p(mt){for(var ct=new Map;mt!==null;)mt.key!==null?ct.set(mt.key,mt):ct.set(mt.index,mt),mt=mt.sibling;return ct}function _(mt,ct){return mt=to(mt,ct),mt.index=0,mt.sibling=null,mt}function M(mt,ct,Et){return mt.index=Et,a?(Et=mt.alternate,Et!==null?(Et=Et.index,Et<ct?(mt.flags|=67108866,ct):Et):(mt.flags|=67108866,ct)):(mt.flags|=1048576,ct)}function O(mt){return a&&mt.alternate===null&&(mt.flags|=67108866),mt}function X(mt,ct,Et,Ft){return ct===null||ct.tag!==6?(ct=mA(Et,mt.mode,Ft),ct.return=mt,ct):(ct=_(ct,Et),ct.return=mt,ct)}function rt(mt,ct,Et,Ft){var Pe=Et.type;return Pe===I?Nt(mt,ct,Et.props.children,Ft,Et.key):ct!==null&&(ct.elementType===Pe||typeof Pe=="object"&&Pe!==null&&Pe.$$typeof===P&&Sc(Pe)===ct.type)?(ct=_(ct,Et.props),zh(ct,Et),ct.return=mt,ct):(ct=Th(Et.type,Et.key,Et.props,null,mt.mode,Ft),zh(ct,Et),ct.return=mt,ct)}function _t(mt,ct,Et,Ft){return ct===null||ct.tag!==4||ct.stateNode.containerInfo!==Et.containerInfo||ct.stateNode.implementation!==Et.implementation?(ct=wr(Et,mt.mode,Ft),ct.return=mt,ct):(ct=_(ct,Et.children||[]),ct.return=mt,ct)}function Nt(mt,ct,Et,Ft,Pe){return ct===null||ct.tag!==7?(ct=No(Et,mt.mode,Ft,Pe),ct.return=mt,ct):(ct=_(ct,Et),ct.return=mt,ct)}function Yt(mt,ct,Et){if(typeof ct=="string"&&ct!==""||typeof ct=="number"||typeof ct=="bigint")return ct=mA(""+ct,mt.mode,Et),ct.return=mt,ct;if(typeof ct=="object"&&ct!==null){switch(ct.$$typeof){case v:return Et=Th(ct.type,ct.key,ct.props,null,mt.mode,Et),zh(Et,ct),Et.return=mt,Et;case C:return ct=wr(ct,mt.mode,Et),ct.return=mt,ct;case P:return ct=Sc(ct),Yt(mt,ct,Et)}if(nt(ct)||Y(ct))return ct=No(ct,mt.mode,Et,null),ct.return=mt,ct;if(typeof ct.then=="function")return Yt(mt,bA(ct),Et);if(ct.$$typeof===w)return Yt(mt,Nh(mt,ct),Et);Oh(mt,ct)}return null}function St(mt,ct,Et,Ft){var Pe=ct!==null?ct.key:null;if(typeof Et=="string"&&Et!==""||typeof Et=="number"||typeof Et=="bigint")return Pe!==null?null:X(mt,ct,""+Et,Ft);if(typeof Et=="object"&&Et!==null){switch(Et.$$typeof){case v:return Et.key===Pe?rt(mt,ct,Et,Ft):null;case C:return Et.key===Pe?_t(mt,ct,Et,Ft):null;case P:return Et=Sc(Et),St(mt,ct,Et,Ft)}if(nt(Et)||Y(Et))return Pe!==null?null:Nt(mt,ct,Et,Ft,null);if(typeof Et.then=="function")return St(mt,ct,bA(Et),Ft);if(Et.$$typeof===w)return St(mt,ct,Nh(mt,Et),Ft);Oh(mt,Et)}return null}function wt(mt,ct,Et,Ft,Pe){if(typeof Ft=="string"&&Ft!==""||typeof Ft=="number"||typeof Ft=="bigint")return mt=mt.get(Et)||null,X(ct,mt,""+Ft,Pe);if(typeof Ft=="object"&&Ft!==null){switch(Ft.$$typeof){case v:return mt=mt.get(Ft.key===null?Et:Ft.key)||null,rt(ct,mt,Ft,Pe);case C:return mt=mt.get(Ft.key===null?Et:Ft.key)||null,_t(ct,mt,Ft,Pe);case P:return Ft=Sc(Ft),wt(mt,ct,Et,Ft,Pe)}if(nt(Ft)||Y(Ft))return mt=mt.get(Et)||null,Nt(ct,mt,Ft,Pe,null);if(typeof Ft.then=="function")return wt(mt,ct,Et,bA(Ft),Pe);if(Ft.$$typeof===w)return wt(mt,ct,Et,Nh(ct,Ft),Pe);Oh(ct,Ft)}return null}function Me(mt,ct,Et,Ft){for(var Pe=null,jn=null,Re=ct,xn=ct=0,Nn=null;Re!==null&&xn<Et.length;xn++){Re.index>xn?(Nn=Re,Re=null):Nn=Re.sibling;var Kn=St(mt,Re,Et[xn],Ft);if(Kn===null){Re===null&&(Re=Nn);break}a&&Re&&Kn.alternate===null&&o(mt,Re),ct=M(Kn,ct,xn),jn===null?Pe=Kn:jn.sibling=Kn,jn=Kn,Re=Nn}if(xn===Et.length)return f(mt,Re),wn&&Uo(mt,xn),Pe;if(Re===null){for(;xn<Et.length;xn++)Re=Yt(mt,Et[xn],Ft),Re!==null&&(ct=M(Re,ct,xn),jn===null?Pe=Re:jn.sibling=Re,jn=Re);return wn&&Uo(mt,xn),Pe}for(Re=p(Re);xn<Et.length;xn++)Nn=wt(Re,mt,xn,Et[xn],Ft),Nn!==null&&(a&&Nn.alternate!==null&&Re.delete(Nn.key===null?xn:Nn.key),ct=M(Nn,ct,xn),jn===null?Pe=Nn:jn.sibling=Nn,jn=Nn);return a&&Re.forEach(function(qu){return o(mt,qu)}),wn&&Uo(mt,xn),Pe}function Ve(mt,ct,Et,Ft){if(Et==null)throw Error(n(151));for(var Pe=null,jn=null,Re=ct,xn=ct=0,Nn=null,Kn=Et.next();Re!==null&&!Kn.done;xn++,Kn=Et.next()){Re.index>xn?(Nn=Re,Re=null):Nn=Re.sibling;var qu=St(mt,Re,Kn.value,Ft);if(qu===null){Re===null&&(Re=Nn);break}a&&Re&&qu.alternate===null&&o(mt,Re),ct=M(qu,ct,xn),jn===null?Pe=qu:jn.sibling=qu,jn=qu,Re=Nn}if(Kn.done)return f(mt,Re),wn&&Uo(mt,xn),Pe;if(Re===null){for(;!Kn.done;xn++,Kn=Et.next())Kn=Yt(mt,Kn.value,Ft),Kn!==null&&(ct=M(Kn,ct,xn),jn===null?Pe=Kn:jn.sibling=Kn,jn=Kn);return wn&&Uo(mt,xn),Pe}for(Re=p(Re);!Kn.done;xn++,Kn=Et.next())Kn=wt(Re,mt,xn,Kn.value,Ft),Kn!==null&&(a&&Kn.alternate!==null&&Re.delete(Kn.key===null?xn:Kn.key),ct=M(Kn,ct,xn),jn===null?Pe=Kn:jn.sibling=Kn,jn=Kn);return a&&Re.forEach(function(xQ){return o(mt,xQ)}),wn&&Uo(mt,xn),Pe}function di(mt,ct,Et,Ft){if(typeof Et=="object"&&Et!==null&&Et.type===I&&Et.key===null&&(Et=Et.props.children),typeof Et=="object"&&Et!==null){switch(Et.$$typeof){case v:t:{for(var Pe=Et.key;ct!==null;){if(ct.key===Pe){if(Pe=Et.type,Pe===I){if(ct.tag===7){f(mt,ct.sibling),Ft=_(ct,Et.props.children),Ft.return=mt,mt=Ft;break t}}else if(ct.elementType===Pe||typeof Pe=="object"&&Pe!==null&&Pe.$$typeof===P&&Sc(Pe)===ct.type){f(mt,ct.sibling),Ft=_(ct,Et.props),zh(Ft,Et),Ft.return=mt,mt=Ft;break t}f(mt,ct);break}else o(mt,ct);ct=ct.sibling}Et.type===I?(Ft=No(Et.props.children,mt.mode,Ft,Et.key),Ft.return=mt,mt=Ft):(Ft=Th(Et.type,Et.key,Et.props,null,mt.mode,Ft),zh(Ft,Et),Ft.return=mt,mt=Ft)}return O(mt);case C:t:{for(Pe=Et.key;ct!==null;){if(ct.key===Pe)if(ct.tag===4&&ct.stateNode.containerInfo===Et.containerInfo&&ct.stateNode.implementation===Et.implementation){f(mt,ct.sibling),Ft=_(ct,Et.children||[]),Ft.return=mt,mt=Ft;break t}else{f(mt,ct);break}else o(mt,ct);ct=ct.sibling}Ft=wr(Et,mt.mode,Ft),Ft.return=mt,mt=Ft}return O(mt);case P:return Et=Sc(Et),di(mt,ct,Et,Ft)}if(nt(Et))return Me(mt,ct,Et,Ft);if(Y(Et)){if(Pe=Y(Et),typeof Pe!="function")throw Error(n(150));return Et=Pe.call(Et),Ve(mt,ct,Et,Ft)}if(typeof Et.then=="function")return di(mt,ct,bA(Et),Ft);if(Et.$$typeof===w)return di(mt,ct,Nh(mt,Et),Ft);Oh(mt,Et)}return typeof Et=="string"&&Et!==""||typeof Et=="number"||typeof Et=="bigint"?(Et=""+Et,ct!==null&&ct.tag===6?(f(mt,ct.sibling),Ft=_(ct,Et),Ft.return=mt,mt=Ft):(f(mt,ct),Ft=mA(Et,mt.mode,Ft),Ft.return=mt,mt=Ft),O(mt)):f(mt,ct)}return function(mt,ct,Et,Ft){try{Ll=0;var Pe=di(mt,ct,Et,Ft);return Ul=null,Pe}catch(Re){if(Re===Nl||Re===Dr)throw Re;var jn=Xs(29,Re,null,mt.mode);return jn.lanes=Ft,jn.return=mt,jn}}}var Ic=Iu(!0),k0=Iu(!1),zl=!1;function Vp(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function Yp(a,o){a=a.updateQueue,o.updateQueue===a&&(o.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,callbacks:null})}function ao(a){return{lane:a,tag:0,payload:null,callback:null,next:null}}function Go(a,o,f){var p=a.updateQueue;if(p===null)return null;if(p=p.shared,(Dn&2)!==0){var _=p.pending;return _===null?o.next=o:(o.next=_.next,_.next=o),p.pending=o,o=Eu(a),gA(a,null,f),o}return wh(a,p,o,f),Eu(a)}function Ol(a,o,f){if(o=o.updateQueue,o!==null&&(o=o.shared,(f&4194048)!==0)){var p=o.lanes;p&=a.pendingLanes,f|=p,o.lanes=f,br(a,f)}}function SA(a,o){var f=a.updateQueue,p=a.alternate;if(p!==null&&(p=p.updateQueue,f===p)){var _=null,M=null;if(f=f.firstBaseUpdate,f!==null){do{var O={lane:f.lane,tag:f.tag,payload:f.payload,callback:null,next:null};M===null?_=M=O:M=M.next=O,f=f.next}while(f!==null);M===null?_=M=o:M=M.next=o}else _=M=o;f={baseState:p.baseState,firstBaseUpdate:_,lastBaseUpdate:M,shared:p.shared,callbacks:p.callbacks},a.updateQueue=f;return}a=f.lastBaseUpdate,a===null?f.firstBaseUpdate=o:a.next=o,f.lastBaseUpdate=o}var qp=!1;function Fh(){if(qp){var a=Qr;if(a!==null)throw a}}function Bc(a,o,f,p){qp=!1;var _=a.updateQueue;zl=!1;var M=_.firstBaseUpdate,O=_.lastBaseUpdate,X=_.shared.pending;if(X!==null){_.shared.pending=null;var rt=X,_t=rt.next;rt.next=null,O===null?M=_t:O.next=_t,O=rt;var Nt=a.alternate;Nt!==null&&(Nt=Nt.updateQueue,X=Nt.lastBaseUpdate,X!==O&&(X===null?Nt.firstBaseUpdate=_t:X.next=_t,Nt.lastBaseUpdate=rt))}if(M!==null){var Yt=_.baseState;O=0,Nt=_t=rt=null,X=M;do{var St=X.lane&-536870913,wt=St!==X.lane;if(wt?(Mn&St)===St:(p&St)===St){St!==0&&St===Po&&(qp=!0),Nt!==null&&(Nt=Nt.next={lane:0,tag:X.tag,payload:X.payload,callback:null,next:null});t:{var Me=a,Ve=X;St=o;var di=f;switch(Ve.tag){case 1:if(Me=Ve.payload,typeof Me=="function"){Yt=Me.call(di,Yt,St);break t}Yt=Me;break t;case 3:Me.flags=Me.flags&-65537|128;case 0:if(Me=Ve.payload,St=typeof Me=="function"?Me.call(di,Yt,St):Me,St==null)break t;Yt=g({},Yt,St);break t;case 2:zl=!0}}St=X.callback,St!==null&&(a.flags|=64,wt&&(a.flags|=8192),wt=_.callbacks,wt===null?_.callbacks=[St]:wt.push(St))}else wt={lane:St,tag:X.tag,payload:X.payload,callback:X.callback,next:null},Nt===null?(_t=Nt=wt,rt=Yt):Nt=Nt.next=wt,O|=St;if(X=X.next,X===null){if(X=_.shared.pending,X===null)break;wt=X,X=wt.next,wt.next=null,_.lastBaseUpdate=wt,_.shared.pending=null}}while(!0);Nt===null&&(rt=Yt),_.baseState=rt,_.firstBaseUpdate=_t,_.lastBaseUpdate=Nt,M===null&&(_.shared.lanes=0),Ha|=O,a.lanes=O,a.memoizedState=Yt}}function ro(a,o){if(typeof a!="function")throw Error(n(191,a));a.call(o)}function Es(a,o){var f=a.callbacks;if(f!==null)for(a.callbacks=null,a=0;a<f.length;a++)ro(f[a],o)}var Ra=V(null),Zs=V(0);function Xp(a,o){a=Vi,xt(Zs,a),xt(Ra,o),Vi=a|o.baseLanes}function Jp(){xt(Zs,Vi),xt(Ra,Ra.current)}function Ls(){Vi=Zs.current,st(Ra),st(Zs)}var ts=V(null),ar=null;function Fl(a){var o=a.alternate;xt(Di,Di.current&1),xt(ts,a),ar===null&&(o===null||Ra.current!==null||o.memoizedState!==null)&&(ar=a)}function Zp(a){xt(Di,Di.current),xt(ts,a),ar===null&&(ar=a)}function H0(a){a.tag===22?(xt(Di,Di.current),xt(ts,a),ar===null&&(ar=a)):ko()}function ko(){xt(Di,Di.current),xt(ts,ts.current)}function Na(a){st(ts),ar===a&&(ar=null),st(Di)}var Di=V(0);function IA(a){for(var o=a;o!==null;){if(o.tag===13){var f=o.memoizedState;if(f!==null&&(f=f.dehydrated,f===null||C_(f)||b_(f)))return o}else if(o.tag===19&&(o.memoizedProps.revealOrder==="forwards"||o.memoizedProps.revealOrder==="backwards"||o.memoizedProps.revealOrder==="unstable_legacy-backwards"||o.memoizedProps.revealOrder==="together")){if((o.flags&128)!==0)return o}else if(o.child!==null){o.child.return=o,o=o.child;continue}if(o===a)break;for(;o.sibling===null;){if(o.return===null||o.return===a)return null;o=o.return}o.sibling.return=o.return,o=o.sibling}return null}var oa=0,Ye=null,ii=null,Ji=null,BA=!1,oo=!1,Mc=!1,MA=0,Ph=0,lo=null,e_=0;function Ri(){throw Error(n(321))}function Wp(a,o){if(o===null)return!1;for(var f=0;f<o.length&&f<a.length;f++)if(!mi(a[f],o[f]))return!1;return!0}function jp(a,o,f,p,_,M){return oa=M,Ye=o,o.memoizedState=null,o.updateQueue=null,o.lanes=0,H.H=a===null||a.memoizedState===null?cy:wu,Mc=!1,M=f(p,_),Mc=!1,oo&&(M=Y0(o,f,p,_)),V0(a),M}function V0(a){H.H=Yh;var o=ii!==null&&ii.next!==null;if(oa=0,Ji=ii=Ye=null,BA=!1,Ph=0,lo=null,o)throw Error(n(300));a===null||yi||(a=a.dependencies,a!==null&&Cu(a)&&(yi=!0))}function Y0(a,o,f,p){Ye=a;var _=0;do{if(oo&&(lo=null),Ph=0,oo=!1,25<=_)throw Error(n(301));if(_+=1,Ji=ii=null,a.updateQueue!=null){var M=a.updateQueue;M.lastEffect=null,M.events=null,M.stores=null,M.memoCache!=null&&(M.memoCache.index=0)}H.H=qh,M=o(f,p)}while(oo);return M}function n_(){var a=H.H,o=a.useState()[0];return o=typeof o.then=="function"?kh(o):o,a=a.useState()[0],(ii!==null?ii.memoizedState:null)!==a&&(Ye.flags|=1024),o}function Kp(){var a=MA!==0;return MA=0,a}function $p(a,o,f){o.updateQueue=a.updateQueue,o.flags&=-2053,a.lanes&=~f}function tg(a){if(BA){for(a=a.memoizedState;a!==null;){var o=a.queue;o!==null&&(o.pending=null),a=a.next}BA=!1}oa=0,Ji=ii=Ye=null,oo=!1,Ph=MA=0,lo=null}function Ws(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Ji===null?Ye.memoizedState=Ji=a:Ji=Ji.next=a,Ji}function Pi(){if(ii===null){var a=Ye.alternate;a=a!==null?a.memoizedState:null}else a=ii.next;var o=Ji===null?Ye.memoizedState:Ji.next;if(o!==null)Ji=o,ii=a;else{if(a===null)throw Ye.alternate===null?Error(n(467)):Error(n(310));ii=a,a={memoizedState:ii.memoizedState,baseState:ii.baseState,baseQueue:ii.baseQueue,queue:ii.queue,next:null},Ji===null?Ye.memoizedState=Ji=a:Ji=Ji.next=a}return Ji}function Gh(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function kh(a){var o=Ph;return Ph+=1,lo===null&&(lo=[]),a=kp(lo,a,o),o=Ye,(Ji===null?o.memoizedState:Ji.next)===null&&(o=o.alternate,H.H=o===null||o.memoizedState===null?cy:wu),a}function wA(a){if(a!==null&&typeof a=="object"){if(typeof a.then=="function")return kh(a);if(a.$$typeof===w)return us(a)}throw Error(n(438,String(a)))}function eg(a){var o=null,f=Ye.updateQueue;if(f!==null&&(o=f.memoCache),o==null){var p=Ye.alternate;p!==null&&(p=p.updateQueue,p!==null&&(p=p.memoCache,p!=null&&(o={data:p.data.map(function(_){return _.slice()}),index:0})))}if(o==null&&(o={data:[],index:0}),f===null&&(f=Gh(),Ye.updateQueue=f),f.memoCache=o,f=o.data[o.index],f===void 0)for(f=o.data[o.index]=Array(a),p=0;p<a;p++)f[p]=L;return o.index++,f}function Ho(a,o){return typeof o=="function"?o(a):o}function TA(a){var o=Pi();return ng(o,ii,a)}function ng(a,o,f){var p=a.queue;if(p===null)throw Error(n(311));p.lastRenderedReducer=f;var _=a.baseQueue,M=p.pending;if(M!==null){if(_!==null){var O=_.next;_.next=M.next,M.next=O}o.baseQueue=_=M,p.pending=null}if(M=a.baseState,_===null)a.memoizedState=M;else{o=_.next;var X=O=null,rt=null,_t=o,Nt=!1;do{var Yt=_t.lane&-536870913;if(Yt!==_t.lane?(Mn&Yt)===Yt:(oa&Yt)===Yt){var St=_t.revertLane;if(St===0)rt!==null&&(rt=rt.next={lane:0,revertLane:0,gesture:null,action:_t.action,hasEagerState:_t.hasEagerState,eagerState:_t.eagerState,next:null}),Yt===Po&&(Nt=!0);else if((oa&St)===St){_t=_t.next,St===Po&&(Nt=!0);continue}else Yt={lane:0,revertLane:_t.revertLane,gesture:null,action:_t.action,hasEagerState:_t.hasEagerState,eagerState:_t.eagerState,next:null},rt===null?(X=rt=Yt,O=M):rt=rt.next=Yt,Ye.lanes|=St,Ha|=St;Yt=_t.action,Mc&&f(M,Yt),M=_t.hasEagerState?_t.eagerState:f(M,Yt)}else St={lane:Yt,revertLane:_t.revertLane,gesture:_t.gesture,action:_t.action,hasEagerState:_t.hasEagerState,eagerState:_t.eagerState,next:null},rt===null?(X=rt=St,O=M):rt=rt.next=St,Ye.lanes|=Yt,Ha|=Yt;_t=_t.next}while(_t!==null&&_t!==o);if(rt===null?O=M:rt.next=X,!mi(M,a.memoizedState)&&(yi=!0,Nt&&(f=Qr,f!==null)))throw f;a.memoizedState=M,a.baseState=O,a.baseQueue=rt,p.lastRenderedState=M}return _===null&&(p.lanes=0),[a.memoizedState,p.dispatch]}function QA(a){var o=Pi(),f=o.queue;if(f===null)throw Error(n(311));f.lastRenderedReducer=a;var p=f.dispatch,_=f.pending,M=o.memoizedState;if(_!==null){f.pending=null;var O=_=_.next;do M=a(M,O.action),O=O.next;while(O!==_);mi(M,o.memoizedState)||(yi=!0),o.memoizedState=M,o.baseQueue===null&&(o.baseState=M),f.lastRenderedState=M}return[M,p]}function ig(a,o,f){var p=Ye,_=Pi(),M=wn;if(M){if(f===void 0)throw Error(n(407));f=f()}else f=o();var O=!mi((ii||_).memoizedState,f);if(O&&(_.memoizedState=f,yi=!0),_=_.queue,lg(ag.bind(null,p,_,a),[a]),_.getSnapshot!==o||O||Ji!==null&&Ji.memoizedState.tag&1){if(p.flags|=2048,Bu(9,{destroy:void 0},sg.bind(null,p,_,f,o),null),Zn===null)throw Error(n(349));M||(oa&127)!==0||q0(p,o,f)}return f}function q0(a,o,f){a.flags|=16384,a={getSnapshot:o,value:f},o=Ye.updateQueue,o===null?(o=Gh(),Ye.updateQueue=o,o.stores=[a]):(f=o.stores,f===null?o.stores=[a]:f.push(a))}function sg(a,o,f,p){o.value=f,o.getSnapshot=p,rg(o)&&DA(a)}function ag(a,o,f){return f(function(){rg(o)&&DA(a)})}function rg(a){var o=a.getSnapshot;a=a.value;try{var f=o();return!mi(a,f)}catch{return!0}}function DA(a){var o=wl(a,2);o!==null&&h(o,a,2)}function Hh(a){var o=Ws();if(typeof a=="function"){var f=a;if(a=f(),Mc){Be(!0);try{f()}finally{Be(!1)}}}return o.memoizedState=o.baseState=a,o.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ho,lastRenderedState:a},o}function X0(a,o,f,p){return a.baseState=f,ng(a,ii,typeof p=="function"?p:Ho)}function i_(a,o,f,p,_){if(Vo(a))throw Error(n(485));if(a=o.action,a!==null){var M={payload:_,action:a,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(O){M.listeners.push(O)}};H.T!==null?f(!0):M.isTransition=!1,p(M),f=o.pending,f===null?(M.next=o.pending=M,J0(o,M)):(M.next=f.next,o.pending=f.next=M)}}function J0(a,o){var f=o.action,p=o.payload,_=a.state;if(o.isTransition){var M=H.T,O={};H.T=O;try{var X=f(_,p),rt=H.S;rt!==null&&rt(O,X),Z0(a,o,X)}catch(_t){RA(a,o,_t)}finally{M!==null&&O.types!==null&&(M.types=O.types),H.T=M}}else try{M=f(_,p),Z0(a,o,M)}catch(_t){RA(a,o,_t)}}function Z0(a,o,f){f!==null&&typeof f=="object"&&typeof f.then=="function"?f.then(function(p){og(a,o,p)},function(p){return RA(a,o,p)}):og(a,o,f)}function og(a,o,f){o.status="fulfilled",o.value=f,W0(o),a.state=f,o=a.pending,o!==null&&(f=o.next,f===o?a.pending=null:(f=f.next,o.next=f,J0(a,f)))}function RA(a,o,f){var p=a.pending;if(a.pending=null,p!==null){p=p.next;do o.status="rejected",o.reason=f,W0(o),o=o.next;while(o!==p)}a.action=null}function W0(a){a=a.listeners;for(var o=0;o<a.length;o++)(0,a[o])()}function j0(a,o){return o}function K0(a,o){if(wn){var f=Zn.formState;if(f!==null){t:{var p=Ye;if(wn){if(hi){e:{for(var _=hi,M=cs;_.nodeType!==8;){if(!M){_=null;break e}if(_=po(_.nextSibling),_===null){_=null;break e}}M=_.data,_=M==="F!"||M==="F"?_:null}if(_){hi=po(_.nextSibling),p=_.data==="F!";break t}}Bn(p)}p=!1}p&&(o=f[0])}}return f=Ws(),f.memoizedState=f.baseState=o,p={pending:null,lanes:0,dispatch:null,lastRenderedReducer:j0,lastRenderedState:o},f.queue=p,f=ly.bind(null,Ye,p),p.dispatch=f,p=Hh(!1),M=Vh.bind(null,Ye,!1,p.queue),p=Ws(),_={state:o,dispatch:null,action:a,pending:null},p.queue=_,f=i_.bind(null,Ye,_,M,f),_.dispatch=f,p.memoizedState=a,[o,f,!1]}function $0(a){var o=Pi();return ty(o,ii,a)}function ty(a,o,f){if(o=ng(a,o,j0)[0],a=TA(Ho)[0],typeof o=="object"&&o!==null&&typeof o.then=="function")try{var p=kh(o)}catch(O){throw O===Nl?Dr:O}else p=o;o=Pi();var _=o.queue,M=_.dispatch;return f!==o.memoizedState&&(Ye.flags|=2048,Bu(9,{destroy:void 0},s_.bind(null,_,f),null)),[p,M,a]}function s_(a,o){a.action=o}function ey(a){var o=Pi(),f=ii;if(f!==null)return ty(o,f,a);Pi(),o=o.memoizedState,f=Pi();var p=f.queue.dispatch;return f.memoizedState=a,[o,p,!1]}function Bu(a,o,f,p){return a={tag:a,create:f,deps:p,inst:o,next:null},o=Ye.updateQueue,o===null&&(o=Gh(),Ye.updateQueue=o),f=o.lastEffect,f===null?o.lastEffect=a.next=a:(p=f.next,f.next=a,a.next=p,o.lastEffect=a),a}function ny(){return Pi().memoizedState}function NA(a,o,f,p){var _=Ws();Ye.flags|=a,_.memoizedState=Bu(1|o,{destroy:void 0},f,p===void 0?null:p)}function UA(a,o,f,p){var _=Pi();p=p===void 0?null:p;var M=_.memoizedState.inst;ii!==null&&p!==null&&Wp(p,ii.memoizedState.deps)?_.memoizedState=Bu(o,M,f,p):(Ye.flags|=a,_.memoizedState=Bu(1|o,M,f,p))}function iy(a,o){NA(8390656,8,a,o)}function lg(a,o){UA(2048,8,a,o)}function sy(a){Ye.flags|=4;var o=Ye.updateQueue;if(o===null)o=Gh(),Ye.updateQueue=o,o.events=[a];else{var f=o.events;f===null?o.events=[a]:f.push(a)}}function ay(a){var o=Pi().memoizedState;return sy({ref:o,nextImpl:a}),function(){if((Dn&2)!==0)throw Error(n(440));return o.impl.apply(void 0,arguments)}}function ry(a,o){return UA(4,2,a,o)}function Ua(a,o){return UA(4,4,a,o)}function cg(a,o){if(typeof o=="function"){a=a();var f=o(a);return function(){typeof f=="function"?f():o(null)}}if(o!=null)return a=a(),o.current=a,function(){o.current=null}}function LA(a,o,f){f=f!=null?f.concat([a]):null,UA(4,4,cg.bind(null,o,a),f)}function zA(){}function ug(a,o){var f=Pi();o=o===void 0?null:o;var p=f.memoizedState;return o!==null&&Wp(o,p[1])?p[0]:(f.memoizedState=[a,o],a)}function hg(a,o){var f=Pi();o=o===void 0?null:o;var p=f.memoizedState;if(o!==null&&Wp(o,p[1]))return p[0];if(p=a(),Mc){Be(!0);try{a()}finally{Be(!1)}}return f.memoizedState=[p,o],p}function fg(a,o,f){return f===void 0||(oa&1073741824)!==0&&(Mn&261930)===0?a.memoizedState=o:(a.memoizedState=f,a=c(),Ye.lanes|=a,Ha|=a,f)}function Ag(a,o,f,p){return mi(f,o)?f:Ra.current!==null?(a=fg(a,f,p),mi(a,o)||(yi=!0),a):(oa&42)===0||(oa&1073741824)!==0&&(Mn&261930)===0?(yi=!0,a.memoizedState=f):(a=c(),Ye.lanes|=a,Ha|=a,o)}function dg(a,o,f,p,_){var M=tt.p;tt.p=M!==0&&8>M?M:8;var O=H.T,X={};H.T=X,Vh(a,!1,o,f);try{var rt=_(),_t=H.S;if(_t!==null&&_t(X,rt),rt!==null&&typeof rt=="object"&&typeof rt.then=="function"){var Nt=Gp(rt,p);Mu(a,o,Nt,Ks(a))}else Mu(a,o,p,Ks(a))}catch(Yt){Mu(a,o,{then:function(){},status:"rejected",reason:Yt},Ks())}finally{tt.p=M,O!==null&&X.types!==null&&(O.types=X.types),H.T=O}}function a_(){}function pg(a,o,f,p){if(a.tag!==5)throw Error(n(476));var _=oy(a).queue;dg(a,_,o,it,f===null?a_:function(){return gg(a),f(p)})}function oy(a){var o=a.memoizedState;if(o!==null)return o;o={memoizedState:it,baseState:it,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ho,lastRenderedState:it},next:null};var f={};return o.next={memoizedState:f,baseState:f,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ho,lastRenderedState:f},next:null},a.memoizedState=o,a=a.alternate,a!==null&&(a.memoizedState=o),o}function gg(a){var o=oy(a);o.next===null&&(o=a.alternate.memoizedState),Mu(a,o.next.queue,{},Ks())}function mg(){return us(Tg)}function _s(){return Pi().memoizedState}function yg(){return Pi().memoizedState}function r_(a){for(var o=a.return;o!==null;){switch(o.tag){case 24:case 3:var f=Ks();a=ao(f);var p=Go(o,a,f);p!==null&&(h(p,o,f),Ol(p,o,f)),o={cache:Op()},a.payload=o;return}o=o.return}}function o_(a,o,f){var p=Ks();f={lane:p,revertLane:0,gesture:null,action:f,hasEagerState:!1,eagerState:null,next:null},Vo(a)?wc(o,f):(f=vu(a,o,f,p),f!==null&&(h(f,a,p),la(f,o,p)))}function ly(a,o,f){var p=Ks();Mu(a,o,f,p)}function Mu(a,o,f,p){var _={lane:p,revertLane:0,gesture:null,action:f,hasEagerState:!1,eagerState:null,next:null};if(Vo(a))wc(o,_);else{var M=a.alternate;if(a.lanes===0&&(M===null||M.lanes===0)&&(M=o.lastRenderedReducer,M!==null))try{var O=o.lastRenderedState,X=M(O,f);if(_.hasEagerState=!0,_.eagerState=X,mi(X,O))return wh(a,o,_,0),Zn===null&&Ml(),!1}catch{}if(f=vu(a,o,_,p),f!==null)return h(f,a,p),la(f,o,p),!0}return!1}function Vh(a,o,f,p){if(p={lane:2,revertLane:h_(),gesture:null,action:p,hasEagerState:!1,eagerState:null,next:null},Vo(a)){if(o)throw Error(n(479))}else o=vu(a,f,p,2),o!==null&&h(o,a,2)}function Vo(a){var o=a.alternate;return a===Ye||o!==null&&o===Ye}function wc(a,o){oo=BA=!0;var f=a.pending;f===null?o.next=o:(o.next=f.next,f.next=o),a.pending=o}function la(a,o,f){if((f&4194048)!==0){var p=o.lanes;p&=a.pendingLanes,f|=p,o.lanes=f,br(a,f)}}var Yh={readContext:us,use:wA,useCallback:Ri,useContext:Ri,useEffect:Ri,useImperativeHandle:Ri,useLayoutEffect:Ri,useInsertionEffect:Ri,useMemo:Ri,useReducer:Ri,useRef:Ri,useState:Ri,useDebugValue:Ri,useDeferredValue:Ri,useTransition:Ri,useSyncExternalStore:Ri,useId:Ri,useHostTransitionStatus:Ri,useFormState:Ri,useActionState:Ri,useOptimistic:Ri,useMemoCache:Ri,useCacheRefresh:Ri};Yh.useEffectEvent=Ri;var cy={readContext:us,use:wA,useCallback:function(a,o){return Ws().memoizedState=[a,o===void 0?null:o],a},useContext:us,useEffect:iy,useImperativeHandle:function(a,o,f){f=f!=null?f.concat([a]):null,NA(4194308,4,cg.bind(null,o,a),f)},useLayoutEffect:function(a,o){return NA(4194308,4,a,o)},useInsertionEffect:function(a,o){NA(4,2,a,o)},useMemo:function(a,o){var f=Ws();o=o===void 0?null:o;var p=a();if(Mc){Be(!0);try{a()}finally{Be(!1)}}return f.memoizedState=[p,o],p},useReducer:function(a,o,f){var p=Ws();if(f!==void 0){var _=f(o);if(Mc){Be(!0);try{f(o)}finally{Be(!1)}}}else _=o;return p.memoizedState=p.baseState=_,a={pending:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:_},p.queue=a,a=a.dispatch=o_.bind(null,Ye,a),[p.memoizedState,a]},useRef:function(a){var o=Ws();return a={current:a},o.memoizedState=a},useState:function(a){a=Hh(a);var o=a.queue,f=ly.bind(null,Ye,o);return o.dispatch=f,[a.memoizedState,f]},useDebugValue:zA,useDeferredValue:function(a,o){var f=Ws();return fg(f,a,o)},useTransition:function(){var a=Hh(!1);return a=dg.bind(null,Ye,a.queue,!0,!1),Ws().memoizedState=a,[!1,a]},useSyncExternalStore:function(a,o,f){var p=Ye,_=Ws();if(wn){if(f===void 0)throw Error(n(407));f=f()}else{if(f=o(),Zn===null)throw Error(n(349));(Mn&127)!==0||q0(p,o,f)}_.memoizedState=f;var M={value:f,getSnapshot:o};return _.queue=M,iy(ag.bind(null,p,M,a),[a]),p.flags|=2048,Bu(9,{destroy:void 0},sg.bind(null,p,M,f,o),null),f},useId:function(){var a=Ws(),o=Zn.identifierPrefix;if(wn){var f=io,p=no;f=(p&~(1<<32-ve(p)-1)).toString(32)+f,o="_"+o+"R_"+f,f=MA++,0<f&&(o+="H"+f.toString(32)),o+="_"}else f=e_++,o="_"+o+"r_"+f.toString(32)+"_";return a.memoizedState=o},useHostTransitionStatus:mg,useFormState:K0,useActionState:K0,useOptimistic:function(a){var o=Ws();o.memoizedState=o.baseState=a;var f={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return o.queue=f,o=Vh.bind(null,Ye,!0,f),f.dispatch=o,[a,o]},useMemoCache:eg,useCacheRefresh:function(){return Ws().memoizedState=r_.bind(null,Ye)},useEffectEvent:function(a){var o=Ws(),f={impl:a};return o.memoizedState=f,function(){if((Dn&2)!==0)throw Error(n(440));return f.impl.apply(void 0,arguments)}}},wu={readContext:us,use:wA,useCallback:ug,useContext:us,useEffect:lg,useImperativeHandle:LA,useInsertionEffect:ry,useLayoutEffect:Ua,useMemo:hg,useReducer:TA,useRef:ny,useState:function(){return TA(Ho)},useDebugValue:zA,useDeferredValue:function(a,o){var f=Pi();return Ag(f,ii.memoizedState,a,o)},useTransition:function(){var a=TA(Ho)[0],o=Pi().memoizedState;return[typeof a=="boolean"?a:kh(a),o]},useSyncExternalStore:ig,useId:_s,useHostTransitionStatus:mg,useFormState:$0,useActionState:$0,useOptimistic:function(a,o){var f=Pi();return X0(f,ii,a,o)},useMemoCache:eg,useCacheRefresh:yg};wu.useEffectEvent=ay;var qh={readContext:us,use:wA,useCallback:ug,useContext:us,useEffect:lg,useImperativeHandle:LA,useInsertionEffect:ry,useLayoutEffect:Ua,useMemo:hg,useReducer:QA,useRef:ny,useState:function(){return QA(Ho)},useDebugValue:zA,useDeferredValue:function(a,o){var f=Pi();return ii===null?fg(f,a,o):Ag(f,ii.memoizedState,a,o)},useTransition:function(){var a=QA(Ho)[0],o=Pi().memoizedState;return[typeof a=="boolean"?a:kh(a),o]},useSyncExternalStore:ig,useId:_s,useHostTransitionStatus:mg,useFormState:ey,useActionState:ey,useOptimistic:function(a,o){var f=Pi();return ii!==null?X0(f,ii,a,o):(f.baseState=a,[a,f.queue.dispatch])},useMemoCache:eg,useCacheRefresh:yg};qh.useEffectEvent=ay;function Tu(a,o,f,p){o=a.memoizedState,f=f(p,o),f=f==null?o:g({},o,f),a.memoizedState=f,a.lanes===0&&(a.updateQueue.baseState=f)}var Xh={enqueueSetState:function(a,o,f){a=a._reactInternals;var p=Ks(),_=ao(p);_.payload=o,f!=null&&(_.callback=f),o=Go(a,_,p),o!==null&&(h(o,a,p),Ol(o,a,p))},enqueueReplaceState:function(a,o,f){a=a._reactInternals;var p=Ks(),_=ao(p);_.tag=1,_.payload=o,f!=null&&(_.callback=f),o=Go(a,_,p),o!==null&&(h(o,a,p),Ol(o,a,p))},enqueueForceUpdate:function(a,o){a=a._reactInternals;var f=Ks(),p=ao(f);p.tag=2,o!=null&&(p.callback=o),o=Go(a,p,f),o!==null&&(h(o,a,f),Ol(o,a,f))}};function uy(a,o,f,p,_,M,O){return a=a.stateNode,typeof a.shouldComponentUpdate=="function"?a.shouldComponentUpdate(p,M,O):o.prototype&&o.prototype.isPureReactComponent?!du(f,p)||!du(_,M):!0}function hy(a,o,f,p){a=o.state,typeof o.componentWillReceiveProps=="function"&&o.componentWillReceiveProps(f,p),typeof o.UNSAFE_componentWillReceiveProps=="function"&&o.UNSAFE_componentWillReceiveProps(f,p),o.state!==a&&Xh.enqueueReplaceState(o,o.state,null)}function Cs(a,o){var f=o;if("ref"in o){f={};for(var p in o)p!=="ref"&&(f[p]=o[p])}if(a=a.defaultProps){f===o&&(f=g({},f));for(var _ in a)f[_]===void 0&&(f[_]=a[_])}return f}function xg(a){Bl(a)}function fy(a){console.error(a)}function OA(a){Bl(a)}function FA(a,o){try{var f=a.onUncaughtError;f(o.value,{componentStack:o.stack})}catch(p){setTimeout(function(){throw p})}}function Ay(a,o,f){try{var p=a.onCaughtError;p(f.value,{componentStack:f.stack,errorBoundary:o.tag===1?o.stateNode:null})}catch(_){setTimeout(function(){throw _})}}function vg(a,o,f){return f=ao(f),f.tag=3,f.payload={element:null},f.callback=function(){FA(a,o)},f}function Qu(a){return a=ao(a),a.tag=3,a}function ca(a,o,f,p){var _=f.type.getDerivedStateFromError;if(typeof _=="function"){var M=p.value;a.payload=function(){return _(M)},a.callback=function(){Ay(o,f,p)}}var O=f.stateNode;O!==null&&typeof O.componentDidCatch=="function"&&(a.callback=function(){Ay(o,f,p),typeof _!="function"&&(Ao===null?Ao=new Set([this]):Ao.add(this));var X=p.stack;this.componentDidCatch(p.value,{componentStack:X!==null?X:""})})}function La(a,o,f,p,_){if(f.flags|=32768,p!==null&&typeof p=="object"&&typeof p.then=="function"){if(o=f.alternate,o!==null&&Dl(o,f,_,!0),f=ts.current,f!==null){switch(f.tag){case 31:case 13:return ar===null?tn():f.alternate===null&&Wn===0&&(Wn=3),f.flags&=-257,f.flags|=65536,f.lanes=_,p===Lh?f.flags|=16384:(o=f.updateQueue,o===null?f.updateQueue=new Set([p]):o.add(p),l_(a,p,_)),!1;case 22:return f.flags|=65536,p===Lh?f.flags|=16384:(o=f.updateQueue,o===null?(o={transitions:null,markerInstances:null,retryQueue:new Set([p])},f.updateQueue=o):(f=o.retryQueue,f===null?o.retryQueue=new Set([p]):f.add(p)),l_(a,p,_)),!1}throw Error(n(435,f.tag))}return l_(a,p,_),tn(),!1}if(wn)return o=ts.current,o!==null?((o.flags&65536)===0&&(o.flags|=256),o.flags|=65536,o.lanes=_,p!==xA&&(a=Error(n(422),{cause:p}),Rh(aa(a,f)))):(p!==xA&&(o=Error(n(423),{cause:p}),Rh(aa(o,f))),a=a.current.alternate,a.flags|=65536,_&=-_,a.lanes|=_,p=aa(p,f),_=vg(a.stateNode,p,_),SA(a,_),Wn!==4&&(Wn=2)),!1;var M=Error(n(520),{cause:p});if(M=aa(M,f),zr===null?zr=[M]:zr.push(M),Wn!==4&&(Wn=2),o===null)return!0;p=aa(p,f),f=o;do{switch(f.tag){case 3:return f.flags|=65536,a=_&-_,f.lanes|=a,a=vg(f.stateNode,p,a),SA(f,a),!1;case 1:if(o=f.type,M=f.stateNode,(f.flags&128)===0&&(typeof o.getDerivedStateFromError=="function"||M!==null&&typeof M.componentDidCatch=="function"&&(Ao===null||!Ao.has(M))))return f.flags|=65536,_&=-_,f.lanes|=_,_=Qu(_),ca(_,a,f,p),SA(f,_),!1}f=f.return}while(f!==null);return!1}var PA=Error(n(461)),yi=!1;function Ni(a,o,f,p){o.child=a===null?k0(o,null,f,p):Ic(o,a.child,f,p)}function Jh(a,o,f,p,_){f=f.render;var M=o.ref;if("ref"in p){var O={};for(var X in p)X!=="ref"&&(O[X]=p[X])}else O=p;return Cc(o),p=jp(a,o,f,O,M,_),X=Kp(),a!==null&&!yi?($p(a,o,_),Ur(a,o,_)):(wn&&X&&yA(o),o.flags|=1,Ni(a,o,p,_),o.child)}function Zh(a,o,f,p,_){if(a===null){var M=f.type;return typeof M=="function"&&!Js(M)&&M.defaultProps===void 0&&f.compare===null?(o.tag=15,o.type=M,za(a,o,M,p,_)):(a=Th(f.type,null,p,o,o.mode,_),a.ref=o.ref,a.return=o,o.child=a)}if(M=a.child,!Gl(a,_)){var O=M.memoizedProps;if(f=f.compare,f=f!==null?f:du,f(O,p)&&a.ref===o.ref)return Ur(a,o,_)}return o.flags|=1,a=to(M,p),a.ref=o.ref,a.return=o,o.child=a}function za(a,o,f,p,_){if(a!==null){var M=a.memoizedProps;if(du(M,p)&&a.ref===o.ref)if(yi=!1,o.pendingProps=p=M,Gl(a,_))(a.flags&131072)!==0&&(yi=!0);else return o.lanes=a.lanes,Ur(a,o,_)}return Du(a,o,f,p,_)}function Oa(a,o,f,p){var _=p.children,M=a!==null?a.memoizedState:null;if(a===null&&o.stateNode===null&&(o.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),p.mode==="hidden"){if((o.flags&128)!==0){if(M=M!==null?M.baseLanes|f:f,a!==null){for(p=o.child=a.child,_=0;p!==null;)_=_|p.lanes|p.childLanes,p=p.sibling;p=_&~M}else p=0,o.child=null;return co(a,o,M,f,p)}if((f&536870912)!==0)o.memoizedState={baseLanes:0,cachePool:null},a!==null&&Su(o,M!==null?M.cachePool:null),M!==null?Xp(o,M):Jp(),H0(o);else return p=o.lanes=536870912,co(a,o,M!==null?M.baseLanes|f:f,f,p)}else M!==null?(Su(o,M.cachePool),Xp(o,M),ko(),o.memoizedState=null):(a!==null&&Su(o,null),Jp(),ko());return Ni(a,o,_,f),o.child}function Rr(a,o){return a!==null&&a.tag===22||o.stateNode!==null||(o.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),o.sibling}function co(a,o,f,p,_){var M=so();return M=M===null?null:{parent:Le._currentValue,pool:M},o.memoizedState={baseLanes:f,cachePool:M},a!==null&&Su(o,null),Jp(),H0(o),a!==null&&Dl(a,o,p,!0),o.childLanes=_,null}function rr(a,o){return o=Ru({mode:o.mode,children:o.children},a.mode),o.ref=a.ref,a.child=o,o.return=a,o}function hs(a,o,f){return Ic(o,a.child,null,f),a=rr(o,o.pendingProps),a.flags|=2,Na(o),o.memoizedState=null,a}function Wh(a,o,f){var p=o.pendingProps,_=(o.flags&128)!==0;if(o.flags&=-129,a===null){if(wn){if(p.mode==="hidden")return a=rr(o,p),o.lanes=536870912,Rr(null,a);if(Zp(o),(a=hi)?(a=zI(a,cs),a=a!==null&&a.data==="&"?a:null,a!==null&&(o.memoizedState={dehydrated:a,treeContext:eo!==null?{id:no,overflow:io}:null,retryLane:536870912,hydrationErrors:null},f=L0(a),f.return=o,o.child=f,ls=o,hi=null)):a=null,a===null)throw Bn(o);return o.lanes=536870912,null}return rr(o,p)}var M=a.memoizedState;if(M!==null){var O=M.dehydrated;if(Zp(o),_)if(o.flags&256)o.flags&=-257,o=hs(a,o,f);else if(o.memoizedState!==null)o.child=a.child,o.flags|=128,o=null;else throw Error(n(558));else if(yi||Dl(a,o,f,!1),_=(f&a.childLanes)!==0,yi||_){if(p=Zn,p!==null&&(O=qr(p,f),O!==0&&O!==M.retryLane))throw M.retryLane=O,wl(a,O),h(p,a,O),PA;tn(),o=hs(a,o,f)}else a=M.treeContext,hi=po(O.nextSibling),ls=o,wn=!0,Lo=null,cs=!1,a!==null&&Dh(o,a),o=rr(o,p),o.flags|=4096;return o}return a=to(a.child,{mode:p.mode,children:p.children}),a.ref=o.ref,o.child=a,a.return=o,a}function Nr(a,o){var f=o.ref;if(f===null)a!==null&&a.ref!==null&&(o.flags|=4194816);else{if(typeof f!="function"&&typeof f!="object")throw Error(n(284));(a===null||a.ref!==f)&&(o.flags|=4194816)}}function Du(a,o,f,p,_){return Cc(o),f=jp(a,o,f,p,void 0,_),p=Kp(),a!==null&&!yi?($p(a,o,_),Ur(a,o,_)):(wn&&p&&yA(o),o.flags|=1,Ni(a,o,f,_),o.child)}function zs(a,o,f,p,_,M){return Cc(o),o.updateQueue=null,f=Y0(o,p,f,_),V0(a),p=Kp(),a!==null&&!yi?($p(a,o,M),Ur(a,o,M)):(wn&&p&&yA(o),o.flags|=1,Ni(a,o,f,M),o.child)}function bs(a,o,f,p,_){if(Cc(o),o.stateNode===null){var M=Tl,O=f.contextType;typeof O=="object"&&O!==null&&(M=us(O)),M=new f(p,M),o.memoizedState=M.state!==null&&M.state!==void 0?M.state:null,M.updater=Xh,o.stateNode=M,M._reactInternals=o,M=o.stateNode,M.props=p,M.state=o.memoizedState,M.refs={},Vp(o),O=f.contextType,M.context=typeof O=="object"&&O!==null?us(O):Tl,M.state=o.memoizedState,O=f.getDerivedStateFromProps,typeof O=="function"&&(Tu(o,f,O,p),M.state=o.memoizedState),typeof f.getDerivedStateFromProps=="function"||typeof M.getSnapshotBeforeUpdate=="function"||typeof M.UNSAFE_componentWillMount!="function"&&typeof M.componentWillMount!="function"||(O=M.state,typeof M.componentWillMount=="function"&&M.componentWillMount(),typeof M.UNSAFE_componentWillMount=="function"&&M.UNSAFE_componentWillMount(),O!==M.state&&Xh.enqueueReplaceState(M,M.state,null),Bc(o,p,M,_),Fh(),M.state=o.memoizedState),typeof M.componentDidMount=="function"&&(o.flags|=4194308),p=!0}else if(a===null){M=o.stateNode;var X=o.memoizedProps,rt=Cs(f,X);M.props=rt;var _t=M.context,Nt=f.contextType;O=Tl,typeof Nt=="object"&&Nt!==null&&(O=us(Nt));var Yt=f.getDerivedStateFromProps;Nt=typeof Yt=="function"||typeof M.getSnapshotBeforeUpdate=="function",X=o.pendingProps!==X,Nt||typeof M.UNSAFE_componentWillReceiveProps!="function"&&typeof M.componentWillReceiveProps!="function"||(X||_t!==O)&&hy(o,M,p,O),zl=!1;var St=o.memoizedState;M.state=St,Bc(o,p,M,_),Fh(),_t=o.memoizedState,X||St!==_t||zl?(typeof Yt=="function"&&(Tu(o,f,Yt,p),_t=o.memoizedState),(rt=zl||uy(o,f,rt,p,St,_t,O))?(Nt||typeof M.UNSAFE_componentWillMount!="function"&&typeof M.componentWillMount!="function"||(typeof M.componentWillMount=="function"&&M.componentWillMount(),typeof M.UNSAFE_componentWillMount=="function"&&M.UNSAFE_componentWillMount()),typeof M.componentDidMount=="function"&&(o.flags|=4194308)):(typeof M.componentDidMount=="function"&&(o.flags|=4194308),o.memoizedProps=p,o.memoizedState=_t),M.props=p,M.state=_t,M.context=O,p=rt):(typeof M.componentDidMount=="function"&&(o.flags|=4194308),p=!1)}else{M=o.stateNode,Yp(a,o),O=o.memoizedProps,Nt=Cs(f,O),M.props=Nt,Yt=o.pendingProps,St=M.context,_t=f.contextType,rt=Tl,typeof _t=="object"&&_t!==null&&(rt=us(_t)),X=f.getDerivedStateFromProps,(_t=typeof X=="function"||typeof M.getSnapshotBeforeUpdate=="function")||typeof M.UNSAFE_componentWillReceiveProps!="function"&&typeof M.componentWillReceiveProps!="function"||(O!==Yt||St!==rt)&&hy(o,M,p,rt),zl=!1,St=o.memoizedState,M.state=St,Bc(o,p,M,_),Fh();var wt=o.memoizedState;O!==Yt||St!==wt||zl||a!==null&&a.dependencies!==null&&Cu(a.dependencies)?(typeof X=="function"&&(Tu(o,f,X,p),wt=o.memoizedState),(Nt=zl||uy(o,f,Nt,p,St,wt,rt)||a!==null&&a.dependencies!==null&&Cu(a.dependencies))?(_t||typeof M.UNSAFE_componentWillUpdate!="function"&&typeof M.componentWillUpdate!="function"||(typeof M.componentWillUpdate=="function"&&M.componentWillUpdate(p,wt,rt),typeof M.UNSAFE_componentWillUpdate=="function"&&M.UNSAFE_componentWillUpdate(p,wt,rt)),typeof M.componentDidUpdate=="function"&&(o.flags|=4),typeof M.getSnapshotBeforeUpdate=="function"&&(o.flags|=1024)):(typeof M.componentDidUpdate!="function"||O===a.memoizedProps&&St===a.memoizedState||(o.flags|=4),typeof M.getSnapshotBeforeUpdate!="function"||O===a.memoizedProps&&St===a.memoizedState||(o.flags|=1024),o.memoizedProps=p,o.memoizedState=wt),M.props=p,M.state=wt,M.context=rt,p=Nt):(typeof M.componentDidUpdate!="function"||O===a.memoizedProps&&St===a.memoizedState||(o.flags|=4),typeof M.getSnapshotBeforeUpdate!="function"||O===a.memoizedProps&&St===a.memoizedState||(o.flags|=1024),p=!1)}return M=p,Nr(a,o),p=(o.flags&128)!==0,M||p?(M=o.stateNode,f=p&&typeof f.getDerivedStateFromError!="function"?null:M.render(),o.flags|=1,a!==null&&p?(o.child=Ic(o,a.child,null,_),o.child=Ic(o,null,f,_)):Ni(a,o,f,_),o.memoizedState=M.state,a=o.child):a=Ur(a,o,_),a}function zn(a,o,f,p){return _c(),o.flags|=256,Ni(a,o,f,p),o.child}var Fa={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function or(a){return{baseLanes:a,cachePool:_A()}}function jh(a,o,f){return a=a!==null?a.childLanes&~f:0,o&&(a|=Rn),a}function Pa(a,o,f){var p=o.pendingProps,_=!1,M=(o.flags&128)!==0,O;if((O=M)||(O=a!==null&&a.memoizedState===null?!1:(Di.current&2)!==0),O&&(_=!0,o.flags&=-129),O=(o.flags&32)!==0,o.flags&=-33,a===null){if(wn){if(_?Fl(o):ko(),(a=hi)?(a=zI(a,cs),a=a!==null&&a.data!=="&"?a:null,a!==null&&(o.memoizedState={dehydrated:a,treeContext:eo!==null?{id:no,overflow:io}:null,retryLane:536870912,hydrationErrors:null},f=L0(a),f.return=o,o.child=f,ls=o,hi=null)):a=null,a===null)throw Bn(o);return b_(a)?o.lanes=32:o.lanes=536870912,null}var X=p.children;return p=p.fallback,_?(ko(),_=o.mode,X=Ru({mode:"hidden",children:X},_),p=No(p,_,f,null),X.return=o,p.return=o,X.sibling=p,o.child=X,p=o.child,p.memoizedState=or(f),p.childLanes=jh(a,O,f),o.memoizedState=Fa,Rr(null,p)):(Fl(o),Pl(o,X))}var rt=a.memoizedState;if(rt!==null&&(X=rt.dehydrated,X!==null)){if(M)o.flags&256?(Fl(o),o.flags&=-257,o=Nu(a,o,f)):o.memoizedState!==null?(ko(),o.child=a.child,o.flags|=128,o=null):(ko(),X=p.fallback,_=o.mode,p=Ru({mode:"visible",children:p.children},_),X=No(X,_,f,null),X.flags|=2,p.return=o,X.return=o,p.sibling=X,o.child=p,Ic(o,a.child,null,f),p=o.child,p.memoizedState=or(f),p.childLanes=jh(a,O,f),o.memoizedState=Fa,o=Rr(null,p));else if(Fl(o),b_(X)){if(O=X.nextSibling&&X.nextSibling.dataset,O)var _t=O.dgst;O=_t,p=Error(n(419)),p.stack="",p.digest=O,Rh({value:p,source:null,stack:null}),o=Nu(a,o,f)}else if(yi||Dl(a,o,f,!1),O=(f&a.childLanes)!==0,yi||O){if(O=Zn,O!==null&&(p=qr(O,f),p!==0&&p!==rt.retryLane))throw rt.retryLane=p,wl(a,p),h(O,a,p),PA;C_(X)||tn(),o=Nu(a,o,f)}else C_(X)?(o.flags|=192,o.child=a.child,o=null):(a=rt.treeContext,hi=po(X.nextSibling),ls=o,wn=!0,Lo=null,cs=!1,a!==null&&Dh(o,a),o=Pl(o,p.children),o.flags|=4096);return o}return _?(ko(),X=p.fallback,_=o.mode,rt=a.child,_t=rt.sibling,p=to(rt,{mode:"hidden",children:p.children}),p.subtreeFlags=rt.subtreeFlags&65011712,_t!==null?X=to(_t,X):(X=No(X,_,f,null),X.flags|=2),X.return=o,p.return=o,p.sibling=X,o.child=p,Rr(null,p),p=o.child,X=a.child.memoizedState,X===null?X=or(f):(_=X.cachePool,_!==null?(rt=Le._currentValue,_=_.parent!==rt?{parent:rt,pool:rt}:_):_=_A(),X={baseLanes:X.baseLanes|f,cachePool:_}),p.memoizedState=X,p.childLanes=jh(a,O,f),o.memoizedState=Fa,Rr(a.child,p)):(Fl(o),f=a.child,a=f.sibling,f=to(f,{mode:"visible",children:p.children}),f.return=o,f.sibling=null,a!==null&&(O=o.deletions,O===null?(o.deletions=[a],o.flags|=16):O.push(a)),o.child=f,o.memoizedState=null,f)}function Pl(a,o){return o=Ru({mode:"visible",children:o},a.mode),o.return=a,a.child=o}function Ru(a,o){return a=Xs(22,a,null,o),a.lanes=0,a}function Nu(a,o,f){return Ic(o,a.child,null,f),a=Pl(o,o.pendingProps.children),a.flags|=2,o.memoizedState=null,a}function Tc(a,o,f){a.lanes|=o;var p=a.alternate;p!==null&&(p.lanes|=o),Fo(a.return,o,f)}function Kh(a,o,f,p,_,M){var O=a.memoizedState;O===null?a.memoizedState={isBackwards:o,rendering:null,renderingStartTime:0,last:p,tail:f,tailMode:_,treeForkCount:M}:(O.isBackwards=o,O.rendering=null,O.renderingStartTime=0,O.last=p,O.tail=f,O.tailMode=_,O.treeForkCount=M)}function $h(a,o,f){var p=o.pendingProps,_=p.revealOrder,M=p.tail;p=p.children;var O=Di.current,X=(O&2)!==0;if(X?(O=O&1|2,o.flags|=128):O&=1,xt(Di,O),Ni(a,o,p,f),p=wn?_u:0,!X&&a!==null&&(a.flags&128)!==0)t:for(a=o.child;a!==null;){if(a.tag===13)a.memoizedState!==null&&Tc(a,f,o);else if(a.tag===19)Tc(a,f,o);else if(a.child!==null){a.child.return=a,a=a.child;continue}if(a===o)break t;for(;a.sibling===null;){if(a.return===null||a.return===o)break t;a=a.return}a.sibling.return=a.return,a=a.sibling}switch(_){case"forwards":for(f=o.child,_=null;f!==null;)a=f.alternate,a!==null&&IA(a)===null&&(_=f),f=f.sibling;f=_,f===null?(_=o.child,o.child=null):(_=f.sibling,f.sibling=null),Kh(o,!1,_,f,M,p);break;case"backwards":case"unstable_legacy-backwards":for(f=null,_=o.child,o.child=null;_!==null;){if(a=_.alternate,a!==null&&IA(a)===null){o.child=_;break}a=_.sibling,_.sibling=f,f=_,_=a}Kh(o,!0,f,null,M,p);break;case"together":Kh(o,!1,null,null,void 0,p);break;default:o.memoizedState=null}return o.child}function Ur(a,o,f){if(a!==null&&(o.dependencies=a.dependencies),Ha|=o.lanes,(f&o.childLanes)===0)if(a!==null){if(Dl(a,o,f,!1),(f&o.childLanes)===0)return null}else return null;if(a!==null&&o.child!==a.child)throw Error(n(153));if(o.child!==null){for(a=o.child,f=to(a,a.pendingProps),o.child=f,f.return=o;a.sibling!==null;)a=a.sibling,f=f.sibling=to(a,a.pendingProps),f.return=o;f.sibling=null}return o.child}function Gl(a,o){return(a.lanes&o)!==0?!0:(a=a.dependencies,!!(a!==null&&Cu(a)))}function tf(a,o,f){switch(o.tag){case 3:qt(o,o.stateNode.containerInfo),Oo(o,Le,a.memoizedState.cache),_c();break;case 27:case 5:ce(o);break;case 4:qt(o,o.stateNode.containerInfo);break;case 10:Oo(o,o.type,o.memoizedProps.value);break;case 31:if(o.memoizedState!==null)return o.flags|=128,Zp(o),null;break;case 13:var p=o.memoizedState;if(p!==null)return p.dehydrated!==null?(Fl(o),o.flags|=128,null):(f&o.child.childLanes)!==0?Pa(a,o,f):(Fl(o),a=Ur(a,o,f),a!==null?a.sibling:null);Fl(o);break;case 19:var _=(a.flags&128)!==0;if(p=(f&o.childLanes)!==0,p||(Dl(a,o,f,!1),p=(f&o.childLanes)!==0),_){if(p)return $h(a,o,f);o.flags|=128}if(_=o.memoizedState,_!==null&&(_.rendering=null,_.tail=null,_.lastEffect=null),xt(Di,Di.current),p)break;return null;case 22:return o.lanes=0,Oa(a,o,f,o.pendingProps);case 24:Oo(o,Le,a.memoizedState.cache)}return Ur(a,o,f)}function GA(a,o,f){if(a!==null)if(a.memoizedProps!==o.pendingProps)yi=!0;else{if(!Gl(a,f)&&(o.flags&128)===0)return yi=!1,tf(a,o,f);yi=(a.flags&131072)!==0}else yi=!1,wn&&(o.flags&1048576)!==0&&Rp(o,_u,o.index);switch(o.lanes=0,o.tag){case 16:t:{var p=o.pendingProps;if(a=Sc(o.elementType),o.type=a,typeof a=="function")Js(a)?(p=Cs(a,p),o.tag=1,o=bs(null,o,a,p,f)):(o.tag=0,o=Du(null,o,a,p,f));else{if(a!=null){var _=a.$$typeof;if(_===Q){o.tag=11,o=Jh(null,o,a,p,f);break t}else if(_===U){o.tag=14,o=Zh(null,o,a,p,f);break t}}throw o=K(a)||a,Error(n(306,o,""))}}return o;case 0:return Du(a,o,o.type,o.pendingProps,f);case 1:return p=o.type,_=Cs(p,o.pendingProps),bs(a,o,p,_,f);case 3:t:{if(qt(o,o.stateNode.containerInfo),a===null)throw Error(n(387));p=o.pendingProps;var M=o.memoizedState;_=M.element,Yp(a,o),Bc(o,p,null,f);var O=o.memoizedState;if(p=O.cache,Oo(o,Le,p),p!==M.cache&&EA(o,[Le],f,!0),Fh(),p=O.element,M.isDehydrated)if(M={element:p,isDehydrated:!1,cache:O.cache},o.updateQueue.baseState=M,o.memoizedState=M,o.flags&256){o=zn(a,o,p,f);break t}else if(p!==_){_=aa(Error(n(424)),o),Rh(_),o=zn(a,o,p,f);break t}else for(a=o.stateNode.containerInfo,a.nodeType===9?a=a.body:a=a.nodeName==="HTML"?a.ownerDocument.body:a,hi=po(a.firstChild),ls=o,wn=!0,Lo=null,cs=!0,f=k0(o,null,p,f),o.child=f;f;)f.flags=f.flags&-3|4096,f=f.sibling;else{if(_c(),p===_){o=Ur(a,o,f);break t}Ni(a,o,p,f)}o=o.child}return o;case 26:return Nr(a,o),a===null?(f=HI(o.type,null,o.pendingProps,null))?o.memoizedState=f:wn||(f=o.type,a=o.pendingProps,p=Ey(dt.current).createElement(f),p[an]=o,p[_i]=a,$s(p,f,a),vt(p),o.stateNode=p):o.memoizedState=HI(o.type,a.memoizedProps,o.pendingProps,a.memoizedState),null;case 27:return ce(o),a===null&&wn&&(p=o.stateNode=PI(o.type,o.pendingProps,dt.current),ls=o,cs=!0,_=hi,Gu(o.type)?(S_=_,hi=po(p.firstChild)):hi=_),Ni(a,o,o.pendingProps.children,f),Nr(a,o),a===null&&(o.flags|=4194304),o.child;case 5:return a===null&&wn&&((_=p=hi)&&(p=ZT(p,o.type,o.pendingProps,cs),p!==null?(o.stateNode=p,ls=o,hi=po(p.firstChild),cs=!1,_=!0):_=!1),_||Bn(o)),ce(o),_=o.type,M=o.pendingProps,O=a!==null?a.memoizedProps:null,p=M.children,v_(_,M)?p=null:O!==null&&v_(_,O)&&(o.flags|=32),o.memoizedState!==null&&(_=jp(a,o,n_,null,null,f),Tg._currentValue=_),Nr(a,o),Ni(a,o,p,f),o.child;case 6:return a===null&&wn&&((a=f=hi)&&(f=WT(f,o.pendingProps,cs),f!==null?(o.stateNode=f,ls=o,hi=null,a=!0):a=!1),a||Bn(o)),null;case 13:return Pa(a,o,f);case 4:return qt(o,o.stateNode.containerInfo),p=o.pendingProps,a===null?o.child=Ic(o,null,p,f):Ni(a,o,p,f),o.child;case 11:return Jh(a,o,o.type,o.pendingProps,f);case 7:return Ni(a,o,o.pendingProps,f),o.child;case 8:return Ni(a,o,o.pendingProps.children,f),o.child;case 12:return Ni(a,o,o.pendingProps.children,f),o.child;case 10:return p=o.pendingProps,Oo(o,o.type,p.value),Ni(a,o,p.children,f),o.child;case 9:return _=o.type._context,p=o.pendingProps.children,Cc(o),_=us(_),p=p(_),o.flags|=1,Ni(a,o,p,f),o.child;case 14:return Zh(a,o,o.type,o.pendingProps,f);case 15:return za(a,o,o.type,o.pendingProps,f);case 19:return $h(a,o,f);case 31:return Wh(a,o,f);case 22:return Oa(a,o,f,o.pendingProps);case 24:return Cc(o),p=us(Le),a===null?(_=so(),_===null&&(_=Zn,M=Op(),_.pooledCache=M,M.refCount++,M!==null&&(_.pooledCacheLanes|=f),_=M),o.memoizedState={parent:p,cache:_},Vp(o),Oo(o,Le,_)):((a.lanes&f)!==0&&(Yp(a,o),Bc(o,null,null,f),Fh()),_=a.memoizedState,M=o.memoizedState,_.parent!==p?(_={parent:p,cache:p},o.memoizedState=_,o.lanes===0&&(o.memoizedState=o.updateQueue.baseState=_),Oo(o,Le,p)):(p=M.cache,Oo(o,Le,p),p!==_.cache&&EA(o,[Le],f,!0))),Ni(a,o,o.pendingProps.children,f),o.child;case 29:throw o.pendingProps}throw Error(n(156,o.tag))}function ua(a){a.flags|=4}function kl(a,o,f,p,_){if((o=(a.mode&32)!==0)&&(o=!1),o){if(a.flags|=16777216,(_&335544128)===_)if(a.stateNode.complete)a.flags|=8192;else if(ne())a.flags|=8192;else throw ke=Lh,Uh}else a.flags&=-16777217}function Yo(a,o){if(o.type!=="stylesheet"||(o.state.loading&4)!==0)a.flags&=-16777217;else if(a.flags|=16777216,!JI(o))if(ne())a.flags|=8192;else throw ke=Lh,Uh}function Uu(a,o){o!==null&&(a.flags|=4),a.flags&16384&&(o=a.tag!==22?In():536870912,a.lanes|=o,Va|=o)}function ef(a,o){if(!wn)switch(a.tailMode){case"hidden":o=a.tail;for(var f=null;o!==null;)o.alternate!==null&&(f=o),o=o.sibling;f===null?a.tail=null:f.sibling=null;break;case"collapsed":f=a.tail;for(var p=null;f!==null;)f.alternate!==null&&(p=f),f=f.sibling;p===null?o||a.tail===null?a.tail=null:a.tail.sibling=null:p.sibling=null}}function ni(a){var o=a.alternate!==null&&a.alternate.child===a.child,f=0,p=0;if(o)for(var _=a.child;_!==null;)f|=_.lanes|_.childLanes,p|=_.subtreeFlags&65011712,p|=_.flags&65011712,_.return=a,_=_.sibling;else for(_=a.child;_!==null;)f|=_.lanes|_.childLanes,p|=_.subtreeFlags,p|=_.flags,_.return=a,_=_.sibling;return a.subtreeFlags|=p,a.childLanes=f,o}function Eg(a,o,f){var p=o.pendingProps;switch(Ql(o),o.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return ni(o),null;case 1:return ni(o),null;case 3:return f=o.stateNode,p=null,a!==null&&(p=a.memoizedState.cache),o.memoizedState.cache!==p&&(o.flags|=2048),sr(Le),Wt(),f.pendingContext&&(f.context=f.pendingContext,f.pendingContext=null),(a===null||a.child===null)&&(Ec(o)?ua(o):a===null||a.memoizedState.isDehydrated&&(o.flags&256)===0||(o.flags|=1024,Np())),ni(o),null;case 26:var _=o.type,M=o.memoizedState;return a===null?(ua(o),M!==null?(ni(o),Yo(o,M)):(ni(o),kl(o,_,null,p,f))):M?M!==a.memoizedState?(ua(o),ni(o),Yo(o,M)):(ni(o),o.flags&=-16777217):(a=a.memoizedProps,a!==p&&ua(o),ni(o),kl(o,_,a,p,f)),null;case 27:if(Ie(o),f=dt.current,_=o.type,a!==null&&o.stateNode!=null)a.memoizedProps!==p&&ua(o);else{if(!p){if(o.stateNode===null)throw Error(n(166));return ni(o),null}a=j.current,Ec(o)?vA(o):(a=PI(_,p,f),o.stateNode=a,ua(o))}return ni(o),null;case 5:if(Ie(o),_=o.type,a!==null&&o.stateNode!=null)a.memoizedProps!==p&&ua(o);else{if(!p){if(o.stateNode===null)throw Error(n(166));return ni(o),null}if(M=j.current,Ec(o))vA(o);else{var O=Ey(dt.current);switch(M){case 1:M=O.createElementNS("http://www.w3.org/2000/svg",_);break;case 2:M=O.createElementNS("http://www.w3.org/1998/Math/MathML",_);break;default:switch(_){case"svg":M=O.createElementNS("http://www.w3.org/2000/svg",_);break;case"math":M=O.createElementNS("http://www.w3.org/1998/Math/MathML",_);break;case"script":M=O.createElement("div"),M.innerHTML="<script><\/script>",M=M.removeChild(M.firstChild);break;case"select":M=typeof p.is=="string"?O.createElement("select",{is:p.is}):O.createElement("select"),p.multiple?M.multiple=!0:p.size&&(M.size=p.size);break;default:M=typeof p.is=="string"?O.createElement(_,{is:p.is}):O.createElement(_)}}M[an]=o,M[_i]=p;t:for(O=o.child;O!==null;){if(O.tag===5||O.tag===6)M.appendChild(O.stateNode);else if(O.tag!==4&&O.tag!==27&&O.child!==null){O.child.return=O,O=O.child;continue}if(O===o)break t;for(;O.sibling===null;){if(O.return===null||O.return===o)break t;O=O.return}O.sibling.return=O.return,O=O.sibling}o.stateNode=M;t:switch($s(M,_,p),_){case"button":case"input":case"select":case"textarea":p=!!p.autoFocus;break t;case"img":p=!0;break t;default:p=!1}p&&ua(o)}}return ni(o),kl(o,o.type,a===null?null:a.memoizedProps,o.pendingProps,f),null;case 6:if(a&&o.stateNode!=null)a.memoizedProps!==p&&ua(o);else{if(typeof p!="string"&&o.stateNode===null)throw Error(n(166));if(a=dt.current,Ec(o)){if(a=o.stateNode,f=o.memoizedProps,p=null,_=ls,_!==null)switch(_.tag){case 27:case 5:p=_.memoizedProps}a[an]=o,a=!!(a.nodeValue===f||p!==null&&p.suppressHydrationWarning===!0||wI(a.nodeValue,f)),a||Bn(o,!0)}else a=Ey(a).createTextNode(p),a[an]=o,o.stateNode=a}return ni(o),null;case 31:if(f=o.memoizedState,a===null||a.memoizedState!==null){if(p=Ec(o),f!==null){if(a===null){if(!p)throw Error(n(318));if(a=o.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(n(557));a[an]=o}else _c(),(o.flags&128)===0&&(o.memoizedState=null),o.flags|=4;ni(o),a=!1}else f=Np(),a!==null&&a.memoizedState!==null&&(a.memoizedState.hydrationErrors=f),a=!0;if(!a)return o.flags&256?(Na(o),o):(Na(o),null);if((o.flags&128)!==0)throw Error(n(558))}return ni(o),null;case 13:if(p=o.memoizedState,a===null||a.memoizedState!==null&&a.memoizedState.dehydrated!==null){if(_=Ec(o),p!==null&&p.dehydrated!==null){if(a===null){if(!_)throw Error(n(318));if(_=o.memoizedState,_=_!==null?_.dehydrated:null,!_)throw Error(n(317));_[an]=o}else _c(),(o.flags&128)===0&&(o.memoizedState=null),o.flags|=4;ni(o),_=!1}else _=Np(),a!==null&&a.memoizedState!==null&&(a.memoizedState.hydrationErrors=_),_=!0;if(!_)return o.flags&256?(Na(o),o):(Na(o),null)}return Na(o),(o.flags&128)!==0?(o.lanes=f,o):(f=p!==null,a=a!==null&&a.memoizedState!==null,f&&(p=o.child,_=null,p.alternate!==null&&p.alternate.memoizedState!==null&&p.alternate.memoizedState.cachePool!==null&&(_=p.alternate.memoizedState.cachePool.pool),M=null,p.memoizedState!==null&&p.memoizedState.cachePool!==null&&(M=p.memoizedState.cachePool.pool),M!==_&&(p.flags|=2048)),f!==a&&f&&(o.child.flags|=8192),Uu(o,o.updateQueue),ni(o),null);case 4:return Wt(),a===null&&p_(o.stateNode.containerInfo),ni(o),null;case 10:return sr(o.type),ni(o),null;case 19:if(st(Di),p=o.memoizedState,p===null)return ni(o),null;if(_=(o.flags&128)!==0,M=p.rendering,M===null)if(_)ef(p,!1);else{if(Wn!==0||a!==null&&(a.flags&128)!==0)for(a=o.child;a!==null;){if(M=IA(a),M!==null){for(o.flags|=128,ef(p,!1),a=M.updateQueue,o.updateQueue=a,Uu(o,a),o.subtreeFlags=0,a=f,f=o.child;f!==null;)Ns(f,a),f=f.sibling;return xt(Di,Di.current&1|2),wn&&Uo(o,p.treeForkCount),o.child}a=a.sibling}p.tail!==null&&G()>Ya&&(o.flags|=128,_=!0,ef(p,!1),o.lanes=4194304)}else{if(!_)if(a=IA(M),a!==null){if(o.flags|=128,_=!0,a=a.updateQueue,o.updateQueue=a,Uu(o,a),ef(p,!0),p.tail===null&&p.tailMode==="hidden"&&!M.alternate&&!wn)return ni(o),null}else 2*G()-p.renderingStartTime>Ya&&f!==536870912&&(o.flags|=128,_=!0,ef(p,!1),o.lanes=4194304);p.isBackwards?(M.sibling=o.child,o.child=M):(a=p.last,a!==null?a.sibling=M:o.child=M,p.last=M)}return p.tail!==null?(a=p.tail,p.rendering=a,p.tail=a.sibling,p.renderingStartTime=G(),a.sibling=null,f=Di.current,xt(Di,_?f&1|2:f&1),wn&&Uo(o,p.treeForkCount),a):(ni(o),null);case 22:case 23:return Na(o),Ls(),p=o.memoizedState!==null,a!==null?a.memoizedState!==null!==p&&(o.flags|=8192):p&&(o.flags|=8192),p?(f&536870912)!==0&&(o.flags&128)===0&&(ni(o),o.subtreeFlags&6&&(o.flags|=8192)):ni(o),f=o.updateQueue,f!==null&&Uu(o,f.retryQueue),f=null,a!==null&&a.memoizedState!==null&&a.memoizedState.cachePool!==null&&(f=a.memoizedState.cachePool.pool),p=null,o.memoizedState!==null&&o.memoizedState.cachePool!==null&&(p=o.memoizedState.cachePool.pool),p!==f&&(o.flags|=2048),a!==null&&st(Rl),null;case 24:return f=null,a!==null&&(f=a.memoizedState.cache),o.memoizedState.cache!==f&&(o.flags|=2048),sr(Le),ni(o),null;case 25:return null;case 30:return null}throw Error(n(156,o.tag))}function kA(a,o){switch(Ql(o),o.tag){case 1:return a=o.flags,a&65536?(o.flags=a&-65537|128,o):null;case 3:return sr(Le),Wt(),a=o.flags,(a&65536)!==0&&(a&128)===0?(o.flags=a&-65537|128,o):null;case 26:case 27:case 5:return Ie(o),null;case 31:if(o.memoizedState!==null){if(Na(o),o.alternate===null)throw Error(n(340));_c()}return a=o.flags,a&65536?(o.flags=a&-65537|128,o):null;case 13:if(Na(o),a=o.memoizedState,a!==null&&a.dehydrated!==null){if(o.alternate===null)throw Error(n(340));_c()}return a=o.flags,a&65536?(o.flags=a&-65537|128,o):null;case 19:return st(Di),null;case 4:return Wt(),null;case 10:return sr(o.type),null;case 22:case 23:return Na(o),Ls(),a!==null&&st(Rl),a=o.flags,a&65536?(o.flags=a&-65537|128,o):null;case 24:return sr(Le),null;case 25:return null;default:return null}}function Qc(a,o){switch(Ql(o),o.tag){case 3:sr(Le),Wt();break;case 26:case 27:case 5:Ie(o);break;case 4:Wt();break;case 31:o.memoizedState!==null&&Na(o);break;case 13:Na(o);break;case 19:st(Di);break;case 10:sr(o.type);break;case 22:case 23:Na(o),Ls(),a!==null&&st(Rl);break;case 24:sr(Le)}}function uo(a,o){try{var f=o.updateQueue,p=f!==null?f.lastEffect:null;if(p!==null){var _=p.next;f=_;do{if((f.tag&a)===a){p=void 0;var M=f.create,O=f.inst;p=M(),O.destroy=p}f=f.next}while(f!==_)}}catch(X){ci(o,o.return,X)}}function lr(a,o,f){try{var p=o.updateQueue,_=p!==null?p.lastEffect:null;if(_!==null){var M=_.next;p=M;do{if((p.tag&a)===a){var O=p.inst,X=O.destroy;if(X!==void 0){O.destroy=void 0,_=o;var rt=f,_t=X;try{_t()}catch(Nt){ci(_,rt,Nt)}}}p=p.next}while(p!==M)}}catch(Nt){ci(o,o.return,Nt)}}function Hl(a){var o=a.updateQueue;if(o!==null){var f=a.stateNode;try{Es(o,f)}catch(p){ci(a,a.return,p)}}}function _g(a,o,f){f.props=Cs(a.type,a.memoizedProps),f.state=a.memoizedState;try{f.componentWillUnmount()}catch(p){ci(a,o,p)}}function ho(a,o){try{var f=a.ref;if(f!==null){switch(a.tag){case 26:case 27:case 5:var p=a.stateNode;break;case 30:p=a.stateNode;break;default:p=a.stateNode}typeof f=="function"?a.refCleanup=f(p):f.current=p}}catch(_){ci(a,o,_)}}function Ga(a,o){var f=a.ref,p=a.refCleanup;if(f!==null)if(typeof p=="function")try{p()}catch(_){ci(a,o,_)}finally{a.refCleanup=null,a=a.alternate,a!=null&&(a.refCleanup=null)}else if(typeof f=="function")try{f(null)}catch(_){ci(a,o,_)}else f.current=null}function ka(a){var o=a.type,f=a.memoizedProps,p=a.stateNode;try{t:switch(o){case"button":case"input":case"select":case"textarea":f.autoFocus&&p.focus();break t;case"img":f.src?p.src=f.src:f.srcSet&&(p.srcset=f.srcSet)}}catch(_){ci(a,a.return,_)}}function cr(a,o,f){try{var p=a.stateNode;HT(p,a.type,f,o),p[_i]=o}catch(_){ci(a,a.return,_)}}function Zi(a){return a.tag===5||a.tag===3||a.tag===26||a.tag===27&&Gu(a.type)||a.tag===4}function fo(a){t:for(;;){for(;a.sibling===null;){if(a.return===null||Zi(a.return))return null;a=a.return}for(a.sibling.return=a.return,a=a.sibling;a.tag!==5&&a.tag!==6&&a.tag!==18;){if(a.tag===27&&Gu(a.type)||a.flags&2||a.child===null||a.tag===4)continue t;a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}function un(a,o,f){var p=a.tag;if(p===5||p===6)a=a.stateNode,o?(f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f).insertBefore(a,o):(o=f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f,o.appendChild(a),f=f._reactRootContainer,f!=null||o.onclick!==null||(o.onclick=nr));else if(p!==4&&(p===27&&Gu(a.type)&&(f=a.stateNode,o=null),a=a.child,a!==null))for(un(a,o,f),a=a.sibling;a!==null;)un(a,o,f),a=a.sibling}function Yn(a,o,f){var p=a.tag;if(p===5||p===6)a=a.stateNode,o?f.insertBefore(a,o):f.appendChild(a);else if(p!==4&&(p===27&&Gu(a.type)&&(f=a.stateNode),a=a.child,a!==null))for(Yn(a,o,f),a=a.sibling;a!==null;)Yn(a,o,f),a=a.sibling}function Gi(a){var o=a.stateNode,f=a.memoizedProps;try{for(var p=a.type,_=o.attributes;_.length;)o.removeAttributeNode(_[0]);$s(o,p,f),o[an]=a,o[_i]=f}catch(M){ci(a,a.return,M)}}var ur=!1,xi=!1,qo=!1,nf=typeof WeakSet=="function"?WeakSet:Set,Ui=null;function Lu(a,o){if(a=a.containerInfo,y_=My,a=uA(a),pu(a)){if("selectionStart"in a)var f={start:a.selectionStart,end:a.selectionEnd};else t:{f=(f=a.ownerDocument)&&f.defaultView||window;var p=f.getSelection&&f.getSelection();if(p&&p.rangeCount!==0){f=p.anchorNode;var _=p.anchorOffset,M=p.focusNode;p=p.focusOffset;try{f.nodeType,M.nodeType}catch{f=null;break t}var O=0,X=-1,rt=-1,_t=0,Nt=0,Yt=a,St=null;e:for(;;){for(var wt;Yt!==f||_!==0&&Yt.nodeType!==3||(X=O+_),Yt!==M||p!==0&&Yt.nodeType!==3||(rt=O+p),Yt.nodeType===3&&(O+=Yt.nodeValue.length),(wt=Yt.firstChild)!==null;)St=Yt,Yt=wt;for(;;){if(Yt===a)break e;if(St===f&&++_t===_&&(X=O),St===M&&++Nt===p&&(rt=O),(wt=Yt.nextSibling)!==null)break;Yt=St,St=Yt.parentNode}Yt=wt}f=X===-1||rt===-1?null:{start:X,end:rt}}else f=null}f=f||{start:0,end:0}}else f=null;for(x_={focusedElem:a,selectionRange:f},My=!1,Ui=o;Ui!==null;)if(o=Ui,a=o.child,(o.subtreeFlags&1028)!==0&&a!==null)a.return=o,Ui=a;else for(;Ui!==null;){switch(o=Ui,M=o.alternate,a=o.flags,o.tag){case 0:if((a&4)!==0&&(a=o.updateQueue,a=a!==null?a.events:null,a!==null))for(f=0;f<a.length;f++)_=a[f],_.ref.impl=_.nextImpl;break;case 11:case 15:break;case 1:if((a&1024)!==0&&M!==null){a=void 0,f=o,_=M.memoizedProps,M=M.memoizedState,p=f.stateNode;try{var Me=Cs(f.type,_);a=p.getSnapshotBeforeUpdate(Me,M),p.__reactInternalSnapshotBeforeUpdate=a}catch(Ve){ci(f,f.return,Ve)}}break;case 3:if((a&1024)!==0){if(a=o.stateNode.containerInfo,f=a.nodeType,f===9)__(a);else if(f===1)switch(a.nodeName){case"HEAD":case"HTML":case"BODY":__(a);break;default:a.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((a&1024)!==0)throw Error(n(163))}if(a=o.sibling,a!==null){a.return=o.return,Ui=a;break}Ui=o.return}}function dy(a,o,f){var p=f.flags;switch(f.tag){case 0:case 11:case 15:Xo(a,f),p&4&&uo(5,f);break;case 1:if(Xo(a,f),p&4)if(a=f.stateNode,o===null)try{a.componentDidMount()}catch(O){ci(f,f.return,O)}else{var _=Cs(f.type,o.memoizedProps);o=o.memoizedState;try{a.componentDidUpdate(_,o,a.__reactInternalSnapshotBeforeUpdate)}catch(O){ci(f,f.return,O)}}p&64&&Hl(f),p&512&&ho(f,f.return);break;case 3:if(Xo(a,f),p&64&&(a=f.updateQueue,a!==null)){if(o=null,f.child!==null)switch(f.child.tag){case 27:case 5:o=f.child.stateNode;break;case 1:o=f.child.stateNode}try{Es(a,o)}catch(O){ci(f,f.return,O)}}break;case 27:o===null&&p&4&&Gi(f);case 26:case 5:Xo(a,f),o===null&&p&4&&ka(f),p&512&&ho(f,f.return);break;case 12:Xo(a,f);break;case 31:Xo(a,f),p&4&&VA(a,f);break;case 13:Xo(a,f),p&4&&Cg(a,f),p&64&&(a=f.memoizedState,a!==null&&(a=a.dehydrated,a!==null&&(f=QT.bind(null,f),jT(a,f))));break;case 22:if(p=f.memoizedState!==null||ur,!p){o=o!==null&&o.memoizedState!==null||xi,_=ur;var M=xi;ur=p,(xi=o)&&!M?Jn(a,f,(f.subtreeFlags&8772)!==0):Xo(a,f),ur=_,xi=M}break;case 30:break;default:Xo(a,f)}}function HA(a){var o=a.alternate;o!==null&&(a.alternate=null,HA(o)),a.child=null,a.deletions=null,a.sibling=null,a.tag===5&&(o=a.stateNode,o!==null&&Ir(o)),a.stateNode=null,a.return=null,a.dependencies=null,a.memoizedProps=null,a.memoizedState=null,a.pendingProps=null,a.stateNode=null,a.updateQueue=null}var On=null,Wi=!1;function Os(a,o,f){for(f=f.child;f!==null;)Vl(a,o,f),f=f.sibling}function Vl(a,o,f){if(Jt&&typeof Jt.onCommitFiberUnmount=="function")try{Jt.onCommitFiberUnmount(Gt,f)}catch{}switch(f.tag){case 26:xi||Ga(f,o),Os(a,o,f),f.memoizedState?f.memoizedState.count--:f.stateNode&&(f=f.stateNode,f.parentNode.removeChild(f));break;case 27:xi||Ga(f,o);var p=On,_=Wi;Gu(f.type)&&(On=f.stateNode,Wi=!1),Os(a,o,f),Bg(f.stateNode),On=p,Wi=_;break;case 5:xi||Ga(f,o);case 6:if(p=On,_=Wi,On=null,Os(a,o,f),On=p,Wi=_,On!==null)if(Wi)try{(On.nodeType===9?On.body:On.nodeName==="HTML"?On.ownerDocument.body:On).removeChild(f.stateNode)}catch(M){ci(f,o,M)}else try{On.removeChild(f.stateNode)}catch(M){ci(f,o,M)}break;case 18:On!==null&&(Wi?(a=On,UI(a.nodeType===9?a.body:a.nodeName==="HTML"?a.ownerDocument.body:a,f.stateNode),ed(a)):UI(On,f.stateNode));break;case 4:p=On,_=Wi,On=f.stateNode.containerInfo,Wi=!0,Os(a,o,f),On=p,Wi=_;break;case 0:case 11:case 14:case 15:lr(2,f,o),xi||lr(4,f,o),Os(a,o,f);break;case 1:xi||(Ga(f,o),p=f.stateNode,typeof p.componentWillUnmount=="function"&&_g(f,o,p)),Os(a,o,f);break;case 21:Os(a,o,f);break;case 22:xi=(p=xi)||f.memoizedState!==null,Os(a,o,f),xi=p;break;default:Os(a,o,f)}}function VA(a,o){if(o.memoizedState===null&&(a=o.alternate,a!==null&&(a=a.memoizedState,a!==null))){a=a.dehydrated;try{ed(a)}catch(f){ci(o,o.return,f)}}}function Cg(a,o){if(o.memoizedState===null&&(a=o.alternate,a!==null&&(a=a.memoizedState,a!==null&&(a=a.dehydrated,a!==null))))try{ed(a)}catch(f){ci(o,o.return,f)}}function py(a){switch(a.tag){case 31:case 13:case 19:var o=a.stateNode;return o===null&&(o=a.stateNode=new nf),o;case 22:return a=a.stateNode,o=a._retryCache,o===null&&(o=a._retryCache=new nf),o;default:throw Error(n(435,a.tag))}}function ki(a,o){var f=py(a);o.forEach(function(p){if(!f.has(p)){f.add(p);var _=DT.bind(null,a,p);p.then(_,_)}})}function Fs(a,o){var f=o.deletions;if(f!==null)for(var p=0;p<f.length;p++){var _=f[p],M=a,O=o,X=O;t:for(;X!==null;){switch(X.tag){case 27:if(Gu(X.type)){On=X.stateNode,Wi=!1;break t}break;case 5:On=X.stateNode,Wi=!1;break t;case 3:case 4:On=X.stateNode.containerInfo,Wi=!0;break t}X=X.return}if(On===null)throw Error(n(160));Vl(M,O,_),On=null,Wi=!1,M=_.alternate,M!==null&&(M.return=null),_.return=null}if(o.subtreeFlags&13886)for(o=o.child;o!==null;)Yl(o,a),o=o.sibling}var ha=null;function Yl(a,o){var f=a.alternate,p=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:Fs(o,a),Li(a),p&4&&(lr(3,a,a.return),uo(3,a),lr(5,a,a.return));break;case 1:Fs(o,a),Li(a),p&512&&(xi||f===null||Ga(f,f.return)),p&64&&ur&&(a=a.updateQueue,a!==null&&(p=a.callbacks,p!==null&&(f=a.shared.hiddenCallbacks,a.shared.hiddenCallbacks=f===null?p:f.concat(p))));break;case 26:var _=ha;if(Fs(o,a),Li(a),p&512&&(xi||f===null||Ga(f,f.return)),p&4){var M=f!==null?f.memoizedState:null;if(p=a.memoizedState,f===null)if(p===null)if(a.stateNode===null){t:{p=a.type,f=a.memoizedProps,_=_.ownerDocument||_;e:switch(p){case"title":M=_.getElementsByTagName("title")[0],(!M||M[ia]||M[an]||M.namespaceURI==="http://www.w3.org/2000/svg"||M.hasAttribute("itemprop"))&&(M=_.createElement(p),_.head.insertBefore(M,_.querySelector("head > title"))),$s(M,p,f),M[an]=a,vt(M),p=M;break t;case"link":var O=qI("link","href",_).get(p+(f.href||""));if(O){for(var X=0;X<O.length;X++)if(M=O[X],M.getAttribute("href")===(f.href==null||f.href===""?null:f.href)&&M.getAttribute("rel")===(f.rel==null?null:f.rel)&&M.getAttribute("title")===(f.title==null?null:f.title)&&M.getAttribute("crossorigin")===(f.crossOrigin==null?null:f.crossOrigin)){O.splice(X,1);break e}}M=_.createElement(p),$s(M,p,f),_.head.appendChild(M);break;case"meta":if(O=qI("meta","content",_).get(p+(f.content||""))){for(X=0;X<O.length;X++)if(M=O[X],M.getAttribute("content")===(f.content==null?null:""+f.content)&&M.getAttribute("name")===(f.name==null?null:f.name)&&M.getAttribute("property")===(f.property==null?null:f.property)&&M.getAttribute("http-equiv")===(f.httpEquiv==null?null:f.httpEquiv)&&M.getAttribute("charset")===(f.charSet==null?null:f.charSet)){O.splice(X,1);break e}}M=_.createElement(p),$s(M,p,f),_.head.appendChild(M);break;default:throw Error(n(468,p))}M[an]=a,vt(M),p=M}a.stateNode=p}else XI(_,a.type,a.stateNode);else a.stateNode=YI(_,p,a.memoizedProps);else M!==p?(M===null?f.stateNode!==null&&(f=f.stateNode,f.parentNode.removeChild(f)):M.count--,p===null?XI(_,a.type,a.stateNode):YI(_,p,a.memoizedProps)):p===null&&a.stateNode!==null&&cr(a,a.memoizedProps,f.memoizedProps)}break;case 27:Fs(o,a),Li(a),p&512&&(xi||f===null||Ga(f,f.return)),f!==null&&p&4&&cr(a,a.memoizedProps,f.memoizedProps);break;case 5:if(Fs(o,a),Li(a),p&512&&(xi||f===null||Ga(f,f.return)),a.flags&32){_=a.stateNode;try{Ma(_,"")}catch(Me){ci(a,a.return,Me)}}p&4&&a.stateNode!=null&&(_=a.memoizedProps,cr(a,_,f!==null?f.memoizedProps:_)),p&1024&&(qo=!0);break;case 6:if(Fs(o,a),Li(a),p&4){if(a.stateNode===null)throw Error(n(162));p=a.memoizedProps,f=a.stateNode;try{f.nodeValue=p}catch(Me){ci(a,a.return,Me)}}break;case 3:if(by=null,_=ha,ha=_y(o.containerInfo),Fs(o,a),ha=_,Li(a),p&4&&f!==null&&f.memoizedState.isDehydrated)try{ed(o.containerInfo)}catch(Me){ci(a,a.return,Me)}qo&&(qo=!1,gy(a));break;case 4:p=ha,ha=_y(a.stateNode.containerInfo),Fs(o,a),Li(a),ha=p;break;case 12:Fs(o,a),Li(a);break;case 31:Fs(o,a),Li(a),p&4&&(p=a.updateQueue,p!==null&&(a.updateQueue=null,ki(a,p)));break;case 13:Fs(o,a),Li(a),a.child.flags&8192&&a.memoizedState!==null!=(f!==null&&f.memoizedState!==null)&&(Wo=G()),p&4&&(p=a.updateQueue,p!==null&&(a.updateQueue=null,ki(a,p)));break;case 22:_=a.memoizedState!==null;var rt=f!==null&&f.memoizedState!==null,_t=ur,Nt=xi;if(ur=_t||_,xi=Nt||rt,Fs(o,a),xi=Nt,ur=_t,Li(a),p&8192)t:for(o=a.stateNode,o._visibility=_?o._visibility&-2:o._visibility|1,_&&(f===null||rt||ur||xi||Dc(a)),f=null,o=a;;){if(o.tag===5||o.tag===26){if(f===null){rt=f=o;try{if(M=rt.stateNode,_)O=M.style,typeof O.setProperty=="function"?O.setProperty("display","none","important"):O.display="none";else{X=rt.stateNode;var Yt=rt.memoizedProps.style,St=Yt!=null&&Yt.hasOwnProperty("display")?Yt.display:null;X.style.display=St==null||typeof St=="boolean"?"":(""+St).trim()}}catch(Me){ci(rt,rt.return,Me)}}}else if(o.tag===6){if(f===null){rt=o;try{rt.stateNode.nodeValue=_?"":rt.memoizedProps}catch(Me){ci(rt,rt.return,Me)}}}else if(o.tag===18){if(f===null){rt=o;try{var wt=rt.stateNode;_?LI(wt,!0):LI(rt.stateNode,!1)}catch(Me){ci(rt,rt.return,Me)}}}else if((o.tag!==22&&o.tag!==23||o.memoizedState===null||o===a)&&o.child!==null){o.child.return=o,o=o.child;continue}if(o===a)break t;for(;o.sibling===null;){if(o.return===null||o.return===a)break t;f===o&&(f=null),o=o.return}f===o&&(f=null),o.sibling.return=o.return,o=o.sibling}p&4&&(p=a.updateQueue,p!==null&&(f=p.retryQueue,f!==null&&(p.retryQueue=null,ki(a,f))));break;case 19:Fs(o,a),Li(a),p&4&&(p=a.updateQueue,p!==null&&(a.updateQueue=null,ki(a,p)));break;case 30:break;case 21:break;default:Fs(o,a),Li(a)}}function Li(a){var o=a.flags;if(o&2){try{for(var f,p=a.return;p!==null;){if(Zi(p)){f=p;break}p=p.return}if(f==null)throw Error(n(160));switch(f.tag){case 27:var _=f.stateNode,M=fo(a);Yn(a,M,_);break;case 5:var O=f.stateNode;f.flags&32&&(Ma(O,""),f.flags&=-33);var X=fo(a);Yn(a,X,O);break;case 3:case 4:var rt=f.stateNode.containerInfo,_t=fo(a);un(a,_t,rt);break;default:throw Error(n(161))}}catch(Nt){ci(a,a.return,Nt)}a.flags&=-3}o&4096&&(a.flags&=-4097)}function gy(a){if(a.subtreeFlags&1024)for(a=a.child;a!==null;){var o=a;gy(o),o.tag===5&&o.flags&1024&&o.stateNode.reset(),a=a.sibling}}function Xo(a,o){if(o.subtreeFlags&8772)for(o=o.child;o!==null;)dy(a,o.alternate,o),o=o.sibling}function Dc(a){for(a=a.child;a!==null;){var o=a;switch(o.tag){case 0:case 11:case 14:case 15:lr(4,o,o.return),Dc(o);break;case 1:Ga(o,o.return);var f=o.stateNode;typeof f.componentWillUnmount=="function"&&_g(o,o.return,f),Dc(o);break;case 27:Bg(o.stateNode);case 26:case 5:Ga(o,o.return),Dc(o);break;case 22:o.memoizedState===null&&Dc(o);break;case 30:Dc(o);break;default:Dc(o)}a=a.sibling}}function Jn(a,o,f){for(f=f&&(o.subtreeFlags&8772)!==0,o=o.child;o!==null;){var p=o.alternate,_=a,M=o,O=M.flags;switch(M.tag){case 0:case 11:case 15:Jn(_,M,f),uo(4,M);break;case 1:if(Jn(_,M,f),p=M,_=p.stateNode,typeof _.componentDidMount=="function")try{_.componentDidMount()}catch(_t){ci(p,p.return,_t)}if(p=M,_=p.updateQueue,_!==null){var X=p.stateNode;try{var rt=_.shared.hiddenCallbacks;if(rt!==null)for(_.shared.hiddenCallbacks=null,_=0;_<rt.length;_++)ro(rt[_],X)}catch(_t){ci(p,p.return,_t)}}f&&O&64&&Hl(M),ho(M,M.return);break;case 27:Gi(M);case 26:case 5:Jn(_,M,f),f&&p===null&&O&4&&ka(M),ho(M,M.return);break;case 12:Jn(_,M,f);break;case 31:Jn(_,M,f),f&&O&4&&VA(_,M);break;case 13:Jn(_,M,f),f&&O&4&&Cg(_,M);break;case 22:M.memoizedState===null&&Jn(_,M,f),ho(M,M.return);break;case 30:break;default:Jn(_,M,f)}o=o.sibling}}function YA(a,o){var f=null;a!==null&&a.memoizedState!==null&&a.memoizedState.cachePool!==null&&(f=a.memoizedState.cachePool.pool),a=null,o.memoizedState!==null&&o.memoizedState.cachePool!==null&&(a=o.memoizedState.cachePool.pool),a!==f&&(a!=null&&a.refCount++,f!=null&&vs(f))}function Jo(a,o){a=null,o.alternate!==null&&(a=o.alternate.memoizedState.cache),o=o.memoizedState.cache,o!==a&&(o.refCount++,a!=null&&vs(a))}function es(a,o,f,p){if(o.subtreeFlags&10256)for(o=o.child;o!==null;)Ii(a,o,f,p),o=o.sibling}function Ii(a,o,f,p){var _=o.flags;switch(o.tag){case 0:case 11:case 15:es(a,o,f,p),_&2048&&uo(9,o);break;case 1:es(a,o,f,p);break;case 3:es(a,o,f,p),_&2048&&(a=null,o.alternate!==null&&(a=o.alternate.memoizedState.cache),o=o.memoizedState.cache,o!==a&&(o.refCount++,a!=null&&vs(a)));break;case 12:if(_&2048){es(a,o,f,p),a=o.stateNode;try{var M=o.memoizedProps,O=M.id,X=M.onPostCommit;typeof X=="function"&&X(O,o.alternate===null?"mount":"update",a.passiveEffectDuration,-0)}catch(rt){ci(o,o.return,rt)}}else es(a,o,f,p);break;case 31:es(a,o,f,p);break;case 13:es(a,o,f,p);break;case 23:break;case 22:M=o.stateNode,O=o.alternate,o.memoizedState!==null?M._visibility&2?es(a,o,f,p):zu(a,o):M._visibility&2?es(a,o,f,p):(M._visibility|=2,ql(a,o,f,p,(o.subtreeFlags&10256)!==0||!1)),_&2048&&YA(O,o);break;case 24:es(a,o,f,p),_&2048&&Jo(o.alternate,o);break;default:es(a,o,f,p)}}function ql(a,o,f,p,_){for(_=_&&((o.subtreeFlags&10256)!==0||!1),o=o.child;o!==null;){var M=a,O=o,X=f,rt=p,_t=O.flags;switch(O.tag){case 0:case 11:case 15:ql(M,O,X,rt,_),uo(8,O);break;case 23:break;case 22:var Nt=O.stateNode;O.memoizedState!==null?Nt._visibility&2?ql(M,O,X,rt,_):zu(M,O):(Nt._visibility|=2,ql(M,O,X,rt,_)),_&&_t&2048&&YA(O.alternate,O);break;case 24:ql(M,O,X,rt,_),_&&_t&2048&&Jo(O.alternate,O);break;default:ql(M,O,X,rt,_)}o=o.sibling}}function zu(a,o){if(o.subtreeFlags&10256)for(o=o.child;o!==null;){var f=a,p=o,_=p.flags;switch(p.tag){case 22:zu(f,p),_&2048&&YA(p.alternate,p);break;case 24:zu(f,p),_&2048&&Jo(p.alternate,p);break;default:zu(f,p)}o=o.sibling}}var zi=8192;function Rc(a,o,f){if(a.subtreeFlags&zi)for(a=a.child;a!==null;)Hi(a,o,f),a=a.sibling}function Hi(a,o,f){switch(a.tag){case 26:Rc(a,o,f),a.flags&zi&&a.memoizedState!==null&&cQ(f,ha,a.memoizedState,a.memoizedProps);break;case 5:Rc(a,o,f);break;case 3:case 4:var p=ha;ha=_y(a.stateNode.containerInfo),Rc(a,o,f),ha=p;break;case 22:a.memoizedState===null&&(p=a.alternate,p!==null&&p.memoizedState!==null?(p=zi,zi=16777216,Rc(a,o,f),zi=p):Rc(a,o,f));break;default:Rc(a,o,f)}}function fa(a){var o=a.alternate;if(o!==null&&(a=o.child,a!==null)){o.child=null;do o=a.sibling,a.sibling=null,a=o;while(a!==null)}}function js(a){var o=a.deletions;if((a.flags&16)!==0){if(o!==null)for(var f=0;f<o.length;f++){var p=o[f];Ui=p,sf(p,a)}fa(a)}if(a.subtreeFlags&10256)for(a=a.child;a!==null;)Nc(a),a=a.sibling}function Nc(a){switch(a.tag){case 0:case 11:case 15:js(a),a.flags&2048&&lr(9,a,a.return);break;case 3:js(a);break;case 12:js(a);break;case 22:var o=a.stateNode;a.memoizedState!==null&&o._visibility&2&&(a.return===null||a.return.tag!==13)?(o._visibility&=-3,qA(a)):js(a);break;default:js(a)}}function qA(a){var o=a.deletions;if((a.flags&16)!==0){if(o!==null)for(var f=0;f<o.length;f++){var p=o[f];Ui=p,sf(p,a)}fa(a)}for(a=a.child;a!==null;){switch(o=a,o.tag){case 0:case 11:case 15:lr(8,o,o.return),qA(o);break;case 22:f=o.stateNode,f._visibility&2&&(f._visibility&=-3,qA(o));break;default:qA(o)}a=a.sibling}}function sf(a,o){for(;Ui!==null;){var f=Ui;switch(f.tag){case 0:case 11:case 15:lr(8,f,o);break;case 23:case 22:if(f.memoizedState!==null&&f.memoizedState.cachePool!==null){var p=f.memoizedState.cachePool.pool;p!=null&&p.refCount++}break;case 24:vs(f.memoizedState.cache)}if(p=f.child,p!==null)p.return=f,Ui=p;else t:for(f=a;Ui!==null;){p=Ui;var _=p.sibling,M=p.return;if(HA(p),p===f){Ui=null;break t}if(_!==null){_.return=M,Ui=_;break t}Ui=M}}}var XA={getCacheForType:function(a){var o=us(Le),f=o.data.get(a);return f===void 0&&(f=a(),o.data.set(a,f)),f},cacheSignal:function(){return us(Le).controller.signal}},JA=typeof WeakMap=="function"?WeakMap:Map,Dn=0,Zn=null,hn=null,Mn=0,ze=0,Cn=null,sn=!1,yn=!1,si=!1,Vi=0,Wn=0,Ha=0,Zo=0,Lr=0,Rn=0,Va=0,zr=null,Ps=null,Aa=!1,Wo=0,Ou=0,Ya=1/0,Fu=null,Ao=null,Bi=0,Or=null,qa=null,hr=0,jo=0,Uc=null,ZA=null,Lc=0,zc=null;function Ks(){return(Dn&2)!==0&&Mn!==0?Mn&-Mn:H.T!==null?h_():gs()}function c(){if(Rn===0)if((Mn&536870912)===0||wn){var a=ee;ee<<=1,(ee&3932160)===0&&(ee=262144),Rn=a}else Rn=536870912;return a=ts.current,a!==null&&(a.flags|=32),Rn}function h(a,o,f){(a===Zn&&(ze===2||ze===9)||a.cancelPendingCommit!==null)&&(yt(a,0),N(a,Mn,Rn,!1)),Ei(a,f),((Dn&2)===0||a!==Zn)&&(a===Zn&&((Dn&2)===0&&(Zo|=f),Wn===4&&N(a,Mn,Rn,!1)),Xl(a))}function x(a,o,f){if((Dn&6)!==0)throw Error(n(327));var p=!f&&(o&127)===0&&(o&a.expiredLanes)===0||Ae(a,o),_=p?Oc(a,o):da(a,o,!0),M=p;do{if(_===0){yn&&!p&&N(a,o,0,!1);break}else{if(f=a.current.alternate,M&&!T(f)){_=da(a,o,!1),M=!1;continue}if(_===2){if(M=o,a.errorRecoveryDisabledLanes&M)var O=0;else O=a.pendingLanes&-536870913,O=O!==0?O:O&536870912?536870912:0;if(O!==0){o=O;t:{var X=a;_=zr;var rt=X.current.memoizedState.isDehydrated;if(rt&&(yt(X,O).flags|=256),O=da(X,O,!1),O!==2){if(si&&!rt){X.errorRecoveryDisabledLanes|=M,Zo|=M,_=4;break t}M=Ps,Ps=_,M!==null&&(Ps===null?Ps=M:Ps.push.apply(Ps,M))}_=O}if(M=!1,_!==2)continue}}if(_===1){yt(a,0),N(a,o,0,!0);break}t:{switch(p=a,M=_,M){case 0:case 1:throw Error(n(345));case 4:if((o&4194048)!==o)break;case 6:N(p,o,Rn,!sn);break t;case 2:Ps=null;break;case 3:case 5:break;default:throw Error(n(329))}if((o&62914560)===o&&(_=Wo+300-G(),10<_)){if(N(p,o,Rn,!sn),Lt(p,0,!0)!==0)break t;hr=o,p.timeoutHandle=RI(b.bind(null,p,f,Ps,Fu,Aa,o,Rn,Zo,Va,sn,M,"Throttled",-0,0),_);break t}b(p,f,Ps,Fu,Aa,o,Rn,Zo,Va,sn,M,null,-0,0)}}break}while(!0);Xl(a)}function b(a,o,f,p,_,M,O,X,rt,_t,Nt,Yt,St,wt){if(a.timeoutHandle=-1,Yt=o.subtreeFlags,Yt&8192||(Yt&16785408)===16785408){Yt={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:nr},Hi(o,M,Yt);var Me=(M&62914560)===M?Wo-G():(M&4194048)===M?Ou-G():0;if(Me=uQ(Yt,Me),Me!==null){hr=M,a.cancelPendingCommit=Me(qe.bind(null,a,o,M,f,p,_,O,X,rt,Nt,Yt,null,St,wt)),N(a,M,O,!_t);return}}qe(a,o,M,f,p,_,O,X,rt)}function T(a){for(var o=a;;){var f=o.tag;if((f===0||f===11||f===15)&&o.flags&16384&&(f=o.updateQueue,f!==null&&(f=f.stores,f!==null)))for(var p=0;p<f.length;p++){var _=f[p],M=_.getSnapshot;_=_.value;try{if(!mi(M(),_))return!1}catch{return!1}}if(f=o.child,o.subtreeFlags&16384&&f!==null)f.return=o,o=f;else{if(o===a)break;for(;o.sibling===null;){if(o.return===null||o.return===a)return!0;o=o.return}o.sibling.return=o.return,o=o.sibling}}return!0}function N(a,o,f,p){o&=~Lr,o&=~Zo,a.suspendedLanes|=o,a.pingedLanes&=~o,p&&(a.warmLanes|=o),p=a.expirationTimes;for(var _=o;0<_;){var M=31-ve(_),O=1<<M;p[M]=-1,_&=~O}f!==0&&Mo(a,f,o)}function J(){return(Dn&6)===0?(bg(0),!1):!0}function at(){if(hn!==null){if(ze===0)var a=hn.return;else a=hn,Us=zo=null,tg(a),Ul=null,Ll=0,a=hn;for(;a!==null;)Qc(a.alternate,a),a=a.return;hn=null}}function yt(a,o){var f=a.timeoutHandle;f!==-1&&(a.timeoutHandle=-1,qT(f)),f=a.cancelPendingCommit,f!==null&&(a.cancelPendingCommit=null,f()),hr=0,at(),Zn=a,hn=f=to(a.current,null),Mn=o,ze=0,Cn=null,sn=!1,yn=Ae(a,o),si=!1,Va=Rn=Lr=Zo=Ha=Wn=0,Ps=zr=null,Aa=!1,(o&8)!==0&&(o|=o&32);var p=a.entangledLanes;if(p!==0)for(a=a.entanglements,p&=o;0<p;){var _=31-ve(p),M=1<<_;o|=a[_],p&=~M}return Vi=o,Ml(),f}function Ut(a,o){Ye=null,H.H=Yh,o===Nl||o===Dr?(o=CA(),ze=3):o===Uh?(o=CA(),ze=4):ze=o===PA?8:o!==null&&typeof o=="object"&&typeof o.then=="function"?6:1,Cn=o,hn===null&&(Wn=1,FA(a,aa(o,a.current)))}function ne(){var a=ts.current;return a===null?!0:(Mn&4194048)===Mn?ar===null:(Mn&62914560)===Mn||(Mn&536870912)!==0?a===ar:!1}function de(){var a=H.H;return H.H=Yh,a===null?Yh:a}function xe(){var a=H.A;return H.A=XA,a}function tn(){Wn=4,sn||(Mn&4194048)!==Mn&&ts.current!==null||(yn=!0),(Ha&134217727)===0&&(Zo&134217727)===0||Zn===null||N(Zn,Mn,Rn,!1)}function da(a,o,f){var p=Dn;Dn|=2;var _=de(),M=xe();(Zn!==a||Mn!==o)&&(Fu=null,yt(a,o)),o=!1;var O=Wn;t:do try{if(ze!==0&&hn!==null){var X=hn,rt=Cn;switch(ze){case 8:at(),O=6;break t;case 3:case 2:case 9:case 6:ts.current===null&&(o=!0);var _t=ze;if(ze=0,Cn=null,jt(a,X,rt,_t),f&&yn){O=0;break t}break;default:_t=ze,ze=0,Cn=null,jt(a,X,rt,_t)}}af(),O=Wn;break}catch(Nt){Ut(a,Nt)}while(!0);return o&&a.shellSuspendCounter++,Us=zo=null,Dn=p,H.H=_,H.A=M,hn===null&&(Zn=null,Mn=0,Ml()),O}function af(){for(;hn!==null;)gt(hn)}function Oc(a,o){var f=Dn;Dn|=2;var p=de(),_=xe();Zn!==a||Mn!==o?(Fu=null,Ya=G()+500,yt(a,o)):yn=Ae(a,o);t:do try{if(ze!==0&&hn!==null){o=hn;var M=Cn;e:switch(ze){case 1:ze=0,Cn=null,jt(a,o,M,1);break;case 2:case 9:if(G0(M)){ze=0,Cn=null,Mt(o);break}o=function(){ze!==2&&ze!==9||Zn!==a||(ze=7),Xl(a)},M.then(o,o);break t;case 3:ze=7;break t;case 4:ze=5;break t;case 7:G0(M)?(ze=0,Cn=null,Mt(o)):(ze=0,Cn=null,jt(a,o,M,7));break;case 5:var O=null;switch(hn.tag){case 26:O=hn.memoizedState;case 5:case 27:var X=hn;if(O?JI(O):X.stateNode.complete){ze=0,Cn=null;var rt=X.sibling;if(rt!==null)hn=rt;else{var _t=X.return;_t!==null?(hn=_t,Ne(_t)):hn=null}break e}}ze=0,Cn=null,jt(a,o,M,5);break;case 6:ze=0,Cn=null,jt(a,o,M,6);break;case 8:at(),Wn=6;break t;default:throw Error(n(462))}}bt();break}catch(Nt){Ut(a,Nt)}while(!0);return Us=zo=null,H.H=p,H.A=_,Dn=f,hn!==null?0:(Zn=null,Mn=0,Ml(),Wn)}function bt(){for(;hn!==null&&!fe();)gt(hn)}function gt(a){var o=GA(a.alternate,a,Vi);a.memoizedProps=a.pendingProps,o===null?Ne(a):hn=o}function Mt(a){var o=a,f=o.alternate;switch(o.tag){case 15:case 0:o=zs(f,o,o.pendingProps,o.type,void 0,Mn);break;case 11:o=zs(f,o,o.pendingProps,o.type.render,o.ref,Mn);break;case 5:tg(o);default:Qc(f,o),o=hn=Ns(o,Vi),o=GA(f,o,Vi)}a.memoizedProps=a.pendingProps,o===null?Ne(a):hn=o}function jt(a,o,f,p){Us=zo=null,tg(o),Ul=null,Ll=0;var _=o.return;try{if(La(a,_,o,f,Mn)){Wn=1,FA(a,aa(f,a.current)),hn=null;return}}catch(M){if(_!==null)throw hn=_,M;Wn=1,FA(a,aa(f,a.current)),hn=null;return}o.flags&32768?(wn||p===1?a=!0:yn||(Mn&536870912)!==0?a=!1:(sn=a=!0,(p===2||p===9||p===3||p===6)&&(p=ts.current,p!==null&&p.tag===13&&(p.flags|=16384))),fi(o,a)):Ne(o)}function Ne(a){var o=a;do{if((o.flags&32768)!==0){fi(o,sn);return}a=o.return;var f=Eg(o.alternate,o,Vi);if(f!==null){hn=f;return}if(o=o.sibling,o!==null){hn=o;return}hn=o=a}while(o!==null);Wn===0&&(Wn=5)}function fi(a,o){do{var f=kA(a.alternate,a);if(f!==null){f.flags&=32767,hn=f;return}if(f=a.return,f!==null&&(f.flags|=32768,f.subtreeFlags=0,f.deletions=null),!o&&(a=a.sibling,a!==null)){hn=a;return}hn=a=f}while(a!==null);Wn=6,hn=null}function qe(a,o,f,p,_,M,O,X,rt){a.cancelPendingCommit=null;do WA();while(Bi!==0);if((Dn&6)!==0)throw Error(n(327));if(o!==null){if(o===a.current)throw Error(n(177));if(M=o.lanes|o.childLanes,M|=pA,$i(a,f,M,O,X,rt),a===Zn&&(hn=Zn=null,Mn=0),qa=o,Or=a,hr=f,jo=M,Uc=_,ZA=p,(o.subtreeFlags&10256)!==0||(o.flags&10256)!==0?(a.callbackNode=null,a.callbackPriority=0,RT(Bt,function(){return gI(),null})):(a.callbackNode=null,a.callbackPriority=0),p=(o.flags&13878)!==0,(o.subtreeFlags&13878)!==0||p){p=H.T,H.T=null,_=tt.p,tt.p=2,O=Dn,Dn|=4;try{Lu(a,o,f)}finally{Dn=O,tt.p=_,H.T=p}}Bi=1,Fn(),ns(),Pn()}}function Fn(){if(Bi===1){Bi=0;var a=Or,o=qa,f=(o.flags&13878)!==0;if((o.subtreeFlags&13878)!==0||f){f=H.T,H.T=null;var p=tt.p;tt.p=2;var _=Dn;Dn|=4;try{Yl(o,a);var M=x_,O=uA(a.containerInfo),X=M.focusedElem,rt=M.selectionRange;if(O!==X&&X&&X.ownerDocument&&cA(X.ownerDocument.documentElement,X)){if(rt!==null&&pu(X)){var _t=rt.start,Nt=rt.end;if(Nt===void 0&&(Nt=_t),"selectionStart"in X)X.selectionStart=_t,X.selectionEnd=Math.min(Nt,X.value.length);else{var Yt=X.ownerDocument||document,St=Yt&&Yt.defaultView||window;if(St.getSelection){var wt=St.getSelection(),Me=X.textContent.length,Ve=Math.min(rt.start,Me),di=rt.end===void 0?Ve:Math.min(rt.end,Me);!wt.extend&&Ve>di&&(O=di,di=Ve,Ve=O);var mt=wp(X,Ve),ct=wp(X,di);if(mt&&ct&&(wt.rangeCount!==1||wt.anchorNode!==mt.node||wt.anchorOffset!==mt.offset||wt.focusNode!==ct.node||wt.focusOffset!==ct.offset)){var Et=Yt.createRange();Et.setStart(mt.node,mt.offset),wt.removeAllRanges(),Ve>di?(wt.addRange(Et),wt.extend(ct.node,ct.offset)):(Et.setEnd(ct.node,ct.offset),wt.addRange(Et))}}}}for(Yt=[],wt=X;wt=wt.parentNode;)wt.nodeType===1&&Yt.push({element:wt,left:wt.scrollLeft,top:wt.scrollTop});for(typeof X.focus=="function"&&X.focus(),X=0;X<Yt.length;X++){var Ft=Yt[X];Ft.element.scrollLeft=Ft.left,Ft.element.scrollTop=Ft.top}}My=!!y_,x_=y_=null}finally{Dn=_,tt.p=p,H.T=f}}a.current=o,Bi=2}}function ns(){if(Bi===2){Bi=0;var a=Or,o=qa,f=(o.flags&8772)!==0;if((o.subtreeFlags&8772)!==0||f){f=H.T,H.T=null;var p=tt.p;tt.p=2;var _=Dn;Dn|=4;try{dy(a,o.alternate,o)}finally{Dn=_,tt.p=p,H.T=f}}Bi=3}}function Pn(){if(Bi===4||Bi===3){Bi=0,$();var a=Or,o=qa,f=hr,p=ZA;(o.subtreeFlags&10256)!==0||(o.flags&10256)!==0?Bi=5:(Bi=0,qa=Or=null,Ko(a,a.pendingLanes));var _=a.pendingLanes;if(_===0&&(Ao=null),Sa(f),o=o.stateNode,Jt&&typeof Jt.onCommitFiberRoot=="function")try{Jt.onCommitFiberRoot(Gt,o,void 0,(o.current.flags&128)===128)}catch{}if(p!==null){o=H.T,_=tt.p,tt.p=2,H.T=null;try{for(var M=a.onRecoverableError,O=0;O<p.length;O++){var X=p[O];M(X.value,{componentStack:X.stack})}}finally{H.T=o,tt.p=_}}(hr&3)!==0&&WA(),Xl(a),_=a.pendingLanes,(f&261930)!==0&&(_&42)!==0?a===zc?Lc++:(Lc=0,zc=a):Lc=0,bg(0)}}function Ko(a,o){(a.pooledCacheLanes&=o)===0&&(o=a.pooledCache,o!=null&&(a.pooledCache=null,vs(o)))}function WA(){return Fn(),ns(),Pn(),gI()}function gI(){if(Bi!==5)return!1;var a=Or,o=jo;jo=0;var f=Sa(hr),p=H.T,_=tt.p;try{tt.p=32>f?32:f,H.T=null,f=Uc,Uc=null;var M=Or,O=hr;if(Bi=0,qa=Or=null,hr=0,(Dn&6)!==0)throw Error(n(331));var X=Dn;if(Dn|=4,Nc(M.current),Ii(M,M.current,O,f),Dn=X,bg(0,!1),Jt&&typeof Jt.onPostCommitFiberRoot=="function")try{Jt.onPostCommitFiberRoot(Gt,M)}catch{}return!0}finally{tt.p=_,H.T=p,Ko(a,o)}}function mI(a,o,f){o=aa(f,o),o=vg(a.stateNode,o,2),a=Go(a,o,2),a!==null&&(Ei(a,2),Xl(a))}function ci(a,o,f){if(a.tag===3)mI(a,a,f);else for(;o!==null;){if(o.tag===3){mI(o,a,f);break}else if(o.tag===1){var p=o.stateNode;if(typeof o.type.getDerivedStateFromError=="function"||typeof p.componentDidCatch=="function"&&(Ao===null||!Ao.has(p))){a=aa(f,a),f=Qu(2),p=Go(o,f,2),p!==null&&(ca(f,p,o,a),Ei(p,2),Xl(p));break}}o=o.return}}function l_(a,o,f){var p=a.pingCache;if(p===null){p=a.pingCache=new JA;var _=new Set;p.set(o,_)}else _=p.get(o),_===void 0&&(_=new Set,p.set(o,_));_.has(f)||(si=!0,_.add(f),a=TT.bind(null,a,o,f),o.then(a,a))}function TT(a,o,f){var p=a.pingCache;p!==null&&p.delete(o),a.pingedLanes|=a.suspendedLanes&f,a.warmLanes&=~f,Zn===a&&(Mn&f)===f&&(Wn===4||Wn===3&&(Mn&62914560)===Mn&&300>G()-Wo?(Dn&2)===0&&yt(a,0):Lr|=f,Va===Mn&&(Va=0)),Xl(a)}function yI(a,o){o===0&&(o=In()),a=wl(a,o),a!==null&&(Ei(a,o),Xl(a))}function QT(a){var o=a.memoizedState,f=0;o!==null&&(f=o.retryLane),yI(a,f)}function DT(a,o){var f=0;switch(a.tag){case 31:case 13:var p=a.stateNode,_=a.memoizedState;_!==null&&(f=_.retryLane);break;case 19:p=a.stateNode;break;case 22:p=a.stateNode._retryCache;break;default:throw Error(n(314))}p!==null&&p.delete(o),yI(a,f)}function RT(a,o){return Zt(a,o)}var my=null,jA=null,c_=!1,yy=!1,u_=!1,Pu=0;function Xl(a){a!==jA&&a.next===null&&(jA===null?my=jA=a:jA=jA.next=a),yy=!0,c_||(c_=!0,UT())}function bg(a,o){if(!u_&&yy){u_=!0;do for(var f=!1,p=my;p!==null;){if(a!==0){var _=p.pendingLanes;if(_===0)var M=0;else{var O=p.suspendedLanes,X=p.pingedLanes;M=(1<<31-ve(42|a)+1)-1,M&=_&~(O&~X),M=M&201326741?M&201326741|1:M?M|2:0}M!==0&&(f=!0,_I(p,M))}else M=Mn,M=Lt(p,p===Zn?M:0,p.cancelPendingCommit!==null||p.timeoutHandle!==-1),(M&3)===0||Ae(p,M)||(f=!0,_I(p,M));p=p.next}while(f);u_=!1}}function NT(){xI()}function xI(){yy=c_=!1;var a=0;Pu!==0&&YT()&&(a=Pu);for(var o=G(),f=null,p=my;p!==null;){var _=p.next,M=vI(p,o);M===0?(p.next=null,f===null?my=_:f.next=_,_===null&&(jA=f)):(f=p,(a!==0||(M&3)!==0)&&(yy=!0)),p=_}Bi!==0&&Bi!==5||bg(a),Pu!==0&&(Pu=0)}function vI(a,o){for(var f=a.suspendedLanes,p=a.pingedLanes,_=a.expirationTimes,M=a.pendingLanes&-62914561;0<M;){var O=31-ve(M),X=1<<O,rt=_[O];rt===-1?((X&f)===0||(X&p)!==0)&&(_[O]=Oe(X,o)):rt<=o&&(a.expiredLanes|=X),M&=~X}if(o=Zn,f=Mn,f=Lt(a,a===o?f:0,a.cancelPendingCommit!==null||a.timeoutHandle!==-1),p=a.callbackNode,f===0||a===o&&(ze===2||ze===9)||a.cancelPendingCommit!==null)return p!==null&&p!==null&&$t(p),a.callbackNode=null,a.callbackPriority=0;if((f&3)===0||Ae(a,f)){if(o=f&-f,o===a.callbackPriority)return o;switch(p!==null&&$t(p),Sa(f)){case 2:case 8:f=Ht;break;case 32:f=Bt;break;case 268435456:f=ae;break;default:f=Bt}return p=EI.bind(null,a),f=Zt(f,p),a.callbackPriority=o,a.callbackNode=f,o}return p!==null&&p!==null&&$t(p),a.callbackPriority=2,a.callbackNode=null,2}function EI(a,o){if(Bi!==0&&Bi!==5)return a.callbackNode=null,a.callbackPriority=0,null;var f=a.callbackNode;if(WA()&&a.callbackNode!==f)return null;var p=Mn;return p=Lt(a,a===Zn?p:0,a.cancelPendingCommit!==null||a.timeoutHandle!==-1),p===0?null:(x(a,p,o),vI(a,G()),a.callbackNode!=null&&a.callbackNode===f?EI.bind(null,a):null)}function _I(a,o){if(WA())return null;x(a,o,!0)}function UT(){XT(function(){(Dn&6)!==0?Zt(Tt,NT):xI()})}function h_(){if(Pu===0){var a=Po;a===0&&(a=re,re<<=1,(re&261888)===0&&(re=256)),Pu=a}return Pu}function CI(a){return a==null||typeof a=="symbol"||typeof a=="boolean"?null:typeof a=="function"?a:uc(""+a)}function bI(a,o){var f=o.ownerDocument.createElement("input");return f.name=o.name,f.value=o.value,a.id&&f.setAttribute("form",a.id),o.parentNode.insertBefore(f,o),a=new FormData(a),f.parentNode.removeChild(f),a}function LT(a,o,f,p,_){if(o==="submit"&&f&&f.stateNode===_){var M=CI((_[_i]||null).action),O=p.submitter;O&&(o=(o=O[_i]||null)?CI(o.formAction):O.getAttribute("formAction"),o!==null&&(M=o,O=null));var X=new Hn("action","action",null,p,_);a.push({event:X,listeners:[{instance:null,listener:function(){if(p.defaultPrevented){if(Pu!==0){var rt=O?bI(_,O):new FormData(_);pg(f,{pending:!0,data:rt,method:_.method,action:M},null,rt)}}else typeof M=="function"&&(X.preventDefault(),rt=O?bI(_,O):new FormData(_),pg(f,{pending:!0,data:rt,method:_.method,action:M},M,rt))},currentTarget:_}]})}}for(var f_=0;f_<dA.length;f_++){var A_=dA[f_],zT=A_.toLowerCase(),OT=A_[0].toUpperCase()+A_.slice(1);Rs(zT,"on"+OT)}Rs(sa,"onAnimationEnd"),Rs(Tp,"onAnimationIteration"),Rs($r,"onAnimationStart"),Rs("dblclick","onDoubleClick"),Rs("focusin","onFocus"),Rs("focusout","onBlur"),Rs(xu,"onTransitionRun"),Rs(Il,"onTransitionStart"),Rs(Qp,"onTransitionCancel"),Rs(AA,"onTransitionEnd"),me("onMouseEnter",["mouseout","mouseover"]),me("onMouseLeave",["mouseout","mouseover"]),me("onPointerEnter",["pointerout","pointerover"]),me("onPointerLeave",["pointerout","pointerover"]),se("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),se("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),se("onBeforeInput",["compositionend","keypress","textInput","paste"]),se("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),se("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),se("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Sg="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),FT=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Sg));function SI(a,o){o=(o&4)!==0;for(var f=0;f<a.length;f++){var p=a[f],_=p.event;p=p.listeners;t:{var M=void 0;if(o)for(var O=p.length-1;0<=O;O--){var X=p[O],rt=X.instance,_t=X.currentTarget;if(X=X.listener,rt!==M&&_.isPropagationStopped())break t;M=X,_.currentTarget=_t;try{M(_)}catch(Nt){Bl(Nt)}_.currentTarget=null,M=rt}else for(O=0;O<p.length;O++){if(X=p[O],rt=X.instance,_t=X.currentTarget,X=X.listener,rt!==M&&_.isPropagationStopped())break t;M=X,_.currentTarget=_t;try{M(_)}catch(Nt){Bl(Nt)}_.currentTarget=null,M=rt}}}}function Tn(a,o){var f=o[Xr];f===void 0&&(f=o[Xr]=new Set);var p=a+"__bubble";f.has(p)||(II(o,a,2,!1),f.add(p))}function d_(a,o,f){var p=0;o&&(p|=4),II(f,a,p,o)}var xy="_reactListening"+Math.random().toString(36).slice(2);function p_(a){if(!a[xy]){a[xy]=!0,ht.forEach(function(f){f!=="selectionchange"&&(FT.has(f)||d_(f,!1,a),d_(f,!0,a))});var o=a.nodeType===9?a:a.ownerDocument;o===null||o[xy]||(o[xy]=!0,d_("selectionchange",!1,o))}}function II(a,o,f,p){switch(e1(o)){case 2:var _=AQ;break;case 8:_=dQ;break;default:_=T_}f=_.bind(null,o,f,a),_=void 0,!Ac||o!=="touchstart"&&o!=="touchmove"&&o!=="wheel"||(_=!0),p?_!==void 0?a.addEventListener(o,f,{capture:!0,passive:_}):a.addEventListener(o,f,!0):_!==void 0?a.addEventListener(o,f,{passive:_}):a.addEventListener(o,f,!1)}function g_(a,o,f,p,_){var M=p;if((o&1)===0&&(o&2)===0&&p!==null)t:for(;;){if(p===null)return;var O=p.tag;if(O===3||O===4){var X=p.stateNode.containerInfo;if(X===_)break;if(O===4)for(O=p.return;O!==null;){var rt=O.tag;if((rt===3||rt===4)&&O.stateNode.containerInfo===_)return;O=O.return}for(;X!==null;){if(O=pi(X),O===null)return;if(rt=O.tag,rt===5||rt===6||rt===26||rt===27){p=M=O;continue t}X=X.parentNode}}p=p.return}Eh(function(){var _t=M,Nt=lu(f),Yt=[];t:{var St=Ro.get(a);if(St!==void 0){var wt=Hn,Me=a;switch(a){case"keypress":if($e(f)===0)break t;case"keydown":case"keyup":wt=xp;break;case"focusin":Me="focus",wt=sA;break;case"focusout":Me="blur",wt=sA;break;case"beforeblur":case"afterblur":wt=sA;break;case"click":if(f.button===2)break t;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":wt=_h;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":wt=x0;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":wt=Qo;break;case sa:case Tp:case $r:wt=_0;break;case AA:wt=t_;break;case"scroll":case"scrollend":wt=Ds;break;case"wheel":wt=vl;break;case"copy":case"cut":case"paste":wt=dp;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":wt=aA;break;case"toggle":case"beforetoggle":wt=Ep}var Ve=(o&4)!==0,di=!Ve&&(a==="scroll"||a==="scrollend"),mt=Ve?St!==null?St+"Capture":null:St;Ve=[];for(var ct=_t,Et;ct!==null;){var Ft=ct;if(Et=Ft.stateNode,Ft=Ft.tag,Ft!==5&&Ft!==26&&Ft!==27||Et===null||mt===null||(Ft=wo(ct,mt),Ft!=null&&Ve.push(Ig(ct,Ft,Et))),di)break;ct=ct.return}0<Ve.length&&(St=new wt(St,Me,null,f,Nt),Yt.push({event:St,listeners:Ve}))}}if((o&7)===0){t:{if(St=a==="mouseover"||a==="pointerover",wt=a==="mouseout"||a==="pointerout",St&&f!==hc&&(Me=f.relatedTarget||f.fromElement)&&(pi(Me)||Me[Ys]))break t;if((wt||St)&&(St=Nt.window===Nt?Nt:(St=Nt.ownerDocument)?St.defaultView||St.parentWindow:window,wt?(Me=f.relatedTarget||f.toElement,wt=_t,Me=Me?pi(Me):null,Me!==null&&(di=r(Me),Ve=Me.tag,Me!==di||Ve!==5&&Ve!==27&&Ve!==6)&&(Me=null)):(wt=null,Me=_t),wt!==Me)){if(Ve=_h,Ft="onMouseLeave",mt="onMouseEnter",ct="mouse",(a==="pointerout"||a==="pointerover")&&(Ve=aA,Ft="onPointerLeave",mt="onPointerEnter",ct="pointer"),di=wt==null?St:ut(wt),Et=Me==null?St:ut(Me),St=new Ve(Ft,ct+"leave",wt,f,Nt),St.target=di,St.relatedTarget=Et,Ft=null,pi(Nt)===_t&&(Ve=new Ve(mt,ct+"enter",Me,f,Nt),Ve.target=Et,Ve.relatedTarget=di,Ft=Ve),di=Ft,wt&&Me)e:{for(Ve=PT,mt=wt,ct=Me,Et=0,Ft=mt;Ft;Ft=Ve(Ft))Et++;Ft=0;for(var Pe=ct;Pe;Pe=Ve(Pe))Ft++;for(;0<Et-Ft;)mt=Ve(mt),Et--;for(;0<Ft-Et;)ct=Ve(ct),Ft--;for(;Et--;){if(mt===ct||ct!==null&&mt===ct.alternate){Ve=mt;break e}mt=Ve(mt),ct=Ve(ct)}Ve=null}else Ve=null;wt!==null&&BI(Yt,St,wt,Ve,!1),Me!==null&&di!==null&&BI(Yt,di,Me,Ve,!0)}}t:{if(St=_t?ut(_t):window,wt=St.nodeName&&St.nodeName.toLowerCase(),wt==="select"||wt==="input"&&St.type==="file")var jn=Ip;else if(bp(St))if(Ih)jn=R0;else{jn=Cl;var Re=Bh}else wt=St.nodeName,!wt||wt.toLowerCase()!=="input"||St.type!=="checkbox"&&St.type!=="radio"?_t&&Zr(_t.elementType)&&(jn=Ip):jn=D0;if(jn&&(jn=jn(a,_t))){lA(Yt,jn,f,Nt);break t}Re&&Re(a,St,_t),a==="focusout"&&_t&&St.type==="number"&&_t.memoizedProps.value!=null&&oi(St,"number",St.value)}switch(Re=_t?ut(_t):window,a){case"focusin":(bp(Re)||Re.contentEditable==="true")&&(gu=Re,hA=_t,mu=null);break;case"focusout":mu=hA=gu=null;break;case"mousedown":Qa=!0;break;case"contextmenu":case"mouseup":case"dragend":Qa=!1,fA(Yt,f,Nt);break;case"selectionchange":if(N0)break;case"keydown":case"keyup":fA(Yt,f,Nt)}var xn;if(pc)t:{switch(a){case"compositionstart":var Nn="onCompositionStart";break t;case"compositionend":Nn="onCompositionEnd";break t;case"compositionupdate":Nn="onCompositionUpdate";break t}Nn=void 0}else _l?rA(a,f)&&(Nn="onCompositionEnd"):a==="keydown"&&f.keyCode===229&&(Nn="onCompositionStart");Nn&&(xs&&f.locale!=="ko"&&(_l||Nn!=="onCompositionStart"?Nn==="onCompositionEnd"&&_l&&(xn=ue()):(Mr=Nt,dc="value"in Mr?Mr.value:Mr.textContent,_l=!0)),Re=vy(_t,Nn),0<Re.length&&(Nn=new pp(Nn,a,null,f,Nt),Yt.push({event:Nn,listeners:Re}),xn?Nn.data=xn:(xn=uu(f),xn!==null&&(Nn.data=xn)))),(xn=gc?oA(a,f):w0(a,f))&&(Nn=vy(_t,"onBeforeInput"),0<Nn.length&&(Re=new pp("onBeforeInput","beforeinput",null,f,Nt),Yt.push({event:Re,listeners:Nn}),Re.data=xn)),LT(Yt,a,_t,f,Nt)}SI(Yt,o)})}function Ig(a,o,f){return{instance:a,listener:o,currentTarget:f}}function vy(a,o){for(var f=o+"Capture",p=[];a!==null;){var _=a,M=_.stateNode;if(_=_.tag,_!==5&&_!==26&&_!==27||M===null||(_=wo(a,f),_!=null&&p.unshift(Ig(a,_,M)),_=wo(a,o),_!=null&&p.push(Ig(a,_,M))),a.tag===3)return p;a=a.return}return[]}function PT(a){if(a===null)return null;do a=a.return;while(a&&a.tag!==5&&a.tag!==27);return a||null}function BI(a,o,f,p,_){for(var M=o._reactName,O=[];f!==null&&f!==p;){var X=f,rt=X.alternate,_t=X.stateNode;if(X=X.tag,rt!==null&&rt===p)break;X!==5&&X!==26&&X!==27||_t===null||(rt=_t,_?(_t=wo(f,M),_t!=null&&O.unshift(Ig(f,_t,rt))):_||(_t=wo(f,M),_t!=null&&O.push(Ig(f,_t,rt)))),f=f.return}O.length!==0&&a.push({event:o,listeners:O})}var GT=/\r\n?/g,kT=/\u0000|\uFFFD/g;function MI(a){return(typeof a=="string"?a:""+a).replace(GT,`
`).replace(kT,"")}function wI(a,o){return o=MI(o),MI(a)===o}function Ai(a,o,f,p,_,M){switch(f){case"children":typeof p=="string"?o==="body"||o==="textarea"&&p===""||Ma(a,p):(typeof p=="number"||typeof p=="bigint")&&o!=="body"&&Ma(a,""+p);break;case"className":En(a,"class",p);break;case"tabIndex":En(a,"tabindex",p);break;case"dir":case"role":case"viewBox":case"width":case"height":En(a,f,p);break;case"style":ml(a,p,M);break;case"data":if(o!=="object"){En(a,"data",p);break}case"src":case"href":if(p===""&&(o!=="a"||f!=="href")){a.removeAttribute(f);break}if(p==null||typeof p=="function"||typeof p=="symbol"||typeof p=="boolean"){a.removeAttribute(f);break}p=uc(""+p),a.setAttribute(f,p);break;case"action":case"formAction":if(typeof p=="function"){a.setAttribute(f,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof M=="function"&&(f==="formAction"?(o!=="input"&&Ai(a,o,"name",_.name,_,null),Ai(a,o,"formEncType",_.formEncType,_,null),Ai(a,o,"formMethod",_.formMethod,_,null),Ai(a,o,"formTarget",_.formTarget,_,null)):(Ai(a,o,"encType",_.encType,_,null),Ai(a,o,"method",_.method,_,null),Ai(a,o,"target",_.target,_,null)));if(p==null||typeof p=="symbol"||typeof p=="boolean"){a.removeAttribute(f);break}p=uc(""+p),a.setAttribute(f,p);break;case"onClick":p!=null&&(a.onclick=nr);break;case"onScroll":p!=null&&Tn("scroll",a);break;case"onScrollEnd":p!=null&&Tn("scrollend",a);break;case"dangerouslySetInnerHTML":if(p!=null){if(typeof p!="object"||!("__html"in p))throw Error(n(61));if(f=p.__html,f!=null){if(_.children!=null)throw Error(n(60));a.innerHTML=f}}break;case"multiple":a.multiple=p&&typeof p!="function"&&typeof p!="symbol";break;case"muted":a.muted=p&&typeof p!="function"&&typeof p!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(p==null||typeof p=="function"||typeof p=="boolean"||typeof p=="symbol"){a.removeAttribute("xlink:href");break}f=uc(""+p),a.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",f);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":p!=null&&typeof p!="function"&&typeof p!="symbol"?a.setAttribute(f,""+p):a.removeAttribute(f);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":p&&typeof p!="function"&&typeof p!="symbol"?a.setAttribute(f,""):a.removeAttribute(f);break;case"capture":case"download":p===!0?a.setAttribute(f,""):p!==!1&&p!=null&&typeof p!="function"&&typeof p!="symbol"?a.setAttribute(f,p):a.removeAttribute(f);break;case"cols":case"rows":case"size":case"span":p!=null&&typeof p!="function"&&typeof p!="symbol"&&!isNaN(p)&&1<=p?a.setAttribute(f,p):a.removeAttribute(f);break;case"rowSpan":case"start":p==null||typeof p=="function"||typeof p=="symbol"||isNaN(p)?a.removeAttribute(f):a.setAttribute(f,p);break;case"popover":Tn("beforetoggle",a),Tn("toggle",a),je(a,"popover",p);break;case"xlinkActuate":Ke(a,"http://www.w3.org/1999/xlink","xlink:actuate",p);break;case"xlinkArcrole":Ke(a,"http://www.w3.org/1999/xlink","xlink:arcrole",p);break;case"xlinkRole":Ke(a,"http://www.w3.org/1999/xlink","xlink:role",p);break;case"xlinkShow":Ke(a,"http://www.w3.org/1999/xlink","xlink:show",p);break;case"xlinkTitle":Ke(a,"http://www.w3.org/1999/xlink","xlink:title",p);break;case"xlinkType":Ke(a,"http://www.w3.org/1999/xlink","xlink:type",p);break;case"xmlBase":Ke(a,"http://www.w3.org/XML/1998/namespace","xml:base",p);break;case"xmlLang":Ke(a,"http://www.w3.org/XML/1998/namespace","xml:lang",p);break;case"xmlSpace":Ke(a,"http://www.w3.org/XML/1998/namespace","xml:space",p);break;case"is":je(a,"is",p);break;case"innerText":case"textContent":break;default:(!(2<f.length)||f[0]!=="o"&&f[0]!=="O"||f[1]!=="n"&&f[1]!=="N")&&(f=vh.get(f)||f,je(a,f,p))}}function m_(a,o,f,p,_,M){switch(f){case"style":ml(a,p,M);break;case"dangerouslySetInnerHTML":if(p!=null){if(typeof p!="object"||!("__html"in p))throw Error(n(61));if(f=p.__html,f!=null){if(_.children!=null)throw Error(n(60));a.innerHTML=f}}break;case"children":typeof p=="string"?Ma(a,p):(typeof p=="number"||typeof p=="bigint")&&Ma(a,""+p);break;case"onScroll":p!=null&&Tn("scroll",a);break;case"onScrollEnd":p!=null&&Tn("scrollend",a);break;case"onClick":p!=null&&(a.onclick=nr);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!Kt.hasOwnProperty(f))t:{if(f[0]==="o"&&f[1]==="n"&&(_=f.endsWith("Capture"),o=f.slice(2,_?f.length-7:void 0),M=a[_i]||null,M=M!=null?M[f]:null,typeof M=="function"&&a.removeEventListener(o,M,_),typeof p=="function")){typeof M!="function"&&M!==null&&(f in a?a[f]=null:a.hasAttribute(f)&&a.removeAttribute(f)),a.addEventListener(o,p,_);break t}f in a?a[f]=p:p===!0?a.setAttribute(f,""):je(a,f,p)}}}function $s(a,o,f){switch(o){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":Tn("error",a),Tn("load",a);var p=!1,_=!1,M;for(M in f)if(f.hasOwnProperty(M)){var O=f[M];if(O!=null)switch(M){case"src":p=!0;break;case"srcSet":_=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(n(137,o));default:Ai(a,o,M,O,f,null)}}_&&Ai(a,o,"srcSet",f.srcSet,f,null),p&&Ai(a,o,"src",f.src,f,null);return;case"input":Tn("invalid",a);var X=M=O=_=null,rt=null,_t=null;for(p in f)if(f.hasOwnProperty(p)){var Nt=f[p];if(Nt!=null)switch(p){case"name":_=Nt;break;case"type":O=Nt;break;case"checked":rt=Nt;break;case"defaultChecked":_t=Nt;break;case"value":M=Nt;break;case"defaultValue":X=Nt;break;case"children":case"dangerouslySetInnerHTML":if(Nt!=null)throw Error(n(137,o));break;default:Ai(a,o,p,Nt,f,null)}}Xn(a,M,X,rt,_t,O,_,!1);return;case"select":Tn("invalid",a),p=O=M=null;for(_ in f)if(f.hasOwnProperty(_)&&(X=f[_],X!=null))switch(_){case"value":M=X;break;case"defaultValue":O=X;break;case"multiple":p=X;default:Ai(a,o,_,X,f,null)}o=M,f=O,a.multiple=!!p,o!=null?Ci(a,!!p,o,!1):f!=null&&Ci(a,!!p,f,!0);return;case"textarea":Tn("invalid",a),M=_=p=null;for(O in f)if(f.hasOwnProperty(O)&&(X=f[O],X!=null))switch(O){case"value":p=X;break;case"defaultValue":_=X;break;case"children":M=X;break;case"dangerouslySetInnerHTML":if(X!=null)throw Error(n(91));break;default:Ai(a,o,O,X,f,null)}bi(a,p,_,M);return;case"option":for(rt in f)f.hasOwnProperty(rt)&&(p=f[rt],p!=null)&&(rt==="selected"?a.selected=p&&typeof p!="function"&&typeof p!="symbol":Ai(a,o,rt,p,f,null));return;case"dialog":Tn("beforetoggle",a),Tn("toggle",a),Tn("cancel",a),Tn("close",a);break;case"iframe":case"object":Tn("load",a);break;case"video":case"audio":for(p=0;p<Sg.length;p++)Tn(Sg[p],a);break;case"image":Tn("error",a),Tn("load",a);break;case"details":Tn("toggle",a);break;case"embed":case"source":case"link":Tn("error",a),Tn("load",a);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(_t in f)if(f.hasOwnProperty(_t)&&(p=f[_t],p!=null))switch(_t){case"children":case"dangerouslySetInnerHTML":throw Error(n(137,o));default:Ai(a,o,_t,p,f,null)}return;default:if(Zr(o)){for(Nt in f)f.hasOwnProperty(Nt)&&(p=f[Nt],p!==void 0&&m_(a,o,Nt,p,f,void 0));return}}for(X in f)f.hasOwnProperty(X)&&(p=f[X],p!=null&&Ai(a,o,X,p,f,null))}function HT(a,o,f,p){switch(o){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var _=null,M=null,O=null,X=null,rt=null,_t=null,Nt=null;for(wt in f){var Yt=f[wt];if(f.hasOwnProperty(wt)&&Yt!=null)switch(wt){case"checked":break;case"value":break;case"defaultValue":rt=Yt;default:p.hasOwnProperty(wt)||Ai(a,o,wt,null,p,Yt)}}for(var St in p){var wt=p[St];if(Yt=f[St],p.hasOwnProperty(St)&&(wt!=null||Yt!=null))switch(St){case"type":M=wt;break;case"name":_=wt;break;case"checked":_t=wt;break;case"defaultChecked":Nt=wt;break;case"value":O=wt;break;case"defaultValue":X=wt;break;case"children":case"dangerouslySetInnerHTML":if(wt!=null)throw Error(n(137,o));break;default:wt!==Yt&&Ai(a,o,St,wt,p,Yt)}}Ba(a,O,X,rt,_t,Nt,M,_);return;case"select":wt=O=X=St=null;for(M in f)if(rt=f[M],f.hasOwnProperty(M)&&rt!=null)switch(M){case"value":break;case"multiple":wt=rt;default:p.hasOwnProperty(M)||Ai(a,o,M,null,p,rt)}for(_ in p)if(M=p[_],rt=f[_],p.hasOwnProperty(_)&&(M!=null||rt!=null))switch(_){case"value":St=M;break;case"defaultValue":X=M;break;case"multiple":O=M;default:M!==rt&&Ai(a,o,_,M,p,rt)}o=X,f=O,p=wt,St!=null?Ci(a,!!f,St,!1):!!p!=!!f&&(o!=null?Ci(a,!!f,o,!0):Ci(a,!!f,f?[]:"",!1));return;case"textarea":wt=St=null;for(X in f)if(_=f[X],f.hasOwnProperty(X)&&_!=null&&!p.hasOwnProperty(X))switch(X){case"value":break;case"children":break;default:Ai(a,o,X,null,p,_)}for(O in p)if(_=p[O],M=f[O],p.hasOwnProperty(O)&&(_!=null||M!=null))switch(O){case"value":St=_;break;case"defaultValue":wt=_;break;case"children":break;case"dangerouslySetInnerHTML":if(_!=null)throw Error(n(91));break;default:_!==M&&Ai(a,o,O,_,p,M)}Qi(a,St,wt);return;case"option":for(var Me in f)St=f[Me],f.hasOwnProperty(Me)&&St!=null&&!p.hasOwnProperty(Me)&&(Me==="selected"?a.selected=!1:Ai(a,o,Me,null,p,St));for(rt in p)St=p[rt],wt=f[rt],p.hasOwnProperty(rt)&&St!==wt&&(St!=null||wt!=null)&&(rt==="selected"?a.selected=St&&typeof St!="function"&&typeof St!="symbol":Ai(a,o,rt,St,p,wt));return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var Ve in f)St=f[Ve],f.hasOwnProperty(Ve)&&St!=null&&!p.hasOwnProperty(Ve)&&Ai(a,o,Ve,null,p,St);for(_t in p)if(St=p[_t],wt=f[_t],p.hasOwnProperty(_t)&&St!==wt&&(St!=null||wt!=null))switch(_t){case"children":case"dangerouslySetInnerHTML":if(St!=null)throw Error(n(137,o));break;default:Ai(a,o,_t,St,p,wt)}return;default:if(Zr(o)){for(var di in f)St=f[di],f.hasOwnProperty(di)&&St!==void 0&&!p.hasOwnProperty(di)&&m_(a,o,di,void 0,p,St);for(Nt in p)St=p[Nt],wt=f[Nt],!p.hasOwnProperty(Nt)||St===wt||St===void 0&&wt===void 0||m_(a,o,Nt,St,p,wt);return}}for(var mt in f)St=f[mt],f.hasOwnProperty(mt)&&St!=null&&!p.hasOwnProperty(mt)&&Ai(a,o,mt,null,p,St);for(Yt in p)St=p[Yt],wt=f[Yt],!p.hasOwnProperty(Yt)||St===wt||St==null&&wt==null||Ai(a,o,Yt,St,p,wt)}function TI(a){switch(a){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function VT(){if(typeof performance.getEntriesByType=="function"){for(var a=0,o=0,f=performance.getEntriesByType("resource"),p=0;p<f.length;p++){var _=f[p],M=_.transferSize,O=_.initiatorType,X=_.duration;if(M&&X&&TI(O)){for(O=0,X=_.responseEnd,p+=1;p<f.length;p++){var rt=f[p],_t=rt.startTime;if(_t>X)break;var Nt=rt.transferSize,Yt=rt.initiatorType;Nt&&TI(Yt)&&(rt=rt.responseEnd,O+=Nt*(rt<X?1:(X-_t)/(rt-_t)))}if(--p,o+=8*(M+O)/(_.duration/1e3),a++,10<a)break}}if(0<a)return o/a/1e6}return navigator.connection&&(a=navigator.connection.downlink,typeof a=="number")?a:5}var y_=null,x_=null;function Ey(a){return a.nodeType===9?a:a.ownerDocument}function QI(a){switch(a){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function DI(a,o){if(a===0)switch(o){case"svg":return 1;case"math":return 2;default:return 0}return a===1&&o==="foreignObject"?0:a}function v_(a,o){return a==="textarea"||a==="noscript"||typeof o.children=="string"||typeof o.children=="number"||typeof o.children=="bigint"||typeof o.dangerouslySetInnerHTML=="object"&&o.dangerouslySetInnerHTML!==null&&o.dangerouslySetInnerHTML.__html!=null}var E_=null;function YT(){var a=window.event;return a&&a.type==="popstate"?a===E_?!1:(E_=a,!0):(E_=null,!1)}var RI=typeof setTimeout=="function"?setTimeout:void 0,qT=typeof clearTimeout=="function"?clearTimeout:void 0,NI=typeof Promise=="function"?Promise:void 0,XT=typeof queueMicrotask=="function"?queueMicrotask:typeof NI<"u"?function(a){return NI.resolve(null).then(a).catch(JT)}:RI;function JT(a){setTimeout(function(){throw a})}function Gu(a){return a==="head"}function UI(a,o){var f=o,p=0;do{var _=f.nextSibling;if(a.removeChild(f),_&&_.nodeType===8)if(f=_.data,f==="/$"||f==="/&"){if(p===0){a.removeChild(_),ed(o);return}p--}else if(f==="$"||f==="$?"||f==="$~"||f==="$!"||f==="&")p++;else if(f==="html")Bg(a.ownerDocument.documentElement);else if(f==="head"){f=a.ownerDocument.head,Bg(f);for(var M=f.firstChild;M;){var O=M.nextSibling,X=M.nodeName;M[ia]||X==="SCRIPT"||X==="STYLE"||X==="LINK"&&M.rel.toLowerCase()==="stylesheet"||f.removeChild(M),M=O}}else f==="body"&&Bg(a.ownerDocument.body);f=_}while(f);ed(o)}function LI(a,o){var f=a;a=0;do{var p=f.nextSibling;if(f.nodeType===1?o?(f._stashedDisplay=f.style.display,f.style.display="none"):(f.style.display=f._stashedDisplay||"",f.getAttribute("style")===""&&f.removeAttribute("style")):f.nodeType===3&&(o?(f._stashedText=f.nodeValue,f.nodeValue=""):f.nodeValue=f._stashedText||""),p&&p.nodeType===8)if(f=p.data,f==="/$"){if(a===0)break;a--}else f!=="$"&&f!=="$?"&&f!=="$~"&&f!=="$!"||a++;f=p}while(f)}function __(a){var o=a.firstChild;for(o&&o.nodeType===10&&(o=o.nextSibling);o;){var f=o;switch(o=o.nextSibling,f.nodeName){case"HTML":case"HEAD":case"BODY":__(f),Ir(f);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(f.rel.toLowerCase()==="stylesheet")continue}a.removeChild(f)}}function ZT(a,o,f,p){for(;a.nodeType===1;){var _=f;if(a.nodeName.toLowerCase()!==o.toLowerCase()){if(!p&&(a.nodeName!=="INPUT"||a.type!=="hidden"))break}else if(p){if(!a[ia])switch(o){case"meta":if(!a.hasAttribute("itemprop"))break;return a;case"link":if(M=a.getAttribute("rel"),M==="stylesheet"&&a.hasAttribute("data-precedence"))break;if(M!==_.rel||a.getAttribute("href")!==(_.href==null||_.href===""?null:_.href)||a.getAttribute("crossorigin")!==(_.crossOrigin==null?null:_.crossOrigin)||a.getAttribute("title")!==(_.title==null?null:_.title))break;return a;case"style":if(a.hasAttribute("data-precedence"))break;return a;case"script":if(M=a.getAttribute("src"),(M!==(_.src==null?null:_.src)||a.getAttribute("type")!==(_.type==null?null:_.type)||a.getAttribute("crossorigin")!==(_.crossOrigin==null?null:_.crossOrigin))&&M&&a.hasAttribute("async")&&!a.hasAttribute("itemprop"))break;return a;default:return a}}else if(o==="input"&&a.type==="hidden"){var M=_.name==null?null:""+_.name;if(_.type==="hidden"&&a.getAttribute("name")===M)return a}else return a;if(a=po(a.nextSibling),a===null)break}return null}function WT(a,o,f){if(o==="")return null;for(;a.nodeType!==3;)if((a.nodeType!==1||a.nodeName!=="INPUT"||a.type!=="hidden")&&!f||(a=po(a.nextSibling),a===null))return null;return a}function zI(a,o){for(;a.nodeType!==8;)if((a.nodeType!==1||a.nodeName!=="INPUT"||a.type!=="hidden")&&!o||(a=po(a.nextSibling),a===null))return null;return a}function C_(a){return a.data==="$?"||a.data==="$~"}function b_(a){return a.data==="$!"||a.data==="$?"&&a.ownerDocument.readyState!=="loading"}function jT(a,o){var f=a.ownerDocument;if(a.data==="$~")a._reactRetry=o;else if(a.data!=="$?"||f.readyState!=="loading")o();else{var p=function(){o(),f.removeEventListener("DOMContentLoaded",p)};f.addEventListener("DOMContentLoaded",p),a._reactRetry=p}}function po(a){for(;a!=null;a=a.nextSibling){var o=a.nodeType;if(o===1||o===3)break;if(o===8){if(o=a.data,o==="$"||o==="$!"||o==="$?"||o==="$~"||o==="&"||o==="F!"||o==="F")break;if(o==="/$"||o==="/&")return null}}return a}var S_=null;function OI(a){a=a.nextSibling;for(var o=0;a;){if(a.nodeType===8){var f=a.data;if(f==="/$"||f==="/&"){if(o===0)return po(a.nextSibling);o--}else f!=="$"&&f!=="$!"&&f!=="$?"&&f!=="$~"&&f!=="&"||o++}a=a.nextSibling}return null}function FI(a){a=a.previousSibling;for(var o=0;a;){if(a.nodeType===8){var f=a.data;if(f==="$"||f==="$!"||f==="$?"||f==="$~"||f==="&"){if(o===0)return a;o--}else f!=="/$"&&f!=="/&"||o++}a=a.previousSibling}return null}function PI(a,o,f){switch(o=Ey(f),a){case"html":if(a=o.documentElement,!a)throw Error(n(452));return a;case"head":if(a=o.head,!a)throw Error(n(453));return a;case"body":if(a=o.body,!a)throw Error(n(454));return a;default:throw Error(n(451))}}function Bg(a){for(var o=a.attributes;o.length;)a.removeAttributeNode(o[0]);Ir(a)}var go=new Map,GI=new Set;function _y(a){return typeof a.getRootNode=="function"?a.getRootNode():a.nodeType===9?a:a.ownerDocument}var Fc=tt.d;tt.d={f:KT,r:$T,D:tQ,C:eQ,L:nQ,m:iQ,X:aQ,S:sQ,M:rQ};function KT(){var a=Fc.f(),o=J();return a||o}function $T(a){var o=q(a);o!==null&&o.tag===5&&o.type==="form"?gg(o):Fc.r(a)}var KA=typeof document>"u"?null:document;function kI(a,o,f){var p=KA;if(p&&typeof o=="string"&&o){var _=Vn(o);_='link[rel="'+a+'"][href="'+_+'"]',typeof f=="string"&&(_+='[crossorigin="'+f+'"]'),GI.has(_)||(GI.add(_),a={rel:a,crossOrigin:f,href:o},p.querySelector(_)===null&&(o=p.createElement("link"),$s(o,"link",a),vt(o),p.head.appendChild(o)))}}function tQ(a){Fc.D(a),kI("dns-prefetch",a,null)}function eQ(a,o){Fc.C(a,o),kI("preconnect",a,o)}function nQ(a,o,f){Fc.L(a,o,f);var p=KA;if(p&&a&&o){var _='link[rel="preload"][as="'+Vn(o)+'"]';o==="image"&&f&&f.imageSrcSet?(_+='[imagesrcset="'+Vn(f.imageSrcSet)+'"]',typeof f.imageSizes=="string"&&(_+='[imagesizes="'+Vn(f.imageSizes)+'"]')):_+='[href="'+Vn(a)+'"]';var M=_;switch(o){case"style":M=$A(a);break;case"script":M=td(a)}go.has(M)||(a=g({rel:"preload",href:o==="image"&&f&&f.imageSrcSet?void 0:a,as:o},f),go.set(M,a),p.querySelector(_)!==null||o==="style"&&p.querySelector(Mg(M))||o==="script"&&p.querySelector(wg(M))||(o=p.createElement("link"),$s(o,"link",a),vt(o),p.head.appendChild(o)))}}function iQ(a,o){Fc.m(a,o);var f=KA;if(f&&a){var p=o&&typeof o.as=="string"?o.as:"script",_='link[rel="modulepreload"][as="'+Vn(p)+'"][href="'+Vn(a)+'"]',M=_;switch(p){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":M=td(a)}if(!go.has(M)&&(a=g({rel:"modulepreload",href:a},o),go.set(M,a),f.querySelector(_)===null)){switch(p){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(f.querySelector(wg(M)))return}p=f.createElement("link"),$s(p,"link",a),vt(p),f.head.appendChild(p)}}}function sQ(a,o,f){Fc.S(a,o,f);var p=KA;if(p&&a){var _=Ct(p).hoistableStyles,M=$A(a);o=o||"default";var O=_.get(M);if(!O){var X={loading:0,preload:null};if(O=p.querySelector(Mg(M)))X.loading=5;else{a=g({rel:"stylesheet",href:a,"data-precedence":o},f),(f=go.get(M))&&I_(a,f);var rt=O=p.createElement("link");vt(rt),$s(rt,"link",a),rt._p=new Promise(function(_t,Nt){rt.onload=_t,rt.onerror=Nt}),rt.addEventListener("load",function(){X.loading|=1}),rt.addEventListener("error",function(){X.loading|=2}),X.loading|=4,Cy(O,o,p)}O={type:"stylesheet",instance:O,count:1,state:X},_.set(M,O)}}}function aQ(a,o){Fc.X(a,o);var f=KA;if(f&&a){var p=Ct(f).hoistableScripts,_=td(a),M=p.get(_);M||(M=f.querySelector(wg(_)),M||(a=g({src:a,async:!0},o),(o=go.get(_))&&B_(a,o),M=f.createElement("script"),vt(M),$s(M,"link",a),f.head.appendChild(M)),M={type:"script",instance:M,count:1,state:null},p.set(_,M))}}function rQ(a,o){Fc.M(a,o);var f=KA;if(f&&a){var p=Ct(f).hoistableScripts,_=td(a),M=p.get(_);M||(M=f.querySelector(wg(_)),M||(a=g({src:a,async:!0,type:"module"},o),(o=go.get(_))&&B_(a,o),M=f.createElement("script"),vt(M),$s(M,"link",a),f.head.appendChild(M)),M={type:"script",instance:M,count:1,state:null},p.set(_,M))}}function HI(a,o,f,p){var _=(_=dt.current)?_y(_):null;if(!_)throw Error(n(446));switch(a){case"meta":case"title":return null;case"style":return typeof f.precedence=="string"&&typeof f.href=="string"?(o=$A(f.href),f=Ct(_).hoistableStyles,p=f.get(o),p||(p={type:"style",instance:null,count:0,state:null},f.set(o,p)),p):{type:"void",instance:null,count:0,state:null};case"link":if(f.rel==="stylesheet"&&typeof f.href=="string"&&typeof f.precedence=="string"){a=$A(f.href);var M=Ct(_).hoistableStyles,O=M.get(a);if(O||(_=_.ownerDocument||_,O={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},M.set(a,O),(M=_.querySelector(Mg(a)))&&!M._p&&(O.instance=M,O.state.loading=5),go.has(a)||(f={rel:"preload",as:"style",href:f.href,crossOrigin:f.crossOrigin,integrity:f.integrity,media:f.media,hrefLang:f.hrefLang,referrerPolicy:f.referrerPolicy},go.set(a,f),M||oQ(_,a,f,O.state))),o&&p===null)throw Error(n(528,""));return O}if(o&&p!==null)throw Error(n(529,""));return null;case"script":return o=f.async,f=f.src,typeof f=="string"&&o&&typeof o!="function"&&typeof o!="symbol"?(o=td(f),f=Ct(_).hoistableScripts,p=f.get(o),p||(p={type:"script",instance:null,count:0,state:null},f.set(o,p)),p):{type:"void",instance:null,count:0,state:null};default:throw Error(n(444,a))}}function $A(a){return'href="'+Vn(a)+'"'}function Mg(a){return'link[rel="stylesheet"]['+a+"]"}function VI(a){return g({},a,{"data-precedence":a.precedence,precedence:null})}function oQ(a,o,f,p){a.querySelector('link[rel="preload"][as="style"]['+o+"]")?p.loading=1:(o=a.createElement("link"),p.preload=o,o.addEventListener("load",function(){return p.loading|=1}),o.addEventListener("error",function(){return p.loading|=2}),$s(o,"link",f),vt(o),a.head.appendChild(o))}function td(a){return'[src="'+Vn(a)+'"]'}function wg(a){return"script[async]"+a}function YI(a,o,f){if(o.count++,o.instance===null)switch(o.type){case"style":var p=a.querySelector('style[data-href~="'+Vn(f.href)+'"]');if(p)return o.instance=p,vt(p),p;var _=g({},f,{"data-href":f.href,"data-precedence":f.precedence,href:null,precedence:null});return p=(a.ownerDocument||a).createElement("style"),vt(p),$s(p,"style",_),Cy(p,f.precedence,a),o.instance=p;case"stylesheet":_=$A(f.href);var M=a.querySelector(Mg(_));if(M)return o.state.loading|=4,o.instance=M,vt(M),M;p=VI(f),(_=go.get(_))&&I_(p,_),M=(a.ownerDocument||a).createElement("link"),vt(M);var O=M;return O._p=new Promise(function(X,rt){O.onload=X,O.onerror=rt}),$s(M,"link",p),o.state.loading|=4,Cy(M,f.precedence,a),o.instance=M;case"script":return M=td(f.src),(_=a.querySelector(wg(M)))?(o.instance=_,vt(_),_):(p=f,(_=go.get(M))&&(p=g({},f),B_(p,_)),a=a.ownerDocument||a,_=a.createElement("script"),vt(_),$s(_,"link",p),a.head.appendChild(_),o.instance=_);case"void":return null;default:throw Error(n(443,o.type))}else o.type==="stylesheet"&&(o.state.loading&4)===0&&(p=o.instance,o.state.loading|=4,Cy(p,f.precedence,a));return o.instance}function Cy(a,o,f){for(var p=f.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),_=p.length?p[p.length-1]:null,M=_,O=0;O<p.length;O++){var X=p[O];if(X.dataset.precedence===o)M=X;else if(M!==_)break}M?M.parentNode.insertBefore(a,M.nextSibling):(o=f.nodeType===9?f.head:f,o.insertBefore(a,o.firstChild))}function I_(a,o){a.crossOrigin==null&&(a.crossOrigin=o.crossOrigin),a.referrerPolicy==null&&(a.referrerPolicy=o.referrerPolicy),a.title==null&&(a.title=o.title)}function B_(a,o){a.crossOrigin==null&&(a.crossOrigin=o.crossOrigin),a.referrerPolicy==null&&(a.referrerPolicy=o.referrerPolicy),a.integrity==null&&(a.integrity=o.integrity)}var by=null;function qI(a,o,f){if(by===null){var p=new Map,_=by=new Map;_.set(f,p)}else _=by,p=_.get(f),p||(p=new Map,_.set(f,p));if(p.has(a))return p;for(p.set(a,null),f=f.getElementsByTagName(a),_=0;_<f.length;_++){var M=f[_];if(!(M[ia]||M[an]||a==="link"&&M.getAttribute("rel")==="stylesheet")&&M.namespaceURI!=="http://www.w3.org/2000/svg"){var O=M.getAttribute(o)||"";O=a+O;var X=p.get(O);X?X.push(M):p.set(O,[M])}}return p}function XI(a,o,f){a=a.ownerDocument||a,a.head.insertBefore(f,o==="title"?a.querySelector("head > title"):null)}function lQ(a,o,f){if(f===1||o.itemProp!=null)return!1;switch(a){case"meta":case"title":return!0;case"style":if(typeof o.precedence!="string"||typeof o.href!="string"||o.href==="")break;return!0;case"link":if(typeof o.rel!="string"||typeof o.href!="string"||o.href===""||o.onLoad||o.onError)break;return o.rel==="stylesheet"?(a=o.disabled,typeof o.precedence=="string"&&a==null):!0;case"script":if(o.async&&typeof o.async!="function"&&typeof o.async!="symbol"&&!o.onLoad&&!o.onError&&o.src&&typeof o.src=="string")return!0}return!1}function JI(a){return!(a.type==="stylesheet"&&(a.state.loading&3)===0)}function cQ(a,o,f,p){if(f.type==="stylesheet"&&(typeof p.media!="string"||matchMedia(p.media).matches!==!1)&&(f.state.loading&4)===0){if(f.instance===null){var _=$A(p.href),M=o.querySelector(Mg(_));if(M){o=M._p,o!==null&&typeof o=="object"&&typeof o.then=="function"&&(a.count++,a=Sy.bind(a),o.then(a,a)),f.state.loading|=4,f.instance=M,vt(M);return}M=o.ownerDocument||o,p=VI(p),(_=go.get(_))&&I_(p,_),M=M.createElement("link"),vt(M);var O=M;O._p=new Promise(function(X,rt){O.onload=X,O.onerror=rt}),$s(M,"link",p),f.instance=M}a.stylesheets===null&&(a.stylesheets=new Map),a.stylesheets.set(f,o),(o=f.state.preload)&&(f.state.loading&3)===0&&(a.count++,f=Sy.bind(a),o.addEventListener("load",f),o.addEventListener("error",f))}}var M_=0;function uQ(a,o){return a.stylesheets&&a.count===0&&By(a,a.stylesheets),0<a.count||0<a.imgCount?function(f){var p=setTimeout(function(){if(a.stylesheets&&By(a,a.stylesheets),a.unsuspend){var M=a.unsuspend;a.unsuspend=null,M()}},6e4+o);0<a.imgBytes&&M_===0&&(M_=62500*VT());var _=setTimeout(function(){if(a.waitingForImages=!1,a.count===0&&(a.stylesheets&&By(a,a.stylesheets),a.unsuspend)){var M=a.unsuspend;a.unsuspend=null,M()}},(a.imgBytes>M_?50:800)+o);return a.unsuspend=f,function(){a.unsuspend=null,clearTimeout(p),clearTimeout(_)}}:null}function Sy(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)By(this,this.stylesheets);else if(this.unsuspend){var a=this.unsuspend;this.unsuspend=null,a()}}}var Iy=null;function By(a,o){a.stylesheets=null,a.unsuspend!==null&&(a.count++,Iy=new Map,o.forEach(hQ,a),Iy=null,Sy.call(a))}function hQ(a,o){if(!(o.state.loading&4)){var f=Iy.get(a);if(f)var p=f.get(null);else{f=new Map,Iy.set(a,f);for(var _=a.querySelectorAll("link[data-precedence],style[data-precedence]"),M=0;M<_.length;M++){var O=_[M];(O.nodeName==="LINK"||O.getAttribute("media")!=="not all")&&(f.set(O.dataset.precedence,O),p=O)}p&&f.set(null,p)}_=o.instance,O=_.getAttribute("data-precedence"),M=f.get(O)||p,M===p&&f.set(null,_),f.set(O,_),this.count++,p=Sy.bind(this),_.addEventListener("load",p),_.addEventListener("error",p),M?M.parentNode.insertBefore(_,M.nextSibling):(a=a.nodeType===9?a.head:a,a.insertBefore(_,a.firstChild)),o.state.loading|=4}}var Tg={$$typeof:w,Provider:null,Consumer:null,_currentValue:it,_currentValue2:it,_threadCount:0};function fQ(a,o,f,p,_,M,O,X,rt){this.tag=1,this.containerInfo=a,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=ln(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=ln(0),this.hiddenUpdates=ln(null),this.identifierPrefix=p,this.onUncaughtError=_,this.onCaughtError=M,this.onRecoverableError=O,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=rt,this.incompleteTransitions=new Map}function ZI(a,o,f,p,_,M,O,X,rt,_t,Nt,Yt){return a=new fQ(a,o,f,O,rt,_t,Nt,Yt,X),o=1,M===!0&&(o|=24),M=Xs(3,null,null,o),a.current=M,M.stateNode=a,o=Op(),o.refCount++,a.pooledCache=o,o.refCount++,M.memoizedState={element:p,isDehydrated:f,cache:o},Vp(M),a}function WI(a){return a?(a=Tl,a):Tl}function jI(a,o,f,p,_,M){_=WI(_),p.context===null?p.context=_:p.pendingContext=_,p=ao(o),p.payload={element:f},M=M===void 0?null:M,M!==null&&(p.callback=M),f=Go(a,p,o),f!==null&&(h(f,a,o),Ol(f,a,o))}function KI(a,o){if(a=a.memoizedState,a!==null&&a.dehydrated!==null){var f=a.retryLane;a.retryLane=f!==0&&f<o?f:o}}function w_(a,o){KI(a,o),(a=a.alternate)&&KI(a,o)}function $I(a){if(a.tag===13||a.tag===31){var o=wl(a,67108864);o!==null&&h(o,a,67108864),w_(a,67108864)}}function t1(a){if(a.tag===13||a.tag===31){var o=Ks();o=ei(o);var f=wl(a,o);f!==null&&h(f,a,o),w_(a,o)}}var My=!0;function AQ(a,o,f,p){var _=H.T;H.T=null;var M=tt.p;try{tt.p=2,T_(a,o,f,p)}finally{tt.p=M,H.T=_}}function dQ(a,o,f,p){var _=H.T;H.T=null;var M=tt.p;try{tt.p=8,T_(a,o,f,p)}finally{tt.p=M,H.T=_}}function T_(a,o,f,p){if(My){var _=Q_(p);if(_===null)g_(a,o,p,wy,f),n1(a,p);else if(gQ(_,a,o,f,p))p.stopPropagation();else if(n1(a,p),o&4&&-1<pQ.indexOf(a)){for(;_!==null;){var M=q(_);if(M!==null)switch(M.tag){case 3:if(M=M.stateNode,M.current.memoizedState.isDehydrated){var O=Xt(M.pendingLanes);if(O!==0){var X=M;for(X.pendingLanes|=2,X.entangledLanes|=2;O;){var rt=1<<31-ve(O);X.entanglements[1]|=rt,O&=~rt}Xl(M),(Dn&6)===0&&(Ya=G()+500,bg(0))}}break;case 31:case 13:X=wl(M,2),X!==null&&h(X,M,2),J(),w_(M,2)}if(M=Q_(p),M===null&&g_(a,o,p,wy,f),M===_)break;_=M}_!==null&&p.stopPropagation()}else g_(a,o,p,null,f)}}function Q_(a){return a=lu(a),D_(a)}var wy=null;function D_(a){if(wy=null,a=pi(a),a!==null){var o=r(a);if(o===null)a=null;else{var f=o.tag;if(f===13){if(a=l(o),a!==null)return a;a=null}else if(f===31){if(a=u(o),a!==null)return a;a=null}else if(f===3){if(o.stateNode.current.memoizedState.isDehydrated)return o.tag===3?o.stateNode.containerInfo:null;a=null}else o!==a&&(a=null)}}return wy=a,null}function e1(a){switch(a){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(ft()){case Tt:return 2;case Ht:return 8;case Bt:case Se:return 32;case ae:return 268435456;default:return 32}default:return 32}}var R_=!1,ku=null,Hu=null,Vu=null,Qg=new Map,Dg=new Map,Yu=[],pQ="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function n1(a,o){switch(a){case"focusin":case"focusout":ku=null;break;case"dragenter":case"dragleave":Hu=null;break;case"mouseover":case"mouseout":Vu=null;break;case"pointerover":case"pointerout":Qg.delete(o.pointerId);break;case"gotpointercapture":case"lostpointercapture":Dg.delete(o.pointerId)}}function Rg(a,o,f,p,_,M){return a===null||a.nativeEvent!==M?(a={blockedOn:o,domEventName:f,eventSystemFlags:p,nativeEvent:M,targetContainers:[_]},o!==null&&(o=q(o),o!==null&&$I(o)),a):(a.eventSystemFlags|=p,o=a.targetContainers,_!==null&&o.indexOf(_)===-1&&o.push(_),a)}function gQ(a,o,f,p,_){switch(o){case"focusin":return ku=Rg(ku,a,o,f,p,_),!0;case"dragenter":return Hu=Rg(Hu,a,o,f,p,_),!0;case"mouseover":return Vu=Rg(Vu,a,o,f,p,_),!0;case"pointerover":var M=_.pointerId;return Qg.set(M,Rg(Qg.get(M)||null,a,o,f,p,_)),!0;case"gotpointercapture":return M=_.pointerId,Dg.set(M,Rg(Dg.get(M)||null,a,o,f,p,_)),!0}return!1}function i1(a){var o=pi(a.target);if(o!==null){var f=r(o);if(f!==null){if(o=f.tag,o===13){if(o=l(f),o!==null){a.blockedOn=o,Qs(a.priority,function(){t1(f)});return}}else if(o===31){if(o=u(f),o!==null){a.blockedOn=o,Qs(a.priority,function(){t1(f)});return}}else if(o===3&&f.stateNode.current.memoizedState.isDehydrated){a.blockedOn=f.tag===3?f.stateNode.containerInfo:null;return}}}a.blockedOn=null}function Ty(a){if(a.blockedOn!==null)return!1;for(var o=a.targetContainers;0<o.length;){var f=Q_(a.nativeEvent);if(f===null){f=a.nativeEvent;var p=new f.constructor(f.type,f);hc=p,f.target.dispatchEvent(p),hc=null}else return o=q(f),o!==null&&$I(o),a.blockedOn=f,!1;o.shift()}return!0}function s1(a,o,f){Ty(a)&&f.delete(o)}function mQ(){R_=!1,ku!==null&&Ty(ku)&&(ku=null),Hu!==null&&Ty(Hu)&&(Hu=null),Vu!==null&&Ty(Vu)&&(Vu=null),Qg.forEach(s1),Dg.forEach(s1)}function Qy(a,o){a.blockedOn===o&&(a.blockedOn=null,R_||(R_=!0,s.unstable_scheduleCallback(s.unstable_NormalPriority,mQ)))}var Dy=null;function a1(a){Dy!==a&&(Dy=a,s.unstable_scheduleCallback(s.unstable_NormalPriority,function(){Dy===a&&(Dy=null);for(var o=0;o<a.length;o+=3){var f=a[o],p=a[o+1],_=a[o+2];if(typeof p!="function"){if(D_(p||f)===null)continue;break}var M=q(f);M!==null&&(a.splice(o,3),o-=3,pg(M,{pending:!0,data:_,method:f.method,action:p},p,_))}}))}function ed(a){function o(rt){return Qy(rt,a)}ku!==null&&Qy(ku,a),Hu!==null&&Qy(Hu,a),Vu!==null&&Qy(Vu,a),Qg.forEach(o),Dg.forEach(o);for(var f=0;f<Yu.length;f++){var p=Yu[f];p.blockedOn===a&&(p.blockedOn=null)}for(;0<Yu.length&&(f=Yu[0],f.blockedOn===null);)i1(f),f.blockedOn===null&&Yu.shift();if(f=(a.ownerDocument||a).$$reactFormReplay,f!=null)for(p=0;p<f.length;p+=3){var _=f[p],M=f[p+1],O=_[_i]||null;if(typeof M=="function")O||a1(f);else if(O){var X=null;if(M&&M.hasAttribute("formAction")){if(_=M,O=M[_i]||null)X=O.formAction;else if(D_(_)!==null)continue}else X=O.action;typeof X=="function"?f[p+1]=X:(f.splice(p,3),p-=3),a1(f)}}}function r1(){function a(M){M.canIntercept&&M.info==="react-transition"&&M.intercept({handler:function(){return new Promise(function(O){return _=O})},focusReset:"manual",scroll:"manual"})}function o(){_!==null&&(_(),_=null),p||setTimeout(f,20)}function f(){if(!p&&!navigation.transition){var M=navigation.currentEntry;M&&M.url!=null&&navigation.navigate(M.url,{state:M.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var p=!1,_=null;return navigation.addEventListener("navigate",a),navigation.addEventListener("navigatesuccess",o),navigation.addEventListener("navigateerror",o),setTimeout(f,100),function(){p=!0,navigation.removeEventListener("navigate",a),navigation.removeEventListener("navigatesuccess",o),navigation.removeEventListener("navigateerror",o),_!==null&&(_(),_=null)}}}function N_(a){this._internalRoot=a}Ry.prototype.render=N_.prototype.render=function(a){var o=this._internalRoot;if(o===null)throw Error(n(409));var f=o.current,p=Ks();jI(f,p,a,o,null,null)},Ry.prototype.unmount=N_.prototype.unmount=function(){var a=this._internalRoot;if(a!==null){this._internalRoot=null;var o=a.containerInfo;jI(a.current,2,null,a,null,null),J(),o[Ys]=null}};function Ry(a){this._internalRoot=a}Ry.prototype.unstable_scheduleHydration=function(a){if(a){var o=gs();a={blockedOn:null,target:a,priority:o};for(var f=0;f<Yu.length&&o!==0&&o<Yu[f].priority;f++);Yu.splice(f,0,a),f===0&&i1(a)}};var o1=t.version;if(o1!=="19.2.3")throw Error(n(527,o1,"19.2.3"));tt.findDOMNode=function(a){var o=a._reactInternals;if(o===void 0)throw typeof a.render=="function"?Error(n(188)):(a=Object.keys(a).join(","),Error(n(268,a)));return a=d(o),a=a!==null?m(a):null,a=a===null?null:a.stateNode,a};var yQ={bundleType:0,version:"19.2.3",rendererPackageName:"react-dom",currentDispatcherRef:H,reconcilerVersion:"19.2.3"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Ny=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Ny.isDisabled&&Ny.supportsFiber)try{Gt=Ny.inject(yQ),Jt=Ny}catch{}}return Ug.createRoot=function(a,o){if(!i(a))throw Error(n(299));var f=!1,p="",_=xg,M=fy,O=OA;return o!=null&&(o.unstable_strictMode===!0&&(f=!0),o.identifierPrefix!==void 0&&(p=o.identifierPrefix),o.onUncaughtError!==void 0&&(_=o.onUncaughtError),o.onCaughtError!==void 0&&(M=o.onCaughtError),o.onRecoverableError!==void 0&&(O=o.onRecoverableError)),o=ZI(a,1,!1,null,null,f,p,null,_,M,O,r1),a[Ys]=o.current,p_(a),new N_(o)},Ug.hydrateRoot=function(a,o,f){if(!i(a))throw Error(n(299));var p=!1,_="",M=xg,O=fy,X=OA,rt=null;return f!=null&&(f.unstable_strictMode===!0&&(p=!0),f.identifierPrefix!==void 0&&(_=f.identifierPrefix),f.onUncaughtError!==void 0&&(M=f.onUncaughtError),f.onCaughtError!==void 0&&(O=f.onCaughtError),f.onRecoverableError!==void 0&&(X=f.onRecoverableError),f.formState!==void 0&&(rt=f.formState)),o=ZI(a,1,!0,o,f??null,p,_,rt,M,O,X,r1),o.context=WI(null),f=o.current,p=Ks(),p=ei(p),_=ao(p),_.callback=null,Go(f,_,p),f=p,o.current.lanes=f,Ei(o,f),Xl(o),a[Ys]=o.current,p_(a),new Ry(o)},Ug.version="19.2.3",Ug}var m1;function MQ(){if(m1)return z_.exports;m1=1;function s(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(s)}catch(t){console.error(t)}}return s(),z_.exports=BQ(),z_.exports}var wQ=MQ(),G_={exports:{}},Pc={};var y1;function TQ(){return y1||(y1=1,Pc.ConcurrentRoot=1,Pc.ContinuousEventPriority=8,Pc.DefaultEventPriority=32,Pc.DiscreteEventPriority=2,Pc.IdleEventPriority=268435456,Pc.LegacyRoot=0,Pc.NoEventPriority=0),Pc}var x1;function QQ(){return x1||(x1=1,G_.exports=TQ()),G_.exports}var ev=QQ();const Kf="181",DQ={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},RQ={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},AM=0,bb=1,dM=2,NQ=3,pM=0,oE=1,gm=2,rl=3,fl=0,_a=1,gr=2,nc=0,Gf=1,Sb=2,Ib=3,Bb=4,gM=5,rh=100,mM=101,yM=102,xM=103,vM=104,EM=200,_M=201,CM=202,bM=203,uv=204,hv=205,SM=206,IM=207,BM=208,MM=209,wM=210,TM=211,QM=212,DM=213,RM=214,fv=0,Av=1,dv=2,Yf=3,pv=4,gv=5,mv=6,yv=7,n0=0,NM=1,UM=2,ic=0,LM=1,zM=2,OM=3,hS=4,FM=5,PM=6,GM=7,Mb="attached",kM="detached",lE=300,eu=301,fh=302,Rm=303,Nm=304,rp=306,Um=1e3,yr=1001,Lm=1002,rs=1003,fS=1004,UQ=1004,Gd=1005,LQ=1005,as=1006,mm=1007,zQ=1007,tc=1008,HM=1008,ea=1009,AS=1010,dS=1011,Jd=1012,cE=1013,Ca=1014,xr=1015,$f=1016,uE=1017,hE=1018,Zd=1020,pS=35902,gS=35899,mS=1021,yS=1022,Ki=1023,Wd=1026,jd=1027,fE=1028,i0=1029,AE=1030,s0=1031,OQ=1032,sc=1033,ym=33776,xm=33777,vm=33778,Em=33779,xv=35840,vv=35841,Ev=35842,_v=35843,Cv=36196,bv=37492,Sv=37496,Iv=37808,Bv=37809,Mv=37810,wv=37811,Tv=37812,Qv=37813,Dv=37814,Rv=37815,Nv=37816,Uv=37817,Lv=37818,zv=37819,Ov=37820,Fv=37821,Pv=36492,Gv=36494,kv=36495,Hv=36283,Vv=36284,Yv=36285,qv=36286,VM=2200,YM=2201,qM=2202,zm=2300,Xv=2301,nv=2302,Df=2400,Rf=2401,Om=2402,dE=2500,xS=2501,FQ=0,PQ=1,GQ=2,XM=3200,JM=3201,kQ=3202,HQ=3203,gh=0,ZM=1,Wc="",ks="srgb",Ah="srgb-linear",Fm="linear",ui="srgb",VQ=0,Mf=7680,YQ=7681,qQ=7682,XQ=7683,JQ=34055,ZQ=34056,WQ=5386,jQ=512,KQ=513,$Q=514,tD=515,eD=516,nD=517,iD=518,wb=519,WM=512,jM=513,KM=514,vS=515,$M=516,tw=517,ew=518,nw=519,Pm=35044,iw=35048,sD=35040,aD=35045,rD=35049,oD=35041,lD=35046,cD=35050,uD=35042,hD="100",Gm="300 es",Hr=2e3,Kd=2001,fD={COMPUTE:"compute",RENDER:"render"},AD={PERSPECTIVE:"perspective",LINEAR:"linear",FLAT:"flat"},dD={NORMAL:"normal",CENTROID:"centroid",SAMPLE:"sample",FIRST:"first",EITHER:"either"};function sw(s){for(let t=s.length-1;t>=0;--t)if(s[t]>=65535)return!0;return!1}const pD={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function kd(s,t){return new pD[s](t)}function km(s){return document.createElementNS("http://www.w3.org/1999/xhtml",s)}function aw(){const s=km("canvas");return s.style.display="block",s}const v1={};let dh=null;function gD(s){dh=s}function mD(){return dh}function Hm(...s){const t="THREE."+s.shift();dh?dh("log",t,...s):console.log(t,...s)}function ge(...s){const t="THREE."+s.shift();dh?dh("warn",t,...s):console.warn(t,...s)}function nn(...s){const t="THREE."+s.shift();dh?dh("error",t,...s):console.error(t,...s)}function $d(...s){const t=s.join(" ");t in v1||(v1[t]=!0,ge(...s))}function yD(s,t,e){return new Promise(function(n,i){function r(){switch(s.clientWaitSync(t,s.SYNC_FLUSH_COMMANDS_BIT,0)){case s.WAIT_FAILED:i();break;case s.TIMEOUT_EXPIRED:setTimeout(r,e);break;default:n()}}setTimeout(r,e)})}let rc=class{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[t]===void 0&&(n[t]=[]),n[t].indexOf(e)===-1&&n[t].push(e)}hasEventListener(t,e){const n=this._listeners;return n===void 0?!1:n[t]!==void 0&&n[t].indexOf(e)!==-1}removeEventListener(t,e){const n=this._listeners;if(n===void 0)return;const i=n[t];if(i!==void 0){const r=i.indexOf(e);r!==-1&&i.splice(r,1)}}dispatchEvent(t){const e=this._listeners;if(e===void 0)return;const n=e[t.type];if(n!==void 0){t.target=this;const i=n.slice(0);for(let r=0,l=i.length;r<l;r++)i[r].call(this,t);t.target=null}}};const ga=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let E1=1234567;const kf=Math.PI/180,tp=180/Math.PI;function Yr(){const s=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(ga[s&255]+ga[s>>8&255]+ga[s>>16&255]+ga[s>>24&255]+"-"+ga[t&255]+ga[t>>8&255]+"-"+ga[t>>16&15|64]+ga[t>>24&255]+"-"+ga[e&63|128]+ga[e>>8&255]+"-"+ga[e>>16&255]+ga[e>>24&255]+ga[n&255]+ga[n>>8&255]+ga[n>>16&255]+ga[n>>24&255]).toLowerCase()}function Je(s,t,e){return Math.max(t,Math.min(e,s))}function ES(s,t){return(s%t+t)%t}function xD(s,t,e,n,i){return n+(s-t)*(i-n)/(e-t)}function vD(s,t,e){return s!==t?(e-s)/(t-s):0}function _m(s,t,e){return(1-e)*s+e*t}function ED(s,t,e,n){return _m(s,t,1-Math.exp(-e*n))}function _D(s,t=1){return t-Math.abs(ES(s,t*2)-t)}function CD(s,t,e){return s<=t?0:s>=e?1:(s=(s-t)/(e-t),s*s*(3-2*s))}function bD(s,t,e){return s<=t?0:s>=e?1:(s=(s-t)/(e-t),s*s*s*(s*(s*6-15)+10))}function SD(s,t){return s+Math.floor(Math.random()*(t-s+1))}function ID(s,t){return s+Math.random()*(t-s)}function BD(s){return s*(.5-Math.random())}function MD(s){s!==void 0&&(E1=s);let t=E1+=1831565813;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}function wD(s){return s*kf}function TD(s){return s*tp}function QD(s){return(s&s-1)===0&&s!==0}function DD(s){return Math.pow(2,Math.ceil(Math.log(s)/Math.LN2))}function RD(s){return Math.pow(2,Math.floor(Math.log(s)/Math.LN2))}function ND(s,t,e,n,i){const r=Math.cos,l=Math.sin,u=r(e/2),A=l(e/2),d=r((t+n)/2),m=l((t+n)/2),g=r((t-n)/2),y=l((t-n)/2),v=r((n-t)/2),C=l((n-t)/2);switch(i){case"XYX":s.set(u*m,A*g,A*y,u*d);break;case"YZY":s.set(A*y,u*m,A*g,u*d);break;case"ZXZ":s.set(A*g,A*y,u*m,u*d);break;case"XZX":s.set(u*m,A*C,A*v,u*d);break;case"YXY":s.set(A*v,u*m,A*C,u*d);break;case"ZYZ":s.set(A*C,A*v,u*m,u*d);break;default:ge("MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function Ka(s,t){switch(t.constructor){case Float32Array:return s;case Uint32Array:return s/4294967295;case Uint16Array:return s/65535;case Uint8Array:return s/255;case Int32Array:return Math.max(s/2147483647,-1);case Int16Array:return Math.max(s/32767,-1);case Int8Array:return Math.max(s/127,-1);default:throw new Error("Invalid component type.")}}function dn(s,t){switch(t.constructor){case Float32Array:return s;case Uint32Array:return Math.round(s*4294967295);case Uint16Array:return Math.round(s*65535);case Uint8Array:return Math.round(s*255);case Int32Array:return Math.round(s*2147483647);case Int16Array:return Math.round(s*32767);case Int8Array:return Math.round(s*127);default:throw new Error("Invalid component type.")}}const _S={DEG2RAD:kf,RAD2DEG:tp,generateUUID:Yr,clamp:Je,euclideanModulo:ES,mapLinear:xD,inverseLerp:vD,lerp:_m,damp:ED,pingpong:_D,smoothstep:CD,smootherstep:bD,randInt:SD,randFloat:ID,randFloatSpread:BD,seededRandom:MD,degToRad:wD,radToDeg:TD,isPowerOfTwo:QD,ceilPowerOfTwo:DD,floorPowerOfTwo:RD,setQuaternionFromProperEuler:ND,normalize:dn,denormalize:Ka};class Dt{constructor(t=0,e=0){Dt.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Je(this.x,t.x,e.x),this.y=Je(this.y,t.y,e.y),this}clampScalar(t,e){return this.x=Je(this.x,t,e),this.y=Je(this.y,t,e),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Je(n,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(Je(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),r=this.x-t.x,l=this.y-t.y;return this.x=r*n-l*i+t.x,this.y=r*i+l*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Ge{constructor(t=0,e=0,n=0,i=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=n,this._w=i}static slerpFlat(t,e,n,i,r,l,u){let A=n[i+0],d=n[i+1],m=n[i+2],g=n[i+3],y=r[l+0],v=r[l+1],C=r[l+2],I=r[l+3];if(u<=0){t[e+0]=A,t[e+1]=d,t[e+2]=m,t[e+3]=g;return}if(u>=1){t[e+0]=y,t[e+1]=v,t[e+2]=C,t[e+3]=I;return}if(g!==I||A!==y||d!==v||m!==C){let S=A*y+d*v+m*C+g*I;S<0&&(y=-y,v=-v,C=-C,I=-I,S=-S);let E=1-u;if(S<.9995){const B=Math.acos(S),w=Math.sin(B);E=Math.sin(E*B)/w,u=Math.sin(u*B)/w,A=A*E+y*u,d=d*E+v*u,m=m*E+C*u,g=g*E+I*u}else{A=A*E+y*u,d=d*E+v*u,m=m*E+C*u,g=g*E+I*u;const B=1/Math.sqrt(A*A+d*d+m*m+g*g);A*=B,d*=B,m*=B,g*=B}}t[e]=A,t[e+1]=d,t[e+2]=m,t[e+3]=g}static multiplyQuaternionsFlat(t,e,n,i,r,l){const u=n[i],A=n[i+1],d=n[i+2],m=n[i+3],g=r[l],y=r[l+1],v=r[l+2],C=r[l+3];return t[e]=u*C+m*g+A*v-d*y,t[e+1]=A*C+m*y+d*g-u*v,t[e+2]=d*C+m*v+u*y-A*g,t[e+3]=m*C-u*g-A*y-d*v,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const n=t._x,i=t._y,r=t._z,l=t._order,u=Math.cos,A=Math.sin,d=u(n/2),m=u(i/2),g=u(r/2),y=A(n/2),v=A(i/2),C=A(r/2);switch(l){case"XYZ":this._x=y*m*g+d*v*C,this._y=d*v*g-y*m*C,this._z=d*m*C+y*v*g,this._w=d*m*g-y*v*C;break;case"YXZ":this._x=y*m*g+d*v*C,this._y=d*v*g-y*m*C,this._z=d*m*C-y*v*g,this._w=d*m*g+y*v*C;break;case"ZXY":this._x=y*m*g-d*v*C,this._y=d*v*g+y*m*C,this._z=d*m*C+y*v*g,this._w=d*m*g-y*v*C;break;case"ZYX":this._x=y*m*g-d*v*C,this._y=d*v*g+y*m*C,this._z=d*m*C-y*v*g,this._w=d*m*g+y*v*C;break;case"YZX":this._x=y*m*g+d*v*C,this._y=d*v*g+y*m*C,this._z=d*m*C-y*v*g,this._w=d*m*g-y*v*C;break;case"XZY":this._x=y*m*g-d*v*C,this._y=d*v*g-y*m*C,this._z=d*m*C+y*v*g,this._w=d*m*g+y*v*C;break;default:ge("Quaternion: .setFromEuler() encountered an unknown order: "+l)}return e===!0&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],r=e[8],l=e[1],u=e[5],A=e[9],d=e[2],m=e[6],g=e[10],y=n+u+g;if(y>0){const v=.5/Math.sqrt(y+1);this._w=.25/v,this._x=(m-A)*v,this._y=(r-d)*v,this._z=(l-i)*v}else if(n>u&&n>g){const v=2*Math.sqrt(1+n-u-g);this._w=(m-A)/v,this._x=.25*v,this._y=(i+l)/v,this._z=(r+d)/v}else if(u>g){const v=2*Math.sqrt(1+u-n-g);this._w=(r-d)/v,this._x=(i+l)/v,this._y=.25*v,this._z=(A+m)/v}else{const v=2*Math.sqrt(1+g-n-u);this._w=(l-i)/v,this._x=(r+d)/v,this._y=(A+m)/v,this._z=.25*v}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<1e-8?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Je(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(n===0)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,r=t._z,l=t._w,u=e._x,A=e._y,d=e._z,m=e._w;return this._x=n*m+l*u+i*d-r*A,this._y=i*m+l*A+r*u-n*d,this._z=r*m+l*d+n*A-i*u,this._w=l*m-n*u-i*A-r*d,this._onChangeCallback(),this}slerp(t,e){if(e<=0)return this;if(e>=1)return this.copy(t);let n=t._x,i=t._y,r=t._z,l=t._w,u=this.dot(t);u<0&&(n=-n,i=-i,r=-r,l=-l,u=-u);let A=1-e;if(u<.9995){const d=Math.acos(u),m=Math.sin(d);A=Math.sin(A*d)/m,e=Math.sin(e*d)/m,this._x=this._x*A+n*e,this._y=this._y*A+i*e,this._z=this._z*A+r*e,this._w=this._w*A+l*e,this._onChangeCallback()}else this._x=this._x*A+n*e,this._y=this._y*A+i*e,this._z=this._z*A+r*e,this._w=this._w*A+l*e,this.normalize();return this}slerpQuaternions(t,e,n){return this.copy(t).slerp(e,n)}random(){const t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),n=Math.random(),i=Math.sqrt(1-n),r=Math.sqrt(n);return this.set(i*Math.sin(t),i*Math.cos(t),r*Math.sin(e),r*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class F{constructor(t=0,e=0,n=0){F.prototype.isVector3=!0,this.x=t,this.y=e,this.z=n}set(t,e,n){return n===void 0&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(_1.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(_1.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6]*i,this.y=r[1]*e+r[4]*n+r[7]*i,this.z=r[2]*e+r[5]*n+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=t.elements,l=1/(r[3]*e+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*n+r[8]*i+r[12])*l,this.y=(r[1]*e+r[5]*n+r[9]*i+r[13])*l,this.z=(r[2]*e+r[6]*n+r[10]*i+r[14])*l,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,r=t.x,l=t.y,u=t.z,A=t.w,d=2*(l*i-u*n),m=2*(u*e-r*i),g=2*(r*n-l*e);return this.x=e+A*d+l*g-u*m,this.y=n+A*m+u*d-r*g,this.z=i+A*g+r*m-l*d,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*n+r[8]*i,this.y=r[1]*e+r[5]*n+r[9]*i,this.z=r[2]*e+r[6]*n+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Je(this.x,t.x,e.x),this.y=Je(this.y,t.y,e.y),this.z=Je(this.z,t.z,e.z),this}clampScalar(t,e){return this.x=Je(this.x,t,e),this.y=Je(this.y,t,e),this.z=Je(this.z,t,e),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Je(n,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,r=t.z,l=e.x,u=e.y,A=e.z;return this.x=i*A-r*u,this.y=r*l-n*A,this.z=n*u-i*l,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return k_.copy(this).projectOnVector(t),this.sub(k_)}reflect(t){return this.sub(k_.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(Je(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,e=Math.random()*2-1,n=Math.sqrt(1-e*e);return this.x=n*Math.cos(t),this.y=e,this.z=n*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const k_=new F,_1=new Ge;class Ze{constructor(t,e,n,i,r,l,u,A,d){Ze.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],t!==void 0&&this.set(t,e,n,i,r,l,u,A,d)}set(t,e,n,i,r,l,u,A,d){const m=this.elements;return m[0]=t,m[1]=i,m[2]=u,m[3]=e,m[4]=r,m[5]=A,m[6]=n,m[7]=l,m[8]=d,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,l=n[0],u=n[3],A=n[6],d=n[1],m=n[4],g=n[7],y=n[2],v=n[5],C=n[8],I=i[0],S=i[3],E=i[6],B=i[1],w=i[4],Q=i[7],R=i[2],D=i[5],U=i[8];return r[0]=l*I+u*B+A*R,r[3]=l*S+u*w+A*D,r[6]=l*E+u*Q+A*U,r[1]=d*I+m*B+g*R,r[4]=d*S+m*w+g*D,r[7]=d*E+m*Q+g*U,r[2]=y*I+v*B+C*R,r[5]=y*S+v*w+C*D,r[8]=y*E+v*Q+C*U,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],l=t[4],u=t[5],A=t[6],d=t[7],m=t[8];return e*l*m-e*u*d-n*r*m+n*u*A+i*r*d-i*l*A}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],l=t[4],u=t[5],A=t[6],d=t[7],m=t[8],g=m*l-u*d,y=u*A-m*r,v=d*r-l*A,C=e*g+n*y+i*v;if(C===0)return this.set(0,0,0,0,0,0,0,0,0);const I=1/C;return t[0]=g*I,t[1]=(i*d-m*n)*I,t[2]=(u*n-i*l)*I,t[3]=y*I,t[4]=(m*e-i*A)*I,t[5]=(i*r-u*e)*I,t[6]=v*I,t[7]=(n*A-d*e)*I,t[8]=(l*e-n*r)*I,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,r,l,u){const A=Math.cos(r),d=Math.sin(r);return this.set(n*A,n*d,-n*(A*l+d*u)+l+t,-i*d,i*A,-i*(-d*l+A*u)+u+e,0,0,1),this}scale(t,e){return this.premultiply(H_.makeScale(t,e)),this}rotate(t){return this.premultiply(H_.makeRotation(-t)),this}translate(t,e){return this.premultiply(H_.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,n,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<9;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return new this.constructor().fromArray(this.elements)}}const H_=new Ze,C1=new Ze().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),b1=new Ze().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function UD(){const s={enabled:!0,workingColorSpace:Ah,spaces:{},convert:function(i,r,l){return this.enabled===!1||r===l||!r||!l||(this.spaces[r].transfer===ui&&(i.r=$c(i.r),i.g=$c(i.g),i.b=$c(i.b)),this.spaces[r].primaries!==this.spaces[l].primaries&&(i.applyMatrix3(this.spaces[r].toXYZ),i.applyMatrix3(this.spaces[l].fromXYZ)),this.spaces[l].transfer===ui&&(i.r=qd(i.r),i.g=qd(i.g),i.b=qd(i.b))),i},workingToColorSpace:function(i,r){return this.convert(i,this.workingColorSpace,r)},colorSpaceToWorking:function(i,r){return this.convert(i,r,this.workingColorSpace)},getPrimaries:function(i){return this.spaces[i].primaries},getTransfer:function(i){return i===Wc?Fm:this.spaces[i].transfer},getToneMappingMode:function(i){return this.spaces[i].outputColorSpaceConfig.toneMappingMode||"standard"},getLuminanceCoefficients:function(i,r=this.workingColorSpace){return i.fromArray(this.spaces[r].luminanceCoefficients)},define:function(i){Object.assign(this.spaces,i)},_getMatrix:function(i,r,l){return i.copy(this.spaces[r].toXYZ).multiply(this.spaces[l].fromXYZ)},_getDrawingBufferColorSpace:function(i){return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(i=this.workingColorSpace){return this.spaces[i].workingColorSpaceConfig.unpackColorSpace},fromWorkingColorSpace:function(i,r){return $d("ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),s.workingToColorSpace(i,r)},toWorkingColorSpace:function(i,r){return $d("ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),s.colorSpaceToWorking(i,r)}},t=[.64,.33,.3,.6,.15,.06],e=[.2126,.7152,.0722],n=[.3127,.329];return s.define({[Ah]:{primaries:t,whitePoint:n,transfer:Fm,toXYZ:C1,fromXYZ:b1,luminanceCoefficients:e,workingColorSpaceConfig:{unpackColorSpace:ks},outputColorSpaceConfig:{drawingBufferColorSpace:ks}},[ks]:{primaries:t,whitePoint:n,transfer:ui,toXYZ:C1,fromXYZ:b1,luminanceCoefficients:e,outputColorSpaceConfig:{drawingBufferColorSpace:ks}}}),s}const Gn=UD();function $c(s){return s<.04045?s*.0773993808:Math.pow(s*.9478672986+.0521327014,2.4)}function qd(s){return s<.0031308?s*12.92:1.055*Math.pow(s,.41666)-.055}let nd;class rw{static getDataURL(t,e="image/png"){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement>"u")return t.src;let n;if(t instanceof HTMLCanvasElement)n=t;else{nd===void 0&&(nd=km("canvas")),nd.width=t.width,nd.height=t.height;const i=nd.getContext("2d");t instanceof ImageData?i.putImageData(t,0,0):i.drawImage(t,0,0,t.width,t.height),n=nd}return n.toDataURL(e)}static sRGBToLinear(t){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const e=km("canvas");e.width=t.width,e.height=t.height;const n=e.getContext("2d");n.drawImage(t,0,0,t.width,t.height);const i=n.getImageData(0,0,t.width,t.height),r=i.data;for(let l=0;l<r.length;l++)r[l]=$c(r[l]/255)*255;return n.putImageData(i,0,0),e}else if(t.data){const e=t.data.slice(0);for(let n=0;n<e.length;n++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[n]=Math.floor($c(e[n]/255)*255):e[n]=$c(e[n]);return{data:e,width:t.width,height:t.height}}else return ge("ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let LD=0;class lh{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:LD++}),this.uuid=Yr(),this.data=t,this.dataReady=!0,this.version=0}getSize(t){const e=this.data;return typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement?t.set(e.videoWidth,e.videoHeight,0):e instanceof VideoFrame?t.set(e.displayHeight,e.displayWidth,0):e!==null?t.set(e.width,e.height,e.depth||0):t.set(0,0,0),t}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const n={uuid:this.uuid,url:""},i=this.data;if(i!==null){let r;if(Array.isArray(i)){r=[];for(let l=0,u=i.length;l<u;l++)i[l].isDataTexture?r.push(V_(i[l].image)):r.push(V_(i[l]))}else r=V_(i);n.url=r}return e||(t.images[this.uuid]=n),n}}function V_(s){return typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&s instanceof ImageBitmap?rw.getDataURL(s):s.data?{data:Array.from(s.data),width:s.width,height:s.height,type:s.data.constructor.name}:(ge("Texture: Unable to serialize Texture."),{})}let zD=0;const Y_=new F;class wi extends rc{constructor(t=wi.DEFAULT_IMAGE,e=wi.DEFAULT_MAPPING,n=yr,i=yr,r=as,l=tc,u=Ki,A=ea,d=wi.DEFAULT_ANISOTROPY,m=Wc){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:zD++}),this.uuid=Yr(),this.name="",this.source=new lh(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=l,this.anisotropy=d,this.format=u,this.internalFormat=null,this.type=A,this.offset=new Dt(0,0),this.repeat=new Dt(1,1),this.center=new Dt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Ze,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=m,this.userData={},this.updateRanges=[],this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.isArrayTexture=!!(t&&t.depth&&t.depth>1),this.pmremVersion=0}get width(){return this.source.getSize(Y_).x}get height(){return this.source.getSize(Y_).y}get depth(){return this.source.getSize(Y_).z}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.renderTarget=t.renderTarget,this.isRenderTargetTexture=t.isRenderTargetTexture,this.isArrayTexture=t.isArrayTexture,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}setValues(t){for(const e in t){const n=t[e];if(n===void 0){ge(`Texture.setValues(): parameter '${e}' has value of undefined.`);continue}const i=this[e];if(i===void 0){ge(`Texture.setValues(): property '${e}' does not exist.`);continue}i&&n&&i.isVector2&&n.isVector2||i&&n&&i.isVector3&&n.isVector3||i&&n&&i.isMatrix3&&n.isMatrix3?i.copy(n):this[e]=n}}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const n={metadata:{version:4.7,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(n.userData=this.userData),e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==lE)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case Um:t.x=t.x-Math.floor(t.x);break;case yr:t.x=t.x<0?0:1;break;case Lm:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case Um:t.y=t.y-Math.floor(t.y);break;case yr:t.y=t.y<0?0:1;break;case Lm:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){t===!0&&this.pmremVersion++}}wi.DEFAULT_IMAGE=null;wi.DEFAULT_MAPPING=lE;wi.DEFAULT_ANISOTROPY=1;class We{constructor(t=0,e=0,n=0,i=1){We.prototype.isVector4=!0,this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=this.w,l=t.elements;return this.x=l[0]*e+l[4]*n+l[8]*i+l[12]*r,this.y=l[1]*e+l[5]*n+l[9]*i+l[13]*r,this.z=l[2]*e+l[6]*n+l[10]*i+l[14]*r,this.w=l[3]*e+l[7]*n+l[11]*i+l[15]*r,this}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,r;const A=t.elements,d=A[0],m=A[4],g=A[8],y=A[1],v=A[5],C=A[9],I=A[2],S=A[6],E=A[10];if(Math.abs(m-y)<.01&&Math.abs(g-I)<.01&&Math.abs(C-S)<.01){if(Math.abs(m+y)<.1&&Math.abs(g+I)<.1&&Math.abs(C+S)<.1&&Math.abs(d+v+E-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const w=(d+1)/2,Q=(v+1)/2,R=(E+1)/2,D=(m+y)/4,U=(g+I)/4,P=(C+S)/4;return w>Q&&w>R?w<.01?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(w),i=D/n,r=U/n):Q>R?Q<.01?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(Q),n=D/i,r=P/i):R<.01?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(R),n=U/r,i=P/r),this.set(n,i,r,e),this}let B=Math.sqrt((S-C)*(S-C)+(g-I)*(g-I)+(y-m)*(y-m));return Math.abs(B)<.001&&(B=1),this.x=(S-C)/B,this.y=(g-I)/B,this.z=(y-m)/B,this.w=Math.acos((d+v+E-1)/2),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Je(this.x,t.x,e.x),this.y=Je(this.y,t.y,e.y),this.z=Je(this.z,t.z,e.z),this.w=Je(this.w,t.w,e.w),this}clampScalar(t,e){return this.x=Je(this.x,t,e),this.y=Je(this.y,t,e),this.z=Je(this.z,t,e),this.w=Je(this.w,t,e),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Je(n,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class CS extends rc{constructor(t=1,e=1,n={}){super(),n=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:as,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1,depth:1,multiview:!1},n),this.isRenderTarget=!0,this.width=t,this.height=e,this.depth=n.depth,this.scissor=new We(0,0,t,e),this.scissorTest=!1,this.viewport=new We(0,0,t,e);const i={width:t,height:e,depth:n.depth},r=new wi(i);this.textures=[];const l=n.count;for(let u=0;u<l;u++)this.textures[u]=r.clone(),this.textures[u].isRenderTargetTexture=!0,this.textures[u].renderTarget=this;this._setTextureOptions(n),this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,this.resolveDepthBuffer=n.resolveDepthBuffer,this.resolveStencilBuffer=n.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=n.depthTexture,this.samples=n.samples,this.multiview=n.multiview}_setTextureOptions(t={}){const e={minFilter:as,generateMipmaps:!1,flipY:!1,internalFormat:null};t.mapping!==void 0&&(e.mapping=t.mapping),t.wrapS!==void 0&&(e.wrapS=t.wrapS),t.wrapT!==void 0&&(e.wrapT=t.wrapT),t.wrapR!==void 0&&(e.wrapR=t.wrapR),t.magFilter!==void 0&&(e.magFilter=t.magFilter),t.minFilter!==void 0&&(e.minFilter=t.minFilter),t.format!==void 0&&(e.format=t.format),t.type!==void 0&&(e.type=t.type),t.anisotropy!==void 0&&(e.anisotropy=t.anisotropy),t.colorSpace!==void 0&&(e.colorSpace=t.colorSpace),t.flipY!==void 0&&(e.flipY=t.flipY),t.generateMipmaps!==void 0&&(e.generateMipmaps=t.generateMipmaps),t.internalFormat!==void 0&&(e.internalFormat=t.internalFormat);for(let n=0;n<this.textures.length;n++)this.textures[n].setValues(e)}get texture(){return this.textures[0]}set texture(t){this.textures[0]=t}set depthTexture(t){this._depthTexture!==null&&(this._depthTexture.renderTarget=null),t!==null&&(t.renderTarget=this),this._depthTexture=t}get depthTexture(){return this._depthTexture}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let i=0,r=this.textures.length;i<r;i++)this.textures[i].image.width=t,this.textures[i].image.height=e,this.textures[i].image.depth=n,this.textures[i].isData3DTexture!==!0&&(this.textures[i].isArrayTexture=this.textures[i].image.depth>1);this.dispose()}this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.scissor.copy(t.scissor),this.scissorTest=t.scissorTest,this.viewport.copy(t.viewport),this.textures.length=0;for(let e=0,n=t.textures.length;e<n;e++){this.textures[e]=t.textures[e].clone(),this.textures[e].isRenderTargetTexture=!0,this.textures[e].renderTarget=this;const i=Object.assign({},t.textures[e].image);this.textures[e].source=new lh(i)}return this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.resolveDepthBuffer=t.resolveDepthBuffer,this.resolveStencilBuffer=t.resolveStencilBuffer,t.depthTexture!==null&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Io extends CS{constructor(t=1,e=1,n={}){super(t,e,n),this.isWebGLRenderTarget=!0}}class hl extends wi{constructor(t=null,e=1,n=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:n,depth:i},this.magFilter=rs,this.minFilter=rs,this.wrapR=yr,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(t){this.layerUpdates.add(t)}clearLayerUpdates(){this.layerUpdates.clear()}}class bS extends Io{constructor(t=1,e=1,n=1,i={}){super(t,e,i),this.isWebGLArrayRenderTarget=!0,this.depth=n,this.texture=new hl(null,t,e,n),this._setTextureOptions(i),this.texture.isRenderTargetTexture=!0}}class a0 extends wi{constructor(t=null,e=1,n=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:t,width:e,height:n,depth:i},this.magFilter=rs,this.minFilter=rs,this.wrapR=yr,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class OD extends Io{constructor(t=1,e=1,n=1,i={}){super(t,e,i),this.isWebGL3DRenderTarget=!0,this.depth=n,this.texture=new a0(null,t,e,n),this._setTextureOptions(i),this.texture.isRenderTargetTexture=!0}}class kn{constructor(t=new F(1/0,1/0,1/0),e=new F(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e+=3)this.expandByPoint($o.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,n=t.count;e<n;e++)this.expandByPoint($o.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=$o.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const n=t.geometry;if(n!==void 0){const r=n.getAttribute("position");if(e===!0&&r!==void 0&&t.isInstancedMesh!==!0)for(let l=0,u=r.count;l<u;l++)t.isMesh===!0?t.getVertexPosition(l,$o):$o.fromBufferAttribute(r,l),$o.applyMatrix4(t.matrixWorld),this.expandByPoint($o);else t.boundingBox!==void 0?(t.boundingBox===null&&t.computeBoundingBox(),Uy.copy(t.boundingBox)):(n.boundingBox===null&&n.computeBoundingBox(),Uy.copy(n.boundingBox)),Uy.applyMatrix4(t.matrixWorld),this.union(Uy)}const i=t.children;for(let r=0,l=i.length;r<l;r++)this.expandByObject(i[r],e);return this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y&&t.z>=this.min.z&&t.z<=this.max.z}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y&&t.max.z>=this.min.z&&t.min.z<=this.max.z}intersectsSphere(t){return this.clampPoint(t.center,$o),$o.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Lg),Ly.subVectors(this.max,Lg),id.subVectors(t.a,Lg),sd.subVectors(t.b,Lg),ad.subVectors(t.c,Lg),Xu.subVectors(sd,id),Ju.subVectors(ad,sd),rf.subVectors(id,ad);let e=[0,-Xu.z,Xu.y,0,-Ju.z,Ju.y,0,-rf.z,rf.y,Xu.z,0,-Xu.x,Ju.z,0,-Ju.x,rf.z,0,-rf.x,-Xu.y,Xu.x,0,-Ju.y,Ju.x,0,-rf.y,rf.x,0];return!q_(e,id,sd,ad,Ly)||(e=[1,0,0,0,1,0,0,0,1],!q_(e,id,sd,ad,Ly))?!1:(zy.crossVectors(Xu,Ju),e=[zy.x,zy.y,zy.z],q_(e,id,sd,ad,Ly))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,$o).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=this.getSize($o).length()*.5),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(Gc[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),Gc[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),Gc[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),Gc[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),Gc[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),Gc[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),Gc[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),Gc[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(Gc),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}toJSON(){return{min:this.min.toArray(),max:this.max.toArray()}}fromJSON(t){return this.min.fromArray(t.min),this.max.fromArray(t.max),this}}const Gc=[new F,new F,new F,new F,new F,new F,new F,new F],$o=new F,Uy=new kn,id=new F,sd=new F,ad=new F,Xu=new F,Ju=new F,rf=new F,Lg=new F,Ly=new F,zy=new F,of=new F;function q_(s,t,e,n,i){for(let r=0,l=s.length-3;r<=l;r+=3){of.fromArray(s,r);const u=i.x*Math.abs(of.x)+i.y*Math.abs(of.y)+i.z*Math.abs(of.z),A=t.dot(of),d=e.dot(of),m=n.dot(of);if(Math.max(-Math.max(A,d,m),Math.min(A,d,m))>u)return!1}return!0}const FD=new kn,zg=new F,X_=new F;class Bs{constructor(t=new F,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;e!==void 0?n.copy(e):FD.setFromPoints(t).getCenter(n);let i=0;for(let r=0,l=t.length;r<l;r++)i=Math.max(i,n.distanceToSquared(t[r]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;zg.subVectors(t,this.center);const e=zg.lengthSq();if(e>this.radius*this.radius){const n=Math.sqrt(e),i=(n-this.radius)*.5;this.center.addScaledVector(zg,i/n),this.radius+=i}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(this.center.equals(t.center)===!0?this.radius=Math.max(this.radius,t.radius):(X_.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(zg.copy(t.center).add(X_)),this.expandByPoint(zg.copy(t.center).sub(X_))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}toJSON(){return{radius:this.radius,center:this.center.toArray()}}fromJSON(t){return this.radius=t.radius,this.center.fromArray(t.center),this}}const kc=new F,J_=new F,Oy=new F,Zu=new F,Z_=new F,Fy=new F,W_=new F;class tA{constructor(t=new F,e=new F(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,kc)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,n)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=kc.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(kc.copy(this.origin).addScaledVector(this.direction,e),kc.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){J_.copy(t).add(e).multiplyScalar(.5),Oy.copy(e).sub(t).normalize(),Zu.copy(this.origin).sub(J_);const r=t.distanceTo(e)*.5,l=-this.direction.dot(Oy),u=Zu.dot(this.direction),A=-Zu.dot(Oy),d=Zu.lengthSq(),m=Math.abs(1-l*l);let g,y,v,C;if(m>0)if(g=l*A-u,y=l*u-A,C=r*m,g>=0)if(y>=-C)if(y<=C){const I=1/m;g*=I,y*=I,v=g*(g+l*y+2*u)+y*(l*g+y+2*A)+d}else y=r,g=Math.max(0,-(l*y+u)),v=-g*g+y*(y+2*A)+d;else y=-r,g=Math.max(0,-(l*y+u)),v=-g*g+y*(y+2*A)+d;else y<=-C?(g=Math.max(0,-(-l*r+u)),y=g>0?-r:Math.min(Math.max(-r,-A),r),v=-g*g+y*(y+2*A)+d):y<=C?(g=0,y=Math.min(Math.max(-r,-A),r),v=y*(y+2*A)+d):(g=Math.max(0,-(l*r+u)),y=g>0?r:Math.min(Math.max(-r,-A),r),v=-g*g+y*(y+2*A)+d);else y=l>0?-r:r,g=Math.max(0,-(l*y+u)),v=-g*g+y*(y+2*A)+d;return n&&n.copy(this.origin).addScaledVector(this.direction,g),i&&i.copy(J_).addScaledVector(Oy,y),v}intersectSphere(t,e){kc.subVectors(t.center,this.origin);const n=kc.dot(this.direction),i=kc.dot(kc)-n*n,r=t.radius*t.radius;if(i>r)return null;const l=Math.sqrt(r-i),u=n-l,A=n+l;return A<0?null:u<0?this.at(A,e):this.at(u,e)}intersectsSphere(t){return t.radius<0?!1:this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return n===null?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,r,l,u,A;const d=1/this.direction.x,m=1/this.direction.y,g=1/this.direction.z,y=this.origin;return d>=0?(n=(t.min.x-y.x)*d,i=(t.max.x-y.x)*d):(n=(t.max.x-y.x)*d,i=(t.min.x-y.x)*d),m>=0?(r=(t.min.y-y.y)*m,l=(t.max.y-y.y)*m):(r=(t.max.y-y.y)*m,l=(t.min.y-y.y)*m),n>l||r>i||((r>n||isNaN(n))&&(n=r),(l<i||isNaN(i))&&(i=l),g>=0?(u=(t.min.z-y.z)*g,A=(t.max.z-y.z)*g):(u=(t.max.z-y.z)*g,A=(t.min.z-y.z)*g),n>A||u>i)||((u>n||n!==n)&&(n=u),(A<i||i!==i)&&(i=A),i<0)?null:this.at(n>=0?n:i,e)}intersectsBox(t){return this.intersectBox(t,kc)!==null}intersectTriangle(t,e,n,i,r){Z_.subVectors(e,t),Fy.subVectors(n,t),W_.crossVectors(Z_,Fy);let l=this.direction.dot(W_),u;if(l>0){if(i)return null;u=1}else if(l<0)u=-1,l=-l;else return null;Zu.subVectors(this.origin,t);const A=u*this.direction.dot(Fy.crossVectors(Zu,Fy));if(A<0)return null;const d=u*this.direction.dot(Z_.cross(Zu));if(d<0||A+d>l)return null;const m=-u*Zu.dot(W_);return m<0?null:this.at(m/l,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class he{constructor(t,e,n,i,r,l,u,A,d,m,g,y,v,C,I,S){he.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],t!==void 0&&this.set(t,e,n,i,r,l,u,A,d,m,g,y,v,C,I,S)}set(t,e,n,i,r,l,u,A,d,m,g,y,v,C,I,S){const E=this.elements;return E[0]=t,E[4]=e,E[8]=n,E[12]=i,E[1]=r,E[5]=l,E[9]=u,E[13]=A,E[2]=d,E[6]=m,E[10]=g,E[14]=y,E[3]=v,E[7]=C,E[11]=I,E[15]=S,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new he().fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/rd.setFromMatrixColumn(t,0).length(),r=1/rd.setFromMatrixColumn(t,1).length(),l=1/rd.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*r,e[5]=n[5]*r,e[6]=n[6]*r,e[7]=0,e[8]=n[8]*l,e[9]=n[9]*l,e[10]=n[10]*l,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,n=t.x,i=t.y,r=t.z,l=Math.cos(n),u=Math.sin(n),A=Math.cos(i),d=Math.sin(i),m=Math.cos(r),g=Math.sin(r);if(t.order==="XYZ"){const y=l*m,v=l*g,C=u*m,I=u*g;e[0]=A*m,e[4]=-A*g,e[8]=d,e[1]=v+C*d,e[5]=y-I*d,e[9]=-u*A,e[2]=I-y*d,e[6]=C+v*d,e[10]=l*A}else if(t.order==="YXZ"){const y=A*m,v=A*g,C=d*m,I=d*g;e[0]=y+I*u,e[4]=C*u-v,e[8]=l*d,e[1]=l*g,e[5]=l*m,e[9]=-u,e[2]=v*u-C,e[6]=I+y*u,e[10]=l*A}else if(t.order==="ZXY"){const y=A*m,v=A*g,C=d*m,I=d*g;e[0]=y-I*u,e[4]=-l*g,e[8]=C+v*u,e[1]=v+C*u,e[5]=l*m,e[9]=I-y*u,e[2]=-l*d,e[6]=u,e[10]=l*A}else if(t.order==="ZYX"){const y=l*m,v=l*g,C=u*m,I=u*g;e[0]=A*m,e[4]=C*d-v,e[8]=y*d+I,e[1]=A*g,e[5]=I*d+y,e[9]=v*d-C,e[2]=-d,e[6]=u*A,e[10]=l*A}else if(t.order==="YZX"){const y=l*A,v=l*d,C=u*A,I=u*d;e[0]=A*m,e[4]=I-y*g,e[8]=C*g+v,e[1]=g,e[5]=l*m,e[9]=-u*m,e[2]=-d*m,e[6]=v*g+C,e[10]=y-I*g}else if(t.order==="XZY"){const y=l*A,v=l*d,C=u*A,I=u*d;e[0]=A*m,e[4]=-g,e[8]=d*m,e[1]=y*g+I,e[5]=l*m,e[9]=v*g-C,e[2]=C*g-v,e[6]=u*m,e[10]=I*g+y}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(PD,t,GD)}lookAt(t,e,n){const i=this.elements;return Fr.subVectors(t,e),Fr.lengthSq()===0&&(Fr.z=1),Fr.normalize(),Wu.crossVectors(n,Fr),Wu.lengthSq()===0&&(Math.abs(n.z)===1?Fr.x+=1e-4:Fr.z+=1e-4,Fr.normalize(),Wu.crossVectors(n,Fr)),Wu.normalize(),Py.crossVectors(Fr,Wu),i[0]=Wu.x,i[4]=Py.x,i[8]=Fr.x,i[1]=Wu.y,i[5]=Py.y,i[9]=Fr.y,i[2]=Wu.z,i[6]=Py.z,i[10]=Fr.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,l=n[0],u=n[4],A=n[8],d=n[12],m=n[1],g=n[5],y=n[9],v=n[13],C=n[2],I=n[6],S=n[10],E=n[14],B=n[3],w=n[7],Q=n[11],R=n[15],D=i[0],U=i[4],P=i[8],z=i[12],L=i[1],k=i[5],Y=i[9],W=i[13],K=i[2],nt=i[6],H=i[10],tt=i[14],it=i[3],ot=i[7],At=i[11],V=i[15];return r[0]=l*D+u*L+A*K+d*it,r[4]=l*U+u*k+A*nt+d*ot,r[8]=l*P+u*Y+A*H+d*At,r[12]=l*z+u*W+A*tt+d*V,r[1]=m*D+g*L+y*K+v*it,r[5]=m*U+g*k+y*nt+v*ot,r[9]=m*P+g*Y+y*H+v*At,r[13]=m*z+g*W+y*tt+v*V,r[2]=C*D+I*L+S*K+E*it,r[6]=C*U+I*k+S*nt+E*ot,r[10]=C*P+I*Y+S*H+E*At,r[14]=C*z+I*W+S*tt+E*V,r[3]=B*D+w*L+Q*K+R*it,r[7]=B*U+w*k+Q*nt+R*ot,r[11]=B*P+w*Y+Q*H+R*At,r[15]=B*z+w*W+Q*tt+R*V,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],r=t[12],l=t[1],u=t[5],A=t[9],d=t[13],m=t[2],g=t[6],y=t[10],v=t[14],C=t[3],I=t[7],S=t[11],E=t[15];return C*(+r*A*g-i*d*g-r*u*y+n*d*y+i*u*v-n*A*v)+I*(+e*A*v-e*d*y+r*l*y-i*l*v+i*d*m-r*A*m)+S*(+e*d*g-e*u*v-r*l*g+n*l*v+r*u*m-n*d*m)+E*(-i*u*m-e*A*g+e*u*y+i*l*g-n*l*y+n*A*m)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],l=t[4],u=t[5],A=t[6],d=t[7],m=t[8],g=t[9],y=t[10],v=t[11],C=t[12],I=t[13],S=t[14],E=t[15],B=g*S*d-I*y*d+I*A*v-u*S*v-g*A*E+u*y*E,w=C*y*d-m*S*d-C*A*v+l*S*v+m*A*E-l*y*E,Q=m*I*d-C*g*d+C*u*v-l*I*v-m*u*E+l*g*E,R=C*g*A-m*I*A-C*u*y+l*I*y+m*u*S-l*g*S,D=e*B+n*w+i*Q+r*R;if(D===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const U=1/D;return t[0]=B*U,t[1]=(I*y*r-g*S*r-I*i*v+n*S*v+g*i*E-n*y*E)*U,t[2]=(u*S*r-I*A*r+I*i*d-n*S*d-u*i*E+n*A*E)*U,t[3]=(g*A*r-u*y*r-g*i*d+n*y*d+u*i*v-n*A*v)*U,t[4]=w*U,t[5]=(m*S*r-C*y*r+C*i*v-e*S*v-m*i*E+e*y*E)*U,t[6]=(C*A*r-l*S*r-C*i*d+e*S*d+l*i*E-e*A*E)*U,t[7]=(l*y*r-m*A*r+m*i*d-e*y*d-l*i*v+e*A*v)*U,t[8]=Q*U,t[9]=(C*g*r-m*I*r-C*n*v+e*I*v+m*n*E-e*g*E)*U,t[10]=(l*I*r-C*u*r+C*n*d-e*I*d-l*n*E+e*u*E)*U,t[11]=(m*u*r-l*g*r-m*n*d+e*g*d+l*n*v-e*u*v)*U,t[12]=R*U,t[13]=(m*I*i-C*g*i+C*n*y-e*I*y-m*n*S+e*g*S)*U,t[14]=(C*u*i-l*I*i-C*n*A+e*I*A+l*n*S-e*u*S)*U,t[15]=(l*g*i-m*u*i+m*n*A-e*g*A-l*n*y+e*u*y)*U,this}scale(t){const e=this.elements,n=t.x,i=t.y,r=t.z;return e[0]*=n,e[4]*=i,e[8]*=r,e[1]*=n,e[5]*=i,e[9]*=r,e[2]*=n,e[6]*=i,e[10]*=r,e[3]*=n,e[7]*=i,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,i))}makeTranslation(t,e,n){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),r=1-n,l=t.x,u=t.y,A=t.z,d=r*l,m=r*u;return this.set(d*l+n,d*u-i*A,d*A+i*u,0,d*u+i*A,m*u+n,m*A-i*l,0,d*A-i*u,m*A+i*l,r*A*A+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,i,r,l){return this.set(1,n,r,0,t,1,l,0,e,i,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,r=e._x,l=e._y,u=e._z,A=e._w,d=r+r,m=l+l,g=u+u,y=r*d,v=r*m,C=r*g,I=l*m,S=l*g,E=u*g,B=A*d,w=A*m,Q=A*g,R=n.x,D=n.y,U=n.z;return i[0]=(1-(I+E))*R,i[1]=(v+Q)*R,i[2]=(C-w)*R,i[3]=0,i[4]=(v-Q)*D,i[5]=(1-(y+E))*D,i[6]=(S+B)*D,i[7]=0,i[8]=(C+w)*U,i[9]=(S-B)*U,i[10]=(1-(y+I))*U,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let r=rd.set(i[0],i[1],i[2]).length();const l=rd.set(i[4],i[5],i[6]).length(),u=rd.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],tl.copy(this);const d=1/r,m=1/l,g=1/u;return tl.elements[0]*=d,tl.elements[1]*=d,tl.elements[2]*=d,tl.elements[4]*=m,tl.elements[5]*=m,tl.elements[6]*=m,tl.elements[8]*=g,tl.elements[9]*=g,tl.elements[10]*=g,e.setFromRotationMatrix(tl),n.x=r,n.y=l,n.z=u,this}makePerspective(t,e,n,i,r,l,u=Hr,A=!1){const d=this.elements,m=2*r/(e-t),g=2*r/(n-i),y=(e+t)/(e-t),v=(n+i)/(n-i);let C,I;if(A)C=r/(l-r),I=l*r/(l-r);else if(u===Hr)C=-(l+r)/(l-r),I=-2*l*r/(l-r);else if(u===Kd)C=-l/(l-r),I=-l*r/(l-r);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+u);return d[0]=m,d[4]=0,d[8]=y,d[12]=0,d[1]=0,d[5]=g,d[9]=v,d[13]=0,d[2]=0,d[6]=0,d[10]=C,d[14]=I,d[3]=0,d[7]=0,d[11]=-1,d[15]=0,this}makeOrthographic(t,e,n,i,r,l,u=Hr,A=!1){const d=this.elements,m=2/(e-t),g=2/(n-i),y=-(e+t)/(e-t),v=-(n+i)/(n-i);let C,I;if(A)C=1/(l-r),I=l/(l-r);else if(u===Hr)C=-2/(l-r),I=-(l+r)/(l-r);else if(u===Kd)C=-1/(l-r),I=-r/(l-r);else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+u);return d[0]=m,d[4]=0,d[8]=0,d[12]=y,d[1]=0,d[5]=g,d[9]=0,d[13]=v,d[2]=0,d[6]=0,d[10]=C,d[14]=I,d[3]=0,d[7]=0,d[11]=0,d[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<16;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}const rd=new F,tl=new he,PD=new F(0,0,0),GD=new F(1,1,1),Wu=new F,Py=new F,Fr=new F,S1=new he,I1=new Ge;class _r{constructor(t=0,e=0,n=0,i=_r.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i=this._order){return this._x=t,this._y=e,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const i=t.elements,r=i[0],l=i[4],u=i[8],A=i[1],d=i[5],m=i[9],g=i[2],y=i[6],v=i[10];switch(e){case"XYZ":this._y=Math.asin(Je(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(-m,v),this._z=Math.atan2(-l,r)):(this._x=Math.atan2(y,d),this._z=0);break;case"YXZ":this._x=Math.asin(-Je(m,-1,1)),Math.abs(m)<.9999999?(this._y=Math.atan2(u,v),this._z=Math.atan2(A,d)):(this._y=Math.atan2(-g,r),this._z=0);break;case"ZXY":this._x=Math.asin(Je(y,-1,1)),Math.abs(y)<.9999999?(this._y=Math.atan2(-g,v),this._z=Math.atan2(-l,d)):(this._y=0,this._z=Math.atan2(A,r));break;case"ZYX":this._y=Math.asin(-Je(g,-1,1)),Math.abs(g)<.9999999?(this._x=Math.atan2(y,v),this._z=Math.atan2(A,r)):(this._x=0,this._z=Math.atan2(-l,d));break;case"YZX":this._z=Math.asin(Je(A,-1,1)),Math.abs(A)<.9999999?(this._x=Math.atan2(-m,d),this._y=Math.atan2(-g,r)):(this._x=0,this._y=Math.atan2(u,v));break;case"XZY":this._z=Math.asin(-Je(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(y,d),this._y=Math.atan2(u,r)):(this._x=Math.atan2(-m,v),this._y=0);break;default:ge("Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,n===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return S1.makeRotationFromQuaternion(t),this.setFromRotationMatrix(S1,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return I1.setFromEuler(this),this.setFromQuaternion(I1,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}_r.DEFAULT_ORDER="XYZ";class ep{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}isEnabled(t){return(this.mask&(1<<t|0))!==0}}let kD=0;const B1=new F,od=new Ge,Hc=new he,Gy=new F,Og=new F,HD=new F,VD=new Ge,M1=new F(1,0,0),w1=new F(0,1,0),T1=new F(0,0,1),Q1={type:"added"},YD={type:"removed"},ld={type:"childadded",child:null},j_={type:"childremoved",child:null};class gn extends rc{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:kD++}),this.uuid=Yr(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=gn.DEFAULT_UP.clone();const t=new F,e=new _r,n=new Ge,i=new F(1,1,1);function r(){n.setFromEuler(e,!1)}function l(){e.setFromQuaternion(n,void 0,!1)}e._onChange(r),n._onChange(l),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new he},normalMatrix:{value:new Ze}}),this.matrix=new he,this.matrixWorld=new he,this.matrixAutoUpdate=gn.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=gn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new ep,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.customDepthMaterial=void 0,this.customDistanceMaterial=void 0,this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return od.setFromAxisAngle(t,e),this.quaternion.multiply(od),this}rotateOnWorldAxis(t,e){return od.setFromAxisAngle(t,e),this.quaternion.premultiply(od),this}rotateX(t){return this.rotateOnAxis(M1,t)}rotateY(t){return this.rotateOnAxis(w1,t)}rotateZ(t){return this.rotateOnAxis(T1,t)}translateOnAxis(t,e){return B1.copy(t).applyQuaternion(this.quaternion),this.position.add(B1.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(M1,t)}translateY(t){return this.translateOnAxis(w1,t)}translateZ(t){return this.translateOnAxis(T1,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(Hc.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?Gy.copy(t):Gy.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),Og.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Hc.lookAt(Og,Gy,this.up):Hc.lookAt(Gy,Og,this.up),this.quaternion.setFromRotationMatrix(Hc),i&&(Hc.extractRotation(i.matrixWorld),od.setFromRotationMatrix(Hc),this.quaternion.premultiply(od.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(nn("Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(Q1),ld.child=t,this.dispatchEvent(ld),ld.child=null):nn("Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(YD),j_.child=t,this.dispatchEvent(j_),j_.child=null),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),Hc.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),Hc.multiply(t.parent.matrixWorld)),t.applyMatrix4(Hc),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(Q1),ld.child=t,this.dispatchEvent(ld),ld.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const l=this.children[n].getObjectByProperty(t,e);if(l!==void 0)return l}}getObjectsByProperty(t,e,n=[]){this[t]===e&&n.push(this);const i=this.children;for(let r=0,l=i.length;r<l;r++)i[r].getObjectsByProperty(t,e,n);return n}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Og,t,HD),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Og,VD,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(t===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),e===!0){const i=this.children;for(let r=0,l=i.length;r<l;r++)i[r].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.7,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.geometryInfo=this._geometryInfo.map(u=>({...u,boundingBox:u.boundingBox?u.boundingBox.toJSON():void 0,boundingSphere:u.boundingSphere?u.boundingSphere.toJSON():void 0})),i.instanceInfo=this._instanceInfo.map(u=>({...u})),i.availableInstanceIds=this._availableInstanceIds.slice(),i.availableGeometryIds=this._availableGeometryIds.slice(),i.nextIndexStart=this._nextIndexStart,i.nextVertexStart=this._nextVertexStart,i.geometryCount=this._geometryCount,i.maxInstanceCount=this._maxInstanceCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.matricesTexture=this._matricesTexture.toJSON(t),i.indirectTexture=this._indirectTexture.toJSON(t),this._colorsTexture!==null&&(i.colorsTexture=this._colorsTexture.toJSON(t)),this.boundingSphere!==null&&(i.boundingSphere=this.boundingSphere.toJSON()),this.boundingBox!==null&&(i.boundingBox=this.boundingBox.toJSON()));function r(u,A){return u[A.uuid]===void 0&&(u[A.uuid]=A.toJSON(t)),A.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(t.geometries,this.geometry);const u=this.geometry.parameters;if(u!==void 0&&u.shapes!==void 0){const A=u.shapes;if(Array.isArray(A))for(let d=0,m=A.length;d<m;d++){const g=A[d];r(t.shapes,g)}else r(t.shapes,A)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const u=[];for(let A=0,d=this.material.length;A<d;A++)u.push(r(t.materials,this.material[A]));i.material=u}else i.material=r(t.materials,this.material);if(this.children.length>0){i.children=[];for(let u=0;u<this.children.length;u++)i.children.push(this.children[u].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let u=0;u<this.animations.length;u++){const A=this.animations[u];i.animations.push(r(t.animations,A))}}if(e){const u=l(t.geometries),A=l(t.materials),d=l(t.textures),m=l(t.images),g=l(t.shapes),y=l(t.skeletons),v=l(t.animations),C=l(t.nodes);u.length>0&&(n.geometries=u),A.length>0&&(n.materials=A),d.length>0&&(n.textures=d),m.length>0&&(n.images=m),g.length>0&&(n.shapes=g),y.length>0&&(n.skeletons=y),v.length>0&&(n.animations=v),C.length>0&&(n.nodes=C)}return n.object=i,n;function l(u){const A=[];for(const d in u){const m=u[d];delete m.metadata,A.push(m)}return A}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let n=0;n<t.children.length;n++){const i=t.children[n];this.add(i.clone())}return this}}gn.DEFAULT_UP=new F(0,1,0);gn.DEFAULT_MATRIX_AUTO_UPDATE=!0;gn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const el=new F,Vc=new F,K_=new F,Yc=new F,cd=new F,ud=new F,D1=new F,$_=new F,tC=new F,eC=new F,nC=new We,iC=new We,sC=new We;class ds{constructor(t=new F,e=new F,n=new F){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,i){i.subVectors(n,e),el.subVectors(t,e),i.cross(el);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(t,e,n,i,r){el.subVectors(i,e),Vc.subVectors(n,e),K_.subVectors(t,e);const l=el.dot(el),u=el.dot(Vc),A=el.dot(K_),d=Vc.dot(Vc),m=Vc.dot(K_),g=l*d-u*u;if(g===0)return r.set(0,0,0),null;const y=1/g,v=(d*A-u*m)*y,C=(l*m-u*A)*y;return r.set(1-v-C,C,v)}static containsPoint(t,e,n,i){return this.getBarycoord(t,e,n,i,Yc)===null?!1:Yc.x>=0&&Yc.y>=0&&Yc.x+Yc.y<=1}static getInterpolation(t,e,n,i,r,l,u,A){return this.getBarycoord(t,e,n,i,Yc)===null?(A.x=0,A.y=0,"z"in A&&(A.z=0),"w"in A&&(A.w=0),null):(A.setScalar(0),A.addScaledVector(r,Yc.x),A.addScaledVector(l,Yc.y),A.addScaledVector(u,Yc.z),A)}static getInterpolatedAttribute(t,e,n,i,r,l){return nC.setScalar(0),iC.setScalar(0),sC.setScalar(0),nC.fromBufferAttribute(t,e),iC.fromBufferAttribute(t,n),sC.fromBufferAttribute(t,i),l.setScalar(0),l.addScaledVector(nC,r.x),l.addScaledVector(iC,r.y),l.addScaledVector(sC,r.z),l}static isFrontFacing(t,e,n,i){return el.subVectors(n,e),Vc.subVectors(t,e),el.cross(Vc).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}setFromAttributeAndIndices(t,e,n,i){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,i),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return el.subVectors(this.c,this.b),Vc.subVectors(this.a,this.b),el.cross(Vc).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return ds.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return ds.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,n,i,r){return ds.getInterpolation(t,this.a,this.b,this.c,e,n,i,r)}containsPoint(t){return ds.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return ds.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,i=this.b,r=this.c;let l,u;cd.subVectors(i,n),ud.subVectors(r,n),$_.subVectors(t,n);const A=cd.dot($_),d=ud.dot($_);if(A<=0&&d<=0)return e.copy(n);tC.subVectors(t,i);const m=cd.dot(tC),g=ud.dot(tC);if(m>=0&&g<=m)return e.copy(i);const y=A*g-m*d;if(y<=0&&A>=0&&m<=0)return l=A/(A-m),e.copy(n).addScaledVector(cd,l);eC.subVectors(t,r);const v=cd.dot(eC),C=ud.dot(eC);if(C>=0&&v<=C)return e.copy(r);const I=v*d-A*C;if(I<=0&&d>=0&&C<=0)return u=d/(d-C),e.copy(n).addScaledVector(ud,u);const S=m*C-v*g;if(S<=0&&g-m>=0&&v-C>=0)return D1.subVectors(r,i),u=(g-m)/(g-m+(v-C)),e.copy(i).addScaledVector(D1,u);const E=1/(S+I+y);return l=I*E,u=y*E,e.copy(n).addScaledVector(cd,l).addScaledVector(ud,u)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const ow={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},ju={h:0,s:0,l:0},ky={h:0,s:0,l:0};function aC(s,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?s+(t-s)*6*e:e<1/2?t:e<2/3?s+(t-s)*6*(2/3-e):s}class le{constructor(t,e,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,n)}set(t,e,n){if(e===void 0&&n===void 0){const i=t;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(t,e,n);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=ks){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,Gn.colorSpaceToWorking(this,e),this}setRGB(t,e,n,i=Gn.workingColorSpace){return this.r=t,this.g=e,this.b=n,Gn.colorSpaceToWorking(this,i),this}setHSL(t,e,n,i=Gn.workingColorSpace){if(t=ES(t,1),e=Je(e,0,1),n=Je(n,0,1),e===0)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+e):n+e-n*e,l=2*n-r;this.r=aC(l,r,t+1/3),this.g=aC(l,r,t),this.b=aC(l,r,t-1/3)}return Gn.colorSpaceToWorking(this,i),this}setStyle(t,e=ks){function n(r){r!==void 0&&parseFloat(r)<1&&ge("Color: Alpha component of "+t+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(t)){let r;const l=i[1],u=i[2];switch(l){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u))return n(r[4]),this.setRGB(Math.min(255,parseInt(r[1],10))/255,Math.min(255,parseInt(r[2],10))/255,Math.min(255,parseInt(r[3],10))/255,e);if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u))return n(r[4]),this.setRGB(Math.min(100,parseInt(r[1],10))/100,Math.min(100,parseInt(r[2],10))/100,Math.min(100,parseInt(r[3],10))/100,e);break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u))return n(r[4]),this.setHSL(parseFloat(r[1])/360,parseFloat(r[2])/100,parseFloat(r[3])/100,e);break;default:ge("Color: Unknown color model "+t)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(t)){const r=i[1],l=r.length;if(l===3)return this.setRGB(parseInt(r.charAt(0),16)/15,parseInt(r.charAt(1),16)/15,parseInt(r.charAt(2),16)/15,e);if(l===6)return this.setHex(parseInt(r,16),e);ge("Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=ks){const n=ow[t.toLowerCase()];return n!==void 0?this.setHex(n,e):ge("Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=$c(t.r),this.g=$c(t.g),this.b=$c(t.b),this}copyLinearToSRGB(t){return this.r=qd(t.r),this.g=qd(t.g),this.b=qd(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=ks){return Gn.workingToColorSpace(ma.copy(this),t),Math.round(Je(ma.r*255,0,255))*65536+Math.round(Je(ma.g*255,0,255))*256+Math.round(Je(ma.b*255,0,255))}getHexString(t=ks){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=Gn.workingColorSpace){Gn.workingToColorSpace(ma.copy(this),e);const n=ma.r,i=ma.g,r=ma.b,l=Math.max(n,i,r),u=Math.min(n,i,r);let A,d;const m=(u+l)/2;if(u===l)A=0,d=0;else{const g=l-u;switch(d=m<=.5?g/(l+u):g/(2-l-u),l){case n:A=(i-r)/g+(i<r?6:0);break;case i:A=(r-n)/g+2;break;case r:A=(n-i)/g+4;break}A/=6}return t.h=A,t.s=d,t.l=m,t}getRGB(t,e=Gn.workingColorSpace){return Gn.workingToColorSpace(ma.copy(this),e),t.r=ma.r,t.g=ma.g,t.b=ma.b,t}getStyle(t=ks){Gn.workingToColorSpace(ma.copy(this),t);const e=ma.r,n=ma.g,i=ma.b;return t!==ks?`color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(e*255)},${Math.round(n*255)},${Math.round(i*255)})`}offsetHSL(t,e,n){return this.getHSL(ju),this.setHSL(ju.h+t,ju.s+e,ju.l+n)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(ju),t.getHSL(ky);const n=_m(ju.h,ky.h,e),i=_m(ju.s,ky.s,e),r=_m(ju.l,ky.l,e);return this.setHSL(n,i,r),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,n=this.g,i=this.b,r=t.elements;return this.r=r[0]*e+r[3]*n+r[6]*i,this.g=r[1]*e+r[4]*n+r[7]*i,this.b=r[2]*e+r[5]*n+r[8]*i,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const ma=new le;le.NAMES=ow;let qD=0;class ba extends rc{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:qD++}),this.uuid=Yr(),this.name="",this.type="Material",this.blending=Gf,this.side=fl,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=uv,this.blendDst=hv,this.blendEquation=rh,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new le(0,0,0),this.blendAlpha=0,this.depthFunc=Yf,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=wb,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Mf,this.stencilZFail=Mf,this.stencilZPass=Mf,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.allowOverride=!0,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const n=t[e];if(n===void 0){ge(`Material: parameter '${e}' has value of undefined.`);continue}const i=this[e];if(i===void 0){ge(`Material: '${e}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[e]=n}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const n={metadata:{version:4.7,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.sheenColorMap&&this.sheenColorMap.isTexture&&(n.sheenColorMap=this.sheenColorMap.toJSON(t).uuid),this.sheenRoughnessMap&&this.sheenRoughnessMap.isTexture&&(n.sheenRoughnessMap=this.sheenRoughnessMap.toJSON(t).uuid),this.dispersion!==void 0&&(n.dispersion=this.dispersion),this.iridescence!==void 0&&(n.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(n.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),this.anisotropy!==void 0&&(n.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(n.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(n.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapRotation!==void 0&&(n.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==Gf&&(n.blending=this.blending),this.side!==fl&&(n.side=this.side),this.vertexColors===!0&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=!0),this.blendSrc!==uv&&(n.blendSrc=this.blendSrc),this.blendDst!==hv&&(n.blendDst=this.blendDst),this.blendEquation!==rh&&(n.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(n.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(n.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(n.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(n.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(n.blendAlpha=this.blendAlpha),this.depthFunc!==Yf&&(n.depthFunc=this.depthFunc),this.depthTest===!1&&(n.depthTest=this.depthTest),this.depthWrite===!1&&(n.depthWrite=this.depthWrite),this.colorWrite===!1&&(n.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(n.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==wb&&(n.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(n.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(n.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Mf&&(n.stencilFail=this.stencilFail),this.stencilZFail!==Mf&&(n.stencilZFail=this.stencilZFail),this.stencilZPass!==Mf&&(n.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(n.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaHash===!0&&(n.alphaHash=!0),this.alphaToCoverage===!0&&(n.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=!0),this.forceSinglePass===!0&&(n.forceSinglePass=!0),this.wireframe===!0&&(n.wireframe=!0),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=!0),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),this.fog===!1&&(n.fog=!1),Object.keys(this.userData).length>0&&(n.userData=this.userData);function i(r){const l=[];for(const u in r){const A=r[u];delete A.metadata,l.push(A)}return l}if(e){const r=i(t.textures),l=i(t.images);r.length>0&&(n.textures=r),l.length>0&&(n.images=l)}return n}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(e!==null){const i=e.length;n=new Array(i);for(let r=0;r!==i;++r)n[r]=e[r].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}}class pl extends ba{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new le(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new _r,this.combine=n0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const jc=XD();function XD(){const s=new ArrayBuffer(4),t=new Float32Array(s),e=new Uint32Array(s),n=new Uint32Array(512),i=new Uint32Array(512);for(let A=0;A<256;++A){const d=A-127;d<-27?(n[A]=0,n[A|256]=32768,i[A]=24,i[A|256]=24):d<-14?(n[A]=1024>>-d-14,n[A|256]=1024>>-d-14|32768,i[A]=-d-1,i[A|256]=-d-1):d<=15?(n[A]=d+15<<10,n[A|256]=d+15<<10|32768,i[A]=13,i[A|256]=13):d<128?(n[A]=31744,n[A|256]=64512,i[A]=24,i[A|256]=24):(n[A]=31744,n[A|256]=64512,i[A]=13,i[A|256]=13)}const r=new Uint32Array(2048),l=new Uint32Array(64),u=new Uint32Array(64);for(let A=1;A<1024;++A){let d=A<<13,m=0;for(;(d&8388608)===0;)d<<=1,m-=8388608;d&=-8388609,m+=947912704,r[A]=d|m}for(let A=1024;A<2048;++A)r[A]=939524096+(A-1024<<13);for(let A=1;A<31;++A)l[A]=A<<23;l[31]=1199570944,l[32]=2147483648;for(let A=33;A<63;++A)l[A]=2147483648+(A-32<<23);l[63]=3347054592;for(let A=1;A<64;++A)A!==32&&(u[A]=1024);return{floatView:t,uint32View:e,baseTable:n,shiftTable:i,mantissaTable:r,exponentTable:l,offsetTable:u}}function dr(s){Math.abs(s)>65504&&ge("DataUtils.toHalfFloat(): Value out of range."),s=Je(s,-65504,65504),jc.floatView[0]=s;const t=jc.uint32View[0],e=t>>23&511;return jc.baseTable[e]+((t&8388607)>>jc.shiftTable[e])}function lm(s){const t=s>>10;return jc.uint32View[0]=jc.mantissaTable[jc.offsetTable[t]+(s&1023)]+jc.exponentTable[t],jc.floatView[0]}class JD{static toHalfFloat(t){return dr(t)}static fromHalfFloat(t){return lm(t)}}const fs=new F,Hy=new Dt;let ZD=0;class Qn{constructor(t,e,n=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:ZD++}),this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=n,this.usage=Pm,this.updateRanges=[],this.gpuType=xr,this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[t+i]=e.array[n+i];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,n=this.count;e<n;e++)Hy.fromBufferAttribute(this,e),Hy.applyMatrix3(t),this.setXY(e,Hy.x,Hy.y);else if(this.itemSize===3)for(let e=0,n=this.count;e<n;e++)fs.fromBufferAttribute(this,e),fs.applyMatrix3(t),this.setXYZ(e,fs.x,fs.y,fs.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)fs.fromBufferAttribute(this,e),fs.applyMatrix4(t),this.setXYZ(e,fs.x,fs.y,fs.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)fs.fromBufferAttribute(this,e),fs.applyNormalMatrix(t),this.setXYZ(e,fs.x,fs.y,fs.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)fs.fromBufferAttribute(this,e),fs.transformDirection(t),this.setXYZ(e,fs.x,fs.y,fs.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let n=this.array[t*this.itemSize+e];return this.normalized&&(n=Ka(n,this.array)),n}setComponent(t,e,n){return this.normalized&&(n=dn(n,this.array)),this.array[t*this.itemSize+e]=n,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=Ka(e,this.array)),e}setX(t,e){return this.normalized&&(e=dn(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=Ka(e,this.array)),e}setY(t,e){return this.normalized&&(e=dn(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=Ka(e,this.array)),e}setZ(t,e){return this.normalized&&(e=dn(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=Ka(e,this.array)),e}setW(t,e){return this.normalized&&(e=dn(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.normalized&&(e=dn(e,this.array),n=dn(n,this.array)),this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,i){return t*=this.itemSize,this.normalized&&(e=dn(e,this.array),n=dn(n,this.array),i=dn(i,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this}setXYZW(t,e,n,i,r){return t*=this.itemSize,this.normalized&&(e=dn(e,this.array),n=dn(n,this.array),i=dn(i,this.array),r=dn(r,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==Pm&&(t.usage=this.usage),t}}class WD extends Qn{constructor(t,e,n){super(new Int8Array(t),e,n)}}class jD extends Qn{constructor(t,e,n){super(new Uint8Array(t),e,n)}}class KD extends Qn{constructor(t,e,n){super(new Uint8ClampedArray(t),e,n)}}class $D extends Qn{constructor(t,e,n){super(new Int16Array(t),e,n)}}class SS extends Qn{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class tR extends Qn{constructor(t,e,n){super(new Int32Array(t),e,n)}}class IS extends Qn{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class eR extends Qn{constructor(t,e,n){super(new Uint16Array(t),e,n),this.isFloat16BufferAttribute=!0}getX(t){let e=lm(this.array[t*this.itemSize]);return this.normalized&&(e=Ka(e,this.array)),e}setX(t,e){return this.normalized&&(e=dn(e,this.array)),this.array[t*this.itemSize]=dr(e),this}getY(t){let e=lm(this.array[t*this.itemSize+1]);return this.normalized&&(e=Ka(e,this.array)),e}setY(t,e){return this.normalized&&(e=dn(e,this.array)),this.array[t*this.itemSize+1]=dr(e),this}getZ(t){let e=lm(this.array[t*this.itemSize+2]);return this.normalized&&(e=Ka(e,this.array)),e}setZ(t,e){return this.normalized&&(e=dn(e,this.array)),this.array[t*this.itemSize+2]=dr(e),this}getW(t){let e=lm(this.array[t*this.itemSize+3]);return this.normalized&&(e=Ka(e,this.array)),e}setW(t,e){return this.normalized&&(e=dn(e,this.array)),this.array[t*this.itemSize+3]=dr(e),this}setXY(t,e,n){return t*=this.itemSize,this.normalized&&(e=dn(e,this.array),n=dn(n,this.array)),this.array[t+0]=dr(e),this.array[t+1]=dr(n),this}setXYZ(t,e,n,i){return t*=this.itemSize,this.normalized&&(e=dn(e,this.array),n=dn(n,this.array),i=dn(i,this.array)),this.array[t+0]=dr(e),this.array[t+1]=dr(n),this.array[t+2]=dr(i),this}setXYZW(t,e,n,i,r){return t*=this.itemSize,this.normalized&&(e=dn(e,this.array),n=dn(n,this.array),i=dn(i,this.array),r=dn(r,this.array)),this.array[t+0]=dr(e),this.array[t+1]=dr(n),this.array[t+2]=dr(i),this.array[t+3]=dr(r),this}}class Ce extends Qn{constructor(t,e,n){super(new Float32Array(t),e,n)}}let nR=0;const mo=new he,rC=new gn,hd=new F,Pr=new kn,Fg=new kn,Gs=new F;class Fe extends rc{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:nR++}),this.uuid=Yr(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(sw(t)?IS:SS)(t,1):this.index=t,this}setIndirect(t){return this.indirect=t,this}getIndirect(){return this.indirect}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const r=new Ze().getNormalMatrix(t);n.applyNormalMatrix(r),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(t),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return mo.makeRotationFromQuaternion(t),this.applyMatrix4(mo),this}rotateX(t){return mo.makeRotationX(t),this.applyMatrix4(mo),this}rotateY(t){return mo.makeRotationY(t),this.applyMatrix4(mo),this}rotateZ(t){return mo.makeRotationZ(t),this.applyMatrix4(mo),this}translate(t,e,n){return mo.makeTranslation(t,e,n),this.applyMatrix4(mo),this}scale(t,e,n){return mo.makeScale(t,e,n),this.applyMatrix4(mo),this}lookAt(t){return rC.lookAt(t),rC.updateMatrix(),this.applyMatrix4(rC.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(hd).negate(),this.translate(hd.x,hd.y,hd.z),this}setFromPoints(t){const e=this.getAttribute("position");if(e===void 0){const n=[];for(let i=0,r=t.length;i<r;i++){const l=t[i];n.push(l.x,l.y,l.z||0)}this.setAttribute("position",new Ce(n,3))}else{const n=Math.min(t.length,e.count);for(let i=0;i<n;i++){const r=t[i];e.setXYZ(i,r.x,r.y,r.z||0)}t.length>e.count&&ge("BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),e.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new kn);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){nn("BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new F(-1/0,-1/0,-1/0),new F(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let n=0,i=e.length;n<i;n++){const r=e[n];Pr.setFromBufferAttribute(r),this.morphTargetsRelative?(Gs.addVectors(this.boundingBox.min,Pr.min),this.boundingBox.expandByPoint(Gs),Gs.addVectors(this.boundingBox.max,Pr.max),this.boundingBox.expandByPoint(Gs)):(this.boundingBox.expandByPoint(Pr.min),this.boundingBox.expandByPoint(Pr.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&nn('BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Bs);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){nn("BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new F,1/0);return}if(t){const n=this.boundingSphere.center;if(Pr.setFromBufferAttribute(t),e)for(let r=0,l=e.length;r<l;r++){const u=e[r];Fg.setFromBufferAttribute(u),this.morphTargetsRelative?(Gs.addVectors(Pr.min,Fg.min),Pr.expandByPoint(Gs),Gs.addVectors(Pr.max,Fg.max),Pr.expandByPoint(Gs)):(Pr.expandByPoint(Fg.min),Pr.expandByPoint(Fg.max))}Pr.getCenter(n);let i=0;for(let r=0,l=t.count;r<l;r++)Gs.fromBufferAttribute(t,r),i=Math.max(i,n.distanceToSquared(Gs));if(e)for(let r=0,l=e.length;r<l;r++){const u=e[r],A=this.morphTargetsRelative;for(let d=0,m=u.count;d<m;d++)Gs.fromBufferAttribute(u,d),A&&(hd.fromBufferAttribute(t,d),Gs.add(hd)),i=Math.max(i,n.distanceToSquared(Gs))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&nn('BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){nn("BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=e.position,i=e.normal,r=e.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Qn(new Float32Array(4*n.count),4));const l=this.getAttribute("tangent"),u=[],A=[];for(let P=0;P<n.count;P++)u[P]=new F,A[P]=new F;const d=new F,m=new F,g=new F,y=new Dt,v=new Dt,C=new Dt,I=new F,S=new F;function E(P,z,L){d.fromBufferAttribute(n,P),m.fromBufferAttribute(n,z),g.fromBufferAttribute(n,L),y.fromBufferAttribute(r,P),v.fromBufferAttribute(r,z),C.fromBufferAttribute(r,L),m.sub(d),g.sub(d),v.sub(y),C.sub(y);const k=1/(v.x*C.y-C.x*v.y);isFinite(k)&&(I.copy(m).multiplyScalar(C.y).addScaledVector(g,-v.y).multiplyScalar(k),S.copy(g).multiplyScalar(v.x).addScaledVector(m,-C.x).multiplyScalar(k),u[P].add(I),u[z].add(I),u[L].add(I),A[P].add(S),A[z].add(S),A[L].add(S))}let B=this.groups;B.length===0&&(B=[{start:0,count:t.count}]);for(let P=0,z=B.length;P<z;++P){const L=B[P],k=L.start,Y=L.count;for(let W=k,K=k+Y;W<K;W+=3)E(t.getX(W+0),t.getX(W+1),t.getX(W+2))}const w=new F,Q=new F,R=new F,D=new F;function U(P){R.fromBufferAttribute(i,P),D.copy(R);const z=u[P];w.copy(z),w.sub(R.multiplyScalar(R.dot(z))).normalize(),Q.crossVectors(D,z);const k=Q.dot(A[P])<0?-1:1;l.setXYZW(P,w.x,w.y,w.z,k)}for(let P=0,z=B.length;P<z;++P){const L=B[P],k=L.start,Y=L.count;for(let W=k,K=k+Y;W<K;W+=3)U(t.getX(W+0)),U(t.getX(W+1)),U(t.getX(W+2))}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new Qn(new Float32Array(e.count*3),3),this.setAttribute("normal",n);else for(let y=0,v=n.count;y<v;y++)n.setXYZ(y,0,0,0);const i=new F,r=new F,l=new F,u=new F,A=new F,d=new F,m=new F,g=new F;if(t)for(let y=0,v=t.count;y<v;y+=3){const C=t.getX(y+0),I=t.getX(y+1),S=t.getX(y+2);i.fromBufferAttribute(e,C),r.fromBufferAttribute(e,I),l.fromBufferAttribute(e,S),m.subVectors(l,r),g.subVectors(i,r),m.cross(g),u.fromBufferAttribute(n,C),A.fromBufferAttribute(n,I),d.fromBufferAttribute(n,S),u.add(m),A.add(m),d.add(m),n.setXYZ(C,u.x,u.y,u.z),n.setXYZ(I,A.x,A.y,A.z),n.setXYZ(S,d.x,d.y,d.z)}else for(let y=0,v=e.count;y<v;y+=3)i.fromBufferAttribute(e,y+0),r.fromBufferAttribute(e,y+1),l.fromBufferAttribute(e,y+2),m.subVectors(l,r),g.subVectors(i,r),m.cross(g),n.setXYZ(y+0,m.x,m.y,m.z),n.setXYZ(y+1,m.x,m.y,m.z),n.setXYZ(y+2,m.x,m.y,m.z);this.normalizeNormals(),n.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)Gs.fromBufferAttribute(t,e),Gs.normalize(),t.setXYZ(e,Gs.x,Gs.y,Gs.z)}toNonIndexed(){function t(u,A){const d=u.array,m=u.itemSize,g=u.normalized,y=new d.constructor(A.length*m);let v=0,C=0;for(let I=0,S=A.length;I<S;I++){u.isInterleavedBufferAttribute?v=A[I]*u.data.stride+u.offset:v=A[I]*m;for(let E=0;E<m;E++)y[C++]=d[v++]}return new Qn(y,m,g)}if(this.index===null)return ge("BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Fe,n=this.index.array,i=this.attributes;for(const u in i){const A=i[u],d=t(A,n);e.setAttribute(u,d)}const r=this.morphAttributes;for(const u in r){const A=[],d=r[u];for(let m=0,g=d.length;m<g;m++){const y=d[m],v=t(y,n);A.push(v)}e.morphAttributes[u]=A}e.morphTargetsRelative=this.morphTargetsRelative;const l=this.groups;for(let u=0,A=l.length;u<A;u++){const d=l[u];e.addGroup(d.start,d.count,d.materialIndex)}return e}toJSON(){const t={metadata:{version:4.7,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const A=this.parameters;for(const d in A)A[d]!==void 0&&(t[d]=A[d]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const A in n){const d=n[A];t.data.attributes[A]=d.toJSON(t.data)}const i={};let r=!1;for(const A in this.morphAttributes){const d=this.morphAttributes[A],m=[];for(let g=0,y=d.length;g<y;g++){const v=d[g];m.push(v.toJSON(t.data))}m.length>0&&(i[A]=m,r=!0)}r&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const l=this.groups;l.length>0&&(t.data.groups=JSON.parse(JSON.stringify(l)));const u=this.boundingSphere;return u!==null&&(t.data.boundingSphere=u.toJSON()),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;n!==null&&this.setIndex(n.clone());const i=t.attributes;for(const d in i){const m=i[d];this.setAttribute(d,m.clone(e))}const r=t.morphAttributes;for(const d in r){const m=[],g=r[d];for(let y=0,v=g.length;y<v;y++)m.push(g[y].clone(e));this.morphAttributes[d]=m}this.morphTargetsRelative=t.morphTargetsRelative;const l=t.groups;for(let d=0,m=l.length;d<m;d++){const g=l[d];this.addGroup(g.start,g.count,g.materialIndex)}const u=t.boundingBox;u!==null&&(this.boundingBox=u.clone());const A=t.boundingSphere;return A!==null&&(this.boundingSphere=A.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const R1=new he,lf=new tA,Vy=new Bs,N1=new F,Yy=new F,qy=new F,Xy=new F,oC=new F,Jy=new F,U1=new F,Zy=new F;class oe extends gn{constructor(t=new Fe,e=new pl){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,l=i.length;r<l;r++){const u=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[u]=r}}}}getVertexPosition(t,e){const n=this.geometry,i=n.attributes.position,r=n.morphAttributes.position,l=n.morphTargetsRelative;e.fromBufferAttribute(i,t);const u=this.morphTargetInfluences;if(r&&u){Jy.set(0,0,0);for(let A=0,d=r.length;A<d;A++){const m=u[A],g=r[A];m!==0&&(oC.fromBufferAttribute(g,t),l?Jy.addScaledVector(oC,m):Jy.addScaledVector(oC.sub(e),m))}e.add(Jy)}return e}raycast(t,e){const n=this.geometry,i=this.material,r=this.matrixWorld;i!==void 0&&(n.boundingSphere===null&&n.computeBoundingSphere(),Vy.copy(n.boundingSphere),Vy.applyMatrix4(r),lf.copy(t.ray).recast(t.near),!(Vy.containsPoint(lf.origin)===!1&&(lf.intersectSphere(Vy,N1)===null||lf.origin.distanceToSquared(N1)>(t.far-t.near)**2))&&(R1.copy(r).invert(),lf.copy(t.ray).applyMatrix4(R1),!(n.boundingBox!==null&&lf.intersectsBox(n.boundingBox)===!1)&&this._computeIntersections(t,e,lf)))}_computeIntersections(t,e,n){let i;const r=this.geometry,l=this.material,u=r.index,A=r.attributes.position,d=r.attributes.uv,m=r.attributes.uv1,g=r.attributes.normal,y=r.groups,v=r.drawRange;if(u!==null)if(Array.isArray(l))for(let C=0,I=y.length;C<I;C++){const S=y[C],E=l[S.materialIndex],B=Math.max(S.start,v.start),w=Math.min(u.count,Math.min(S.start+S.count,v.start+v.count));for(let Q=B,R=w;Q<R;Q+=3){const D=u.getX(Q),U=u.getX(Q+1),P=u.getX(Q+2);i=Wy(this,E,t,n,d,m,g,D,U,P),i&&(i.faceIndex=Math.floor(Q/3),i.face.materialIndex=S.materialIndex,e.push(i))}}else{const C=Math.max(0,v.start),I=Math.min(u.count,v.start+v.count);for(let S=C,E=I;S<E;S+=3){const B=u.getX(S),w=u.getX(S+1),Q=u.getX(S+2);i=Wy(this,l,t,n,d,m,g,B,w,Q),i&&(i.faceIndex=Math.floor(S/3),e.push(i))}}else if(A!==void 0)if(Array.isArray(l))for(let C=0,I=y.length;C<I;C++){const S=y[C],E=l[S.materialIndex],B=Math.max(S.start,v.start),w=Math.min(A.count,Math.min(S.start+S.count,v.start+v.count));for(let Q=B,R=w;Q<R;Q+=3){const D=Q,U=Q+1,P=Q+2;i=Wy(this,E,t,n,d,m,g,D,U,P),i&&(i.faceIndex=Math.floor(Q/3),i.face.materialIndex=S.materialIndex,e.push(i))}}else{const C=Math.max(0,v.start),I=Math.min(A.count,v.start+v.count);for(let S=C,E=I;S<E;S+=3){const B=S,w=S+1,Q=S+2;i=Wy(this,l,t,n,d,m,g,B,w,Q),i&&(i.faceIndex=Math.floor(S/3),e.push(i))}}}}function iR(s,t,e,n,i,r,l,u){let A;if(t.side===_a?A=n.intersectTriangle(l,r,i,!0,u):A=n.intersectTriangle(i,r,l,t.side===fl,u),A===null)return null;Zy.copy(u),Zy.applyMatrix4(s.matrixWorld);const d=e.ray.origin.distanceTo(Zy);return d<e.near||d>e.far?null:{distance:d,point:Zy.clone(),object:s}}function Wy(s,t,e,n,i,r,l,u,A,d){s.getVertexPosition(u,Yy),s.getVertexPosition(A,qy),s.getVertexPosition(d,Xy);const m=iR(s,t,e,n,Yy,qy,Xy,U1);if(m){const g=new F;ds.getBarycoord(U1,Yy,qy,Xy,g),i&&(m.uv=ds.getInterpolatedAttribute(i,u,A,d,g,new Dt)),r&&(m.uv1=ds.getInterpolatedAttribute(r,u,A,d,g,new Dt)),l&&(m.normal=ds.getInterpolatedAttribute(l,u,A,d,g,new F),m.normal.dot(n.direction)>0&&m.normal.multiplyScalar(-1));const y={a:u,b:A,c:d,normal:new F,materialIndex:0};ds.getNormal(Yy,qy,Xy,y.normal),m.face=y,m.barycoord=g}return m}class pr extends Fe{constructor(t=1,e=1,n=1,i=1,r=1,l=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:r,depthSegments:l};const u=this;i=Math.floor(i),r=Math.floor(r),l=Math.floor(l);const A=[],d=[],m=[],g=[];let y=0,v=0;C("z","y","x",-1,-1,n,e,t,l,r,0),C("z","y","x",1,-1,n,e,-t,l,r,1),C("x","z","y",1,1,t,n,e,i,l,2),C("x","z","y",1,-1,t,n,-e,i,l,3),C("x","y","z",1,-1,t,e,n,i,r,4),C("x","y","z",-1,-1,t,e,-n,i,r,5),this.setIndex(A),this.setAttribute("position",new Ce(d,3)),this.setAttribute("normal",new Ce(m,3)),this.setAttribute("uv",new Ce(g,2));function C(I,S,E,B,w,Q,R,D,U,P,z){const L=Q/U,k=R/P,Y=Q/2,W=R/2,K=D/2,nt=U+1,H=P+1;let tt=0,it=0;const ot=new F;for(let At=0;At<H;At++){const V=At*k-W;for(let st=0;st<nt;st++){const xt=st*L-Y;ot[I]=xt*B,ot[S]=V*w,ot[E]=K,d.push(ot.x,ot.y,ot.z),ot[I]=0,ot[S]=0,ot[E]=D>0?1:-1,m.push(ot.x,ot.y,ot.z),g.push(st/U),g.push(1-At/P),tt+=1}}for(let At=0;At<P;At++)for(let V=0;V<U;V++){const st=y+V+nt*At,xt=y+V+nt*(At+1),j=y+(V+1)+nt*(At+1),Rt=y+(V+1)+nt*At;A.push(st,xt,Rt),A.push(xt,j,Rt),it+=6}u.addGroup(v,it,z),v+=it,y+=tt}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new pr(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function np(s){const t={};for(const e in s){t[e]={};for(const n in s[e]){const i=s[e][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(ge("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),t[e][n]=null):t[e][n]=i.clone():Array.isArray(i)?t[e][n]=i.slice():t[e][n]=i}}return t}function Za(s){const t={};for(let e=0;e<s.length;e++){const n=np(s[e]);for(const i in n)t[i]=n[i]}return t}function sR(s){const t=[];for(let e=0;e<s.length;e++)t.push(s[e].clone());return t}function lw(s){const t=s.getRenderTarget();return t===null?s.outputColorSpace:t.isXRRenderTarget===!0?t.texture.colorSpace:Gn.workingColorSpace}const BS={clone:np,merge:Za};var aR=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,rR=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class $a extends ba{constructor(t){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=aR,this.fragmentShader=rR,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=np(t.uniforms),this.uniformsGroups=sR(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const i in this.uniforms){const l=this.uniforms[i].value;l&&l.isTexture?e.uniforms[i]={type:"t",value:l.toJSON(t).uuid}:l&&l.isColor?e.uniforms[i]={type:"c",value:l.getHex()}:l&&l.isVector2?e.uniforms[i]={type:"v2",value:l.toArray()}:l&&l.isVector3?e.uniforms[i]={type:"v3",value:l.toArray()}:l&&l.isVector4?e.uniforms[i]={type:"v4",value:l.toArray()}:l&&l.isMatrix3?e.uniforms[i]={type:"m3",value:l.toArray()}:l&&l.isMatrix4?e.uniforms[i]={type:"m4",value:l.toArray()}:e.uniforms[i]={value:l}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.lights=this.lights,e.clipping=this.clipping;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}class pE extends gn{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new he,this.projectionMatrix=new he,this.projectionMatrixInverse=new he,this.coordinateSystem=Hr,this._reversedDepth=!1}get reversedDepth(){return this._reversedDepth}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){return super.getWorldDirection(t).negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const Ku=new F,L1=new Dt,z1=new Dt;class As extends pE{constructor(t=50,e=1,n=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=tp*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(kf*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return tp*2*Math.atan(Math.tan(kf*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(t,e,n){Ku.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),e.set(Ku.x,Ku.y).multiplyScalar(-t/Ku.z),Ku.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),n.set(Ku.x,Ku.y).multiplyScalar(-t/Ku.z)}getViewSize(t,e){return this.getViewBounds(t,L1,z1),e.subVectors(z1,L1)}setViewOffset(t,e,n,i,r,l){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=l,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(kf*.5*this.fov)/this.zoom,n=2*e,i=this.aspect*n,r=-.5*i;const l=this.view;if(this.view!==null&&this.view.enabled){const A=l.fullWidth,d=l.fullHeight;r+=l.offsetX*i/A,e-=l.offsetY*n/d,i*=l.width/A,n*=l.height/d}const u=this.filmOffset;u!==0&&(r+=t*u/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,e,e-n,t,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const fd=-90,Ad=1;class MS extends gn{constructor(t,e,n){super(),this.type="CubeCamera",this.renderTarget=n,this.coordinateSystem=null,this.activeMipmapLevel=0;const i=new As(fd,Ad,t,e);i.layers=this.layers,this.add(i);const r=new As(fd,Ad,t,e);r.layers=this.layers,this.add(r);const l=new As(fd,Ad,t,e);l.layers=this.layers,this.add(l);const u=new As(fd,Ad,t,e);u.layers=this.layers,this.add(u);const A=new As(fd,Ad,t,e);A.layers=this.layers,this.add(A);const d=new As(fd,Ad,t,e);d.layers=this.layers,this.add(d)}updateCoordinateSystem(){const t=this.coordinateSystem,e=this.children.concat(),[n,i,r,l,u,A]=e;for(const d of e)this.remove(d);if(t===Hr)n.up.set(0,1,0),n.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),r.up.set(0,0,-1),r.lookAt(0,1,0),l.up.set(0,0,1),l.lookAt(0,-1,0),u.up.set(0,1,0),u.lookAt(0,0,1),A.up.set(0,1,0),A.lookAt(0,0,-1);else if(t===Kd)n.up.set(0,-1,0),n.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),r.up.set(0,0,1),r.lookAt(0,1,0),l.up.set(0,0,-1),l.lookAt(0,-1,0),u.up.set(0,-1,0),u.lookAt(0,0,1),A.up.set(0,-1,0),A.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+t);for(const d of e)this.add(d),d.updateMatrixWorld()}update(t,e){this.parent===null&&this.updateMatrixWorld();const{renderTarget:n,activeMipmapLevel:i}=this;this.coordinateSystem!==t.coordinateSystem&&(this.coordinateSystem=t.coordinateSystem,this.updateCoordinateSystem());const[r,l,u,A,d,m]=this.children,g=t.getRenderTarget(),y=t.getActiveCubeFace(),v=t.getActiveMipmapLevel(),C=t.xr.enabled;t.xr.enabled=!1;const I=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0,i),t.render(e,r),t.setRenderTarget(n,1,i),t.render(e,l),t.setRenderTarget(n,2,i),t.render(e,u),t.setRenderTarget(n,3,i),t.render(e,A),t.setRenderTarget(n,4,i),t.render(e,d),n.texture.generateMipmaps=I,t.setRenderTarget(n,5,i),t.render(e,m),t.setRenderTarget(g,y,v),t.xr.enabled=C,n.texture.needsPMREMUpdate=!0}}class r0 extends wi{constructor(t=[],e=eu,n,i,r,l,u,A,d,m){super(t,e,n,i,r,l,u,A,d,m),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}class wS extends Io{constructor(t=1,e={}){super(t,t,e),this.isWebGLCubeRenderTarget=!0;const n={width:t,height:t,depth:1},i=[n,n,n,n,n,n];this.texture=new r0(i),this._setTextureOptions(e),this.texture.isRenderTargetTexture=!0}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.colorSpace=e.colorSpace,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new pr(5,5,5),r=new $a({name:"CubemapFromEquirect",uniforms:np(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:_a,blending:nc});r.uniforms.tEquirect.value=e;const l=new oe(i,r),u=e.minFilter;return e.minFilter===tc&&(e.minFilter=as),new MS(1,10,this).update(t,l),e.minFilter=u,l.geometry.dispose(),l.material.dispose(),this}clear(t,e=!0,n=!0,i=!0){const r=t.getRenderTarget();for(let l=0;l<6;l++)t.setRenderTarget(this,l),t.clear(e,n,i);t.setRenderTarget(r)}}class Nf extends gn{constructor(){super(),this.isGroup=!0,this.type="Group"}}const oR={type:"move"};class iv{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Nf,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Nf,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new F,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new F),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Nf,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new F,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new F),this._grip}dispatchEvent(t){return this._targetRay!==null&&this._targetRay.dispatchEvent(t),this._grip!==null&&this._grip.dispatchEvent(t),this._hand!==null&&this._hand.dispatchEvent(t),this}connect(t){if(t&&t.hand){const e=this._hand;if(e)for(const n of t.hand.values())this._getHandJoint(e,n)}return this.dispatchEvent({type:"connected",data:t}),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(t,e,n){let i=null,r=null,l=null;const u=this._targetRay,A=this._grip,d=this._hand;if(t&&e.session.visibilityState!=="visible-blurred"){if(d&&t.hand){l=!0;for(const I of t.hand.values()){const S=e.getJointPose(I,n),E=this._getHandJoint(d,I);S!==null&&(E.matrix.fromArray(S.transform.matrix),E.matrix.decompose(E.position,E.rotation,E.scale),E.matrixWorldNeedsUpdate=!0,E.jointRadius=S.radius),E.visible=S!==null}const m=d.joints["index-finger-tip"],g=d.joints["thumb-tip"],y=m.position.distanceTo(g.position),v=.02,C=.005;d.inputState.pinching&&y>v+C?(d.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!d.inputState.pinching&&y<=v-C&&(d.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else A!==null&&t.gripSpace&&(r=e.getPose(t.gripSpace,n),r!==null&&(A.matrix.fromArray(r.transform.matrix),A.matrix.decompose(A.position,A.rotation,A.scale),A.matrixWorldNeedsUpdate=!0,r.linearVelocity?(A.hasLinearVelocity=!0,A.linearVelocity.copy(r.linearVelocity)):A.hasLinearVelocity=!1,r.angularVelocity?(A.hasAngularVelocity=!0,A.angularVelocity.copy(r.angularVelocity)):A.hasAngularVelocity=!1));u!==null&&(i=e.getPose(t.targetRaySpace,n),i===null&&r!==null&&(i=r),i!==null&&(u.matrix.fromArray(i.transform.matrix),u.matrix.decompose(u.position,u.rotation,u.scale),u.matrixWorldNeedsUpdate=!0,i.linearVelocity?(u.hasLinearVelocity=!0,u.linearVelocity.copy(i.linearVelocity)):u.hasLinearVelocity=!1,i.angularVelocity?(u.hasAngularVelocity=!0,u.angularVelocity.copy(i.angularVelocity)):u.hasAngularVelocity=!1,this.dispatchEvent(oR)))}return u!==null&&(u.visible=i!==null),A!==null&&(A.visible=r!==null),d!==null&&(d.visible=l!==null),this}_getHandJoint(t,e){if(t.joints[e.jointName]===void 0){const n=new Nf;n.matrixAutoUpdate=!1,n.visible=!1,t.joints[e.jointName]=n,t.add(n)}return t.joints[e.jointName]}}class gE{constructor(t,e=25e-5){this.isFogExp2=!0,this.name="",this.color=new le(t),this.density=e}clone(){return new gE(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class mE{constructor(t,e=1,n=1e3){this.isFog=!0,this.name="",this.color=new le(t),this.near=e,this.far=n}clone(){return new mE(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}let TS=class extends gn{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new _r,this.environmentIntensity=1,this.environmentRotation=new _r,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),this.backgroundBlurriness=t.backgroundBlurriness,this.backgroundIntensity=t.backgroundIntensity,this.backgroundRotation.copy(t.backgroundRotation),this.environmentIntensity=t.environmentIntensity,this.environmentRotation.copy(t.environmentRotation),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(e.object.backgroundIntensity=this.backgroundIntensity),e.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(e.object.environmentIntensity=this.environmentIntensity),e.object.environmentRotation=this.environmentRotation.toArray(),e}};class yE{constructor(t,e){this.isInterleavedBuffer=!0,this.array=t,this.stride=e,this.count=t!==void 0?t.length/e:0,this.usage=Pm,this.updateRanges=[],this.version=0,this.uuid=Yr()}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,n){t*=this.stride,n*=e.stride;for(let i=0,r=this.stride;i<r;i++)this.array[t+i]=e.array[n+i];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Yr()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(e,this.stride);return n.setUsage(this.usage),n}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Yr()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Xa=new F;class qf{constructor(t,e,n,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,n=this.data.count;e<n;e++)Xa.fromBufferAttribute(this,e),Xa.applyMatrix4(t),this.setXYZ(e,Xa.x,Xa.y,Xa.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)Xa.fromBufferAttribute(this,e),Xa.applyNormalMatrix(t),this.setXYZ(e,Xa.x,Xa.y,Xa.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)Xa.fromBufferAttribute(this,e),Xa.transformDirection(t),this.setXYZ(e,Xa.x,Xa.y,Xa.z);return this}getComponent(t,e){let n=this.array[t*this.data.stride+this.offset+e];return this.normalized&&(n=Ka(n,this.array)),n}setComponent(t,e,n){return this.normalized&&(n=dn(n,this.array)),this.data.array[t*this.data.stride+this.offset+e]=n,this}setX(t,e){return this.normalized&&(e=dn(e,this.array)),this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.normalized&&(e=dn(e,this.array)),this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.normalized&&(e=dn(e,this.array)),this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.normalized&&(e=dn(e,this.array)),this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){let e=this.data.array[t*this.data.stride+this.offset];return this.normalized&&(e=Ka(e,this.array)),e}getY(t){let e=this.data.array[t*this.data.stride+this.offset+1];return this.normalized&&(e=Ka(e,this.array)),e}getZ(t){let e=this.data.array[t*this.data.stride+this.offset+2];return this.normalized&&(e=Ka(e,this.array)),e}getW(t){let e=this.data.array[t*this.data.stride+this.offset+3];return this.normalized&&(e=Ka(e,this.array)),e}setXY(t,e,n){return t=t*this.data.stride+this.offset,this.normalized&&(e=dn(e,this.array),n=dn(n,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=n,this}setXYZ(t,e,n,i){return t=t*this.data.stride+this.offset,this.normalized&&(e=dn(e,this.array),n=dn(n,this.array),i=dn(i,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this}setXYZW(t,e,n,i,r){return t=t*this.data.stride+this.offset,this.normalized&&(e=dn(e,this.array),n=dn(n,this.array),i=dn(i,this.array),r=dn(r,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this.data.array[t+3]=r,this}clone(t){if(t===void 0){Hm("InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[i+r])}return new Qn(new this.array.constructor(e),this.itemSize,this.normalized)}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new qf(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(t===void 0){Hm("InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[i+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class QS extends ba{constructor(t){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new le(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}let dd;const Pg=new F,pd=new F,gd=new F,md=new Dt,Gg=new Dt,cw=new he,jy=new F,kg=new F,Ky=new F,O1=new Dt,lC=new Dt,F1=new Dt;class uw extends gn{constructor(t=new QS){if(super(),this.isSprite=!0,this.type="Sprite",dd===void 0){dd=new Fe;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new yE(e,5);dd.setIndex([0,1,2,0,2,3]),dd.setAttribute("position",new qf(n,3,0,!1)),dd.setAttribute("uv",new qf(n,2,3,!1))}this.geometry=dd,this.material=t,this.center=new Dt(.5,.5),this.count=1}raycast(t,e){t.camera===null&&nn('Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),pd.setFromMatrixScale(this.matrixWorld),cw.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),gd.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&pd.multiplyScalar(-gd.z);const n=this.material.rotation;let i,r;n!==0&&(r=Math.cos(n),i=Math.sin(n));const l=this.center;$y(jy.set(-.5,-.5,0),gd,l,pd,i,r),$y(kg.set(.5,-.5,0),gd,l,pd,i,r),$y(Ky.set(.5,.5,0),gd,l,pd,i,r),O1.set(0,0),lC.set(1,0),F1.set(1,1);let u=t.ray.intersectTriangle(jy,kg,Ky,!1,Pg);if(u===null&&($y(kg.set(-.5,.5,0),gd,l,pd,i,r),lC.set(0,1),u=t.ray.intersectTriangle(jy,Ky,kg,!1,Pg),u===null))return;const A=t.ray.origin.distanceTo(Pg);A<t.near||A>t.far||e.push({distance:A,point:Pg.clone(),uv:ds.getInterpolation(Pg,jy,kg,Ky,O1,lC,F1,new Dt),face:null,object:this})}copy(t,e){return super.copy(t,e),t.center!==void 0&&this.center.copy(t.center),this.material=t.material,this}}function $y(s,t,e,n,i,r){md.subVectors(s,e).addScalar(.5).multiply(n),i!==void 0?(Gg.x=r*md.x-i*md.y,Gg.y=i*md.x+r*md.y):Gg.copy(md),s.copy(t),s.x+=Gg.x,s.y+=Gg.y,s.applyMatrix4(cw)}const tx=new F,P1=new F;class hw extends gn{constructor(){super(),this.isLOD=!0,this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}copy(t){super.copy(t,!1);const e=t.levels;for(let n=0,i=e.length;n<i;n++){const r=e[n];this.addLevel(r.object.clone(),r.distance,r.hysteresis)}return this.autoUpdate=t.autoUpdate,this}addLevel(t,e=0,n=0){e=Math.abs(e);const i=this.levels;let r;for(r=0;r<i.length&&!(e<i[r].distance);r++);return i.splice(r,0,{distance:e,hysteresis:n,object:t}),this.add(t),this}removeLevel(t){const e=this.levels;for(let n=0;n<e.length;n++)if(e[n].distance===t){const i=e.splice(n,1);return this.remove(i[0].object),!0}return!1}getCurrentLevel(){return this._currentLevel}getObjectForDistance(t){const e=this.levels;if(e.length>0){let n,i;for(n=1,i=e.length;n<i;n++){let r=e[n].distance;if(e[n].object.visible&&(r-=r*e[n].hysteresis),t<r)break}return e[n-1].object}return null}raycast(t,e){if(this.levels.length>0){tx.setFromMatrixPosition(this.matrixWorld);const i=t.ray.origin.distanceTo(tx);this.getObjectForDistance(i).raycast(t,e)}}update(t){const e=this.levels;if(e.length>1){tx.setFromMatrixPosition(t.matrixWorld),P1.setFromMatrixPosition(this.matrixWorld);const n=tx.distanceTo(P1)/t.zoom;e[0].object.visible=!0;let i,r;for(i=1,r=e.length;i<r;i++){let l=e[i].distance;if(e[i].object.visible&&(l-=l*e[i].hysteresis),n>=l)e[i-1].object.visible=!1,e[i].object.visible=!0;else break}for(this._currentLevel=i-1;i<r;i++)e[i].object.visible=!1}}toJSON(t){const e=super.toJSON(t);this.autoUpdate===!1&&(e.object.autoUpdate=!1),e.object.levels=[];const n=this.levels;for(let i=0,r=n.length;i<r;i++){const l=n[i];e.object.levels.push({object:l.object.uuid,distance:l.distance,hysteresis:l.hysteresis})}return e}}const G1=new F,k1=new We,H1=new We,lR=new F,V1=new he,ex=new F,cC=new Bs,Y1=new he,uC=new tA;class fw extends oe{constructor(t,e){super(t,e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=Mb,this.bindMatrix=new he,this.bindMatrixInverse=new he,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const t=this.geometry;this.boundingBox===null&&(this.boundingBox=new kn),this.boundingBox.makeEmpty();const e=t.getAttribute("position");for(let n=0;n<e.count;n++)this.getVertexPosition(n,ex),this.boundingBox.expandByPoint(ex)}computeBoundingSphere(){const t=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new Bs),this.boundingSphere.makeEmpty();const e=t.getAttribute("position");for(let n=0;n<e.count;n++)this.getVertexPosition(n,ex),this.boundingSphere.expandByPoint(ex)}copy(t,e){return super.copy(t,e),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,t.boundingBox!==null&&(this.boundingBox=t.boundingBox.clone()),t.boundingSphere!==null&&(this.boundingSphere=t.boundingSphere.clone()),this}raycast(t,e){const n=this.material,i=this.matrixWorld;n!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),cC.copy(this.boundingSphere),cC.applyMatrix4(i),t.ray.intersectsSphere(cC)!==!1&&(Y1.copy(i).invert(),uC.copy(t.ray).applyMatrix4(Y1),!(this.boundingBox!==null&&uC.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(t,e,uC)))}getVertexPosition(t,e){return super.getVertexPosition(t,e),this.applyBoneTransform(t,e),e}bind(t,e){this.skeleton=t,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new We,e=this.geometry.attributes.skinWeight;for(let n=0,i=e.count;n<i;n++){t.fromBufferAttribute(e,n);const r=1/t.manhattanLength();r!==1/0?t.multiplyScalar(r):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode===Mb?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===kM?this.bindMatrixInverse.copy(this.bindMatrix).invert():ge("SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(t,e){const n=this.skeleton,i=this.geometry;k1.fromBufferAttribute(i.attributes.skinIndex,t),H1.fromBufferAttribute(i.attributes.skinWeight,t),G1.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let r=0;r<4;r++){const l=H1.getComponent(r);if(l!==0){const u=k1.getComponent(r);V1.multiplyMatrices(n.bones[u].matrixWorld,n.boneInverses[u]),e.addScaledVector(lR.copy(G1).applyMatrix4(V1),l)}}return e.applyMatrix4(this.bindMatrixInverse)}}class DS extends gn{constructor(){super(),this.isBone=!0,this.type="Bone"}}class So extends wi{constructor(t=null,e=1,n=1,i,r,l,u,A,d=rs,m=rs,g,y){super(null,l,u,A,d,m,i,r,g,y),this.isDataTexture=!0,this.image={data:t,width:e,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const q1=new he,cR=new he;class xE{constructor(t=[],e=[]){this.uuid=Yr(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(t.length*16),e.length===0)this.calculateInverses();else if(t.length!==e.length){ge("Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let n=0,i=this.bones.length;n<i;n++)this.boneInverses.push(new he)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const n=new he;this.bones[t]&&n.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(n)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const n=this.bones[t];n&&n.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const n=this.bones[t];n&&(n.parent&&n.parent.isBone?(n.matrix.copy(n.parent.matrixWorld).invert(),n.matrix.multiply(n.matrixWorld)):n.matrix.copy(n.matrixWorld),n.matrix.decompose(n.position,n.quaternion,n.scale))}}update(){const t=this.bones,e=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let r=0,l=t.length;r<l;r++){const u=t[r]?t[r].matrixWorld:cR;q1.multiplyMatrices(u,e[r]),q1.toArray(n,r*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new xE(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(this.bones.length*4);t=Math.ceil(t/4)*4,t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const n=new So(e,t,t,Ki,xr);return n.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=n,this}getBoneByName(t){for(let e=0,n=this.bones.length;e<n;e++){const i=this.bones[e];if(i.name===t)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let n=0,i=t.bones.length;n<i;n++){const r=t.bones[n];let l=e[r];l===void 0&&(ge("Skeleton: No bone found with UUID:",r),l=new DS),this.bones.push(l),this.boneInverses.push(new he().fromArray(t.boneInverses[n]))}return this.init(),this}toJSON(){const t={metadata:{version:4.7,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,n=this.boneInverses;for(let i=0,r=e.length;i<r;i++){const l=e[i];t.bones.push(l.uuid);const u=n[i];t.boneInverses.push(u.toArray())}return t}}class Xf extends Qn{constructor(t,e,n,i=1){super(t,e,n),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}const yd=new he,X1=new he,nx=[],J1=new kn,uR=new he,Hg=new oe,Vg=new Bs;class Hf extends oe{constructor(t,e,n){super(t,e),this.isInstancedMesh=!0,this.instanceMatrix=new Xf(new Float32Array(n*16),16),this.instanceColor=null,this.morphTexture=null,this.count=n,this.boundingBox=null,this.boundingSphere=null;for(let i=0;i<n;i++)this.setMatrixAt(i,uR)}computeBoundingBox(){const t=this.geometry,e=this.count;this.boundingBox===null&&(this.boundingBox=new kn),t.boundingBox===null&&t.computeBoundingBox(),this.boundingBox.makeEmpty();for(let n=0;n<e;n++)this.getMatrixAt(n,yd),J1.copy(t.boundingBox).applyMatrix4(yd),this.boundingBox.union(J1)}computeBoundingSphere(){const t=this.geometry,e=this.count;this.boundingSphere===null&&(this.boundingSphere=new Bs),t.boundingSphere===null&&t.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let n=0;n<e;n++)this.getMatrixAt(n,yd),Vg.copy(t.boundingSphere).applyMatrix4(yd),this.boundingSphere.union(Vg)}copy(t,e){return super.copy(t,e),this.instanceMatrix.copy(t.instanceMatrix),t.morphTexture!==null&&(this.morphTexture=t.morphTexture.clone()),t.instanceColor!==null&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,t.boundingBox!==null&&(this.boundingBox=t.boundingBox.clone()),t.boundingSphere!==null&&(this.boundingSphere=t.boundingSphere.clone()),this}getColorAt(t,e){e.fromArray(this.instanceColor.array,t*3)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,t*16)}getMorphAt(t,e){const n=e.morphTargetInfluences,i=this.morphTexture.source.data.data,r=n.length+1,l=t*r+1;for(let u=0;u<n.length;u++)n[u]=i[l+u]}raycast(t,e){const n=this.matrixWorld,i=this.count;if(Hg.geometry=this.geometry,Hg.material=this.material,Hg.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Vg.copy(this.boundingSphere),Vg.applyMatrix4(n),t.ray.intersectsSphere(Vg)!==!1))for(let r=0;r<i;r++){this.getMatrixAt(r,yd),X1.multiplyMatrices(n,yd),Hg.matrixWorld=X1,Hg.raycast(t,nx);for(let l=0,u=nx.length;l<u;l++){const A=nx[l];A.instanceId=r,A.object=this,e.push(A)}nx.length=0}}setColorAt(t,e){this.instanceColor===null&&(this.instanceColor=new Xf(new Float32Array(this.instanceMatrix.count*3).fill(1),3)),e.toArray(this.instanceColor.array,t*3)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,t*16)}setMorphAt(t,e){const n=e.morphTargetInfluences,i=n.length+1;this.morphTexture===null&&(this.morphTexture=new So(new Float32Array(i*this.count),i,this.count,fE,xr));const r=this.morphTexture.source.data.data;let l=0;for(let d=0;d<n.length;d++)l+=n[d];const u=this.geometry.morphTargetsRelative?1:1-l,A=i*t;r[A]=u,r.set(n,A+1)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null)}}const hC=new F,hR=new F,fR=new Ze;class Kl{constructor(t=new F(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=hC.subVectors(n,e).cross(hR.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const n=t.delta(hC),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:e.copy(t.start).addScaledVector(n,r)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||fR.getNormalMatrix(t),i=this.coplanarPoint(hC).applyMatrix4(t),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}const cf=new Bs,AR=new Dt(.5,.5),ix=new F;class op{constructor(t=new Kl,e=new Kl,n=new Kl,i=new Kl,r=new Kl,l=new Kl){this.planes=[t,e,n,i,r,l]}set(t,e,n,i,r,l){const u=this.planes;return u[0].copy(t),u[1].copy(e),u[2].copy(n),u[3].copy(i),u[4].copy(r),u[5].copy(l),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t,e=Hr,n=!1){const i=this.planes,r=t.elements,l=r[0],u=r[1],A=r[2],d=r[3],m=r[4],g=r[5],y=r[6],v=r[7],C=r[8],I=r[9],S=r[10],E=r[11],B=r[12],w=r[13],Q=r[14],R=r[15];if(i[0].setComponents(d-l,v-m,E-C,R-B).normalize(),i[1].setComponents(d+l,v+m,E+C,R+B).normalize(),i[2].setComponents(d+u,v+g,E+I,R+w).normalize(),i[3].setComponents(d-u,v-g,E-I,R-w).normalize(),n)i[4].setComponents(A,y,S,Q).normalize(),i[5].setComponents(d-A,v-y,E-S,R-Q).normalize();else if(i[4].setComponents(d-A,v-y,E-S,R-Q).normalize(),e===Hr)i[5].setComponents(d+A,v+y,E+S,R+Q).normalize();else if(e===Kd)i[5].setComponents(A,y,S,Q).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+e);return this}intersectsObject(t){if(t.boundingSphere!==void 0)t.boundingSphere===null&&t.computeBoundingSphere(),cf.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else{const e=t.geometry;e.boundingSphere===null&&e.computeBoundingSphere(),cf.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)}return this.intersectsSphere(cf)}intersectsSprite(t){cf.center.set(0,0,0);const e=AR.distanceTo(t.center);return cf.radius=.7071067811865476+e,cf.applyMatrix4(t.matrixWorld),this.intersectsSphere(cf)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let r=0;r<6;r++)if(e[r].distanceToPoint(n)<i)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(ix.x=i.normal.x>0?t.max.x:t.min.x,ix.y=i.normal.y>0?t.max.y:t.min.y,ix.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(ix)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}const Jl=new he,Zl=new op;class vE{constructor(){this.coordinateSystem=Hr}intersectsObject(t,e){if(!e.isArrayCamera||e.cameras.length===0)return!1;for(let n=0;n<e.cameras.length;n++){const i=e.cameras[n];if(Jl.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Zl.setFromProjectionMatrix(Jl,i.coordinateSystem,i.reversedDepth),Zl.intersectsObject(t))return!0}return!1}intersectsSprite(t,e){if(!e||!e.cameras||e.cameras.length===0)return!1;for(let n=0;n<e.cameras.length;n++){const i=e.cameras[n];if(Jl.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Zl.setFromProjectionMatrix(Jl,i.coordinateSystem,i.reversedDepth),Zl.intersectsSprite(t))return!0}return!1}intersectsSphere(t,e){if(!e||!e.cameras||e.cameras.length===0)return!1;for(let n=0;n<e.cameras.length;n++){const i=e.cameras[n];if(Jl.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Zl.setFromProjectionMatrix(Jl,i.coordinateSystem,i.reversedDepth),Zl.intersectsSphere(t))return!0}return!1}intersectsBox(t,e){if(!e||!e.cameras||e.cameras.length===0)return!1;for(let n=0;n<e.cameras.length;n++){const i=e.cameras[n];if(Jl.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Zl.setFromProjectionMatrix(Jl,i.coordinateSystem,i.reversedDepth),Zl.intersectsBox(t))return!0}return!1}containsPoint(t,e){if(!e||!e.cameras||e.cameras.length===0)return!1;for(let n=0;n<e.cameras.length;n++){const i=e.cameras[n];if(Jl.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Zl.setFromProjectionMatrix(Jl,i.coordinateSystem,i.reversedDepth),Zl.containsPoint(t))return!0}return!1}clone(){return new vE}}function fC(s,t){return s-t}function dR(s,t){return s.z-t.z}function pR(s,t){return t.z-s.z}class gR{constructor(){this.index=0,this.pool=[],this.list=[]}push(t,e,n,i){const r=this.pool,l=this.list;this.index>=r.length&&r.push({start:-1,count:-1,z:-1,index:-1});const u=r[this.index];l.push(u),this.index++,u.start=t,u.count=e,u.z=n,u.index=i}reset(){this.list.length=0,this.index=0}}const fr=new he,mR=new le(1,1,1),Z1=new op,yR=new vE,sx=new kn,uf=new Bs,Yg=new F,W1=new F,xR=new F,AC=new gR,ya=new oe,ax=[];function vR(s,t,e=0){const n=t.itemSize;if(s.isInterleavedBufferAttribute||s.array.constructor!==t.array.constructor){const i=s.count;for(let r=0;r<i;r++)for(let l=0;l<n;l++)t.setComponent(r+e,l,s.getComponent(r,l))}else t.array.set(s.array,e*n);t.needsUpdate=!0}function hf(s,t){if(s.constructor!==t.constructor){const e=Math.min(s.length,t.length);for(let n=0;n<e;n++)t[n]=s[n]}else{const e=Math.min(s.length,t.length);t.set(new s.constructor(s.buffer,0,e))}}class RS extends oe{constructor(t,e,n=e*2,i){super(new Fe,i),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._instanceInfo=[],this._geometryInfo=[],this._availableInstanceIds=[],this._availableGeometryIds=[],this._nextIndexStart=0,this._nextVertexStart=0,this._geometryCount=0,this._visibilityChanged=!0,this._geometryInitialized=!1,this._maxInstanceCount=t,this._maxVertexCount=e,this._maxIndexCount=n,this._multiDrawCounts=new Int32Array(t),this._multiDrawStarts=new Int32Array(t),this._multiDrawCount=0,this._multiDrawInstances=null,this._matricesTexture=null,this._indirectTexture=null,this._colorsTexture=null,this._initMatricesTexture(),this._initIndirectTexture()}get maxInstanceCount(){return this._maxInstanceCount}get instanceCount(){return this._instanceInfo.length-this._availableInstanceIds.length}get unusedVertexCount(){return this._maxVertexCount-this._nextVertexStart}get unusedIndexCount(){return this._maxIndexCount-this._nextIndexStart}_initMatricesTexture(){let t=Math.sqrt(this._maxInstanceCount*4);t=Math.ceil(t/4)*4,t=Math.max(t,4);const e=new Float32Array(t*t*4),n=new So(e,t,t,Ki,xr);this._matricesTexture=n}_initIndirectTexture(){let t=Math.sqrt(this._maxInstanceCount);t=Math.ceil(t);const e=new Uint32Array(t*t),n=new So(e,t,t,i0,Ca);this._indirectTexture=n}_initColorsTexture(){let t=Math.sqrt(this._maxInstanceCount);t=Math.ceil(t);const e=new Float32Array(t*t*4).fill(1),n=new So(e,t,t,Ki,xr);n.colorSpace=Gn.workingColorSpace,this._colorsTexture=n}_initializeGeometry(t){const e=this.geometry,n=this._maxVertexCount,i=this._maxIndexCount;if(this._geometryInitialized===!1){for(const r in t.attributes){const l=t.getAttribute(r),{array:u,itemSize:A,normalized:d}=l,m=new u.constructor(n*A),g=new Qn(m,A,d);e.setAttribute(r,g)}if(t.getIndex()!==null){const r=n>65535?new Uint32Array(i):new Uint16Array(i);e.setIndex(new Qn(r,1))}this._geometryInitialized=!0}}_validateGeometry(t){const e=this.geometry;if(!!t.getIndex()!=!!e.getIndex())throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');for(const n in e.attributes){if(!t.hasAttribute(n))throw new Error(`THREE.BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);const i=t.getAttribute(n),r=e.getAttribute(n);if(i.itemSize!==r.itemSize||i.normalized!==r.normalized)throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}validateInstanceId(t){const e=this._instanceInfo;if(t<0||t>=e.length||e[t].active===!1)throw new Error(`THREE.BatchedMesh: Invalid instanceId ${t}. Instance is either out of range or has been deleted.`)}validateGeometryId(t){const e=this._geometryInfo;if(t<0||t>=e.length||e[t].active===!1)throw new Error(`THREE.BatchedMesh: Invalid geometryId ${t}. Geometry is either out of range or has been deleted.`)}setCustomSort(t){return this.customSort=t,this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new kn);const t=this.boundingBox,e=this._instanceInfo;t.makeEmpty();for(let n=0,i=e.length;n<i;n++){if(e[n].active===!1)continue;const r=e[n].geometryIndex;this.getMatrixAt(n,fr),this.getBoundingBoxAt(r,sx).applyMatrix4(fr),t.union(sx)}}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Bs);const t=this.boundingSphere,e=this._instanceInfo;t.makeEmpty();for(let n=0,i=e.length;n<i;n++){if(e[n].active===!1)continue;const r=e[n].geometryIndex;this.getMatrixAt(n,fr),this.getBoundingSphereAt(r,uf).applyMatrix4(fr),t.union(uf)}}addInstance(t){if(this._instanceInfo.length>=this.maxInstanceCount&&this._availableInstanceIds.length===0)throw new Error("THREE.BatchedMesh: Maximum item count reached.");const n={visible:!0,active:!0,geometryIndex:t};let i=null;this._availableInstanceIds.length>0?(this._availableInstanceIds.sort(fC),i=this._availableInstanceIds.shift(),this._instanceInfo[i]=n):(i=this._instanceInfo.length,this._instanceInfo.push(n));const r=this._matricesTexture;fr.identity().toArray(r.image.data,i*16),r.needsUpdate=!0;const l=this._colorsTexture;return l&&(mR.toArray(l.image.data,i*4),l.needsUpdate=!0),this._visibilityChanged=!0,i}addGeometry(t,e=-1,n=-1){this._initializeGeometry(t),this._validateGeometry(t);const i={vertexStart:-1,vertexCount:-1,reservedVertexCount:-1,indexStart:-1,indexCount:-1,reservedIndexCount:-1,start:-1,count:-1,boundingBox:null,boundingSphere:null,active:!0},r=this._geometryInfo;i.vertexStart=this._nextVertexStart,i.reservedVertexCount=e===-1?t.getAttribute("position").count:e;const l=t.getIndex();if(l!==null&&(i.indexStart=this._nextIndexStart,i.reservedIndexCount=n===-1?l.count:n),i.indexStart!==-1&&i.indexStart+i.reservedIndexCount>this._maxIndexCount||i.vertexStart+i.reservedVertexCount>this._maxVertexCount)throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");let A;return this._availableGeometryIds.length>0?(this._availableGeometryIds.sort(fC),A=this._availableGeometryIds.shift(),r[A]=i):(A=this._geometryCount,this._geometryCount++,r.push(i)),this.setGeometryAt(A,t),this._nextIndexStart=i.indexStart+i.reservedIndexCount,this._nextVertexStart=i.vertexStart+i.reservedVertexCount,A}setGeometryAt(t,e){if(t>=this._geometryCount)throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");this._validateGeometry(e);const n=this.geometry,i=n.getIndex()!==null,r=n.getIndex(),l=e.getIndex(),u=this._geometryInfo[t];if(i&&l.count>u.reservedIndexCount||e.attributes.position.count>u.reservedVertexCount)throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");const A=u.vertexStart,d=u.reservedVertexCount;u.vertexCount=e.getAttribute("position").count;for(const m in n.attributes){const g=e.getAttribute(m),y=n.getAttribute(m);vR(g,y,A);const v=g.itemSize;for(let C=g.count,I=d;C<I;C++){const S=A+C;for(let E=0;E<v;E++)y.setComponent(S,E,0)}y.needsUpdate=!0,y.addUpdateRange(A*v,d*v)}if(i){const m=u.indexStart,g=u.reservedIndexCount;u.indexCount=e.getIndex().count;for(let y=0;y<l.count;y++)r.setX(m+y,A+l.getX(y));for(let y=l.count,v=g;y<v;y++)r.setX(m+y,A);r.needsUpdate=!0,r.addUpdateRange(m,u.reservedIndexCount)}return u.start=i?u.indexStart:u.vertexStart,u.count=i?u.indexCount:u.vertexCount,u.boundingBox=null,e.boundingBox!==null&&(u.boundingBox=e.boundingBox.clone()),u.boundingSphere=null,e.boundingSphere!==null&&(u.boundingSphere=e.boundingSphere.clone()),this._visibilityChanged=!0,t}deleteGeometry(t){const e=this._geometryInfo;if(t>=e.length||e[t].active===!1)return this;const n=this._instanceInfo;for(let i=0,r=n.length;i<r;i++)n[i].active&&n[i].geometryIndex===t&&this.deleteInstance(i);return e[t].active=!1,this._availableGeometryIds.push(t),this._visibilityChanged=!0,this}deleteInstance(t){return this.validateInstanceId(t),this._instanceInfo[t].active=!1,this._availableInstanceIds.push(t),this._visibilityChanged=!0,this}optimize(){let t=0,e=0;const n=this._geometryInfo,i=n.map((l,u)=>u).sort((l,u)=>n[l].vertexStart-n[u].vertexStart),r=this.geometry;for(let l=0,u=n.length;l<u;l++){const A=i[l],d=n[A];if(d.active!==!1){if(r.index!==null){if(d.indexStart!==e){const{indexStart:m,vertexStart:g,reservedIndexCount:y}=d,v=r.index,C=v.array,I=t-g;for(let S=m;S<m+y;S++)C[S]=C[S]+I;v.array.copyWithin(e,m,m+y),v.addUpdateRange(e,y),d.indexStart=e}e+=d.reservedIndexCount}if(d.vertexStart!==t){const{vertexStart:m,reservedVertexCount:g}=d,y=r.attributes;for(const v in y){const C=y[v],{array:I,itemSize:S}=C;I.copyWithin(t*S,m*S,(m+g)*S),C.addUpdateRange(t*S,g*S)}d.vertexStart=t}t+=d.reservedVertexCount,d.start=r.index?d.indexStart:d.vertexStart,this._nextIndexStart=r.index?d.indexStart+d.reservedIndexCount:0,this._nextVertexStart=d.vertexStart+d.reservedVertexCount}}return this}getBoundingBoxAt(t,e){if(t>=this._geometryCount)return null;const n=this.geometry,i=this._geometryInfo[t];if(i.boundingBox===null){const r=new kn,l=n.index,u=n.attributes.position;for(let A=i.start,d=i.start+i.count;A<d;A++){let m=A;l&&(m=l.getX(m)),r.expandByPoint(Yg.fromBufferAttribute(u,m))}i.boundingBox=r}return e.copy(i.boundingBox),e}getBoundingSphereAt(t,e){if(t>=this._geometryCount)return null;const n=this.geometry,i=this._geometryInfo[t];if(i.boundingSphere===null){const r=new Bs;this.getBoundingBoxAt(t,sx),sx.getCenter(r.center);const l=n.index,u=n.attributes.position;let A=0;for(let d=i.start,m=i.start+i.count;d<m;d++){let g=d;l&&(g=l.getX(g)),Yg.fromBufferAttribute(u,g),A=Math.max(A,r.center.distanceToSquared(Yg))}r.radius=Math.sqrt(A),i.boundingSphere=r}return e.copy(i.boundingSphere),e}setMatrixAt(t,e){this.validateInstanceId(t);const n=this._matricesTexture,i=this._matricesTexture.image.data;return e.toArray(i,t*16),n.needsUpdate=!0,this}getMatrixAt(t,e){return this.validateInstanceId(t),e.fromArray(this._matricesTexture.image.data,t*16)}setColorAt(t,e){return this.validateInstanceId(t),this._colorsTexture===null&&this._initColorsTexture(),e.toArray(this._colorsTexture.image.data,t*4),this._colorsTexture.needsUpdate=!0,this}getColorAt(t,e){return this.validateInstanceId(t),e.fromArray(this._colorsTexture.image.data,t*4)}setVisibleAt(t,e){return this.validateInstanceId(t),this._instanceInfo[t].visible===e?this:(this._instanceInfo[t].visible=e,this._visibilityChanged=!0,this)}getVisibleAt(t){return this.validateInstanceId(t),this._instanceInfo[t].visible}setGeometryIdAt(t,e){return this.validateInstanceId(t),this.validateGeometryId(e),this._instanceInfo[t].geometryIndex=e,this}getGeometryIdAt(t){return this.validateInstanceId(t),this._instanceInfo[t].geometryIndex}getGeometryRangeAt(t,e={}){this.validateGeometryId(t);const n=this._geometryInfo[t];return e.vertexStart=n.vertexStart,e.vertexCount=n.vertexCount,e.reservedVertexCount=n.reservedVertexCount,e.indexStart=n.indexStart,e.indexCount=n.indexCount,e.reservedIndexCount=n.reservedIndexCount,e.start=n.start,e.count=n.count,e}setInstanceCount(t){const e=this._availableInstanceIds,n=this._instanceInfo;for(e.sort(fC);e[e.length-1]===n.length-1;)n.pop(),e.pop();if(t<n.length)throw new Error(`BatchedMesh: Instance ids outside the range ${t} are being used. Cannot shrink instance count.`);const i=new Int32Array(t),r=new Int32Array(t);hf(this._multiDrawCounts,i),hf(this._multiDrawStarts,r),this._multiDrawCounts=i,this._multiDrawStarts=r,this._maxInstanceCount=t;const l=this._indirectTexture,u=this._matricesTexture,A=this._colorsTexture;l.dispose(),this._initIndirectTexture(),hf(l.image.data,this._indirectTexture.image.data),u.dispose(),this._initMatricesTexture(),hf(u.image.data,this._matricesTexture.image.data),A&&(A.dispose(),this._initColorsTexture(),hf(A.image.data,this._colorsTexture.image.data))}setGeometrySize(t,e){const n=[...this._geometryInfo].filter(u=>u.active);if(Math.max(...n.map(u=>u.vertexStart+u.reservedVertexCount))>t)throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${e}. Cannot shrink further.`);if(this.geometry.index&&Math.max(...n.map(A=>A.indexStart+A.reservedIndexCount))>e)throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${e}. Cannot shrink further.`);const r=this.geometry;r.dispose(),this._maxVertexCount=t,this._maxIndexCount=e,this._geometryInitialized&&(this._geometryInitialized=!1,this.geometry=new Fe,this._initializeGeometry(r));const l=this.geometry;r.index&&hf(r.index.array,l.index.array);for(const u in r.attributes)hf(r.attributes[u].array,l.attributes[u].array)}raycast(t,e){const n=this._instanceInfo,i=this._geometryInfo,r=this.matrixWorld,l=this.geometry;ya.material=this.material,ya.geometry.index=l.index,ya.geometry.attributes=l.attributes,ya.geometry.boundingBox===null&&(ya.geometry.boundingBox=new kn),ya.geometry.boundingSphere===null&&(ya.geometry.boundingSphere=new Bs);for(let u=0,A=n.length;u<A;u++){if(!n[u].visible||!n[u].active)continue;const d=n[u].geometryIndex,m=i[d];ya.geometry.setDrawRange(m.start,m.count),this.getMatrixAt(u,ya.matrixWorld).premultiply(r),this.getBoundingBoxAt(d,ya.geometry.boundingBox),this.getBoundingSphereAt(d,ya.geometry.boundingSphere),ya.raycast(t,ax);for(let g=0,y=ax.length;g<y;g++){const v=ax[g];v.object=this,v.batchId=u,e.push(v)}ax.length=0}ya.material=null,ya.geometry.index=null,ya.geometry.attributes={},ya.geometry.setDrawRange(0,1/0)}copy(t){return super.copy(t),this.geometry=t.geometry.clone(),this.perObjectFrustumCulled=t.perObjectFrustumCulled,this.sortObjects=t.sortObjects,this.boundingBox=t.boundingBox!==null?t.boundingBox.clone():null,this.boundingSphere=t.boundingSphere!==null?t.boundingSphere.clone():null,this._geometryInfo=t._geometryInfo.map(e=>({...e,boundingBox:e.boundingBox!==null?e.boundingBox.clone():null,boundingSphere:e.boundingSphere!==null?e.boundingSphere.clone():null})),this._instanceInfo=t._instanceInfo.map(e=>({...e})),this._availableInstanceIds=t._availableInstanceIds.slice(),this._availableGeometryIds=t._availableGeometryIds.slice(),this._nextIndexStart=t._nextIndexStart,this._nextVertexStart=t._nextVertexStart,this._geometryCount=t._geometryCount,this._maxInstanceCount=t._maxInstanceCount,this._maxVertexCount=t._maxVertexCount,this._maxIndexCount=t._maxIndexCount,this._geometryInitialized=t._geometryInitialized,this._multiDrawCounts=t._multiDrawCounts.slice(),this._multiDrawStarts=t._multiDrawStarts.slice(),this._indirectTexture=t._indirectTexture.clone(),this._indirectTexture.image.data=this._indirectTexture.image.data.slice(),this._matricesTexture=t._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.data.slice(),this._colorsTexture!==null&&(this._colorsTexture=t._colorsTexture.clone(),this._colorsTexture.image.data=this._colorsTexture.image.data.slice()),this}dispose(){this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this._indirectTexture.dispose(),this._indirectTexture=null,this._colorsTexture!==null&&(this._colorsTexture.dispose(),this._colorsTexture=null)}onBeforeRender(t,e,n,i,r){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const l=i.getIndex(),u=l===null?1:l.array.BYTES_PER_ELEMENT,A=this._instanceInfo,d=this._multiDrawStarts,m=this._multiDrawCounts,g=this._geometryInfo,y=this.perObjectFrustumCulled,v=this._indirectTexture,C=v.image.data,I=n.isArrayCamera?yR:Z1;y&&!n.isArrayCamera&&(fr.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse).multiply(this.matrixWorld),Z1.setFromProjectionMatrix(fr,n.coordinateSystem,n.reversedDepth));let S=0;if(this.sortObjects){fr.copy(this.matrixWorld).invert(),Yg.setFromMatrixPosition(n.matrixWorld).applyMatrix4(fr),W1.set(0,0,-1).transformDirection(n.matrixWorld).transformDirection(fr);for(let w=0,Q=A.length;w<Q;w++)if(A[w].visible&&A[w].active){const R=A[w].geometryIndex;this.getMatrixAt(w,fr),this.getBoundingSphereAt(R,uf).applyMatrix4(fr);let D=!1;if(y&&(D=!I.intersectsSphere(uf,n)),!D){const U=g[R],P=xR.subVectors(uf.center,Yg).dot(W1);AC.push(U.start,U.count,P,w)}}const E=AC.list,B=this.customSort;B===null?E.sort(r.transparent?pR:dR):B.call(this,E,n);for(let w=0,Q=E.length;w<Q;w++){const R=E[w];d[S]=R.start*u,m[S]=R.count,C[S]=R.index,S++}AC.reset()}else for(let E=0,B=A.length;E<B;E++)if(A[E].visible&&A[E].active){const w=A[E].geometryIndex;let Q=!1;if(y&&(this.getMatrixAt(E,fr),this.getBoundingSphereAt(w,uf).applyMatrix4(fr),Q=!I.intersectsSphere(uf,n)),!Q){const R=g[w];d[S]=R.start*u,m[S]=R.count,C[S]=E,S++}}v.needsUpdate=!0,this._multiDrawCount=S,this._visibilityChanged=!1}onBeforeShadow(t,e,n,i,r,l){this.onBeforeRender(t,null,i,r,l)}}class na extends ba{constructor(t){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new le(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}const Jv=new F,Zv=new F,j1=new he,qg=new tA,rx=new Bs,dC=new F,K1=new F;class Sn extends gn{constructor(t=new Fe,e=new na){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=e,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.index===null){const e=t.attributes.position,n=[0];for(let i=1,r=e.count;i<r;i++)Jv.fromBufferAttribute(e,i-1),Zv.fromBufferAttribute(e,i),n[i]=n[i-1],n[i]+=Jv.distanceTo(Zv);t.setAttribute("lineDistance",new Ce(n,1))}else ge("Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Line.threshold,l=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),rx.copy(n.boundingSphere),rx.applyMatrix4(i),rx.radius+=r,t.ray.intersectsSphere(rx)===!1)return;j1.copy(i).invert(),qg.copy(t.ray).applyMatrix4(j1);const u=r/((this.scale.x+this.scale.y+this.scale.z)/3),A=u*u,d=this.isLineSegments?2:1,m=n.index,y=n.attributes.position;if(m!==null){const v=Math.max(0,l.start),C=Math.min(m.count,l.start+l.count);for(let I=v,S=C-1;I<S;I+=d){const E=m.getX(I),B=m.getX(I+1),w=ox(this,t,qg,A,E,B,I);w&&e.push(w)}if(this.isLineLoop){const I=m.getX(C-1),S=m.getX(v),E=ox(this,t,qg,A,I,S,C-1);E&&e.push(E)}}else{const v=Math.max(0,l.start),C=Math.min(y.count,l.start+l.count);for(let I=v,S=C-1;I<S;I+=d){const E=ox(this,t,qg,A,I,I+1,I);E&&e.push(E)}if(this.isLineLoop){const I=ox(this,t,qg,A,C-1,v,C-1);I&&e.push(I)}}}updateMorphTargets(){const e=this.geometry.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,l=i.length;r<l;r++){const u=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[u]=r}}}}}function ox(s,t,e,n,i,r,l){const u=s.geometry.attributes.position;if(Jv.fromBufferAttribute(u,i),Zv.fromBufferAttribute(u,r),e.distanceSqToSegment(Jv,Zv,dC,K1)>n)return;dC.applyMatrix4(s.matrixWorld);const d=t.ray.origin.distanceTo(dC);if(!(d<t.near||d>t.far))return{distance:d,point:K1.clone().applyMatrix4(s.matrixWorld),index:l,face:null,faceIndex:null,barycoord:null,object:s}}const $1=new F,t2=new F;class oc extends Sn{constructor(t,e){super(t,e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.index===null){const e=t.attributes.position,n=[];for(let i=0,r=e.count;i<r;i+=2)$1.fromBufferAttribute(e,i),t2.fromBufferAttribute(e,i+1),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+$1.distanceTo(t2);t.setAttribute("lineDistance",new Ce(n,1))}else ge("LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class Aw extends Sn{constructor(t,e){super(t,e),this.isLineLoop=!0,this.type="LineLoop"}}class NS extends ba{constructor(t){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new le(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}const e2=new he,Tb=new tA,lx=new Bs,cx=new F;class dw extends gn{constructor(t=new Fe,e=new NS){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Points.threshold,l=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),lx.copy(n.boundingSphere),lx.applyMatrix4(i),lx.radius+=r,t.ray.intersectsSphere(lx)===!1)return;e2.copy(i).invert(),Tb.copy(t.ray).applyMatrix4(e2);const u=r/((this.scale.x+this.scale.y+this.scale.z)/3),A=u*u,d=n.index,g=n.attributes.position;if(d!==null){const y=Math.max(0,l.start),v=Math.min(d.count,l.start+l.count);for(let C=y,I=v;C<I;C++){const S=d.getX(C);cx.fromBufferAttribute(g,S),n2(cx,S,A,i,t,e,this)}}else{const y=Math.max(0,l.start),v=Math.min(g.count,l.start+l.count);for(let C=y,I=v;C<I;C++)cx.fromBufferAttribute(g,C),n2(cx,C,A,i,t,e,this)}}updateMorphTargets(){const e=this.geometry.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,l=i.length;r<l;r++){const u=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[u]=r}}}}}function n2(s,t,e,n,i,r,l){const u=Tb.distanceSqToPoint(s);if(u<e){const A=new F;Tb.closestPointToPoint(s,A),A.applyMatrix4(n);const d=i.ray.origin.distanceTo(A);if(d<i.near||d>i.far)return;r.push({distance:d,distanceToRay:Math.sqrt(u),point:A,index:t,face:null,faceIndex:null,barycoord:null,object:l})}}class pw extends wi{constructor(t,e,n,i,r=as,l=as,u,A,d){super(t,e,n,i,r,l,u,A,d),this.isVideoTexture=!0,this.generateMipmaps=!1,this._requestVideoFrameCallbackId=0;const m=this;function g(){m.needsUpdate=!0,m._requestVideoFrameCallbackId=t.requestVideoFrameCallback(g)}"requestVideoFrameCallback"in t&&(this._requestVideoFrameCallbackId=t.requestVideoFrameCallback(g))}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;"requestVideoFrameCallback"in t===!1&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}dispose(){this._requestVideoFrameCallbackId!==0&&(this.source.data.cancelVideoFrameCallback(this._requestVideoFrameCallbackId),this._requestVideoFrameCallbackId=0),super.dispose()}}class ER extends pw{constructor(t,e,n,i,r,l,u,A){super({},t,e,n,i,r,l,u,A),this.isVideoFrameTexture=!0}update(){}clone(){return new this.constructor().copy(this)}setFrame(t){this.image=t,this.needsUpdate=!0}}class _R extends wi{constructor(t,e){super({width:t,height:e}),this.isFramebufferTexture=!0,this.magFilter=rs,this.minFilter=rs,this.generateMipmaps=!1,this.needsUpdate=!0}}class EE extends wi{constructor(t,e,n,i,r,l,u,A,d,m,g,y){super(null,l,u,A,d,m,i,r,g,y),this.isCompressedTexture=!0,this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}class CR extends EE{constructor(t,e,n,i,r,l){super(t,e,n,r,l),this.isCompressedArrayTexture=!0,this.image.depth=i,this.wrapR=yr,this.layerUpdates=new Set}addLayerUpdate(t){this.layerUpdates.add(t)}clearLayerUpdates(){this.layerUpdates.clear()}}class bR extends EE{constructor(t,e,n){super(void 0,t[0].width,t[0].height,e,n,eu),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=t}}class SR extends wi{constructor(t,e,n,i,r,l,u,A,d){super(t,e,n,i,r,l,u,A,d),this.isCanvasTexture=!0,this.needsUpdate=!0}}class US extends wi{constructor(t,e,n=Ca,i,r,l,u=rs,A=rs,d,m=Wd,g=1){if(m!==Wd&&m!==jd)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");const y={width:t,height:e,depth:g};super(y,i,r,l,u,A,m,n,d),this.isDepthTexture=!0,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(t){return super.copy(t),this.source=new lh(Object.assign({},t.image)),this.compareFunction=t.compareFunction,this}toJSON(t){const e=super.toJSON(t);return this.compareFunction!==null&&(e.compareFunction=this.compareFunction),e}}class LS extends wi{constructor(t=null){super(),this.sourceTexture=t,this.isExternalTexture=!0}copy(t){return super.copy(t),this.sourceTexture=t.sourceTexture,this}}class _E extends Fe{constructor(t=1,e=1,n=4,i=8,r=1){super(),this.type="CapsuleGeometry",this.parameters={radius:t,height:e,capSegments:n,radialSegments:i,heightSegments:r},e=Math.max(0,e),n=Math.max(1,Math.floor(n)),i=Math.max(3,Math.floor(i)),r=Math.max(1,Math.floor(r));const l=[],u=[],A=[],d=[],m=e/2,g=Math.PI/2*t,y=e,v=2*g+y,C=n*2+r,I=i+1,S=new F,E=new F;for(let B=0;B<=C;B++){let w=0,Q=0,R=0,D=0;if(B<=n){const z=B/n,L=z*Math.PI/2;Q=-m-t*Math.cos(L),R=t*Math.sin(L),D=-t*Math.cos(L),w=z*g}else if(B<=n+r){const z=(B-n)/r;Q=-m+z*e,R=t,D=0,w=g+z*y}else{const z=(B-n-r)/n,L=z*Math.PI/2;Q=m+t*Math.sin(L),R=t*Math.cos(L),D=t*Math.sin(L),w=g+y+z*g}const U=Math.max(0,Math.min(1,w/v));let P=0;B===0?P=.5/i:B===C&&(P=-.5/i);for(let z=0;z<=i;z++){const L=z/i,k=L*Math.PI*2,Y=Math.sin(k),W=Math.cos(k);E.x=-R*W,E.y=Q,E.z=R*Y,u.push(E.x,E.y,E.z),S.set(-R*W,D,R*Y),S.normalize(),A.push(S.x,S.y,S.z),d.push(L+P,U)}if(B>0){const z=(B-1)*I;for(let L=0;L<i;L++){const k=z+L,Y=z+L+1,W=B*I+L,K=B*I+L+1;l.push(k,Y,W),l.push(Y,K,W)}}}this.setIndex(l),this.setAttribute("position",new Ce(u,3)),this.setAttribute("normal",new Ce(A,3)),this.setAttribute("uv",new Ce(d,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new _E(t.radius,t.height,t.capSegments,t.radialSegments,t.heightSegments)}}class CE extends Fe{constructor(t=1,e=32,n=0,i=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:n,thetaLength:i},e=Math.max(3,e);const r=[],l=[],u=[],A=[],d=new F,m=new Dt;l.push(0,0,0),u.push(0,0,1),A.push(.5,.5);for(let g=0,y=3;g<=e;g++,y+=3){const v=n+g/e*i;d.x=t*Math.cos(v),d.y=t*Math.sin(v),l.push(d.x,d.y,d.z),u.push(0,0,1),m.x=(l[y]/t+1)/2,m.y=(l[y+1]/t+1)/2,A.push(m.x,m.y)}for(let g=1;g<=e;g++)r.push(g,g+1,0);this.setIndex(r),this.setAttribute("position",new Ce(l,3)),this.setAttribute("normal",new Ce(u,3)),this.setAttribute("uv",new Ce(A,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new CE(t.radius,t.segments,t.thetaStart,t.thetaLength)}}class Ea extends Fe{constructor(t=1,e=1,n=1,i=32,r=1,l=!1,u=0,A=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:n,radialSegments:i,heightSegments:r,openEnded:l,thetaStart:u,thetaLength:A};const d=this;i=Math.floor(i),r=Math.floor(r);const m=[],g=[],y=[],v=[];let C=0;const I=[],S=n/2;let E=0;B(),l===!1&&(t>0&&w(!0),e>0&&w(!1)),this.setIndex(m),this.setAttribute("position",new Ce(g,3)),this.setAttribute("normal",new Ce(y,3)),this.setAttribute("uv",new Ce(v,2));function B(){const Q=new F,R=new F;let D=0;const U=(e-t)/n;for(let P=0;P<=r;P++){const z=[],L=P/r,k=L*(e-t)+t;for(let Y=0;Y<=i;Y++){const W=Y/i,K=W*A+u,nt=Math.sin(K),H=Math.cos(K);R.x=k*nt,R.y=-L*n+S,R.z=k*H,g.push(R.x,R.y,R.z),Q.set(nt,U,H).normalize(),y.push(Q.x,Q.y,Q.z),v.push(W,1-L),z.push(C++)}I.push(z)}for(let P=0;P<i;P++)for(let z=0;z<r;z++){const L=I[z][P],k=I[z+1][P],Y=I[z+1][P+1],W=I[z][P+1];(t>0||z!==0)&&(m.push(L,k,W),D+=3),(e>0||z!==r-1)&&(m.push(k,Y,W),D+=3)}d.addGroup(E,D,0),E+=D}function w(Q){const R=C,D=new Dt,U=new F;let P=0;const z=Q===!0?t:e,L=Q===!0?1:-1;for(let Y=1;Y<=i;Y++)g.push(0,S*L,0),y.push(0,L,0),v.push(.5,.5),C++;const k=C;for(let Y=0;Y<=i;Y++){const K=Y/i*A+u,nt=Math.cos(K),H=Math.sin(K);U.x=z*H,U.y=S*L,U.z=z*nt,g.push(U.x,U.y,U.z),y.push(0,L,0),D.x=nt*.5+.5,D.y=H*.5*L+.5,v.push(D.x,D.y),C++}for(let Y=0;Y<i;Y++){const W=R+Y,K=k+Y;Q===!0?m.push(K,K+1,W):m.push(K+1,K,W),P+=3}d.addGroup(E,P,Q===!0?1:2),E+=P}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Ea(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class o0 extends Ea{constructor(t=1,e=1,n=32,i=1,r=!1,l=0,u=Math.PI*2){super(0,t,e,n,i,r,l,u),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:n,heightSegments:i,openEnded:r,thetaStart:l,thetaLength:u}}static fromJSON(t){return new o0(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class mh extends Fe{constructor(t=[],e=[],n=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:n,detail:i};const r=[],l=[];u(i),d(n),m(),this.setAttribute("position",new Ce(r,3)),this.setAttribute("normal",new Ce(r.slice(),3)),this.setAttribute("uv",new Ce(l,2)),i===0?this.computeVertexNormals():this.normalizeNormals();function u(B){const w=new F,Q=new F,R=new F;for(let D=0;D<e.length;D+=3)v(e[D+0],w),v(e[D+1],Q),v(e[D+2],R),A(w,Q,R,B)}function A(B,w,Q,R){const D=R+1,U=[];for(let P=0;P<=D;P++){U[P]=[];const z=B.clone().lerp(Q,P/D),L=w.clone().lerp(Q,P/D),k=D-P;for(let Y=0;Y<=k;Y++)Y===0&&P===D?U[P][Y]=z:U[P][Y]=z.clone().lerp(L,Y/k)}for(let P=0;P<D;P++)for(let z=0;z<2*(D-P)-1;z++){const L=Math.floor(z/2);z%2===0?(y(U[P][L+1]),y(U[P+1][L]),y(U[P][L])):(y(U[P][L+1]),y(U[P+1][L+1]),y(U[P+1][L]))}}function d(B){const w=new F;for(let Q=0;Q<r.length;Q+=3)w.x=r[Q+0],w.y=r[Q+1],w.z=r[Q+2],w.normalize().multiplyScalar(B),r[Q+0]=w.x,r[Q+1]=w.y,r[Q+2]=w.z}function m(){const B=new F;for(let w=0;w<r.length;w+=3){B.x=r[w+0],B.y=r[w+1],B.z=r[w+2];const Q=S(B)/2/Math.PI+.5,R=E(B)/Math.PI+.5;l.push(Q,1-R)}C(),g()}function g(){for(let B=0;B<l.length;B+=6){const w=l[B+0],Q=l[B+2],R=l[B+4],D=Math.max(w,Q,R),U=Math.min(w,Q,R);D>.9&&U<.1&&(w<.2&&(l[B+0]+=1),Q<.2&&(l[B+2]+=1),R<.2&&(l[B+4]+=1))}}function y(B){r.push(B.x,B.y,B.z)}function v(B,w){const Q=B*3;w.x=t[Q+0],w.y=t[Q+1],w.z=t[Q+2]}function C(){const B=new F,w=new F,Q=new F,R=new F,D=new Dt,U=new Dt,P=new Dt;for(let z=0,L=0;z<r.length;z+=9,L+=6){B.set(r[z+0],r[z+1],r[z+2]),w.set(r[z+3],r[z+4],r[z+5]),Q.set(r[z+6],r[z+7],r[z+8]),D.set(l[L+0],l[L+1]),U.set(l[L+2],l[L+3]),P.set(l[L+4],l[L+5]),R.copy(B).add(w).add(Q).divideScalar(3);const k=S(R);I(D,L+0,B,k),I(U,L+2,w,k),I(P,L+4,Q,k)}}function I(B,w,Q,R){R<0&&B.x===1&&(l[w]=B.x-1),Q.x===0&&Q.z===0&&(l[w]=R/2/Math.PI+.5)}function S(B){return Math.atan2(B.z,-B.x)}function E(B){return Math.atan2(-B.y,Math.sqrt(B.x*B.x+B.z*B.z))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new mh(t.vertices,t.indices,t.radius,t.details)}}class bE extends mh{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2,i=1/n,r=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-n,0,-i,n,0,i,-n,0,i,n,-i,-n,0,-i,n,0,i,-n,0,i,n,0,-n,0,-i,n,0,-i,-n,0,i,n,0,i],l=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(r,l,t,e),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new bE(t.radius,t.detail)}}const ux=new F,hx=new F,pC=new F,fx=new ds;class gw extends Fe{constructor(t=null,e=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:t,thresholdAngle:e},t!==null){const i=Math.pow(10,4),r=Math.cos(kf*e),l=t.getIndex(),u=t.getAttribute("position"),A=l?l.count:u.count,d=[0,0,0],m=["a","b","c"],g=new Array(3),y={},v=[];for(let C=0;C<A;C+=3){l?(d[0]=l.getX(C),d[1]=l.getX(C+1),d[2]=l.getX(C+2)):(d[0]=C,d[1]=C+1,d[2]=C+2);const{a:I,b:S,c:E}=fx;if(I.fromBufferAttribute(u,d[0]),S.fromBufferAttribute(u,d[1]),E.fromBufferAttribute(u,d[2]),fx.getNormal(pC),g[0]=`${Math.round(I.x*i)},${Math.round(I.y*i)},${Math.round(I.z*i)}`,g[1]=`${Math.round(S.x*i)},${Math.round(S.y*i)},${Math.round(S.z*i)}`,g[2]=`${Math.round(E.x*i)},${Math.round(E.y*i)},${Math.round(E.z*i)}`,!(g[0]===g[1]||g[1]===g[2]||g[2]===g[0]))for(let B=0;B<3;B++){const w=(B+1)%3,Q=g[B],R=g[w],D=fx[m[B]],U=fx[m[w]],P=`${Q}_${R}`,z=`${R}_${Q}`;z in y&&y[z]?(pC.dot(y[z].normal)<=r&&(v.push(D.x,D.y,D.z),v.push(U.x,U.y,U.z)),y[z]=null):P in y||(y[P]={index0:d[B],index1:d[w],normal:pC.clone()})}}for(const C in y)if(y[C]){const{index0:I,index1:S}=y[C];ux.fromBufferAttribute(u,I),hx.fromBufferAttribute(u,S),v.push(ux.x,ux.y,ux.z),v.push(hx.x,hx.y,hx.z)}this.setAttribute("position",new Ce(v,3))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}class gl{constructor(){this.type="Curve",this.arcLengthDivisions=200,this.needsUpdate=!1,this.cacheArcLengths=null}getPoint(){ge("Curve: .getPoint() not implemented.")}getPointAt(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)}getPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e}getSpacedPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,i=this.getPoint(0),r=0;e.push(0);for(let l=1;l<=t;l++)n=this.getPoint(l/t),r+=n.distanceTo(i),e.push(r),i=n;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e=null){const n=this.getLengths();let i=0;const r=n.length;let l;e?l=e:l=t*n[r-1];let u=0,A=r-1,d;for(;u<=A;)if(i=Math.floor(u+(A-u)/2),d=n[i]-l,d<0)u=i+1;else if(d>0)A=i-1;else{A=i;break}if(i=A,n[i]===l)return i/(r-1);const m=n[i],y=n[i+1]-m,v=(l-m)/y;return(i+v)/(r-1)}getTangent(t,e){let i=t-1e-4,r=t+1e-4;i<0&&(i=0),r>1&&(r=1);const l=this.getPoint(i),u=this.getPoint(r),A=e||(l.isVector2?new Dt:new F);return A.copy(u).sub(l).normalize(),A}getTangentAt(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)}computeFrenetFrames(t,e=!1){const n=new F,i=[],r=[],l=[],u=new F,A=new he;for(let v=0;v<=t;v++){const C=v/t;i[v]=this.getTangentAt(C,new F)}r[0]=new F,l[0]=new F;let d=Number.MAX_VALUE;const m=Math.abs(i[0].x),g=Math.abs(i[0].y),y=Math.abs(i[0].z);m<=d&&(d=m,n.set(1,0,0)),g<=d&&(d=g,n.set(0,1,0)),y<=d&&n.set(0,0,1),u.crossVectors(i[0],n).normalize(),r[0].crossVectors(i[0],u),l[0].crossVectors(i[0],r[0]);for(let v=1;v<=t;v++){if(r[v]=r[v-1].clone(),l[v]=l[v-1].clone(),u.crossVectors(i[v-1],i[v]),u.length()>Number.EPSILON){u.normalize();const C=Math.acos(Je(i[v-1].dot(i[v]),-1,1));r[v].applyMatrix4(A.makeRotationAxis(u,C))}l[v].crossVectors(i[v],r[v])}if(e===!0){let v=Math.acos(Je(r[0].dot(r[t]),-1,1));v/=t,i[0].dot(u.crossVectors(r[0],r[t]))>0&&(v=-v);for(let C=1;C<=t;C++)r[C].applyMatrix4(A.makeRotationAxis(i[C],v*C)),l[C].crossVectors(i[C],r[C])}return{tangents:i,normals:r,binormals:l}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.7,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class SE extends gl{constructor(t=0,e=0,n=1,i=1,r=0,l=Math.PI*2,u=!1,A=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=n,this.yRadius=i,this.aStartAngle=r,this.aEndAngle=l,this.aClockwise=u,this.aRotation=A}getPoint(t,e=new Dt){const n=e,i=Math.PI*2;let r=this.aEndAngle-this.aStartAngle;const l=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(l?r=0:r=i),this.aClockwise===!0&&!l&&(r===i?r=-i:r=r-i);const u=this.aStartAngle+t*r;let A=this.aX+this.xRadius*Math.cos(u),d=this.aY+this.yRadius*Math.sin(u);if(this.aRotation!==0){const m=Math.cos(this.aRotation),g=Math.sin(this.aRotation),y=A-this.aX,v=d-this.aY;A=y*m-v*g+this.aX,d=y*g+v*m+this.aY}return n.set(A,d)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}class mw extends SE{constructor(t,e,n,i,r,l){super(t,e,n,n,i,r,l),this.isArcCurve=!0,this.type="ArcCurve"}}function zS(){let s=0,t=0,e=0,n=0;function i(r,l,u,A){s=r,t=u,e=-3*r+3*l-2*u-A,n=2*r-2*l+u+A}return{initCatmullRom:function(r,l,u,A,d){i(l,u,d*(u-r),d*(A-l))},initNonuniformCatmullRom:function(r,l,u,A,d,m,g){let y=(l-r)/d-(u-r)/(d+m)+(u-l)/m,v=(u-l)/m-(A-l)/(m+g)+(A-u)/g;y*=m,v*=m,i(l,u,y,v)},calc:function(r){const l=r*r,u=l*r;return s+t*r+e*l+n*u}}}const Ax=new F,gC=new zS,mC=new zS,yC=new zS;class yw extends gl{constructor(t=[],e=!1,n="centripetal",i=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=i}getPoint(t,e=new F){const n=e,i=this.points,r=i.length,l=(r-(this.closed?0:1))*t;let u=Math.floor(l),A=l-u;this.closed?u+=u>0?0:(Math.floor(Math.abs(u)/r)+1)*r:A===0&&u===r-1&&(u=r-2,A=1);let d,m;this.closed||u>0?d=i[(u-1)%r]:(Ax.subVectors(i[0],i[1]).add(i[0]),d=Ax);const g=i[u%r],y=i[(u+1)%r];if(this.closed||u+2<r?m=i[(u+2)%r]:(Ax.subVectors(i[r-1],i[r-2]).add(i[r-1]),m=Ax),this.curveType==="centripetal"||this.curveType==="chordal"){const v=this.curveType==="chordal"?.5:.25;let C=Math.pow(d.distanceToSquared(g),v),I=Math.pow(g.distanceToSquared(y),v),S=Math.pow(y.distanceToSquared(m),v);I<1e-4&&(I=1),C<1e-4&&(C=I),S<1e-4&&(S=I),gC.initNonuniformCatmullRom(d.x,g.x,y.x,m.x,C,I,S),mC.initNonuniformCatmullRom(d.y,g.y,y.y,m.y,C,I,S),yC.initNonuniformCatmullRom(d.z,g.z,y.z,m.z,C,I,S)}else this.curveType==="catmullrom"&&(gC.initCatmullRom(d.x,g.x,y.x,m.x,this.tension),mC.initCatmullRom(d.y,g.y,y.y,m.y,this.tension),yC.initCatmullRom(d.z,g.z,y.z,m.z,this.tension));return n.set(gC.calc(A),mC.calc(A),yC.calc(A)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(i.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const i=this.points[e];t.points.push(i.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(new F().fromArray(i))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}function i2(s,t,e,n,i){const r=(n-t)*.5,l=(i-e)*.5,u=s*s,A=s*u;return(2*e-2*n+r+l)*A+(-3*e+3*n-2*r-l)*u+r*s+e}function IR(s,t){const e=1-s;return e*e*t}function BR(s,t){return 2*(1-s)*s*t}function MR(s,t){return s*s*t}function Cm(s,t,e,n){return IR(s,t)+BR(s,e)+MR(s,n)}function wR(s,t){const e=1-s;return e*e*e*t}function TR(s,t){const e=1-s;return 3*e*e*s*t}function QR(s,t){return 3*(1-s)*s*s*t}function DR(s,t){return s*s*s*t}function bm(s,t,e,n,i){return wR(s,t)+TR(s,e)+QR(s,n)+DR(s,i)}class OS extends gl{constructor(t=new Dt,e=new Dt,n=new Dt,i=new Dt){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new Dt){const n=e,i=this.v0,r=this.v1,l=this.v2,u=this.v3;return n.set(bm(t,i.x,r.x,l.x,u.x),bm(t,i.y,r.y,l.y,u.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class xw extends gl{constructor(t=new F,e=new F,n=new F,i=new F){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new F){const n=e,i=this.v0,r=this.v1,l=this.v2,u=this.v3;return n.set(bm(t,i.x,r.x,l.x,u.x),bm(t,i.y,r.y,l.y,u.y),bm(t,i.z,r.z,l.z,u.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class FS extends gl{constructor(t=new Dt,e=new Dt){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new Dt){const n=e;return t===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new Dt){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class vw extends gl{constructor(t=new F,e=new F){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=t,this.v2=e}getPoint(t,e=new F){const n=e;return t===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new F){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class PS extends gl{constructor(t=new Dt,e=new Dt,n=new Dt){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new Dt){const n=e,i=this.v0,r=this.v1,l=this.v2;return n.set(Cm(t,i.x,r.x,l.x),Cm(t,i.y,r.y,l.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class GS extends gl{constructor(t=new F,e=new F,n=new F){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new F){const n=e,i=this.v0,r=this.v1,l=this.v2;return n.set(Cm(t,i.x,r.x,l.x),Cm(t,i.y,r.y,l.y),Cm(t,i.z,r.z,l.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class kS extends gl{constructor(t=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=t}getPoint(t,e=new Dt){const n=e,i=this.points,r=(i.length-1)*t,l=Math.floor(r),u=r-l,A=i[l===0?l:l-1],d=i[l],m=i[l>i.length-2?i.length-1:l+1],g=i[l>i.length-3?i.length-1:l+2];return n.set(i2(u,A.x,d.x,m.x,g.x),i2(u,A.y,d.y,m.y,g.y)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const i=this.points[e];t.points.push(i.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(new Dt().fromArray(i))}return this}}var Wv=Object.freeze({__proto__:null,ArcCurve:mw,CatmullRomCurve3:yw,CubicBezierCurve:OS,CubicBezierCurve3:xw,EllipseCurve:SE,LineCurve:FS,LineCurve3:vw,QuadraticBezierCurve:PS,QuadraticBezierCurve3:GS,SplineCurve:kS});class Ew extends gl{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);if(!t.equals(e)){const n=t.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new Wv[n](e,t))}return this}getPoint(t,e){const n=t*this.getLength(),i=this.getCurveLengths();let r=0;for(;r<i.length;){if(i[r]>=n){const l=i[r]-n,u=this.curves[r],A=u.getLength(),d=A===0?0:1-l/A;return u.getPointAt(d,e)}r++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,i=this.curves.length;n<i;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let n;for(let i=0,r=this.curves;i<r.length;i++){const l=r[i],u=l.isEllipseCurve?t*2:l.isLineCurve||l.isLineCurve3?1:l.isSplineCurve?t*l.points.length:t,A=l.getPoints(u);for(let d=0;d<A.length;d++){const m=A[d];n&&n.equals(m)||(e.push(m),n=m)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const i=t.curves[e];this.curves.push(i.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++){const i=this.curves[e];t.curves.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const i=t.curves[e];this.curves.push(new Wv[i.type]().fromJSON(i))}return this}}class jv extends Ew{constructor(t){super(),this.type="Path",this.currentPoint=new Dt,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const n=new FS(this.currentPoint.clone(),new Dt(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,n,i){const r=new PS(this.currentPoint.clone(),new Dt(t,e),new Dt(n,i));return this.curves.push(r),this.currentPoint.set(n,i),this}bezierCurveTo(t,e,n,i,r,l){const u=new OS(this.currentPoint.clone(),new Dt(t,e),new Dt(n,i),new Dt(r,l));return this.curves.push(u),this.currentPoint.set(r,l),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),n=new kS(e);return this.curves.push(n),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,n,i,r,l){const u=this.currentPoint.x,A=this.currentPoint.y;return this.absarc(t+u,e+A,n,i,r,l),this}absarc(t,e,n,i,r,l){return this.absellipse(t,e,n,n,i,r,l),this}ellipse(t,e,n,i,r,l,u,A){const d=this.currentPoint.x,m=this.currentPoint.y;return this.absellipse(t+d,e+m,n,i,r,l,u,A),this}absellipse(t,e,n,i,r,l,u,A){const d=new SE(t,e,n,i,r,l,u,A);if(this.curves.length>0){const g=d.getPoint(0);g.equals(this.currentPoint)||this.lineTo(g.x,g.y)}this.curves.push(d);const m=d.getPoint(1);return this.currentPoint.copy(m),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class Vf extends jv{constructor(t){super(t),this.uuid=Yr(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let n=0,i=this.holes.length;n<i;n++)e[n]=this.holes[n].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const i=t.holes[e];this.holes.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++){const i=this.holes[e];t.holes.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const i=t.holes[e];this.holes.push(new jv().fromJSON(i))}return this}}function RR(s,t,e=2){const n=t&&t.length,i=n?t[0]*e:s.length;let r=_w(s,0,i,e,!0);const l=[];if(!r||r.next===r.prev)return l;let u,A,d;if(n&&(r=OR(s,t,r,e)),s.length>80*e){u=s[0],A=s[1];let m=u,g=A;for(let y=e;y<i;y+=e){const v=s[y],C=s[y+1];v<u&&(u=v),C<A&&(A=C),v>m&&(m=v),C>g&&(g=C)}d=Math.max(m-u,g-A),d=d!==0?32767/d:0}return Vm(r,l,e,u,A,d,0),l}function _w(s,t,e,n,i){let r;if(i===ZR(s,t,e,n)>0)for(let l=t;l<e;l+=n)r=s2(l/n|0,s[l],s[l+1],r);else for(let l=e-n;l>=t;l-=n)r=s2(l/n|0,s[l],s[l+1],r);return r&&ip(r,r.next)&&(qm(r),r=r.next),r}function Jf(s,t){if(!s)return s;t||(t=s);let e=s,n;do if(n=!1,!e.steiner&&(ip(e,e.next)||Xi(e.prev,e,e.next)===0)){if(qm(e),e=t=e.prev,e===e.next)break;n=!0}else e=e.next;while(n||e!==t);return t}function Vm(s,t,e,n,i,r,l){if(!s)return;!l&&r&&HR(s,n,i,r);let u=s;for(;s.prev!==s.next;){const A=s.prev,d=s.next;if(r?UR(s,n,i,r):NR(s)){t.push(A.i,s.i,d.i),qm(s),s=d.next,u=d.next;continue}if(s=d,s===u){l?l===1?(s=LR(Jf(s),t),Vm(s,t,e,n,i,r,2)):l===2&&zR(s,t,e,n,i,r):Vm(Jf(s),t,e,n,i,r,1);break}}}function NR(s){const t=s.prev,e=s,n=s.next;if(Xi(t,e,n)>=0)return!1;const i=t.x,r=e.x,l=n.x,u=t.y,A=e.y,d=n.y,m=Math.min(i,r,l),g=Math.min(u,A,d),y=Math.max(i,r,l),v=Math.max(u,A,d);let C=n.next;for(;C!==t;){if(C.x>=m&&C.x<=y&&C.y>=g&&C.y<=v&&cm(i,u,r,A,l,d,C.x,C.y)&&Xi(C.prev,C,C.next)>=0)return!1;C=C.next}return!0}function UR(s,t,e,n){const i=s.prev,r=s,l=s.next;if(Xi(i,r,l)>=0)return!1;const u=i.x,A=r.x,d=l.x,m=i.y,g=r.y,y=l.y,v=Math.min(u,A,d),C=Math.min(m,g,y),I=Math.max(u,A,d),S=Math.max(m,g,y),E=Qb(v,C,t,e,n),B=Qb(I,S,t,e,n);let w=s.prevZ,Q=s.nextZ;for(;w&&w.z>=E&&Q&&Q.z<=B;){if(w.x>=v&&w.x<=I&&w.y>=C&&w.y<=S&&w!==i&&w!==l&&cm(u,m,A,g,d,y,w.x,w.y)&&Xi(w.prev,w,w.next)>=0||(w=w.prevZ,Q.x>=v&&Q.x<=I&&Q.y>=C&&Q.y<=S&&Q!==i&&Q!==l&&cm(u,m,A,g,d,y,Q.x,Q.y)&&Xi(Q.prev,Q,Q.next)>=0))return!1;Q=Q.nextZ}for(;w&&w.z>=E;){if(w.x>=v&&w.x<=I&&w.y>=C&&w.y<=S&&w!==i&&w!==l&&cm(u,m,A,g,d,y,w.x,w.y)&&Xi(w.prev,w,w.next)>=0)return!1;w=w.prevZ}for(;Q&&Q.z<=B;){if(Q.x>=v&&Q.x<=I&&Q.y>=C&&Q.y<=S&&Q!==i&&Q!==l&&cm(u,m,A,g,d,y,Q.x,Q.y)&&Xi(Q.prev,Q,Q.next)>=0)return!1;Q=Q.nextZ}return!0}function LR(s,t){let e=s;do{const n=e.prev,i=e.next.next;!ip(n,i)&&bw(n,e,e.next,i)&&Ym(n,i)&&Ym(i,n)&&(t.push(n.i,e.i,i.i),qm(e),qm(e.next),e=s=i),e=e.next}while(e!==s);return Jf(e)}function zR(s,t,e,n,i,r){let l=s;do{let u=l.next.next;for(;u!==l.prev;){if(l.i!==u.i&&qR(l,u)){let A=Sw(l,u);l=Jf(l,l.next),A=Jf(A,A.next),Vm(l,t,e,n,i,r,0),Vm(A,t,e,n,i,r,0);return}u=u.next}l=l.next}while(l!==s)}function OR(s,t,e,n){const i=[];for(let r=0,l=t.length;r<l;r++){const u=t[r]*n,A=r<l-1?t[r+1]*n:s.length,d=_w(s,u,A,n,!1);d===d.next&&(d.steiner=!0),i.push(YR(d))}i.sort(FR);for(let r=0;r<i.length;r++)e=PR(i[r],e);return e}function FR(s,t){let e=s.x-t.x;if(e===0&&(e=s.y-t.y,e===0)){const n=(s.next.y-s.y)/(s.next.x-s.x),i=(t.next.y-t.y)/(t.next.x-t.x);e=n-i}return e}function PR(s,t){const e=GR(s,t);if(!e)return t;const n=Sw(e,s);return Jf(n,n.next),Jf(e,e.next)}function GR(s,t){let e=t;const n=s.x,i=s.y;let r=-1/0,l;if(ip(s,e))return e;do{if(ip(s,e.next))return e.next;if(i<=e.y&&i>=e.next.y&&e.next.y!==e.y){const g=e.x+(i-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(g<=n&&g>r&&(r=g,l=e.x<e.next.x?e:e.next,g===n))return l}e=e.next}while(e!==t);if(!l)return null;const u=l,A=l.x,d=l.y;let m=1/0;e=l;do{if(n>=e.x&&e.x>=A&&n!==e.x&&Cw(i<d?n:r,i,A,d,i<d?r:n,i,e.x,e.y)){const g=Math.abs(i-e.y)/(n-e.x);Ym(e,s)&&(g<m||g===m&&(e.x>l.x||e.x===l.x&&kR(l,e)))&&(l=e,m=g)}e=e.next}while(e!==u);return l}function kR(s,t){return Xi(s.prev,s,t.prev)<0&&Xi(t.next,s,s.next)<0}function HR(s,t,e,n){let i=s;do i.z===0&&(i.z=Qb(i.x,i.y,t,e,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==s);i.prevZ.nextZ=null,i.prevZ=null,VR(i)}function VR(s){let t,e=1;do{let n=s,i;s=null;let r=null;for(t=0;n;){t++;let l=n,u=0;for(let d=0;d<e&&(u++,l=l.nextZ,!!l);d++);let A=e;for(;u>0||A>0&&l;)u!==0&&(A===0||!l||n.z<=l.z)?(i=n,n=n.nextZ,u--):(i=l,l=l.nextZ,A--),r?r.nextZ=i:s=i,i.prevZ=r,r=i;n=l}r.nextZ=null,e*=2}while(t>1);return s}function Qb(s,t,e,n,i){return s=(s-e)*i|0,t=(t-n)*i|0,s=(s|s<<8)&16711935,s=(s|s<<4)&252645135,s=(s|s<<2)&858993459,s=(s|s<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,s|t<<1}function YR(s){let t=s,e=s;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==s);return e}function Cw(s,t,e,n,i,r,l,u){return(i-l)*(t-u)>=(s-l)*(r-u)&&(s-l)*(n-u)>=(e-l)*(t-u)&&(e-l)*(r-u)>=(i-l)*(n-u)}function cm(s,t,e,n,i,r,l,u){return!(s===l&&t===u)&&Cw(s,t,e,n,i,r,l,u)}function qR(s,t){return s.next.i!==t.i&&s.prev.i!==t.i&&!XR(s,t)&&(Ym(s,t)&&Ym(t,s)&&JR(s,t)&&(Xi(s.prev,s,t.prev)||Xi(s,t.prev,t))||ip(s,t)&&Xi(s.prev,s,s.next)>0&&Xi(t.prev,t,t.next)>0)}function Xi(s,t,e){return(t.y-s.y)*(e.x-t.x)-(t.x-s.x)*(e.y-t.y)}function ip(s,t){return s.x===t.x&&s.y===t.y}function bw(s,t,e,n){const i=px(Xi(s,t,e)),r=px(Xi(s,t,n)),l=px(Xi(e,n,s)),u=px(Xi(e,n,t));return!!(i!==r&&l!==u||i===0&&dx(s,e,t)||r===0&&dx(s,n,t)||l===0&&dx(e,s,n)||u===0&&dx(e,t,n))}function dx(s,t,e){return t.x<=Math.max(s.x,e.x)&&t.x>=Math.min(s.x,e.x)&&t.y<=Math.max(s.y,e.y)&&t.y>=Math.min(s.y,e.y)}function px(s){return s>0?1:s<0?-1:0}function XR(s,t){let e=s;do{if(e.i!==s.i&&e.next.i!==s.i&&e.i!==t.i&&e.next.i!==t.i&&bw(e,e.next,s,t))return!0;e=e.next}while(e!==s);return!1}function Ym(s,t){return Xi(s.prev,s,s.next)<0?Xi(s,t,s.next)>=0&&Xi(s,s.prev,t)>=0:Xi(s,t,s.prev)<0||Xi(s,s.next,t)<0}function JR(s,t){let e=s,n=!1;const i=(s.x+t.x)/2,r=(s.y+t.y)/2;do e.y>r!=e.next.y>r&&e.next.y!==e.y&&i<(e.next.x-e.x)*(r-e.y)/(e.next.y-e.y)+e.x&&(n=!n),e=e.next;while(e!==s);return n}function Sw(s,t){const e=Db(s.i,s.x,s.y),n=Db(t.i,t.x,t.y),i=s.next,r=t.prev;return s.next=t,t.prev=s,e.next=i,i.prev=e,n.next=e,e.prev=n,r.next=n,n.prev=r,n}function s2(s,t,e,n){const i=Db(s,t,e);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function qm(s){s.next.prev=s.prev,s.prev.next=s.next,s.prevZ&&(s.prevZ.nextZ=s.nextZ),s.nextZ&&(s.nextZ.prevZ=s.prevZ)}function Db(s,t,e){return{i:s,x:t,y:e,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}function ZR(s,t,e,n){let i=0;for(let r=t,l=e-n;r<e;r+=n)i+=(s[l]-s[r])*(s[r+1]+s[l+1]),l=r;return i}class WR{static triangulate(t,e,n=2){return RR(t,e,n)}}class cl{static area(t){const e=t.length;let n=0;for(let i=e-1,r=0;r<e;i=r++)n+=t[i].x*t[r].y-t[r].x*t[i].y;return n*.5}static isClockWise(t){return cl.area(t)<0}static triangulateShape(t,e){const n=[],i=[],r=[];a2(t),r2(n,t);let l=t.length;e.forEach(a2);for(let A=0;A<e.length;A++)i.push(l),l+=e[A].length,r2(n,e[A]);const u=WR.triangulate(n,i);for(let A=0;A<u.length;A+=3)r.push(u.slice(A,A+3));return r}}function a2(s){const t=s.length;t>2&&s[t-1].equals(s[0])&&s.pop()}function r2(s,t){for(let e=0;e<t.length;e++)s.push(t[e].x),s.push(t[e].y)}class IE extends Fe{constructor(t=new Vf([new Dt(.5,.5),new Dt(-.5,.5),new Dt(-.5,-.5),new Dt(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,i=[],r=[];for(let u=0,A=t.length;u<A;u++){const d=t[u];l(d)}this.setAttribute("position",new Ce(i,3)),this.setAttribute("uv",new Ce(r,2)),this.computeVertexNormals();function l(u){const A=[],d=e.curveSegments!==void 0?e.curveSegments:12,m=e.steps!==void 0?e.steps:1,g=e.depth!==void 0?e.depth:1;let y=e.bevelEnabled!==void 0?e.bevelEnabled:!0,v=e.bevelThickness!==void 0?e.bevelThickness:.2,C=e.bevelSize!==void 0?e.bevelSize:v-.1,I=e.bevelOffset!==void 0?e.bevelOffset:0,S=e.bevelSegments!==void 0?e.bevelSegments:3;const E=e.extrudePath,B=e.UVGenerator!==void 0?e.UVGenerator:jR;let w,Q=!1,R,D,U,P;E&&(w=E.getSpacedPoints(m),Q=!0,y=!1,R=E.computeFrenetFrames(m,!1),D=new F,U=new F,P=new F),y||(S=0,v=0,C=0,I=0);const z=u.extractPoints(d);let L=z.shape;const k=z.holes;if(!cl.isClockWise(L)){L=L.reverse();for(let zt=0,Z=k.length;zt<Z;zt++){const Ot=k[zt];cl.isClockWise(Ot)&&(k[zt]=Ot.reverse())}}function W(zt){const Ot=10000000000000001e-36;let Vt=zt[0];for(let Pt=1;Pt<=zt.length;Pt++){const kt=Pt%zt.length,Zt=zt[kt],$t=Zt.x-Vt.x,fe=Zt.y-Vt.y,$=$t*$t+fe*fe,G=Math.max(Math.abs(Zt.x),Math.abs(Zt.y),Math.abs(Vt.x),Math.abs(Vt.y)),ft=Ot*G*G;if($<=ft){zt.splice(kt,1),Pt--;continue}Vt=Zt}}W(L),k.forEach(W);const K=k.length,nt=L;for(let zt=0;zt<K;zt++){const Z=k[zt];L=L.concat(Z)}function H(zt,Z,Ot){return Z||nn("ExtrudeGeometry: vec does not exist"),zt.clone().addScaledVector(Z,Ot)}const tt=L.length;function it(zt,Z,Ot){let Vt,Pt,kt;const Zt=zt.x-Z.x,$t=zt.y-Z.y,fe=Ot.x-zt.x,$=Ot.y-zt.y,G=Zt*Zt+$t*$t,ft=Zt*$-$t*fe;if(Math.abs(ft)>Number.EPSILON){const Tt=Math.sqrt(G),Ht=Math.sqrt(fe*fe+$*$),Bt=Z.x-$t/Tt,Se=Z.y+Zt/Tt,ae=Ot.x-$/Ht,we=Ot.y+fe/Ht,Ee=((ae-Bt)*$-(we-Se)*fe)/(Zt*$-$t*fe);Vt=Bt+Zt*Ee-zt.x,Pt=Se+$t*Ee-zt.y;const Gt=Vt*Vt+Pt*Pt;if(Gt<=2)return new Dt(Vt,Pt);kt=Math.sqrt(Gt/2)}else{let Tt=!1;Zt>Number.EPSILON?fe>Number.EPSILON&&(Tt=!0):Zt<-Number.EPSILON?fe<-Number.EPSILON&&(Tt=!0):Math.sign($t)===Math.sign($)&&(Tt=!0),Tt?(Vt=-$t,Pt=Zt,kt=Math.sqrt(G)):(Vt=Zt,Pt=$t,kt=Math.sqrt(G/2))}return new Dt(Vt/kt,Pt/kt)}const ot=[];for(let zt=0,Z=nt.length,Ot=Z-1,Vt=zt+1;zt<Z;zt++,Ot++,Vt++)Ot===Z&&(Ot=0),Vt===Z&&(Vt=0),ot[zt]=it(nt[zt],nt[Ot],nt[Vt]);const At=[];let V,st=ot.concat();for(let zt=0,Z=K;zt<Z;zt++){const Ot=k[zt];V=[];for(let Vt=0,Pt=Ot.length,kt=Pt-1,Zt=Vt+1;Vt<Pt;Vt++,kt++,Zt++)kt===Pt&&(kt=0),Zt===Pt&&(Zt=0),V[Vt]=it(Ot[Vt],Ot[kt],Ot[Zt]);At.push(V),st=st.concat(V)}let xt;if(S===0)xt=cl.triangulateShape(nt,k);else{const zt=[],Z=[];for(let Ot=0;Ot<S;Ot++){const Vt=Ot/S,Pt=v*Math.cos(Vt*Math.PI/2),kt=C*Math.sin(Vt*Math.PI/2)+I;for(let Zt=0,$t=nt.length;Zt<$t;Zt++){const fe=H(nt[Zt],ot[Zt],kt);Wt(fe.x,fe.y,-Pt),Vt===0&&zt.push(fe)}for(let Zt=0,$t=K;Zt<$t;Zt++){const fe=k[Zt];V=At[Zt];const $=[];for(let G=0,ft=fe.length;G<ft;G++){const Tt=H(fe[G],V[G],kt);Wt(Tt.x,Tt.y,-Pt),Vt===0&&$.push(Tt)}Vt===0&&Z.push($)}}xt=cl.triangulateShape(zt,Z)}const j=xt.length,Rt=C+I;for(let zt=0;zt<tt;zt++){const Z=y?H(L[zt],st[zt],Rt):L[zt];Q?(U.copy(R.normals[0]).multiplyScalar(Z.x),D.copy(R.binormals[0]).multiplyScalar(Z.y),P.copy(w[0]).add(U).add(D),Wt(P.x,P.y,P.z)):Wt(Z.x,Z.y,0)}for(let zt=1;zt<=m;zt++)for(let Z=0;Z<tt;Z++){const Ot=y?H(L[Z],st[Z],Rt):L[Z];Q?(U.copy(R.normals[zt]).multiplyScalar(Ot.x),D.copy(R.binormals[zt]).multiplyScalar(Ot.y),P.copy(w[zt]).add(U).add(D),Wt(P.x,P.y,P.z)):Wt(Ot.x,Ot.y,g/m*zt)}for(let zt=S-1;zt>=0;zt--){const Z=zt/S,Ot=v*Math.cos(Z*Math.PI/2),Vt=C*Math.sin(Z*Math.PI/2)+I;for(let Pt=0,kt=nt.length;Pt<kt;Pt++){const Zt=H(nt[Pt],ot[Pt],Vt);Wt(Zt.x,Zt.y,g+Ot)}for(let Pt=0,kt=k.length;Pt<kt;Pt++){const Zt=k[Pt];V=At[Pt];for(let $t=0,fe=Zt.length;$t<fe;$t++){const $=H(Zt[$t],V[$t],Vt);Q?Wt($.x,$.y+w[m-1].y,w[m-1].x+Ot):Wt($.x,$.y,g+Ot)}}}dt(),pt();function dt(){const zt=i.length/3;if(y){let Z=0,Ot=tt*Z;for(let Vt=0;Vt<j;Vt++){const Pt=xt[Vt];ce(Pt[2]+Ot,Pt[1]+Ot,Pt[0]+Ot)}Z=m+S*2,Ot=tt*Z;for(let Vt=0;Vt<j;Vt++){const Pt=xt[Vt];ce(Pt[0]+Ot,Pt[1]+Ot,Pt[2]+Ot)}}else{for(let Z=0;Z<j;Z++){const Ot=xt[Z];ce(Ot[2],Ot[1],Ot[0])}for(let Z=0;Z<j;Z++){const Ot=xt[Z];ce(Ot[0]+tt*m,Ot[1]+tt*m,Ot[2]+tt*m)}}n.addGroup(zt,i.length/3-zt,0)}function pt(){const zt=i.length/3;let Z=0;qt(nt,Z),Z+=nt.length;for(let Ot=0,Vt=k.length;Ot<Vt;Ot++){const Pt=k[Ot];qt(Pt,Z),Z+=Pt.length}n.addGroup(zt,i.length/3-zt,1)}function qt(zt,Z){let Ot=zt.length;for(;--Ot>=0;){const Vt=Ot;let Pt=Ot-1;Pt<0&&(Pt=zt.length-1);for(let kt=0,Zt=m+S*2;kt<Zt;kt++){const $t=tt*kt,fe=tt*(kt+1),$=Z+Vt+$t,G=Z+Pt+$t,ft=Z+Pt+fe,Tt=Z+Vt+fe;Ie($,G,ft,Tt)}}}function Wt(zt,Z,Ot){A.push(zt),A.push(Z),A.push(Ot)}function ce(zt,Z,Ot){He(zt),He(Z),He(Ot);const Vt=i.length/3,Pt=B.generateTopUV(n,i,Vt-3,Vt-2,Vt-1);be(Pt[0]),be(Pt[1]),be(Pt[2])}function Ie(zt,Z,Ot,Vt){He(zt),He(Z),He(Vt),He(Z),He(Ot),He(Vt);const Pt=i.length/3,kt=B.generateSideWallUV(n,i,Pt-6,Pt-3,Pt-2,Pt-1);be(kt[0]),be(kt[1]),be(kt[3]),be(kt[1]),be(kt[2]),be(kt[3])}function He(zt){i.push(A[zt*3+0]),i.push(A[zt*3+1]),i.push(A[zt*3+2])}function be(zt){r.push(zt.x),r.push(zt.y)}}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON(),e=this.parameters.shapes,n=this.parameters.options;return KR(e,n,t)}static fromJSON(t,e){const n=[];for(let r=0,l=t.shapes.length;r<l;r++){const u=e[t.shapes[r]];n.push(u)}const i=t.options.extrudePath;return i!==void 0&&(t.options.extrudePath=new Wv[i.type]().fromJSON(i)),new IE(n,t.options)}}const jR={generateTopUV:function(s,t,e,n,i){const r=t[e*3],l=t[e*3+1],u=t[n*3],A=t[n*3+1],d=t[i*3],m=t[i*3+1];return[new Dt(r,l),new Dt(u,A),new Dt(d,m)]},generateSideWallUV:function(s,t,e,n,i,r){const l=t[e*3],u=t[e*3+1],A=t[e*3+2],d=t[n*3],m=t[n*3+1],g=t[n*3+2],y=t[i*3],v=t[i*3+1],C=t[i*3+2],I=t[r*3],S=t[r*3+1],E=t[r*3+2];return Math.abs(u-m)<Math.abs(l-d)?[new Dt(l,1-A),new Dt(d,1-g),new Dt(y,1-C),new Dt(I,1-E)]:[new Dt(u,1-A),new Dt(m,1-g),new Dt(v,1-C),new Dt(S,1-E)]}};function KR(s,t,e){if(e.shapes=[],Array.isArray(s))for(let n=0,i=s.length;n<i;n++){const r=s[n];e.shapes.push(r.uuid)}else e.shapes.push(s.uuid);return e.options=Object.assign({},t),t.extrudePath!==void 0&&(e.options.extrudePath=t.extrudePath.toJSON()),e}class BE extends mh{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2,i=[-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],r=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(i,r,t,e),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new BE(t.radius,t.detail)}}class ME extends Fe{constructor(t=[new Dt(0,-.5),new Dt(.5,0),new Dt(0,.5)],e=12,n=0,i=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:n,phiLength:i},e=Math.floor(e),i=Je(i,0,Math.PI*2);const r=[],l=[],u=[],A=[],d=[],m=1/e,g=new F,y=new Dt,v=new F,C=new F,I=new F;let S=0,E=0;for(let B=0;B<=t.length-1;B++)switch(B){case 0:S=t[B+1].x-t[B].x,E=t[B+1].y-t[B].y,v.x=E*1,v.y=-S,v.z=E*0,I.copy(v),v.normalize(),A.push(v.x,v.y,v.z);break;case t.length-1:A.push(I.x,I.y,I.z);break;default:S=t[B+1].x-t[B].x,E=t[B+1].y-t[B].y,v.x=E*1,v.y=-S,v.z=E*0,C.copy(v),v.x+=I.x,v.y+=I.y,v.z+=I.z,v.normalize(),A.push(v.x,v.y,v.z),I.copy(C)}for(let B=0;B<=e;B++){const w=n+B*m*i,Q=Math.sin(w),R=Math.cos(w);for(let D=0;D<=t.length-1;D++){g.x=t[D].x*Q,g.y=t[D].y,g.z=t[D].x*R,l.push(g.x,g.y,g.z),y.x=B/e,y.y=D/(t.length-1),u.push(y.x,y.y);const U=A[3*D+0]*Q,P=A[3*D+1],z=A[3*D+0]*R;d.push(U,P,z)}}for(let B=0;B<e;B++)for(let w=0;w<t.length-1;w++){const Q=w+B*t.length,R=Q,D=Q+t.length,U=Q+t.length+1,P=Q+1;r.push(R,D,P),r.push(U,P,D)}this.setIndex(r),this.setAttribute("position",new Ce(l,3)),this.setAttribute("uv",new Ce(u,2)),this.setAttribute("normal",new Ce(d,3))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new ME(t.points,t.segments,t.phiStart,t.phiLength)}}class xo extends mh{constructor(t=1,e=0){const n=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(n,i,t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new xo(t.radius,t.detail)}}class kr extends Fe{constructor(t=1,e=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const r=t/2,l=e/2,u=Math.floor(n),A=Math.floor(i),d=u+1,m=A+1,g=t/u,y=e/A,v=[],C=[],I=[],S=[];for(let E=0;E<m;E++){const B=E*y-l;for(let w=0;w<d;w++){const Q=w*g-r;C.push(Q,-B,0),I.push(0,0,1),S.push(w/u),S.push(1-E/A)}}for(let E=0;E<A;E++)for(let B=0;B<u;B++){const w=B+d*E,Q=B+d*(E+1),R=B+1+d*(E+1),D=B+1+d*E;v.push(w,Q,D),v.push(Q,R,D)}this.setIndex(v),this.setAttribute("position",new Ce(C,3)),this.setAttribute("normal",new Ce(I,3)),this.setAttribute("uv",new Ce(S,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new kr(t.width,t.height,t.widthSegments,t.heightSegments)}}class wE extends Fe{constructor(t=.5,e=1,n=32,i=1,r=0,l=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:n,phiSegments:i,thetaStart:r,thetaLength:l},n=Math.max(3,n),i=Math.max(1,i);const u=[],A=[],d=[],m=[];let g=t;const y=(e-t)/i,v=new F,C=new Dt;for(let I=0;I<=i;I++){for(let S=0;S<=n;S++){const E=r+S/n*l;v.x=g*Math.cos(E),v.y=g*Math.sin(E),A.push(v.x,v.y,v.z),d.push(0,0,1),C.x=(v.x/e+1)/2,C.y=(v.y/e+1)/2,m.push(C.x,C.y)}g+=y}for(let I=0;I<i;I++){const S=I*(n+1);for(let E=0;E<n;E++){const B=E+S,w=B,Q=B+n+1,R=B+n+2,D=B+1;u.push(w,Q,D),u.push(Q,R,D)}}this.setIndex(u),this.setAttribute("position",new Ce(A,3)),this.setAttribute("normal",new Ce(d,3)),this.setAttribute("uv",new Ce(m,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new wE(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)}}class TE extends Fe{constructor(t=new Vf([new Dt(0,.5),new Dt(-.5,-.5),new Dt(.5,-.5)]),e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],i=[],r=[],l=[];let u=0,A=0;if(Array.isArray(t)===!1)d(t);else for(let m=0;m<t.length;m++)d(t[m]),this.addGroup(u,A,m),u+=A,A=0;this.setIndex(n),this.setAttribute("position",new Ce(i,3)),this.setAttribute("normal",new Ce(r,3)),this.setAttribute("uv",new Ce(l,2));function d(m){const g=i.length/3,y=m.extractPoints(e);let v=y.shape;const C=y.holes;cl.isClockWise(v)===!1&&(v=v.reverse());for(let S=0,E=C.length;S<E;S++){const B=C[S];cl.isClockWise(B)===!0&&(C[S]=B.reverse())}const I=cl.triangulateShape(v,C);for(let S=0,E=C.length;S<E;S++){const B=C[S];v=v.concat(B)}for(let S=0,E=v.length;S<E;S++){const B=v[S];i.push(B.x,B.y,0),r.push(0,0,1),l.push(B.x,B.y)}for(let S=0,E=I.length;S<E;S++){const B=I[S],w=B[0]+g,Q=B[1]+g,R=B[2]+g;n.push(w,Q,R),A+=3}}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON(),e=this.parameters.shapes;return $R(e,t)}static fromJSON(t,e){const n=[];for(let i=0,r=t.shapes.length;i<r;i++){const l=e[t.shapes[i]];n.push(l)}return new TE(n,t.curveSegments)}}function $R(s,t){if(t.shapes=[],Array.isArray(s))for(let e=0,n=s.length;e<n;e++){const i=s[e];t.shapes.push(i.uuid)}else t.shapes.push(s.uuid);return t}class lp extends Fe{constructor(t=1,e=32,n=16,i=0,r=Math.PI*2,l=0,u=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:n,phiStart:i,phiLength:r,thetaStart:l,thetaLength:u},e=Math.max(3,Math.floor(e)),n=Math.max(2,Math.floor(n));const A=Math.min(l+u,Math.PI);let d=0;const m=[],g=new F,y=new F,v=[],C=[],I=[],S=[];for(let E=0;E<=n;E++){const B=[],w=E/n;let Q=0;E===0&&l===0?Q=.5/e:E===n&&A===Math.PI&&(Q=-.5/e);for(let R=0;R<=e;R++){const D=R/e;g.x=-t*Math.cos(i+D*r)*Math.sin(l+w*u),g.y=t*Math.cos(l+w*u),g.z=t*Math.sin(i+D*r)*Math.sin(l+w*u),C.push(g.x,g.y,g.z),y.copy(g).normalize(),I.push(y.x,y.y,y.z),S.push(D+Q,1-w),B.push(d++)}m.push(B)}for(let E=0;E<n;E++)for(let B=0;B<e;B++){const w=m[E][B+1],Q=m[E][B],R=m[E+1][B],D=m[E+1][B+1];(E!==0||l>0)&&v.push(w,Q,D),(E!==n-1||A<Math.PI)&&v.push(Q,R,D)}this.setIndex(v),this.setAttribute("position",new Ce(C,3)),this.setAttribute("normal",new Ce(I,3)),this.setAttribute("uv",new Ce(S,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new lp(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class QE extends mh{constructor(t=1,e=0){const n=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],i=[2,1,0,0,3,2,1,3,0,2,3,1];super(n,i,t,e),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new QE(t.radius,t.detail)}}class ch extends Fe{constructor(t=1,e=.4,n=12,i=48,r=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:n,tubularSegments:i,arc:r},n=Math.floor(n),i=Math.floor(i);const l=[],u=[],A=[],d=[],m=new F,g=new F,y=new F;for(let v=0;v<=n;v++)for(let C=0;C<=i;C++){const I=C/i*r,S=v/n*Math.PI*2;g.x=(t+e*Math.cos(S))*Math.cos(I),g.y=(t+e*Math.cos(S))*Math.sin(I),g.z=e*Math.sin(S),u.push(g.x,g.y,g.z),m.x=t*Math.cos(I),m.y=t*Math.sin(I),y.subVectors(g,m).normalize(),A.push(y.x,y.y,y.z),d.push(C/i),d.push(v/n)}for(let v=1;v<=n;v++)for(let C=1;C<=i;C++){const I=(i+1)*v+C-1,S=(i+1)*(v-1)+C-1,E=(i+1)*(v-1)+C,B=(i+1)*v+C;l.push(I,S,B),l.push(S,E,B)}this.setIndex(l),this.setAttribute("position",new Ce(u,3)),this.setAttribute("normal",new Ce(A,3)),this.setAttribute("uv",new Ce(d,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new ch(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class DE extends Fe{constructor(t=1,e=.4,n=64,i=8,r=2,l=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:e,tubularSegments:n,radialSegments:i,p:r,q:l},n=Math.floor(n),i=Math.floor(i);const u=[],A=[],d=[],m=[],g=new F,y=new F,v=new F,C=new F,I=new F,S=new F,E=new F;for(let w=0;w<=n;++w){const Q=w/n*r*Math.PI*2;B(Q,r,l,t,v),B(Q+.01,r,l,t,C),S.subVectors(C,v),E.addVectors(C,v),I.crossVectors(S,E),E.crossVectors(I,S),I.normalize(),E.normalize();for(let R=0;R<=i;++R){const D=R/i*Math.PI*2,U=-e*Math.cos(D),P=e*Math.sin(D);g.x=v.x+(U*E.x+P*I.x),g.y=v.y+(U*E.y+P*I.y),g.z=v.z+(U*E.z+P*I.z),A.push(g.x,g.y,g.z),y.subVectors(g,v).normalize(),d.push(y.x,y.y,y.z),m.push(w/n),m.push(R/i)}}for(let w=1;w<=n;w++)for(let Q=1;Q<=i;Q++){const R=(i+1)*(w-1)+(Q-1),D=(i+1)*w+(Q-1),U=(i+1)*w+Q,P=(i+1)*(w-1)+Q;u.push(R,D,P),u.push(D,U,P)}this.setIndex(u),this.setAttribute("position",new Ce(A,3)),this.setAttribute("normal",new Ce(d,3)),this.setAttribute("uv",new Ce(m,2));function B(w,Q,R,D,U){const P=Math.cos(w),z=Math.sin(w),L=R/Q*w,k=Math.cos(L);U.x=D*(2+k)*.5*P,U.y=D*(2+k)*z*.5,U.z=D*Math.sin(L)*.5}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new DE(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)}}class RE extends Fe{constructor(t=new GS(new F(-1,-1,0),new F(-1,1,0),new F(1,1,0)),e=64,n=1,i=8,r=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:n,radialSegments:i,closed:r};const l=t.computeFrenetFrames(e,r);this.tangents=l.tangents,this.normals=l.normals,this.binormals=l.binormals;const u=new F,A=new F,d=new Dt;let m=new F;const g=[],y=[],v=[],C=[];I(),this.setIndex(C),this.setAttribute("position",new Ce(g,3)),this.setAttribute("normal",new Ce(y,3)),this.setAttribute("uv",new Ce(v,2));function I(){for(let w=0;w<e;w++)S(w);S(r===!1?e:0),B(),E()}function S(w){m=t.getPointAt(w/e,m);const Q=l.normals[w],R=l.binormals[w];for(let D=0;D<=i;D++){const U=D/i*Math.PI*2,P=Math.sin(U),z=-Math.cos(U);A.x=z*Q.x+P*R.x,A.y=z*Q.y+P*R.y,A.z=z*Q.z+P*R.z,A.normalize(),y.push(A.x,A.y,A.z),u.x=m.x+n*A.x,u.y=m.y+n*A.y,u.z=m.z+n*A.z,g.push(u.x,u.y,u.z)}}function E(){for(let w=1;w<=e;w++)for(let Q=1;Q<=i;Q++){const R=(i+1)*(w-1)+(Q-1),D=(i+1)*w+(Q-1),U=(i+1)*w+Q,P=(i+1)*(w-1)+Q;C.push(R,D,P),C.push(D,U,P)}}function B(){for(let w=0;w<=e;w++)for(let Q=0;Q<=i;Q++)d.x=w/e,d.y=Q/i,v.push(d.x,d.y)}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return t.path=this.parameters.path.toJSON(),t}static fromJSON(t){return new RE(new Wv[t.path.type]().fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)}}class Iw extends Fe{constructor(t=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:t},t!==null){const e=[],n=new Set,i=new F,r=new F;if(t.index!==null){const l=t.attributes.position,u=t.index;let A=t.groups;A.length===0&&(A=[{start:0,count:u.count,materialIndex:0}]);for(let d=0,m=A.length;d<m;++d){const g=A[d],y=g.start,v=g.count;for(let C=y,I=y+v;C<I;C+=3)for(let S=0;S<3;S++){const E=u.getX(C+S),B=u.getX(C+(S+1)%3);i.fromBufferAttribute(l,E),r.fromBufferAttribute(l,B),o2(i,r,n)===!0&&(e.push(i.x,i.y,i.z),e.push(r.x,r.y,r.z))}}}else{const l=t.attributes.position;for(let u=0,A=l.count/3;u<A;u++)for(let d=0;d<3;d++){const m=3*u+d,g=3*u+(d+1)%3;i.fromBufferAttribute(l,m),r.fromBufferAttribute(l,g),o2(i,r,n)===!0&&(e.push(i.x,i.y,i.z),e.push(r.x,r.y,r.z))}}this.setAttribute("position",new Ce(e,3))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}function o2(s,t,e){const n=`${s.x},${s.y},${s.z}-${t.x},${t.y},${t.z}`,i=`${t.x},${t.y},${t.z}-${s.x},${s.y},${s.z}`;return e.has(n)===!0||e.has(i)===!0?!1:(e.add(n),e.add(i),!0)}var l2=Object.freeze({__proto__:null,BoxGeometry:pr,CapsuleGeometry:_E,CircleGeometry:CE,ConeGeometry:o0,CylinderGeometry:Ea,DodecahedronGeometry:bE,EdgesGeometry:gw,ExtrudeGeometry:IE,IcosahedronGeometry:BE,LatheGeometry:ME,OctahedronGeometry:xo,PlaneGeometry:kr,PolyhedronGeometry:mh,RingGeometry:wE,ShapeGeometry:TE,SphereGeometry:lp,TetrahedronGeometry:QE,TorusGeometry:ch,TorusKnotGeometry:DE,TubeGeometry:RE,WireframeGeometry:Iw});class Bw extends ba{constructor(t){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new le(0),this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.fog=t.fog,this}}class l0 extends $a{constructor(t){super(t),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class Xm extends ba{constructor(t){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new le(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new le(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=gh,this.normalScale=new Dt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new _r,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Mw extends Xm{constructor(t){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Dt(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Je(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new le(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new le(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new le(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(t)}get anisotropy(){return this._anisotropy}set anisotropy(t){this._anisotropy>0!=t>0&&this.version++,this._anisotropy=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get iridescence(){return this._iridescence}set iridescence(t){this._iridescence>0!=t>0&&this.version++,this._iridescence=t}get dispersion(){return this._dispersion}set dispersion(t){this._dispersion>0!=t>0&&this.version++,this._dispersion=t}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=t.anisotropy,this.anisotropyRotation=t.anisotropyRotation,this.anisotropyMap=t.anisotropyMap,this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.dispersion=t.dispersion,this.ior=t.ior,this.iridescence=t.iridescence,this.iridescenceMap=t.iridescenceMap,this.iridescenceIOR=t.iridescenceIOR,this.iridescenceThicknessRange=[...t.iridescenceThicknessRange],this.iridescenceThicknessMap=t.iridescenceThicknessMap,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}class ww extends ba{constructor(t){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new le(16777215),this.specular=new le(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new le(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=gh,this.normalScale=new Dt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new _r,this.combine=n0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Tw extends ba{constructor(t){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new le(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new le(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=gh,this.normalScale=new Dt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}class Qw extends ba{constructor(t){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=gh,this.normalScale=new Dt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}class Dw extends ba{constructor(t){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new le(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new le(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=gh,this.normalScale=new Dt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new _r,this.combine=n0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class HS extends ba{constructor(t){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=XM,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}class VS extends ba{constructor(t){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(t)}copy(t){return super.copy(t),this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}class Rw extends ba{constructor(t){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new le(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=gh,this.normalScale=new Dt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Nw extends na{constructor(t){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}function Uf(s,t){return!s||s.constructor===t?s:typeof t.BYTES_PER_ELEMENT=="number"?new t(s):Array.prototype.slice.call(s)}function Uw(s){return ArrayBuffer.isView(s)&&!(s instanceof DataView)}function Lw(s){function t(i,r){return s[i]-s[r]}const e=s.length,n=new Array(e);for(let i=0;i!==e;++i)n[i]=i;return n.sort(t),n}function Rb(s,t,e){const n=s.length,i=new s.constructor(n);for(let r=0,l=0;l!==n;++r){const u=e[r]*t;for(let A=0;A!==t;++A)i[l++]=s[u+A]}return i}function YS(s,t,e,n){let i=1,r=s[0];for(;r!==void 0&&r[n]===void 0;)r=s[i++];if(r===void 0)return;let l=r[n];if(l!==void 0)if(Array.isArray(l))do l=r[n],l!==void 0&&(t.push(r.time),e.push(...l)),r=s[i++];while(r!==void 0);else if(l.toArray!==void 0)do l=r[n],l!==void 0&&(t.push(r.time),l.toArray(e,e.length)),r=s[i++];while(r!==void 0);else do l=r[n],l!==void 0&&(t.push(r.time),e.push(l)),r=s[i++];while(r!==void 0)}function tN(s,t,e,n,i=30){const r=s.clone();r.name=t;const l=[];for(let A=0;A<r.tracks.length;++A){const d=r.tracks[A],m=d.getValueSize(),g=[],y=[];for(let v=0;v<d.times.length;++v){const C=d.times[v]*i;if(!(C<e||C>=n)){g.push(d.times[v]);for(let I=0;I<m;++I)y.push(d.values[v*m+I])}}g.length!==0&&(d.times=Uf(g,d.times.constructor),d.values=Uf(y,d.values.constructor),l.push(d))}r.tracks=l;let u=1/0;for(let A=0;A<r.tracks.length;++A)u>r.tracks[A].times[0]&&(u=r.tracks[A].times[0]);for(let A=0;A<r.tracks.length;++A)r.tracks[A].shift(-1*u);return r.resetDuration(),r}function eN(s,t=0,e=s,n=30){n<=0&&(n=30);const i=e.tracks.length,r=t/n;for(let l=0;l<i;++l){const u=e.tracks[l],A=u.ValueTypeName;if(A==="bool"||A==="string")continue;const d=s.tracks.find(function(E){return E.name===u.name&&E.ValueTypeName===A});if(d===void 0)continue;let m=0;const g=u.getValueSize();u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(m=g/3);let y=0;const v=d.getValueSize();d.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(y=v/3);const C=u.times.length-1;let I;if(r<=u.times[0]){const E=m,B=g-m;I=u.values.slice(E,B)}else if(r>=u.times[C]){const E=C*g+m,B=E+g-m;I=u.values.slice(E,B)}else{const E=u.createInterpolant(),B=m,w=g-m;E.evaluate(r),I=E.resultBuffer.slice(B,w)}A==="quaternion"&&new Ge().fromArray(I).normalize().conjugate().toArray(I);const S=d.times.length;for(let E=0;E<S;++E){const B=E*v+y;if(A==="quaternion")Ge.multiplyQuaternionsFlat(d.values,B,I,0,d.values,B);else{const w=v-y*2;for(let Q=0;Q<w;++Q)d.values[B+Q]-=I[Q]}}}return s.blendMode=xS,s}class nN{static convertArray(t,e){return Uf(t,e)}static isTypedArray(t){return Uw(t)}static getKeyframeOrder(t){return Lw(t)}static sortedArray(t,e,n){return Rb(t,e,n)}static flattenJSON(t,e,n,i){YS(t,e,n,i)}static subclip(t,e,n,i,r=30){return tN(t,e,n,i,r)}static makeClipAdditive(t,e=0,n=t,i=30){return eN(t,e,n,i)}}class c0{constructor(t,e,n,i){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new e.constructor(n),this.sampleValues=e,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let n=this._cachedIndex,i=e[n],r=e[n-1];t:{e:{let l;n:{i:if(!(t<i)){for(let u=n+2;;){if(i===void 0){if(t<r)break i;return n=e.length,this._cachedIndex=n,this.copySampleValue_(n-1)}if(n===u)break;if(r=i,i=e[++n],t<i)break e}l=e.length;break n}if(!(t>=r)){const u=e[1];t<u&&(n=2,r=u);for(let A=n-2;;){if(r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(n===A)break;if(i=r,r=e[--n-1],t>=r)break e}l=n,n=0;break n}break t}for(;n<l;){const u=n+l>>>1;t<e[u]?l=u:n=u+1}if(i=e[n],r=e[n-1],r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===void 0)return n=e.length,this._cachedIndex=n,this.copySampleValue_(n-1)}this._cachedIndex=n,this.intervalChanged_(n,r,i)}return this.interpolate_(n,r,t,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=t*i;for(let l=0;l!==i;++l)e[l]=n[r+l];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class zw extends c0{constructor(t,e,n,i){super(t,e,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Df,endingEnd:Df}}intervalChanged_(t,e,n){const i=this.parameterPositions;let r=t-2,l=t+1,u=i[r],A=i[l];if(u===void 0)switch(this.getSettings_().endingStart){case Rf:r=t,u=2*e-n;break;case Om:r=i.length-2,u=e+i[r]-i[r+1];break;default:r=t,u=n}if(A===void 0)switch(this.getSettings_().endingEnd){case Rf:l=t,A=2*n-e;break;case Om:l=1,A=n+i[1]-i[0];break;default:l=t-1,A=e}const d=(n-e)*.5,m=this.valueSize;this._weightPrev=d/(e-u),this._weightNext=d/(A-n),this._offsetPrev=r*m,this._offsetNext=l*m}interpolate_(t,e,n,i){const r=this.resultBuffer,l=this.sampleValues,u=this.valueSize,A=t*u,d=A-u,m=this._offsetPrev,g=this._offsetNext,y=this._weightPrev,v=this._weightNext,C=(n-e)/(i-e),I=C*C,S=I*C,E=-y*S+2*y*I-y*C,B=(1+y)*S+(-1.5-2*y)*I+(-.5+y)*C+1,w=(-1-v)*S+(1.5+v)*I+.5*C,Q=v*S-v*I;for(let R=0;R!==u;++R)r[R]=E*l[m+R]+B*l[d+R]+w*l[A+R]+Q*l[g+R];return r}}class qS extends c0{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const r=this.resultBuffer,l=this.sampleValues,u=this.valueSize,A=t*u,d=A-u,m=(n-e)/(i-e),g=1-m;for(let y=0;y!==u;++y)r[y]=l[d+y]*g+l[A+y]*m;return r}}class Ow extends c0{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t){return this.copySampleValue_(t-1)}}class Bo{constructor(t,e,n,i){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=Uf(e,this.TimeBufferType),this.values=Uf(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let n;if(e.toJSON!==this.toJSON)n=e.toJSON(t);else{n={name:t.name,times:Uf(t.times,Array),values:Uf(t.values,Array)};const i=t.getInterpolation();i!==t.DefaultInterpolation&&(n.interpolation=i)}return n.type=t.ValueTypeName,n}InterpolantFactoryMethodDiscrete(t){return new Ow(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new qS(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new zw(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case zm:e=this.InterpolantFactoryMethodDiscrete;break;case Xv:e=this.InterpolantFactoryMethodLinear;break;case nv:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return ge("KeyframeTrack:",n),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return zm;case this.InterpolantFactoryMethodLinear:return Xv;case this.InterpolantFactoryMethodSmooth:return nv}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]*=t}return this}trim(t,e){const n=this.times,i=n.length;let r=0,l=i-1;for(;r!==i&&n[r]<t;)++r;for(;l!==-1&&n[l]>e;)--l;if(++l,r!==0||l!==i){r>=l&&(l=Math.max(l,1),r=l-1);const u=this.getValueSize();this.times=n.slice(r,l),this.values=this.values.slice(r*u,l*u)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(nn("KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,i=this.values,r=n.length;r===0&&(nn("KeyframeTrack: Track is empty.",this),t=!1);let l=null;for(let u=0;u!==r;u++){const A=n[u];if(typeof A=="number"&&isNaN(A)){nn("KeyframeTrack: Time is not a valid number.",this,u,A),t=!1;break}if(l!==null&&l>A){nn("KeyframeTrack: Out of order keys.",this,u,A,l),t=!1;break}l=A}if(i!==void 0&&Uw(i))for(let u=0,A=i.length;u!==A;++u){const d=i[u];if(isNaN(d)){nn("KeyframeTrack: Value is not a valid number.",this,u,d),t=!1;break}}return t}optimize(){const t=this.times.slice(),e=this.values.slice(),n=this.getValueSize(),i=this.getInterpolation()===nv,r=t.length-1;let l=1;for(let u=1;u<r;++u){let A=!1;const d=t[u],m=t[u+1];if(d!==m&&(u!==1||d!==t[0]))if(i)A=!0;else{const g=u*n,y=g-n,v=g+n;for(let C=0;C!==n;++C){const I=e[g+C];if(I!==e[y+C]||I!==e[v+C]){A=!0;break}}}if(A){if(u!==l){t[l]=t[u];const g=u*n,y=l*n;for(let v=0;v!==n;++v)e[y+v]=e[g+v]}++l}}if(r>0){t[l]=t[r];for(let u=r*n,A=l*n,d=0;d!==n;++d)e[A+d]=e[u+d];++l}return l!==t.length?(this.times=t.slice(0,l),this.values=e.slice(0,l*n)):(this.times=t,this.values=e),this}clone(){const t=this.times.slice(),e=this.values.slice(),n=this.constructor,i=new n(this.name,t,e);return i.createInterpolant=this.createInterpolant,i}}Bo.prototype.ValueTypeName="";Bo.prototype.TimeBufferType=Float32Array;Bo.prototype.ValueBufferType=Float32Array;Bo.prototype.DefaultInterpolation=Xv;class eA extends Bo{constructor(t,e,n){super(t,e,n)}}eA.prototype.ValueTypeName="bool";eA.prototype.ValueBufferType=Array;eA.prototype.DefaultInterpolation=zm;eA.prototype.InterpolantFactoryMethodLinear=void 0;eA.prototype.InterpolantFactoryMethodSmooth=void 0;class XS extends Bo{constructor(t,e,n,i){super(t,e,n,i)}}XS.prototype.ValueTypeName="color";class Jm extends Bo{constructor(t,e,n,i){super(t,e,n,i)}}Jm.prototype.ValueTypeName="number";class Fw extends c0{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const r=this.resultBuffer,l=this.sampleValues,u=this.valueSize,A=(n-e)/(i-e);let d=t*u;for(let m=d+u;d!==m;d+=4)Ge.slerpFlat(r,0,l,d-u,l,d,A);return r}}class u0 extends Bo{constructor(t,e,n,i){super(t,e,n,i)}InterpolantFactoryMethodLinear(t){return new Fw(this.times,this.values,this.getValueSize(),t)}}u0.prototype.ValueTypeName="quaternion";u0.prototype.InterpolantFactoryMethodSmooth=void 0;class nA extends Bo{constructor(t,e,n){super(t,e,n)}}nA.prototype.ValueTypeName="string";nA.prototype.ValueBufferType=Array;nA.prototype.DefaultInterpolation=zm;nA.prototype.InterpolantFactoryMethodLinear=void 0;nA.prototype.InterpolantFactoryMethodSmooth=void 0;class Zm extends Bo{constructor(t,e,n,i){super(t,e,n,i)}}Zm.prototype.ValueTypeName="vector";class Wm{constructor(t="",e=-1,n=[],i=dE){this.name=t,this.tracks=n,this.duration=e,this.blendMode=i,this.uuid=Yr(),this.userData={},this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,i=1/(t.fps||1);for(let l=0,u=n.length;l!==u;++l)e.push(sN(n[l]).scale(i));const r=new this(t.name,t.duration,e,t.blendMode);return r.uuid=t.uuid,r.userData=JSON.parse(t.userData||"{}"),r}static toJSON(t){const e=[],n=t.tracks,i={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode,userData:JSON.stringify(t.userData)};for(let r=0,l=n.length;r!==l;++r)e.push(Bo.toJSON(n[r]));return i}static CreateFromMorphTargetSequence(t,e,n,i){const r=e.length,l=[];for(let u=0;u<r;u++){let A=[],d=[];A.push((u+r-1)%r,u,(u+1)%r),d.push(0,1,0);const m=Lw(A);A=Rb(A,1,m),d=Rb(d,1,m),!i&&A[0]===0&&(A.push(r),d.push(d[0])),l.push(new Jm(".morphTargetInfluences["+e[u].name+"]",A,d).scale(1/n))}return new this(t,-1,l)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const i=t;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===e)return n[i];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const i={},r=/^([\w-]*?)([\d]+)$/;for(let u=0,A=t.length;u<A;u++){const d=t[u],m=d.name.match(r);if(m&&m.length>1){const g=m[1];let y=i[g];y||(i[g]=y=[]),y.push(d)}}const l=[];for(const u in i)l.push(this.CreateFromMorphTargetSequence(u,i[u],e,n));return l}static parseAnimation(t,e){if(ge("AnimationClip: parseAnimation() is deprecated and will be removed with r185"),!t)return nn("AnimationClip: No animation in JSONLoader data."),null;const n=function(g,y,v,C,I){if(v.length!==0){const S=[],E=[];YS(v,S,E,C),S.length!==0&&I.push(new g(y,S,E))}},i=[],r=t.name||"default",l=t.fps||30,u=t.blendMode;let A=t.length||-1;const d=t.hierarchy||[];for(let g=0;g<d.length;g++){const y=d[g].keys;if(!(!y||y.length===0))if(y[0].morphTargets){const v={};let C;for(C=0;C<y.length;C++)if(y[C].morphTargets)for(let I=0;I<y[C].morphTargets.length;I++)v[y[C].morphTargets[I]]=-1;for(const I in v){const S=[],E=[];for(let B=0;B!==y[C].morphTargets.length;++B){const w=y[C];S.push(w.time),E.push(w.morphTarget===I?1:0)}i.push(new Jm(".morphTargetInfluence["+I+"]",S,E))}A=v.length*l}else{const v=".bones["+e[g].name+"]";n(Zm,v+".position",y,"pos",i),n(u0,v+".quaternion",y,"rot",i),n(Zm,v+".scale",y,"scl",i)}}return i.length===0?null:new this(r,A,i,u)}resetDuration(){const t=this.tracks;let e=0;for(let n=0,i=t.length;n!==i;++n){const r=this.tracks[n];e=Math.max(e,r.times[r.times.length-1])}return this.duration=e,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let n=0;n<this.tracks.length;n++)t.push(this.tracks[n].clone());const e=new this.constructor(this.name,this.duration,t,this.blendMode);return e.userData=JSON.parse(JSON.stringify(this.userData)),e}toJSON(){return this.constructor.toJSON(this)}}function iN(s){switch(s.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Jm;case"vector":case"vector2":case"vector3":case"vector4":return Zm;case"color":return XS;case"quaternion":return u0;case"bool":case"boolean":return eA;case"string":return nA}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+s)}function sN(s){if(s.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=iN(s.type);if(s.times===void 0){const e=[],n=[];YS(s.keys,e,n,"value"),s.times=e,s.values=n}return t.parse!==void 0?t.parse(s):new t(s.name,s.times,s.values,s.interpolation)}const ec={enabled:!1,files:{},add:function(s,t){this.enabled!==!1&&(this.files[s]=t)},get:function(s){if(this.enabled!==!1)return this.files[s]},remove:function(s){delete this.files[s]},clear:function(){this.files={}}};class JS{constructor(t,e,n){const i=this;let r=!1,l=0,u=0,A;const d=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this._abortController=null,this.itemStart=function(m){u++,r===!1&&i.onStart!==void 0&&i.onStart(m,l,u),r=!0},this.itemEnd=function(m){l++,i.onProgress!==void 0&&i.onProgress(m,l,u),l===u&&(r=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(m){i.onError!==void 0&&i.onError(m)},this.resolveURL=function(m){return A?A(m):m},this.setURLModifier=function(m){return A=m,this},this.addHandler=function(m,g){return d.push(m,g),this},this.removeHandler=function(m){const g=d.indexOf(m);return g!==-1&&d.splice(g,2),this},this.getHandler=function(m){for(let g=0,y=d.length;g<y;g+=2){const v=d[g],C=d[g+1];if(v.global&&(v.lastIndex=0),v.test(m))return C}return null},this.abort=function(){return this.abortController.abort(),this._abortController=null,this}}get abortController(){return this._abortController||(this._abortController=new AbortController),this._abortController}}const Hd=new JS;let tr=class{constructor(t){this.manager=t!==void 0?t:Hd,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise(function(i,r){n.load(t,i,e,r)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}abort(){return this}};tr.DEFAULT_MATERIAL_NAME="__DEFAULT";const qc={};class aN extends Error{constructor(t,e){super(t),this.response=e}}class ac extends tr{constructor(t){super(t),this.mimeType="",this.responseType="",this._abortController=new AbortController}load(t,e,n,i){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=ec.get(`file:${t}`);if(r!==void 0)return this.manager.itemStart(t),setTimeout(()=>{e&&e(r),this.manager.itemEnd(t)},0),r;if(qc[t]!==void 0){qc[t].push({onLoad:e,onProgress:n,onError:i});return}qc[t]=[],qc[t].push({onLoad:e,onProgress:n,onError:i});const l=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin",signal:typeof AbortSignal.any=="function"?AbortSignal.any([this._abortController.signal,this.manager.abortController.signal]):this._abortController.signal}),u=this.mimeType,A=this.responseType;fetch(l).then(d=>{if(d.status===200||d.status===0){if(d.status===0&&ge("FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||d.body===void 0||d.body.getReader===void 0)return d;const m=qc[t],g=d.body.getReader(),y=d.headers.get("X-File-Size")||d.headers.get("Content-Length"),v=y?parseInt(y):0,C=v!==0;let I=0;const S=new ReadableStream({start(E){B();function B(){g.read().then(({done:w,value:Q})=>{if(w)E.close();else{I+=Q.byteLength;const R=new ProgressEvent("progress",{lengthComputable:C,loaded:I,total:v});for(let D=0,U=m.length;D<U;D++){const P=m[D];P.onProgress&&P.onProgress(R)}E.enqueue(Q),B()}},w=>{E.error(w)})}}});return new Response(S)}else throw new aN(`fetch for "${d.url}" responded with ${d.status}: ${d.statusText}`,d)}).then(d=>{switch(A){case"arraybuffer":return d.arrayBuffer();case"blob":return d.blob();case"document":return d.text().then(m=>new DOMParser().parseFromString(m,u));case"json":return d.json();default:if(u==="")return d.text();{const g=/charset="?([^;"\s]*)"?/i.exec(u),y=g&&g[1]?g[1].toLowerCase():void 0,v=new TextDecoder(y);return d.arrayBuffer().then(C=>v.decode(C))}}}).then(d=>{ec.add(`file:${t}`,d);const m=qc[t];delete qc[t];for(let g=0,y=m.length;g<y;g++){const v=m[g];v.onLoad&&v.onLoad(d)}}).catch(d=>{const m=qc[t];if(m===void 0)throw this.manager.itemError(t),d;delete qc[t];for(let g=0,y=m.length;g<y;g++){const v=m[g];v.onError&&v.onError(d)}this.manager.itemError(t)}).finally(()=>{this.manager.itemEnd(t)}),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}abort(){return this._abortController.abort(),this._abortController=new AbortController,this}}class rN extends tr{constructor(t){super(t)}load(t,e,n,i){const r=this,l=new ac(this.manager);l.setPath(this.path),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(t,function(u){try{e(r.parse(JSON.parse(u)))}catch(A){i?i(A):nn(A),r.manager.itemError(t)}},n,i)}parse(t){const e=[];for(let n=0;n<t.length;n++){const i=Wm.parse(t[n]);e.push(i)}return e}}class oN extends tr{constructor(t){super(t)}load(t,e,n,i){const r=this,l=[],u=new EE,A=new ac(this.manager);A.setPath(this.path),A.setResponseType("arraybuffer"),A.setRequestHeader(this.requestHeader),A.setWithCredentials(r.withCredentials);let d=0;function m(g){A.load(t[g],function(y){const v=r.parse(y,!0);l[g]={width:v.width,height:v.height,format:v.format,mipmaps:v.mipmaps},d+=1,d===6&&(v.mipmapCount===1&&(u.minFilter=as),u.image=l,u.format=v.format,u.needsUpdate=!0,e&&e(u))},n,i)}if(Array.isArray(t))for(let g=0,y=t.length;g<y;++g)m(g);else A.load(t,function(g){const y=r.parse(g,!0);if(y.isCubemap){const v=y.mipmaps.length/y.mipmapCount;for(let C=0;C<v;C++){l[C]={mipmaps:[]};for(let I=0;I<y.mipmapCount;I++)l[C].mipmaps.push(y.mipmaps[C*y.mipmapCount+I]),l[C].format=y.format,l[C].width=y.width,l[C].height=y.height}u.image=l}else u.image.width=y.width,u.image.height=y.height,u.mipmaps=y.mipmaps;y.mipmapCount===1&&(u.minFilter=as),u.format=y.format,u.needsUpdate=!0,e&&e(u)},n,i);return u}}const xd=new WeakMap;class jm extends tr{constructor(t){super(t)}load(t,e,n,i){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,l=ec.get(`image:${t}`);if(l!==void 0){if(l.complete===!0)r.manager.itemStart(t),setTimeout(function(){e&&e(l),r.manager.itemEnd(t)},0);else{let g=xd.get(l);g===void 0&&(g=[],xd.set(l,g)),g.push({onLoad:e,onError:i})}return l}const u=km("img");function A(){m(),e&&e(this);const g=xd.get(this)||[];for(let y=0;y<g.length;y++){const v=g[y];v.onLoad&&v.onLoad(this)}xd.delete(this),r.manager.itemEnd(t)}function d(g){m(),i&&i(g),ec.remove(`image:${t}`);const y=xd.get(this)||[];for(let v=0;v<y.length;v++){const C=y[v];C.onError&&C.onError(g)}xd.delete(this),r.manager.itemError(t),r.manager.itemEnd(t)}function m(){u.removeEventListener("load",A,!1),u.removeEventListener("error",d,!1)}return u.addEventListener("load",A,!1),u.addEventListener("error",d,!1),t.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(u.crossOrigin=this.crossOrigin),ec.add(`image:${t}`,u),r.manager.itemStart(t),u.src=t,u}}class lN extends tr{constructor(t){super(t)}load(t,e,n,i){const r=new r0;r.colorSpace=ks;const l=new jm(this.manager);l.setCrossOrigin(this.crossOrigin),l.setPath(this.path);let u=0;function A(d){l.load(t[d],function(m){r.images[d]=m,u++,u===6&&(r.needsUpdate=!0,e&&e(r))},void 0,i)}for(let d=0;d<t.length;++d)A(d);return r}}class cN extends tr{constructor(t){super(t)}load(t,e,n,i){const r=this,l=new So,u=new ac(this.manager);return u.setResponseType("arraybuffer"),u.setRequestHeader(this.requestHeader),u.setPath(this.path),u.setWithCredentials(r.withCredentials),u.load(t,function(A){let d;try{d=r.parse(A)}catch(m){if(i!==void 0)i(m);else{m(m);return}}d.image!==void 0?l.image=d.image:d.data!==void 0&&(l.image.width=d.width,l.image.height=d.height,l.image.data=d.data),l.wrapS=d.wrapS!==void 0?d.wrapS:yr,l.wrapT=d.wrapT!==void 0?d.wrapT:yr,l.magFilter=d.magFilter!==void 0?d.magFilter:as,l.minFilter=d.minFilter!==void 0?d.minFilter:as,l.anisotropy=d.anisotropy!==void 0?d.anisotropy:1,d.colorSpace!==void 0&&(l.colorSpace=d.colorSpace),d.flipY!==void 0&&(l.flipY=d.flipY),d.format!==void 0&&(l.format=d.format),d.type!==void 0&&(l.type=d.type),d.mipmaps!==void 0&&(l.mipmaps=d.mipmaps,l.minFilter=tc),d.mipmapCount===1&&(l.minFilter=as),d.generateMipmaps!==void 0&&(l.generateMipmaps=d.generateMipmaps),l.needsUpdate=!0,e&&e(l,d)},n,i),l}}class NE extends tr{constructor(t){super(t)}load(t,e,n,i){const r=new wi,l=new jm(this.manager);return l.setCrossOrigin(this.crossOrigin),l.setPath(this.path),l.load(t,function(u){r.image=u,r.needsUpdate=!0,e!==void 0&&e(r)},n,i),r}}class yh extends gn{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new le(t),this.intensity=e}dispose(){}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(e.object.target=this.target.uuid),e}}class Pw extends yh{constructor(t,e,n){super(t,n),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(gn.DEFAULT_UP),this.updateMatrix(),this.groundColor=new le(e)}copy(t,e){return super.copy(t,e),this.groundColor.copy(t.groundColor),this}}const xC=new he,c2=new F,u2=new F;class ZS{constructor(t){this.camera=t,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Dt(512,512),this.mapType=ea,this.map=null,this.mapPass=null,this.matrix=new he,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new op,this._frameExtents=new Dt(1,1),this._viewportCount=1,this._viewports=[new We(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;c2.setFromMatrixPosition(t.matrixWorld),e.position.copy(c2),u2.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(u2),e.updateMatrixWorld(),xC.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(xC,e.coordinateSystem,e.reversedDepth),e.reversedDepth?n.set(.5,0,0,.5,0,.5,0,.5,0,0,1,0,0,0,0,1):n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(xC)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.intensity=t.intensity,this.bias=t.bias,this.radius=t.radius,this.autoUpdate=t.autoUpdate,this.needsUpdate=t.needsUpdate,this.normalBias=t.normalBias,this.blurSamples=t.blurSamples,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.intensity!==1&&(t.intensity=this.intensity),this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class uN extends ZS{constructor(){super(new As(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1,this.aspect=1}updateMatrices(t){const e=this.camera,n=tp*2*t.angle*this.focus,i=this.mapSize.width/this.mapSize.height*this.aspect,r=t.distance||e.far;(n!==e.fov||i!==e.aspect||r!==e.far)&&(e.fov=n,e.aspect=i,e.far=r,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}class Gw extends yh{constructor(t,e,n=0,i=Math.PI/3,r=0,l=2){super(t,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(gn.DEFAULT_UP),this.updateMatrix(),this.target=new gn,this.distance=n,this.angle=i,this.penumbra=r,this.decay=l,this.map=null,this.shadow=new uN}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}const h2=new he,Xg=new F,vC=new F;class hN extends ZS{constructor(){super(new As(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Dt(4,2),this._viewportCount=6,this._viewports=[new We(2,1,1,1),new We(0,1,1,1),new We(3,1,1,1),new We(1,1,1,1),new We(3,0,1,1),new We(1,0,1,1)],this._cubeDirections=[new F(1,0,0),new F(-1,0,0),new F(0,0,1),new F(0,0,-1),new F(0,1,0),new F(0,-1,0)],this._cubeUps=[new F(0,1,0),new F(0,1,0),new F(0,1,0),new F(0,1,0),new F(0,0,1),new F(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,i=this.matrix,r=t.distance||n.far;r!==n.far&&(n.far=r,n.updateProjectionMatrix()),Xg.setFromMatrixPosition(t.matrixWorld),n.position.copy(Xg),vC.copy(n.position),vC.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(vC),n.updateMatrixWorld(),i.makeTranslation(-Xg.x,-Xg.y,-Xg.z),h2.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(h2,n.coordinateSystem,n.reversedDepth)}}class kw extends yh{constructor(t,e,n=0,i=2){super(t,e),this.isPointLight=!0,this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new hN}get power(){return this.intensity*4*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}class cp extends pE{constructor(t=-1,e=1,n=1,i=-1,r=.1,l=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=r,this.far=l,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,n,i,r,l){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=l,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-t,l=n+t,u=i+e,A=i-e;if(this.view!==null&&this.view.enabled){const d=(this.right-this.left)/this.view.fullWidth/this.zoom,m=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=d*this.view.offsetX,l=r+d*this.view.width,u-=m*this.view.offsetY,A=u-m*this.view.height}this.projectionMatrix.makeOrthographic(r,l,u,A,this.near,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}class fN extends ZS{constructor(){super(new cp(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class Hw extends yh{constructor(t,e){super(t,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(gn.DEFAULT_UP),this.updateMatrix(),this.target=new gn,this.shadow=new fN}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}class Vw extends yh{constructor(t,e){super(t,e),this.isAmbientLight=!0,this.type="AmbientLight"}}class Yw extends yh{constructor(t,e,n=10,i=10){super(t,e),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=n,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}class qw{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new F)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,i=t.y,r=t.z,l=this.coefficients;return e.copy(l[0]).multiplyScalar(.282095),e.addScaledVector(l[1],.488603*i),e.addScaledVector(l[2],.488603*r),e.addScaledVector(l[3],.488603*n),e.addScaledVector(l[4],1.092548*(n*i)),e.addScaledVector(l[5],1.092548*(i*r)),e.addScaledVector(l[6],.315392*(3*r*r-1)),e.addScaledVector(l[7],1.092548*(n*r)),e.addScaledVector(l[8],.546274*(n*n-i*i)),e}getIrradianceAt(t,e){const n=t.x,i=t.y,r=t.z,l=this.coefficients;return e.copy(l[0]).multiplyScalar(.886227),e.addScaledVector(l[1],2*.511664*i),e.addScaledVector(l[2],2*.511664*r),e.addScaledVector(l[3],2*.511664*n),e.addScaledVector(l[4],2*.429043*n*i),e.addScaledVector(l[5],2*.429043*i*r),e.addScaledVector(l[6],.743125*r*r-.247708),e.addScaledVector(l[7],2*.429043*n*r),e.addScaledVector(l[8],.429043*(n*n-i*i)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(t,e+i*3);return this}toArray(t=[],e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(t,e+i*3);return t}static getBasisAt(t,e){const n=t.x,i=t.y,r=t.z;e[0]=.282095,e[1]=.488603*i,e[2]=.488603*r,e[3]=.488603*n,e[4]=1.092548*n*i,e[5]=1.092548*i*r,e[6]=.315392*(3*r*r-1),e[7]=1.092548*n*r,e[8]=.546274*(n*n-i*i)}}class Xw extends yh{constructor(t=new qw,e=1){super(void 0,e),this.isLightProbe=!0,this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}class UE extends tr{constructor(t){super(t),this.textures={}}load(t,e,n,i){const r=this,l=new ac(r.manager);l.setPath(r.path),l.setRequestHeader(r.requestHeader),l.setWithCredentials(r.withCredentials),l.load(t,function(u){try{e(r.parse(JSON.parse(u)))}catch(A){i?i(A):nn(A),r.manager.itemError(t)}},n,i)}parse(t){const e=this.textures;function n(r){return e[r]===void 0&&ge("MaterialLoader: Undefined texture",r),e[r]}const i=this.createMaterialFromType(t.type);if(t.uuid!==void 0&&(i.uuid=t.uuid),t.name!==void 0&&(i.name=t.name),t.color!==void 0&&i.color!==void 0&&i.color.setHex(t.color),t.roughness!==void 0&&(i.roughness=t.roughness),t.metalness!==void 0&&(i.metalness=t.metalness),t.sheen!==void 0&&(i.sheen=t.sheen),t.sheenColor!==void 0&&(i.sheenColor=new le().setHex(t.sheenColor)),t.sheenRoughness!==void 0&&(i.sheenRoughness=t.sheenRoughness),t.emissive!==void 0&&i.emissive!==void 0&&i.emissive.setHex(t.emissive),t.specular!==void 0&&i.specular!==void 0&&i.specular.setHex(t.specular),t.specularIntensity!==void 0&&(i.specularIntensity=t.specularIntensity),t.specularColor!==void 0&&i.specularColor!==void 0&&i.specularColor.setHex(t.specularColor),t.shininess!==void 0&&(i.shininess=t.shininess),t.clearcoat!==void 0&&(i.clearcoat=t.clearcoat),t.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=t.clearcoatRoughness),t.dispersion!==void 0&&(i.dispersion=t.dispersion),t.iridescence!==void 0&&(i.iridescence=t.iridescence),t.iridescenceIOR!==void 0&&(i.iridescenceIOR=t.iridescenceIOR),t.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=t.iridescenceThicknessRange),t.transmission!==void 0&&(i.transmission=t.transmission),t.thickness!==void 0&&(i.thickness=t.thickness),t.attenuationDistance!==void 0&&(i.attenuationDistance=t.attenuationDistance),t.attenuationColor!==void 0&&i.attenuationColor!==void 0&&i.attenuationColor.setHex(t.attenuationColor),t.anisotropy!==void 0&&(i.anisotropy=t.anisotropy),t.anisotropyRotation!==void 0&&(i.anisotropyRotation=t.anisotropyRotation),t.fog!==void 0&&(i.fog=t.fog),t.flatShading!==void 0&&(i.flatShading=t.flatShading),t.blending!==void 0&&(i.blending=t.blending),t.combine!==void 0&&(i.combine=t.combine),t.side!==void 0&&(i.side=t.side),t.shadowSide!==void 0&&(i.shadowSide=t.shadowSide),t.opacity!==void 0&&(i.opacity=t.opacity),t.transparent!==void 0&&(i.transparent=t.transparent),t.alphaTest!==void 0&&(i.alphaTest=t.alphaTest),t.alphaHash!==void 0&&(i.alphaHash=t.alphaHash),t.depthFunc!==void 0&&(i.depthFunc=t.depthFunc),t.depthTest!==void 0&&(i.depthTest=t.depthTest),t.depthWrite!==void 0&&(i.depthWrite=t.depthWrite),t.colorWrite!==void 0&&(i.colorWrite=t.colorWrite),t.blendSrc!==void 0&&(i.blendSrc=t.blendSrc),t.blendDst!==void 0&&(i.blendDst=t.blendDst),t.blendEquation!==void 0&&(i.blendEquation=t.blendEquation),t.blendSrcAlpha!==void 0&&(i.blendSrcAlpha=t.blendSrcAlpha),t.blendDstAlpha!==void 0&&(i.blendDstAlpha=t.blendDstAlpha),t.blendEquationAlpha!==void 0&&(i.blendEquationAlpha=t.blendEquationAlpha),t.blendColor!==void 0&&i.blendColor!==void 0&&i.blendColor.setHex(t.blendColor),t.blendAlpha!==void 0&&(i.blendAlpha=t.blendAlpha),t.stencilWriteMask!==void 0&&(i.stencilWriteMask=t.stencilWriteMask),t.stencilFunc!==void 0&&(i.stencilFunc=t.stencilFunc),t.stencilRef!==void 0&&(i.stencilRef=t.stencilRef),t.stencilFuncMask!==void 0&&(i.stencilFuncMask=t.stencilFuncMask),t.stencilFail!==void 0&&(i.stencilFail=t.stencilFail),t.stencilZFail!==void 0&&(i.stencilZFail=t.stencilZFail),t.stencilZPass!==void 0&&(i.stencilZPass=t.stencilZPass),t.stencilWrite!==void 0&&(i.stencilWrite=t.stencilWrite),t.wireframe!==void 0&&(i.wireframe=t.wireframe),t.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=t.wireframeLinewidth),t.wireframeLinecap!==void 0&&(i.wireframeLinecap=t.wireframeLinecap),t.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=t.wireframeLinejoin),t.rotation!==void 0&&(i.rotation=t.rotation),t.linewidth!==void 0&&(i.linewidth=t.linewidth),t.dashSize!==void 0&&(i.dashSize=t.dashSize),t.gapSize!==void 0&&(i.gapSize=t.gapSize),t.scale!==void 0&&(i.scale=t.scale),t.polygonOffset!==void 0&&(i.polygonOffset=t.polygonOffset),t.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=t.polygonOffsetFactor),t.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=t.polygonOffsetUnits),t.dithering!==void 0&&(i.dithering=t.dithering),t.alphaToCoverage!==void 0&&(i.alphaToCoverage=t.alphaToCoverage),t.premultipliedAlpha!==void 0&&(i.premultipliedAlpha=t.premultipliedAlpha),t.forceSinglePass!==void 0&&(i.forceSinglePass=t.forceSinglePass),t.visible!==void 0&&(i.visible=t.visible),t.toneMapped!==void 0&&(i.toneMapped=t.toneMapped),t.userData!==void 0&&(i.userData=t.userData),t.vertexColors!==void 0&&(typeof t.vertexColors=="number"?i.vertexColors=t.vertexColors>0:i.vertexColors=t.vertexColors),t.uniforms!==void 0)for(const r in t.uniforms){const l=t.uniforms[r];switch(i.uniforms[r]={},l.type){case"t":i.uniforms[r].value=n(l.value);break;case"c":i.uniforms[r].value=new le().setHex(l.value);break;case"v2":i.uniforms[r].value=new Dt().fromArray(l.value);break;case"v3":i.uniforms[r].value=new F().fromArray(l.value);break;case"v4":i.uniforms[r].value=new We().fromArray(l.value);break;case"m3":i.uniforms[r].value=new Ze().fromArray(l.value);break;case"m4":i.uniforms[r].value=new he().fromArray(l.value);break;default:i.uniforms[r].value=l.value}}if(t.defines!==void 0&&(i.defines=t.defines),t.vertexShader!==void 0&&(i.vertexShader=t.vertexShader),t.fragmentShader!==void 0&&(i.fragmentShader=t.fragmentShader),t.glslVersion!==void 0&&(i.glslVersion=t.glslVersion),t.extensions!==void 0)for(const r in t.extensions)i.extensions[r]=t.extensions[r];if(t.lights!==void 0&&(i.lights=t.lights),t.clipping!==void 0&&(i.clipping=t.clipping),t.size!==void 0&&(i.size=t.size),t.sizeAttenuation!==void 0&&(i.sizeAttenuation=t.sizeAttenuation),t.map!==void 0&&(i.map=n(t.map)),t.matcap!==void 0&&(i.matcap=n(t.matcap)),t.alphaMap!==void 0&&(i.alphaMap=n(t.alphaMap)),t.bumpMap!==void 0&&(i.bumpMap=n(t.bumpMap)),t.bumpScale!==void 0&&(i.bumpScale=t.bumpScale),t.normalMap!==void 0&&(i.normalMap=n(t.normalMap)),t.normalMapType!==void 0&&(i.normalMapType=t.normalMapType),t.normalScale!==void 0){let r=t.normalScale;Array.isArray(r)===!1&&(r=[r,r]),i.normalScale=new Dt().fromArray(r)}return t.displacementMap!==void 0&&(i.displacementMap=n(t.displacementMap)),t.displacementScale!==void 0&&(i.displacementScale=t.displacementScale),t.displacementBias!==void 0&&(i.displacementBias=t.displacementBias),t.roughnessMap!==void 0&&(i.roughnessMap=n(t.roughnessMap)),t.metalnessMap!==void 0&&(i.metalnessMap=n(t.metalnessMap)),t.emissiveMap!==void 0&&(i.emissiveMap=n(t.emissiveMap)),t.emissiveIntensity!==void 0&&(i.emissiveIntensity=t.emissiveIntensity),t.specularMap!==void 0&&(i.specularMap=n(t.specularMap)),t.specularIntensityMap!==void 0&&(i.specularIntensityMap=n(t.specularIntensityMap)),t.specularColorMap!==void 0&&(i.specularColorMap=n(t.specularColorMap)),t.envMap!==void 0&&(i.envMap=n(t.envMap)),t.envMapRotation!==void 0&&i.envMapRotation.fromArray(t.envMapRotation),t.envMapIntensity!==void 0&&(i.envMapIntensity=t.envMapIntensity),t.reflectivity!==void 0&&(i.reflectivity=t.reflectivity),t.refractionRatio!==void 0&&(i.refractionRatio=t.refractionRatio),t.lightMap!==void 0&&(i.lightMap=n(t.lightMap)),t.lightMapIntensity!==void 0&&(i.lightMapIntensity=t.lightMapIntensity),t.aoMap!==void 0&&(i.aoMap=n(t.aoMap)),t.aoMapIntensity!==void 0&&(i.aoMapIntensity=t.aoMapIntensity),t.gradientMap!==void 0&&(i.gradientMap=n(t.gradientMap)),t.clearcoatMap!==void 0&&(i.clearcoatMap=n(t.clearcoatMap)),t.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=n(t.clearcoatRoughnessMap)),t.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=n(t.clearcoatNormalMap)),t.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new Dt().fromArray(t.clearcoatNormalScale)),t.iridescenceMap!==void 0&&(i.iridescenceMap=n(t.iridescenceMap)),t.iridescenceThicknessMap!==void 0&&(i.iridescenceThicknessMap=n(t.iridescenceThicknessMap)),t.transmissionMap!==void 0&&(i.transmissionMap=n(t.transmissionMap)),t.thicknessMap!==void 0&&(i.thicknessMap=n(t.thicknessMap)),t.anisotropyMap!==void 0&&(i.anisotropyMap=n(t.anisotropyMap)),t.sheenColorMap!==void 0&&(i.sheenColorMap=n(t.sheenColorMap)),t.sheenRoughnessMap!==void 0&&(i.sheenRoughnessMap=n(t.sheenRoughnessMap)),i}setTextures(t){return this.textures=t,this}createMaterialFromType(t){return UE.createMaterialFromType(t)}static createMaterialFromType(t){const e={ShadowMaterial:Bw,SpriteMaterial:QS,RawShaderMaterial:l0,ShaderMaterial:$a,PointsMaterial:NS,MeshPhysicalMaterial:Mw,MeshStandardMaterial:Xm,MeshPhongMaterial:ww,MeshToonMaterial:Tw,MeshNormalMaterial:Qw,MeshLambertMaterial:Dw,MeshDepthMaterial:HS,MeshDistanceMaterial:VS,MeshBasicMaterial:pl,MeshMatcapMaterial:Rw,LineDashedMaterial:Nw,LineBasicMaterial:na,Material:ba};return new e[t]}}class Nb{static extractUrlBase(t){const e=t.lastIndexOf("/");return e===-1?"./":t.slice(0,e+1)}static resolveURL(t,e){return typeof t!="string"||t===""?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class WS extends Fe{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}toJSON(){const t=super.toJSON();return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}class Jw extends tr{constructor(t){super(t)}load(t,e,n,i){const r=this,l=new ac(r.manager);l.setPath(r.path),l.setRequestHeader(r.requestHeader),l.setWithCredentials(r.withCredentials),l.load(t,function(u){try{e(r.parse(JSON.parse(u)))}catch(A){i?i(A):nn(A),r.manager.itemError(t)}},n,i)}parse(t){const e={},n={};function i(v,C){if(e[C]!==void 0)return e[C];const S=v.interleavedBuffers[C],E=r(v,S.buffer),B=kd(S.type,E),w=new yE(B,S.stride);return w.uuid=S.uuid,e[C]=w,w}function r(v,C){if(n[C]!==void 0)return n[C];const S=v.arrayBuffers[C],E=new Uint32Array(S).buffer;return n[C]=E,E}const l=t.isInstancedBufferGeometry?new WS:new Fe,u=t.data.index;if(u!==void 0){const v=kd(u.type,u.array);l.setIndex(new Qn(v,1))}const A=t.data.attributes;for(const v in A){const C=A[v];let I;if(C.isInterleavedBufferAttribute){const S=i(t.data,C.data);I=new qf(S,C.itemSize,C.offset,C.normalized)}else{const S=kd(C.type,C.array),E=C.isInstancedBufferAttribute?Xf:Qn;I=new E(S,C.itemSize,C.normalized)}C.name!==void 0&&(I.name=C.name),C.usage!==void 0&&I.setUsage(C.usage),l.setAttribute(v,I)}const d=t.data.morphAttributes;if(d)for(const v in d){const C=d[v],I=[];for(let S=0,E=C.length;S<E;S++){const B=C[S];let w;if(B.isInterleavedBufferAttribute){const Q=i(t.data,B.data);w=new qf(Q,B.itemSize,B.offset,B.normalized)}else{const Q=kd(B.type,B.array);w=new Qn(Q,B.itemSize,B.normalized)}B.name!==void 0&&(w.name=B.name),I.push(w)}l.morphAttributes[v]=I}t.data.morphTargetsRelative&&(l.morphTargetsRelative=!0);const g=t.data.groups||t.data.drawcalls||t.data.offsets;if(g!==void 0)for(let v=0,C=g.length;v!==C;++v){const I=g[v];l.addGroup(I.start,I.count,I.materialIndex)}const y=t.data.boundingSphere;return y!==void 0&&(l.boundingSphere=new Bs().fromJSON(y)),t.name&&(l.name=t.name),t.userData&&(l.userData=t.userData),l}}class AN extends tr{constructor(t){super(t)}load(t,e,n,i){const r=this,l=this.path===""?Nb.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||l;const u=new ac(this.manager);u.setPath(this.path),u.setRequestHeader(this.requestHeader),u.setWithCredentials(this.withCredentials),u.load(t,function(A){let d=null;try{d=JSON.parse(A)}catch(g){i!==void 0&&i(g),g("ObjectLoader: Can't parse "+t+".",g.message);return}const m=d.metadata;if(m===void 0||m.type===void 0||m.type.toLowerCase()==="geometry"){i!==void 0&&i(new Error("THREE.ObjectLoader: Can't load "+t)),nn("ObjectLoader: Can't load "+t);return}r.parse(d,e)},n,i)}async loadAsync(t,e){const n=this,i=this.path===""?Nb.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||i;const r=new ac(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials);const l=await r.loadAsync(t,e),u=JSON.parse(l),A=u.metadata;if(A===void 0||A.type===void 0||A.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+t);return await n.parseAsync(u)}parse(t,e){const n=this.parseAnimations(t.animations),i=this.parseShapes(t.shapes),r=this.parseGeometries(t.geometries,i),l=this.parseImages(t.images,function(){e!==void 0&&e(d)}),u=this.parseTextures(t.textures,l),A=this.parseMaterials(t.materials,u),d=this.parseObject(t.object,r,A,u,n),m=this.parseSkeletons(t.skeletons,d);if(this.bindSkeletons(d,m),this.bindLightTargets(d),e!==void 0){let g=!1;for(const y in l)if(l[y].data instanceof HTMLImageElement){g=!0;break}g===!1&&e(d)}return d}async parseAsync(t){const e=this.parseAnimations(t.animations),n=this.parseShapes(t.shapes),i=this.parseGeometries(t.geometries,n),r=await this.parseImagesAsync(t.images),l=this.parseTextures(t.textures,r),u=this.parseMaterials(t.materials,l),A=this.parseObject(t.object,i,u,l,e),d=this.parseSkeletons(t.skeletons,A);return this.bindSkeletons(A,d),this.bindLightTargets(A),A}parseShapes(t){const e={};if(t!==void 0)for(let n=0,i=t.length;n<i;n++){const r=new Vf().fromJSON(t[n]);e[r.uuid]=r}return e}parseSkeletons(t,e){const n={},i={};if(e.traverse(function(r){r.isBone&&(i[r.uuid]=r)}),t!==void 0)for(let r=0,l=t.length;r<l;r++){const u=new xE().fromJSON(t[r],i);n[u.uuid]=u}return n}parseGeometries(t,e){const n={};if(t!==void 0){const i=new Jw;for(let r=0,l=t.length;r<l;r++){let u;const A=t[r];switch(A.type){case"BufferGeometry":case"InstancedBufferGeometry":u=i.parse(A);break;default:A.type in l2?u=l2[A.type].fromJSON(A,e):ge(`ObjectLoader: Unsupported geometry type "${A.type}"`)}u.uuid=A.uuid,A.name!==void 0&&(u.name=A.name),A.userData!==void 0&&(u.userData=A.userData),n[A.uuid]=u}}return n}parseMaterials(t,e){const n={},i={};if(t!==void 0){const r=new UE;r.setTextures(e);for(let l=0,u=t.length;l<u;l++){const A=t[l];n[A.uuid]===void 0&&(n[A.uuid]=r.parse(A)),i[A.uuid]=n[A.uuid]}}return i}parseAnimations(t){const e={};if(t!==void 0)for(let n=0;n<t.length;n++){const i=t[n],r=Wm.parse(i);e[r.uuid]=r}return e}parseImages(t,e){const n=this,i={};let r;function l(A){return n.manager.itemStart(A),r.load(A,function(){n.manager.itemEnd(A)},void 0,function(){n.manager.itemError(A),n.manager.itemEnd(A)})}function u(A){if(typeof A=="string"){const d=A,m=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(d)?d:n.resourcePath+d;return l(m)}else return A.data?{data:kd(A.type,A.data),width:A.width,height:A.height}:null}if(t!==void 0&&t.length>0){const A=new JS(e);r=new jm(A),r.setCrossOrigin(this.crossOrigin);for(let d=0,m=t.length;d<m;d++){const g=t[d],y=g.url;if(Array.isArray(y)){const v=[];for(let C=0,I=y.length;C<I;C++){const S=y[C],E=u(S);E!==null&&(E instanceof HTMLImageElement?v.push(E):v.push(new So(E.data,E.width,E.height)))}i[g.uuid]=new lh(v)}else{const v=u(g.url);i[g.uuid]=new lh(v)}}}return i}async parseImagesAsync(t){const e=this,n={};let i;async function r(l){if(typeof l=="string"){const u=l,A=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(u)?u:e.resourcePath+u;return await i.loadAsync(A)}else return l.data?{data:kd(l.type,l.data),width:l.width,height:l.height}:null}if(t!==void 0&&t.length>0){i=new jm(this.manager),i.setCrossOrigin(this.crossOrigin);for(let l=0,u=t.length;l<u;l++){const A=t[l],d=A.url;if(Array.isArray(d)){const m=[];for(let g=0,y=d.length;g<y;g++){const v=d[g],C=await r(v);C!==null&&(C instanceof HTMLImageElement?m.push(C):m.push(new So(C.data,C.width,C.height)))}n[A.uuid]=new lh(m)}else{const m=await r(A.url);n[A.uuid]=new lh(m)}}}return n}parseTextures(t,e){function n(r,l){return typeof r=="number"?r:(ge("ObjectLoader.parseTexture: Constant should be in numeric form.",r),l[r])}const i={};if(t!==void 0)for(let r=0,l=t.length;r<l;r++){const u=t[r];u.image===void 0&&ge('ObjectLoader: No "image" specified for',u.uuid),e[u.image]===void 0&&ge("ObjectLoader: Undefined image",u.image);const A=e[u.image],d=A.data;let m;Array.isArray(d)?(m=new r0,d.length===6&&(m.needsUpdate=!0)):(d&&d.data?m=new So:m=new wi,d&&(m.needsUpdate=!0)),m.source=A,m.uuid=u.uuid,u.name!==void 0&&(m.name=u.name),u.mapping!==void 0&&(m.mapping=n(u.mapping,dN)),u.channel!==void 0&&(m.channel=u.channel),u.offset!==void 0&&m.offset.fromArray(u.offset),u.repeat!==void 0&&m.repeat.fromArray(u.repeat),u.center!==void 0&&m.center.fromArray(u.center),u.rotation!==void 0&&(m.rotation=u.rotation),u.wrap!==void 0&&(m.wrapS=n(u.wrap[0],f2),m.wrapT=n(u.wrap[1],f2)),u.format!==void 0&&(m.format=u.format),u.internalFormat!==void 0&&(m.internalFormat=u.internalFormat),u.type!==void 0&&(m.type=u.type),u.colorSpace!==void 0&&(m.colorSpace=u.colorSpace),u.minFilter!==void 0&&(m.minFilter=n(u.minFilter,A2)),u.magFilter!==void 0&&(m.magFilter=n(u.magFilter,A2)),u.anisotropy!==void 0&&(m.anisotropy=u.anisotropy),u.flipY!==void 0&&(m.flipY=u.flipY),u.generateMipmaps!==void 0&&(m.generateMipmaps=u.generateMipmaps),u.premultiplyAlpha!==void 0&&(m.premultiplyAlpha=u.premultiplyAlpha),u.unpackAlignment!==void 0&&(m.unpackAlignment=u.unpackAlignment),u.compareFunction!==void 0&&(m.compareFunction=u.compareFunction),u.userData!==void 0&&(m.userData=u.userData),i[u.uuid]=m}return i}parseObject(t,e,n,i,r){let l;function u(y){return e[y]===void 0&&ge("ObjectLoader: Undefined geometry",y),e[y]}function A(y){if(y!==void 0){if(Array.isArray(y)){const v=[];for(let C=0,I=y.length;C<I;C++){const S=y[C];n[S]===void 0&&ge("ObjectLoader: Undefined material",S),v.push(n[S])}return v}return n[y]===void 0&&ge("ObjectLoader: Undefined material",y),n[y]}}function d(y){return i[y]===void 0&&ge("ObjectLoader: Undefined texture",y),i[y]}let m,g;switch(t.type){case"Scene":l=new TS,t.background!==void 0&&(Number.isInteger(t.background)?l.background=new le(t.background):l.background=d(t.background)),t.environment!==void 0&&(l.environment=d(t.environment)),t.fog!==void 0&&(t.fog.type==="Fog"?l.fog=new mE(t.fog.color,t.fog.near,t.fog.far):t.fog.type==="FogExp2"&&(l.fog=new gE(t.fog.color,t.fog.density)),t.fog.name!==""&&(l.fog.name=t.fog.name)),t.backgroundBlurriness!==void 0&&(l.backgroundBlurriness=t.backgroundBlurriness),t.backgroundIntensity!==void 0&&(l.backgroundIntensity=t.backgroundIntensity),t.backgroundRotation!==void 0&&l.backgroundRotation.fromArray(t.backgroundRotation),t.environmentIntensity!==void 0&&(l.environmentIntensity=t.environmentIntensity),t.environmentRotation!==void 0&&l.environmentRotation.fromArray(t.environmentRotation);break;case"PerspectiveCamera":l=new As(t.fov,t.aspect,t.near,t.far),t.focus!==void 0&&(l.focus=t.focus),t.zoom!==void 0&&(l.zoom=t.zoom),t.filmGauge!==void 0&&(l.filmGauge=t.filmGauge),t.filmOffset!==void 0&&(l.filmOffset=t.filmOffset),t.view!==void 0&&(l.view=Object.assign({},t.view));break;case"OrthographicCamera":l=new cp(t.left,t.right,t.top,t.bottom,t.near,t.far),t.zoom!==void 0&&(l.zoom=t.zoom),t.view!==void 0&&(l.view=Object.assign({},t.view));break;case"AmbientLight":l=new Vw(t.color,t.intensity);break;case"DirectionalLight":l=new Hw(t.color,t.intensity),l.target=t.target||"";break;case"PointLight":l=new kw(t.color,t.intensity,t.distance,t.decay);break;case"RectAreaLight":l=new Yw(t.color,t.intensity,t.width,t.height);break;case"SpotLight":l=new Gw(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay),l.target=t.target||"";break;case"HemisphereLight":l=new Pw(t.color,t.groundColor,t.intensity);break;case"LightProbe":l=new Xw().fromJSON(t);break;case"SkinnedMesh":m=u(t.geometry),g=A(t.material),l=new fw(m,g),t.bindMode!==void 0&&(l.bindMode=t.bindMode),t.bindMatrix!==void 0&&l.bindMatrix.fromArray(t.bindMatrix),t.skeleton!==void 0&&(l.skeleton=t.skeleton);break;case"Mesh":m=u(t.geometry),g=A(t.material),l=new oe(m,g);break;case"InstancedMesh":m=u(t.geometry),g=A(t.material);const y=t.count,v=t.instanceMatrix,C=t.instanceColor;l=new Hf(m,g,y),l.instanceMatrix=new Xf(new Float32Array(v.array),16),C!==void 0&&(l.instanceColor=new Xf(new Float32Array(C.array),C.itemSize));break;case"BatchedMesh":m=u(t.geometry),g=A(t.material),l=new RS(t.maxInstanceCount,t.maxVertexCount,t.maxIndexCount,g),l.geometry=m,l.perObjectFrustumCulled=t.perObjectFrustumCulled,l.sortObjects=t.sortObjects,l._drawRanges=t.drawRanges,l._reservedRanges=t.reservedRanges,l._geometryInfo=t.geometryInfo.map(I=>{let S=null,E=null;return I.boundingBox!==void 0&&(S=new kn().fromJSON(I.boundingBox)),I.boundingSphere!==void 0&&(E=new Bs().fromJSON(I.boundingSphere)),{...I,boundingBox:S,boundingSphere:E}}),l._instanceInfo=t.instanceInfo,l._availableInstanceIds=t._availableInstanceIds,l._availableGeometryIds=t._availableGeometryIds,l._nextIndexStart=t.nextIndexStart,l._nextVertexStart=t.nextVertexStart,l._geometryCount=t.geometryCount,l._maxInstanceCount=t.maxInstanceCount,l._maxVertexCount=t.maxVertexCount,l._maxIndexCount=t.maxIndexCount,l._geometryInitialized=t.geometryInitialized,l._matricesTexture=d(t.matricesTexture.uuid),l._indirectTexture=d(t.indirectTexture.uuid),t.colorsTexture!==void 0&&(l._colorsTexture=d(t.colorsTexture.uuid)),t.boundingSphere!==void 0&&(l.boundingSphere=new Bs().fromJSON(t.boundingSphere)),t.boundingBox!==void 0&&(l.boundingBox=new kn().fromJSON(t.boundingBox));break;case"LOD":l=new hw;break;case"Line":l=new Sn(u(t.geometry),A(t.material));break;case"LineLoop":l=new Aw(u(t.geometry),A(t.material));break;case"LineSegments":l=new oc(u(t.geometry),A(t.material));break;case"PointCloud":case"Points":l=new dw(u(t.geometry),A(t.material));break;case"Sprite":l=new uw(A(t.material));break;case"Group":l=new Nf;break;case"Bone":l=new DS;break;default:l=new gn}if(l.uuid=t.uuid,t.name!==void 0&&(l.name=t.name),t.matrix!==void 0?(l.matrix.fromArray(t.matrix),t.matrixAutoUpdate!==void 0&&(l.matrixAutoUpdate=t.matrixAutoUpdate),l.matrixAutoUpdate&&l.matrix.decompose(l.position,l.quaternion,l.scale)):(t.position!==void 0&&l.position.fromArray(t.position),t.rotation!==void 0&&l.rotation.fromArray(t.rotation),t.quaternion!==void 0&&l.quaternion.fromArray(t.quaternion),t.scale!==void 0&&l.scale.fromArray(t.scale)),t.up!==void 0&&l.up.fromArray(t.up),t.castShadow!==void 0&&(l.castShadow=t.castShadow),t.receiveShadow!==void 0&&(l.receiveShadow=t.receiveShadow),t.shadow&&(t.shadow.intensity!==void 0&&(l.shadow.intensity=t.shadow.intensity),t.shadow.bias!==void 0&&(l.shadow.bias=t.shadow.bias),t.shadow.normalBias!==void 0&&(l.shadow.normalBias=t.shadow.normalBias),t.shadow.radius!==void 0&&(l.shadow.radius=t.shadow.radius),t.shadow.mapSize!==void 0&&l.shadow.mapSize.fromArray(t.shadow.mapSize),t.shadow.camera!==void 0&&(l.shadow.camera=this.parseObject(t.shadow.camera))),t.visible!==void 0&&(l.visible=t.visible),t.frustumCulled!==void 0&&(l.frustumCulled=t.frustumCulled),t.renderOrder!==void 0&&(l.renderOrder=t.renderOrder),t.userData!==void 0&&(l.userData=t.userData),t.layers!==void 0&&(l.layers.mask=t.layers),t.children!==void 0){const y=t.children;for(let v=0;v<y.length;v++)l.add(this.parseObject(y[v],e,n,i,r))}if(t.animations!==void 0){const y=t.animations;for(let v=0;v<y.length;v++){const C=y[v];l.animations.push(r[C])}}if(t.type==="LOD"){t.autoUpdate!==void 0&&(l.autoUpdate=t.autoUpdate);const y=t.levels;for(let v=0;v<y.length;v++){const C=y[v],I=l.getObjectByProperty("uuid",C.object);I!==void 0&&l.addLevel(I,C.distance,C.hysteresis)}}return l}bindSkeletons(t,e){Object.keys(e).length!==0&&t.traverse(function(n){if(n.isSkinnedMesh===!0&&n.skeleton!==void 0){const i=e[n.skeleton];i===void 0?ge("ObjectLoader: No skeleton found with UUID:",n.skeleton):n.bind(i,n.bindMatrix)}})}bindLightTargets(t){t.traverse(function(e){if(e.isDirectionalLight||e.isSpotLight){const n=e.target,i=t.getObjectByProperty("uuid",n);i!==void 0?e.target=i:e.target=new gn}})}}const dN={UVMapping:lE,CubeReflectionMapping:eu,CubeRefractionMapping:fh,EquirectangularReflectionMapping:Rm,EquirectangularRefractionMapping:Nm,CubeUVReflectionMapping:rp},f2={RepeatWrapping:Um,ClampToEdgeWrapping:yr,MirroredRepeatWrapping:Lm},A2={NearestFilter:rs,NearestMipmapNearestFilter:fS,NearestMipmapLinearFilter:Gd,LinearFilter:as,LinearMipmapNearestFilter:mm,LinearMipmapLinearFilter:tc},EC=new WeakMap;class pN extends tr{constructor(t){super(t),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&ge("ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&ge("ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"},this._abortController=new AbortController}setOptions(t){return this.options=t,this}load(t,e,n,i){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,l=ec.get(`image-bitmap:${t}`);if(l!==void 0){if(r.manager.itemStart(t),l.then){l.then(d=>{if(EC.has(l)===!0)i&&i(EC.get(l)),r.manager.itemError(t),r.manager.itemEnd(t);else return e&&e(d),r.manager.itemEnd(t),d});return}return setTimeout(function(){e&&e(l),r.manager.itemEnd(t)},0),l}const u={};u.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",u.headers=this.requestHeader,u.signal=typeof AbortSignal.any=="function"?AbortSignal.any([this._abortController.signal,this.manager.abortController.signal]):this._abortController.signal;const A=fetch(t,u).then(function(d){return d.blob()}).then(function(d){return createImageBitmap(d,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(d){return ec.add(`image-bitmap:${t}`,d),e&&e(d),r.manager.itemEnd(t),d}).catch(function(d){i&&i(d),EC.set(A,d),ec.remove(`image-bitmap:${t}`),r.manager.itemError(t),r.manager.itemEnd(t)});ec.add(`image-bitmap:${t}`,A),r.manager.itemStart(t)}abort(){return this._abortController.abort(),this._abortController=new AbortController,this}}let gx;class jS{static getContext(){return gx===void 0&&(gx=new(window.AudioContext||window.webkitAudioContext)),gx}static setContext(t){gx=t}}class gN extends tr{constructor(t){super(t)}load(t,e,n,i){const r=this,l=new ac(this.manager);l.setResponseType("arraybuffer"),l.setPath(this.path),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(t,function(A){try{const d=A.slice(0);jS.getContext().decodeAudioData(d,function(g){e(g)}).catch(u)}catch(d){u(d)}},n,i);function u(A){i?i(A):nn(A),r.manager.itemError(t)}}}const d2=new he,p2=new he,ff=new he;class mN{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new As,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new As,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(t){const e=this._cache;if(e.focus!==t.focus||e.fov!==t.fov||e.aspect!==t.aspect*this.aspect||e.near!==t.near||e.far!==t.far||e.zoom!==t.zoom||e.eyeSep!==this.eyeSep){e.focus=t.focus,e.fov=t.fov,e.aspect=t.aspect*this.aspect,e.near=t.near,e.far=t.far,e.zoom=t.zoom,e.eyeSep=this.eyeSep,ff.copy(t.projectionMatrix);const i=e.eyeSep/2,r=i*e.near/e.focus,l=e.near*Math.tan(kf*e.fov*.5)/e.zoom;let u,A;p2.elements[12]=-i,d2.elements[12]=i,u=-l*e.aspect+r,A=l*e.aspect+r,ff.elements[0]=2*e.near/(A-u),ff.elements[8]=(A+u)/(A-u),this.cameraL.projectionMatrix.copy(ff),u=-l*e.aspect-r,A=l*e.aspect-r,ff.elements[0]=2*e.near/(A-u),ff.elements[8]=(A+u)/(A-u),this.cameraR.projectionMatrix.copy(ff)}this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(p2),this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(d2)}}class Zw extends As{constructor(t=[]){super(),this.isArrayCamera=!0,this.isMultiViewCamera=!1,this.cameras=t}}class h0{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=performance.now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=performance.now();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}const Af=new F,_C=new Ge,yN=new F,df=new F,pf=new F;class xN extends gn{constructor(){super(),this.type="AudioListener",this.context=jS.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new h0}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(t){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=t,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}updateMatrixWorld(t){super.updateMatrixWorld(t);const e=this.context.listener;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Af,_C,yN),df.set(0,0,-1).applyQuaternion(_C),pf.set(0,1,0).applyQuaternion(_C),e.positionX){const n=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime(Af.x,n),e.positionY.linearRampToValueAtTime(Af.y,n),e.positionZ.linearRampToValueAtTime(Af.z,n),e.forwardX.linearRampToValueAtTime(df.x,n),e.forwardY.linearRampToValueAtTime(df.y,n),e.forwardZ.linearRampToValueAtTime(df.z,n),e.upX.linearRampToValueAtTime(pf.x,n),e.upY.linearRampToValueAtTime(pf.y,n),e.upZ.linearRampToValueAtTime(pf.z,n)}else e.setPosition(Af.x,Af.y,Af.z),e.setOrientation(df.x,df.y,df.z,pf.x,pf.y,pf.z)}}class Ww extends gn{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(this.isPlaying===!0){ge("Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){ge("Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){ge("Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(t=0){if(this.hasPlaybackControl===!1){ge("Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(this.context.currentTime+t),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(t){return t||(t=[]),this._connected===!0?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){return this.detune=t,this.isPlaying===!0&&this.source.detune!==void 0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(this.hasPlaybackControl===!1){ge("Audio: this Audio has no playback control.");return}return this.playbackRate=t,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1,this._progress=0}getLoop(){return this.hasPlaybackControl===!1?(ge("Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(this.hasPlaybackControl===!1){ge("Audio: this Audio has no playback control.");return}return this.loop=t,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}copy(t,e){return super.copy(t,e),t.sourceType!=="buffer"?(ge("Audio: Audio source type cannot be copied."),this):(this.autoplay=t.autoplay,this.buffer=t.buffer,this.detune=t.detune,this.loop=t.loop,this.loopStart=t.loopStart,this.loopEnd=t.loopEnd,this.offset=t.offset,this.duration=t.duration,this.playbackRate=t.playbackRate,this.hasPlaybackControl=t.hasPlaybackControl,this.sourceType=t.sourceType,this.filters=t.filters.slice(),this)}clone(t){return new this.constructor(this.listener).copy(this,t)}}const gf=new F,g2=new Ge,vN=new F,mf=new F;class EN extends Ww{constructor(t){super(t),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){return super.connect(),this.panner.connect(this.gain),this}disconnect(){return super.disconnect(),this.panner.disconnect(this.gain),this}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(t){return this.panner.refDistance=t,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(t){return this.panner.rolloffFactor=t,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(t){return this.panner.distanceModel=t,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(t){return this.panner.maxDistance=t,this}setDirectionalCone(t,e,n){return this.panner.coneInnerAngle=t,this.panner.coneOuterAngle=e,this.panner.coneOuterGain=n,this}updateMatrixWorld(t){if(super.updateMatrixWorld(t),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(gf,g2,vN),mf.set(0,0,1).applyQuaternion(g2);const e=this.panner;if(e.positionX){const n=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(gf.x,n),e.positionY.linearRampToValueAtTime(gf.y,n),e.positionZ.linearRampToValueAtTime(gf.z,n),e.orientationX.linearRampToValueAtTime(mf.x,n),e.orientationY.linearRampToValueAtTime(mf.y,n),e.orientationZ.linearRampToValueAtTime(mf.z,n)}else e.setPosition(gf.x,gf.y,gf.z),e.setOrientation(mf.x,mf.y,mf.z)}}class _N{constructor(t,e=2048){this.analyser=t.context.createAnalyser(),this.analyser.fftSize=e,this.data=new Uint8Array(this.analyser.frequencyBinCount),t.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let t=0;const e=this.getFrequencyData();for(let n=0;n<e.length;n++)t+=e[n];return t/e.length}}class jw{constructor(t,e,n){this.binding=t,this.valueSize=n;let i,r,l;switch(e){case"quaternion":i=this._slerp,r=this._slerpAdditive,l=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,l=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:i=this._lerp,r=this._lerpAdditive,l=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=l,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const n=this.buffer,i=this.valueSize,r=t*i+i;let l=this.cumulativeWeight;if(l===0){for(let u=0;u!==i;++u)n[r+u]=n[u];l=e}else{l+=e;const u=e/l;this._mixBufferRegion(n,r,0,u,i)}this.cumulativeWeight=l}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,i=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,i,0,t,n),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,n=this.buffer,i=t*e+e,r=this.cumulativeWeight,l=this.cumulativeWeightAdditive,u=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const A=e*this._origIndex;this._mixBufferRegion(n,i,A,1-r,e)}l>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*e,1,e);for(let A=e,d=e+e;A!==d;++A)if(n[A]!==n[A+e]){u.setValue(n,i);break}}saveOriginalState(){const t=this.binding,e=this.buffer,n=this.valueSize,i=n*this._origIndex;t.getValue(e,i);for(let r=n,l=i;r!==l;++r)e[r]=e[i+r%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=this.valueSize*3;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]}_select(t,e,n,i,r){if(i>=.5)for(let l=0;l!==r;++l)t[e+l]=t[n+l]}_slerp(t,e,n,i){Ge.slerpFlat(t,e,t,e,t,n,i)}_slerpAdditive(t,e,n,i,r){const l=this._workIndex*r;Ge.multiplyQuaternionsFlat(t,l,t,e,t,n),Ge.slerpFlat(t,e,t,e,t,l,i)}_lerp(t,e,n,i,r){const l=1-i;for(let u=0;u!==r;++u){const A=e+u;t[A]=t[A]*l+t[n+u]*i}}_lerpAdditive(t,e,n,i,r){for(let l=0;l!==r;++l){const u=e+l;t[u]=t[u]+t[n+l]*i}}}const KS="\\[\\]\\.:\\/",CN=new RegExp("["+KS+"]","g"),$S="[^"+KS+"]",bN="[^"+KS.replace("\\.","")+"]",SN=/((?:WC+[\/:])*)/.source.replace("WC",$S),IN=/(WCOD+)?/.source.replace("WCOD",bN),BN=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",$S),MN=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",$S),wN=new RegExp("^"+SN+IN+BN+MN+"$"),TN=["material","materials","bones","map"];class QN{constructor(t,e,n){const i=n||qn.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,i)}getValue(t,e){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];i!==void 0&&i.getValue(t,e)}setValue(t,e){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=n.length;i!==r;++i)n[i].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}}class qn{constructor(t,e,n){this.path=e,this.parsedPath=n||qn.parseTrackName(e),this.node=qn.findNode(t,this.parsedPath.nodeName),this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,n){return t&&t.isAnimationObjectGroup?new qn.Composite(t,e,n):new qn(t,e,n)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(CN,"")}static parseTrackName(t){const e=wN.exec(t);if(e===null)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const r=n.nodeName.substring(i+1);TN.indexOf(r)!==-1&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=r)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n}static findNode(t,e){if(e===void 0||e===""||e==="."||e===-1||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(n!==void 0)return n}if(t.children){const n=function(r){for(let l=0;l<r.length;l++){const u=r[l];if(u.name===e||u.uuid===e)return u;const A=n(u.children);if(A)return A}return null},i=n(t.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)t[e++]=n[i]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,n=e.objectName,i=e.propertyName;let r=e.propertyIndex;if(t||(t=qn.findNode(this.rootNode,e.nodeName),this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t){ge("PropertyBinding: No target node found for track: "+this.path+".");return}if(n){let d=e.objectIndex;switch(n){case"materials":if(!t.material){nn("PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.materials){nn("PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}t=t.material.materials;break;case"bones":if(!t.skeleton){nn("PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}t=t.skeleton.bones;for(let m=0;m<t.length;m++)if(t[m].name===d){d=m;break}break;case"map":if("map"in t){t=t.map;break}if(!t.material){nn("PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.map){nn("PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}t=t.material.map;break;default:if(t[n]===void 0){nn("PropertyBinding: Can not bind to objectName of node undefined.",this);return}t=t[n]}if(d!==void 0){if(t[d]===void 0){nn("PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);return}t=t[d]}}const l=t[i];if(l===void 0){const d=e.nodeName;nn("PropertyBinding: Trying to update property for track: "+d+"."+i+" but it wasn't found.",t);return}let u=this.Versioning.None;this.targetObject=t,t.isMaterial===!0?u=this.Versioning.NeedsUpdate:t.isObject3D===!0&&(u=this.Versioning.MatrixWorldNeedsUpdate);let A=this.BindingType.Direct;if(r!==void 0){if(i==="morphTargetInfluences"){if(!t.geometry){nn("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!t.geometry.morphAttributes){nn("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}t.morphTargetDictionary[r]!==void 0&&(r=t.morphTargetDictionary[r])}A=this.BindingType.ArrayElement,this.resolvedProperty=l,this.propertyIndex=r}else l.fromArray!==void 0&&l.toArray!==void 0?(A=this.BindingType.HasFromToArray,this.resolvedProperty=l):Array.isArray(l)?(A=this.BindingType.EntireArray,this.resolvedProperty=l):this.propertyName=i;this.getValue=this.GetterByBindingType[A],this.setValue=this.SetterByBindingTypeAndVersioning[A][u]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}qn.Composite=QN;qn.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};qn.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};qn.prototype.GetterByBindingType=[qn.prototype._getValue_direct,qn.prototype._getValue_array,qn.prototype._getValue_arrayElement,qn.prototype._getValue_toArray];qn.prototype.SetterByBindingTypeAndVersioning=[[qn.prototype._setValue_direct,qn.prototype._setValue_direct_setNeedsUpdate,qn.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[qn.prototype._setValue_array,qn.prototype._setValue_array_setNeedsUpdate,qn.prototype._setValue_array_setMatrixWorldNeedsUpdate],[qn.prototype._setValue_arrayElement,qn.prototype._setValue_arrayElement_setNeedsUpdate,qn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[qn.prototype._setValue_fromArray,qn.prototype._setValue_fromArray_setNeedsUpdate,qn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class DN{constructor(){this.isAnimationObjectGroup=!0,this.uuid=Yr(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const t={};this._indicesByUUID=t;for(let n=0,i=arguments.length;n!==i;++n)t[arguments[n].uuid]=n;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}add(){const t=this._objects,e=this._indicesByUUID,n=this._paths,i=this._parsedPaths,r=this._bindings,l=r.length;let u,A=t.length,d=this.nCachedObjects_;for(let m=0,g=arguments.length;m!==g;++m){const y=arguments[m],v=y.uuid;let C=e[v];if(C===void 0){C=A++,e[v]=C,t.push(y);for(let I=0,S=l;I!==S;++I)r[I].push(new qn(y,n[I],i[I]))}else if(C<d){u=t[C];const I=--d,S=t[I];e[S.uuid]=C,t[C]=S,e[v]=I,t[I]=y;for(let E=0,B=l;E!==B;++E){const w=r[E],Q=w[I];let R=w[C];w[C]=Q,R===void 0&&(R=new qn(y,n[E],i[E])),w[I]=R}}else t[C]!==u&&nn("AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=d}remove(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_;for(let l=0,u=arguments.length;l!==u;++l){const A=arguments[l],d=A.uuid,m=e[d];if(m!==void 0&&m>=r){const g=r++,y=t[g];e[y.uuid]=m,t[m]=y,e[d]=g,t[g]=A;for(let v=0,C=i;v!==C;++v){const I=n[v],S=I[g],E=I[m];I[m]=S,I[g]=E}}}this.nCachedObjects_=r}uncache(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_,l=t.length;for(let u=0,A=arguments.length;u!==A;++u){const d=arguments[u],m=d.uuid,g=e[m];if(g!==void 0)if(delete e[m],g<r){const y=--r,v=t[y],C=--l,I=t[C];e[v.uuid]=g,t[g]=v,e[I.uuid]=y,t[y]=I,t.pop();for(let S=0,E=i;S!==E;++S){const B=n[S],w=B[y],Q=B[C];B[g]=w,B[y]=Q,B.pop()}}else{const y=--l,v=t[y];y>0&&(e[v.uuid]=g),t[g]=v,t.pop();for(let C=0,I=i;C!==I;++C){const S=n[C];S[g]=S[y],S.pop()}}}this.nCachedObjects_=r}subscribe_(t,e){const n=this._bindingsIndicesByPath;let i=n[t];const r=this._bindings;if(i!==void 0)return r[i];const l=this._paths,u=this._parsedPaths,A=this._objects,d=A.length,m=this.nCachedObjects_,g=new Array(d);i=r.length,n[t]=i,l.push(t),u.push(e),r.push(g);for(let y=m,v=A.length;y!==v;++y){const C=A[y];g[y]=new qn(C,t,e)}return g}unsubscribe_(t){const e=this._bindingsIndicesByPath,n=e[t];if(n!==void 0){const i=this._paths,r=this._parsedPaths,l=this._bindings,u=l.length-1,A=l[u],d=t[u];e[d]=n,l[n]=A,l.pop(),r[n]=r[u],r.pop(),i[n]=i[u],i.pop()}}}class Kw{constructor(t,e,n=null,i=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=i;const r=e.tracks,l=r.length,u=new Array(l),A={endingStart:Df,endingEnd:Df};for(let d=0;d!==l;++d){const m=r[d].createInterpolant(null);u[d]=m,m.settings=A}this._interpolantSettings=A,this._interpolants=u,this._propertyBindings=new Array(l),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=YM,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n=!1){if(t.fadeOut(e),this.fadeIn(e),n===!0){const i=this._clip.duration,r=t._clip.duration,l=r/i,u=i/r;t.warp(1,l,e),this.warp(u,1,e)}return this}crossFadeTo(t,e,n=!1){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return t!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const i=this._mixer,r=i.time,l=this.timeScale;let u=this._timeScaleInterpolant;u===null&&(u=i._lendControlInterpolant(),this._timeScaleInterpolant=u);const A=u.parameterPositions,d=u.sampleValues;return A[0]=r,A[1]=r+n,d[0]=t/l,d[1]=e/l,this}stopWarping(){const t=this._timeScaleInterpolant;return t!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,i){if(!this.enabled){this._updateWeight(t);return}const r=this._startTime;if(r!==null){const A=(t-r)*n;A<0||n===0?e=0:(this._startTime=null,e=n*A)}e*=this._updateTimeScale(t);const l=this._updateTime(e),u=this._updateWeight(t);if(u>0){const A=this._interpolants,d=this._propertyBindings;switch(this.blendMode){case xS:for(let m=0,g=A.length;m!==g;++m)A[m].evaluate(l),d[m].accumulateAdditive(u);break;case dE:default:for(let m=0,g=A.length;m!==g;++m)A[m].evaluate(l),d[m].accumulate(i,u)}}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(n!==null){const i=n.evaluate(t)[0];e*=i,t>n.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;if(n!==null){const i=n.evaluate(t)[0];e*=i,t>n.parameterPositions[1]&&(this.stopWarping(),e===0?this.paused=!0:this.timeScale=e)}}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let i=this.time+t,r=this._loopCount;const l=n===qM;if(t===0)return r===-1?i:l&&(r&1)===1?e-i:i;if(n===VM){r===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(i>=e)i=e;else if(i<0)i=0;else{this.time=i;break t}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(r===-1&&(t>=0?(r=0,this._setEndings(!0,this.repetitions===0,l)):this._setEndings(this.repetitions===0,!0,l)),i>=e||i<0){const u=Math.floor(i/e);i-=e*u,r+=Math.abs(u);const A=this.repetitions-r;if(A<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=t>0?e:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(A===1){const d=t<0;this._setEndings(d,!d,l)}else this._setEndings(!1,!1,l);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:u})}}else this.time=i;if(l&&(r&1)===1)return e-i}return i}_setEndings(t,e,n){const i=this._interpolantSettings;n?(i.endingStart=Rf,i.endingEnd=Rf):(t?i.endingStart=this.zeroSlopeAtStart?Rf:Df:i.endingStart=Om,e?i.endingEnd=this.zeroSlopeAtEnd?Rf:Df:i.endingEnd=Om)}_scheduleFading(t,e,n){const i=this._mixer,r=i.time;let l=this._weightInterpolant;l===null&&(l=i._lendControlInterpolant(),this._weightInterpolant=l);const u=l.parameterPositions,A=l.sampleValues;return u[0]=r,A[0]=e,u[1]=r+t,A[1]=n,this}}const RN=new Float32Array(1);class NN extends rc{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const n=t._localRoot||this._root,i=t._clip.tracks,r=i.length,l=t._propertyBindings,u=t._interpolants,A=n.uuid,d=this._bindingsByRootAndName;let m=d[A];m===void 0&&(m={},d[A]=m);for(let g=0;g!==r;++g){const y=i[g],v=y.name;let C=m[v];if(C!==void 0)++C.referenceCount,l[g]=C;else{if(C=l[g],C!==void 0){C._cacheIndex===null&&(++C.referenceCount,this._addInactiveBinding(C,A,v));continue}const I=e&&e._propertyBindings[g].binding.parsedPath;C=new jw(qn.create(n,v,I),y.ValueTypeName,y.getValueSize()),++C.referenceCount,this._addInactiveBinding(C,A,v),l[g]=C}u[g].resultBuffer=C.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(t._cacheIndex===null){const n=(t._localRoot||this._root).uuid,i=t._clip.uuid,r=this._actionsByClip[i];this._bindAction(t,r&&r.knownActions[0]),this._addInactiveAction(t,i,n)}const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const r=e[n];r.useCount++===0&&(this._lendBinding(r),r.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const r=e[n];--r.useCount===0&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return e!==null&&e<this._nActiveActions}_addInactiveAction(t,e,n){const i=this._actions,r=this._actionsByClip;let l=r[e];if(l===void 0)l={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,r[e]=l;else{const u=l.knownActions;t._byClipCacheIndex=u.length,u.push(t)}t._cacheIndex=i.length,i.push(t),l.actionByRoot[n]=t}_removeInactiveAction(t){const e=this._actions,n=e[e.length-1],i=t._cacheIndex;n._cacheIndex=i,e[i]=n,e.pop(),t._cacheIndex=null;const r=t._clip.uuid,l=this._actionsByClip,u=l[r],A=u.knownActions,d=A[A.length-1],m=t._byClipCacheIndex;d._byClipCacheIndex=m,A[m]=d,A.pop(),t._byClipCacheIndex=null;const g=u.actionByRoot,y=(t._localRoot||this._root).uuid;delete g[y],A.length===0&&delete l[r],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const r=e[n];--r.referenceCount===0&&this._removeInactiveBinding(r)}}_lendAction(t){const e=this._actions,n=t._cacheIndex,i=this._nActiveActions++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_takeBackAction(t){const e=this._actions,n=t._cacheIndex,i=--this._nActiveActions,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_addInactiveBinding(t,e,n){const i=this._bindingsByRootAndName,r=this._bindings;let l=i[e];l===void 0&&(l={},i[e]=l),l[n]=t,t._cacheIndex=r.length,r.push(t)}_removeInactiveBinding(t){const e=this._bindings,n=t.binding,i=n.rootNode.uuid,r=n.path,l=this._bindingsByRootAndName,u=l[i],A=e[e.length-1],d=t._cacheIndex;A._cacheIndex=d,e[d]=A,e.pop(),delete u[r],Object.keys(u).length===0&&delete l[i]}_lendBinding(t){const e=this._bindings,n=t._cacheIndex,i=this._nActiveBindings++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_takeBackBinding(t){const e=this._bindings,n=t._cacheIndex,i=--this._nActiveBindings,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return n===void 0&&(n=new qS(new Float32Array(2),new Float32Array(2),1,RN),n.__cacheIndex=e,t[e]=n),n}_takeBackControlInterpolant(t){const e=this._controlInterpolants,n=t.__cacheIndex,i=--this._nActiveControlInterpolants,r=e[i];t.__cacheIndex=i,e[i]=t,r.__cacheIndex=n,e[n]=r}clipAction(t,e,n){const i=e||this._root,r=i.uuid;let l=typeof t=="string"?Wm.findByName(i,t):t;const u=l!==null?l.uuid:t,A=this._actionsByClip[u];let d=null;if(n===void 0&&(l!==null?n=l.blendMode:n=dE),A!==void 0){const g=A.actionByRoot[r];if(g!==void 0&&g.blendMode===n)return g;d=A.knownActions[0],l===null&&(l=d._clip)}if(l===null)return null;const m=new Kw(this,l,e,n);return this._bindAction(m,d),this._addInactiveAction(m,u,r),m}existingAction(t,e){const n=e||this._root,i=n.uuid,r=typeof t=="string"?Wm.findByName(n,t):t,l=r?r.uuid:t,u=this._actionsByClip[l];return u!==void 0&&u.actionByRoot[i]||null}stopAllAction(){const t=this._actions,e=this._nActiveActions;for(let n=e-1;n>=0;--n)t[n].stop();return this}update(t){t*=this.timeScale;const e=this._actions,n=this._nActiveActions,i=this.time+=t,r=Math.sign(t),l=this._accuIndex^=1;for(let d=0;d!==n;++d)e[d]._update(i,t,r,l);const u=this._bindings,A=this._nActiveBindings;for(let d=0;d!==A;++d)u[d].apply(l);return this}setTime(t){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,n=t.uuid,i=this._actionsByClip,r=i[n];if(r!==void 0){const l=r.knownActions;for(let u=0,A=l.length;u!==A;++u){const d=l[u];this._deactivateAction(d);const m=d._cacheIndex,g=e[e.length-1];d._cacheIndex=null,d._byClipCacheIndex=null,g._cacheIndex=m,e[m]=g,e.pop(),this._removeInactiveBindingsForAction(d)}delete i[n]}}uncacheRoot(t){const e=t.uuid,n=this._actionsByClip;for(const l in n){const u=n[l].actionByRoot,A=u[e];A!==void 0&&(this._deactivateAction(A),this._removeInactiveAction(A))}const i=this._bindingsByRootAndName,r=i[e];if(r!==void 0)for(const l in r){const u=r[l];u.restoreOriginalState(),this._removeInactiveBinding(u)}}uncacheAction(t,e){const n=this.existingAction(t,e);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}class UN extends CS{constructor(t=1,e=1,n=1,i={}){super(t,e,i),this.isRenderTarget3D=!0,this.depth=n,this.texture=new a0(null,t,e,n),this._setTextureOptions(i),this.texture.isRenderTargetTexture=!0}}class LE{constructor(t){this.value=t}clone(){return new LE(this.value.clone===void 0?this.value:this.value.clone())}}let LN=0;class zN extends rc{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:LN++}),this.name="",this.usage=Pm,this.uniforms=[]}add(t){return this.uniforms.push(t),this}remove(t){const e=this.uniforms.indexOf(t);return e!==-1&&this.uniforms.splice(e,1),this}setName(t){return this.name=t,this}setUsage(t){return this.usage=t,this}dispose(){this.dispatchEvent({type:"dispose"})}copy(t){this.name=t.name,this.usage=t.usage;const e=t.uniforms;this.uniforms.length=0;for(let n=0,i=e.length;n<i;n++){const r=Array.isArray(e[n])?e[n]:[e[n]];for(let l=0;l<r.length;l++)this.uniforms.push(r[l].clone())}return this}clone(){return new this.constructor().copy(this)}}class ON extends yE{constructor(t,e,n=1){super(t,e),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}class FN{constructor(t,e,n,i,r,l=!1){this.isGLBufferAttribute=!0,this.name="",this.buffer=t,this.type=e,this.itemSize=n,this.elementSize=i,this.count=r,this.normalized=l,this.version=0}set needsUpdate(t){t===!0&&this.version++}setBuffer(t){return this.buffer=t,this}setType(t,e){return this.type=t,this.elementSize=e,this}setItemSize(t){return this.itemSize=t,this}setCount(t){return this.count=t,this}}const m2=new he;class f0{constructor(t,e,n=0,i=1/0){this.ray=new tA(t,e),this.near=n,this.far=i,this.camera=null,this.layers=new ep,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):nn("Raycaster: Unsupported camera type: "+e.type)}setFromXRController(t){return m2.identity().extractRotation(t.matrixWorld),this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(m2),this}intersectObject(t,e=!0,n=[]){return Ub(t,this,n,e),n.sort(y2),n}intersectObjects(t,e=!0,n=[]){for(let i=0,r=t.length;i<r;i++)Ub(t[i],this,n,e);return n.sort(y2),n}}function y2(s,t){return s.distance-t.distance}function Ub(s,t,e,n){let i=!0;if(s.layers.test(t.layers)&&s.raycast(t,e)===!1&&(i=!1),i===!0&&n===!0){const r=s.children;for(let l=0,u=r.length;l<u;l++)Ub(r[l],t,e,!0)}}class PN{constructor(){this._previousTime=0,this._currentTime=0,this._startTime=performance.now(),this._delta=0,this._elapsed=0,this._timescale=1,this._document=null,this._pageVisibilityHandler=null}connect(t){this._document=t,t.hidden!==void 0&&(this._pageVisibilityHandler=GN.bind(this),t.addEventListener("visibilitychange",this._pageVisibilityHandler,!1))}disconnect(){this._pageVisibilityHandler!==null&&(this._document.removeEventListener("visibilitychange",this._pageVisibilityHandler),this._pageVisibilityHandler=null),this._document=null}getDelta(){return this._delta/1e3}getElapsed(){return this._elapsed/1e3}getTimescale(){return this._timescale}setTimescale(t){return this._timescale=t,this}reset(){return this._currentTime=performance.now()-this._startTime,this}dispose(){this.disconnect()}update(t){return this._pageVisibilityHandler!==null&&this._document.hidden===!0?this._delta=0:(this._previousTime=this._currentTime,this._currentTime=(t!==void 0?t:performance.now())-this._startTime,this._delta=(this._currentTime-this._previousTime)*this._timescale,this._elapsed+=this._delta),this}}function GN(){this._document.hidden===!1&&this.reset()}class $w{constructor(t=1,e=0,n=0){this.radius=t,this.phi=e,this.theta=n}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){return this.phi=Je(this.phi,1e-6,Math.PI-1e-6),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(Je(e/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class kN{constructor(t=1,e=0,n=0){this.radius=t,this.theta=e,this.y=n}set(t,e,n){return this.radius=t,this.theta=e,this.y=n,this}copy(t){return this.radius=t.radius,this.theta=t.theta,this.y=t.y,this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+n*n),this.theta=Math.atan2(t,n),this.y=e,this}clone(){return new this.constructor().copy(this)}}class A0{constructor(t,e,n,i){A0.prototype.isMatrix2=!0,this.elements=[1,0,0,1],t!==void 0&&this.set(t,e,n,i)}identity(){return this.set(1,0,0,1),this}fromArray(t,e=0){for(let n=0;n<4;n++)this.elements[n]=t[n+e];return this}set(t,e,n,i){const r=this.elements;return r[0]=t,r[2]=e,r[1]=n,r[3]=i,this}}const x2=new Dt;class HN{constructor(t=new Dt(1/0,1/0),e=new Dt(-1/0,-1/0)){this.isBox2=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=x2.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,x2).distanceTo(t)}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const v2=new F,mx=new F,vd=new F,Ed=new F,CC=new F,VN=new F,YN=new F;class vr{constructor(t=new F,e=new F){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){v2.subVectors(t,this.start),mx.subVectors(this.end,this.start);const n=mx.dot(mx);let r=mx.dot(v2)/n;return e&&(r=Je(r,0,1)),r}closestPointToPoint(t,e,n){const i=this.closestPointToPointParameter(t,e);return this.delta(n).multiplyScalar(i).add(this.start)}distanceSqToLine3(t,e=VN,n=YN){const i=10000000000000001e-32;let r,l;const u=this.start,A=t.start,d=this.end,m=t.end;vd.subVectors(d,u),Ed.subVectors(m,A),CC.subVectors(u,A);const g=vd.dot(vd),y=Ed.dot(Ed),v=Ed.dot(CC);if(g<=i&&y<=i)return e.copy(u),n.copy(A),e.sub(n),e.dot(e);if(g<=i)r=0,l=v/y,l=Je(l,0,1);else{const C=vd.dot(CC);if(y<=i)l=0,r=Je(-C/g,0,1);else{const I=vd.dot(Ed),S=g*y-I*I;S!==0?r=Je((I*v-C*y)/S,0,1):r=0,l=(I*r+v)/y,l<0?(l=0,r=Je(-C/g,0,1)):l>1&&(l=1,r=Je((I-C)/g,0,1))}}return e.copy(u).add(vd.multiplyScalar(r)),n.copy(A).add(Ed.multiplyScalar(l)),e.sub(n),e.dot(e)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const E2=new F;class qN extends gn{constructor(t,e){super(),this.light=t,this.matrixAutoUpdate=!1,this.color=e,this.type="SpotLightHelper";const n=new Fe,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let l=0,u=1,A=32;l<A;l++,u++){const d=l/A*Math.PI*2,m=u/A*Math.PI*2;i.push(Math.cos(d),Math.sin(d),1,Math.cos(m),Math.sin(m),1)}n.setAttribute("position",new Ce(i,3));const r=new na({fog:!1,toneMapped:!1});this.cone=new oc(n,r),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const t=this.light.distance?this.light.distance:1e3,e=t*Math.tan(this.light.angle);this.cone.scale.set(e,e,t),E2.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(E2),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const $u=new F,yx=new he,bC=new he;class XN extends oc{constructor(t){const e=t3(t),n=new Fe,i=[],r=[];for(let d=0;d<e.length;d++){const m=e[d];m.parent&&m.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(0,0,0),r.push(0,0,0))}n.setAttribute("position",new Ce(i,3)),n.setAttribute("color",new Ce(r,3));const l=new na({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,l),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1;const u=new le(255),A=new le(65280);this.setColors(u,A)}updateMatrixWorld(t){const e=this.bones,n=this.geometry,i=n.getAttribute("position");bC.copy(this.root.matrixWorld).invert();for(let r=0,l=0;r<e.length;r++){const u=e[r];u.parent&&u.parent.isBone&&(yx.multiplyMatrices(bC,u.matrixWorld),$u.setFromMatrixPosition(yx),i.setXYZ(l,$u.x,$u.y,$u.z),yx.multiplyMatrices(bC,u.parent.matrixWorld),$u.setFromMatrixPosition(yx),i.setXYZ(l+1,$u.x,$u.y,$u.z),l+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}setColors(t,e){const i=this.geometry.getAttribute("color");for(let r=0;r<i.count;r+=2)i.setXYZ(r,t.r,t.g,t.b),i.setXYZ(r+1,e.r,e.g,e.b);return i.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}function t3(s){const t=[];s.isBone===!0&&t.push(s);for(let e=0;e<s.children.length;e++)t.push(...t3(s.children[e]));return t}class JN extends oe{constructor(t,e,n){const i=new lp(e,4,2),r=new pl({wireframe:!0,fog:!1,toneMapped:!1});super(i,r),this.light=t,this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const ZN=new F,_2=new le,C2=new le;class WN extends gn{constructor(t,e,n){super(),this.light=t,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,this.type="HemisphereLightHelper";const i=new xo(e);i.rotateY(Math.PI*.5),this.material=new pl({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const r=i.getAttribute("position"),l=new Float32Array(r.count*3);i.setAttribute("color",new Qn(l,3)),this.add(new oe(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const t=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const e=t.geometry.getAttribute("color");_2.copy(this.light.color),C2.copy(this.light.groundColor);for(let n=0,i=e.count;n<i;n++){const r=n<i/2?_2:C2;e.setXYZ(n,r.r,r.g,r.b)}e.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),t.lookAt(ZN.setFromMatrixPosition(this.light.matrixWorld).negate())}}class jN extends oc{constructor(t=10,e=10,n=4473924,i=8947848){n=new le(n),i=new le(i);const r=e/2,l=t/e,u=t/2,A=[],d=[];for(let y=0,v=0,C=-u;y<=e;y++,C+=l){A.push(-u,0,C,u,0,C),A.push(C,0,-u,C,0,u);const I=y===r?n:i;I.toArray(d,v),v+=3,I.toArray(d,v),v+=3,I.toArray(d,v),v+=3,I.toArray(d,v),v+=3}const m=new Fe;m.setAttribute("position",new Ce(A,3)),m.setAttribute("color",new Ce(d,3));const g=new na({vertexColors:!0,toneMapped:!1});super(m,g),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class KN extends oc{constructor(t=10,e=16,n=8,i=64,r=4473924,l=8947848){r=new le(r),l=new le(l);const u=[],A=[];if(e>1)for(let g=0;g<e;g++){const y=g/e*(Math.PI*2),v=Math.sin(y)*t,C=Math.cos(y)*t;u.push(0,0,0),u.push(v,0,C);const I=g&1?r:l;A.push(I.r,I.g,I.b),A.push(I.r,I.g,I.b)}for(let g=0;g<n;g++){const y=g&1?r:l,v=t-t/n*g;for(let C=0;C<i;C++){let I=C/i*(Math.PI*2),S=Math.sin(I)*v,E=Math.cos(I)*v;u.push(S,0,E),A.push(y.r,y.g,y.b),I=(C+1)/i*(Math.PI*2),S=Math.sin(I)*v,E=Math.cos(I)*v,u.push(S,0,E),A.push(y.r,y.g,y.b)}}const d=new Fe;d.setAttribute("position",new Ce(u,3)),d.setAttribute("color",new Ce(A,3));const m=new na({vertexColors:!0,toneMapped:!1});super(d,m),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const b2=new F,xx=new F,S2=new F;class $N extends gn{constructor(t,e,n){super(),this.light=t,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,this.type="DirectionalLightHelper",e===void 0&&(e=1);let i=new Fe;i.setAttribute("position",new Ce([-e,e,0,e,e,0,e,-e,0,-e,-e,0,-e,e,0],3));const r=new na({fog:!1,toneMapped:!1});this.lightPlane=new Sn(i,r),this.add(this.lightPlane),i=new Fe,i.setAttribute("position",new Ce([0,0,0,0,0,1],3)),this.targetLine=new Sn(i,r),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),b2.setFromMatrixPosition(this.light.matrixWorld),xx.setFromMatrixPosition(this.light.target.matrixWorld),S2.subVectors(xx,b2),this.lightPlane.lookAt(xx),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(xx),this.targetLine.scale.z=S2.length()}}const vx=new F,ji=new pE;class tU extends oc{constructor(t){const e=new Fe,n=new na({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],r=[],l={};u("n1","n2"),u("n2","n4"),u("n4","n3"),u("n3","n1"),u("f1","f2"),u("f2","f4"),u("f4","f3"),u("f3","f1"),u("n1","f1"),u("n2","f2"),u("n3","f3"),u("n4","f4"),u("p","n1"),u("p","n2"),u("p","n3"),u("p","n4"),u("u1","u2"),u("u2","u3"),u("u3","u1"),u("c","t"),u("p","c"),u("cn1","cn2"),u("cn3","cn4"),u("cf1","cf2"),u("cf3","cf4");function u(C,I){A(C),A(I)}function A(C){i.push(0,0,0),r.push(0,0,0),l[C]===void 0&&(l[C]=[]),l[C].push(i.length/3-1)}e.setAttribute("position",new Ce(i,3)),e.setAttribute("color",new Ce(r,3)),super(e,n),this.type="CameraHelper",this.camera=t,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=l,this.update();const d=new le(16755200),m=new le(16711680),g=new le(43775),y=new le(16777215),v=new le(3355443);this.setColors(d,m,g,y,v)}setColors(t,e,n,i,r){const u=this.geometry.getAttribute("color");return u.setXYZ(0,t.r,t.g,t.b),u.setXYZ(1,t.r,t.g,t.b),u.setXYZ(2,t.r,t.g,t.b),u.setXYZ(3,t.r,t.g,t.b),u.setXYZ(4,t.r,t.g,t.b),u.setXYZ(5,t.r,t.g,t.b),u.setXYZ(6,t.r,t.g,t.b),u.setXYZ(7,t.r,t.g,t.b),u.setXYZ(8,t.r,t.g,t.b),u.setXYZ(9,t.r,t.g,t.b),u.setXYZ(10,t.r,t.g,t.b),u.setXYZ(11,t.r,t.g,t.b),u.setXYZ(12,t.r,t.g,t.b),u.setXYZ(13,t.r,t.g,t.b),u.setXYZ(14,t.r,t.g,t.b),u.setXYZ(15,t.r,t.g,t.b),u.setXYZ(16,t.r,t.g,t.b),u.setXYZ(17,t.r,t.g,t.b),u.setXYZ(18,t.r,t.g,t.b),u.setXYZ(19,t.r,t.g,t.b),u.setXYZ(20,t.r,t.g,t.b),u.setXYZ(21,t.r,t.g,t.b),u.setXYZ(22,t.r,t.g,t.b),u.setXYZ(23,t.r,t.g,t.b),u.setXYZ(24,e.r,e.g,e.b),u.setXYZ(25,e.r,e.g,e.b),u.setXYZ(26,e.r,e.g,e.b),u.setXYZ(27,e.r,e.g,e.b),u.setXYZ(28,e.r,e.g,e.b),u.setXYZ(29,e.r,e.g,e.b),u.setXYZ(30,e.r,e.g,e.b),u.setXYZ(31,e.r,e.g,e.b),u.setXYZ(32,n.r,n.g,n.b),u.setXYZ(33,n.r,n.g,n.b),u.setXYZ(34,n.r,n.g,n.b),u.setXYZ(35,n.r,n.g,n.b),u.setXYZ(36,n.r,n.g,n.b),u.setXYZ(37,n.r,n.g,n.b),u.setXYZ(38,i.r,i.g,i.b),u.setXYZ(39,i.r,i.g,i.b),u.setXYZ(40,r.r,r.g,r.b),u.setXYZ(41,r.r,r.g,r.b),u.setXYZ(42,r.r,r.g,r.b),u.setXYZ(43,r.r,r.g,r.b),u.setXYZ(44,r.r,r.g,r.b),u.setXYZ(45,r.r,r.g,r.b),u.setXYZ(46,r.r,r.g,r.b),u.setXYZ(47,r.r,r.g,r.b),u.setXYZ(48,r.r,r.g,r.b),u.setXYZ(49,r.r,r.g,r.b),u.needsUpdate=!0,this}update(){const t=this.geometry,e=this.pointMap,n=1,i=1;let r,l;if(ji.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),this.camera.reversedDepth===!0)r=1,l=0;else if(this.camera.coordinateSystem===Hr)r=-1,l=1;else if(this.camera.coordinateSystem===Kd)r=0,l=1;else throw new Error("THREE.CameraHelper.update(): Invalid coordinate system: "+this.camera.coordinateSystem);is("c",e,t,ji,0,0,r),is("t",e,t,ji,0,0,l),is("n1",e,t,ji,-n,-i,r),is("n2",e,t,ji,n,-i,r),is("n3",e,t,ji,-n,i,r),is("n4",e,t,ji,n,i,r),is("f1",e,t,ji,-n,-i,l),is("f2",e,t,ji,n,-i,l),is("f3",e,t,ji,-n,i,l),is("f4",e,t,ji,n,i,l),is("u1",e,t,ji,n*.7,i*1.1,r),is("u2",e,t,ji,-n*.7,i*1.1,r),is("u3",e,t,ji,0,i*2,r),is("cf1",e,t,ji,-n,0,l),is("cf2",e,t,ji,n,0,l),is("cf3",e,t,ji,0,-i,l),is("cf4",e,t,ji,0,i,l),is("cn1",e,t,ji,-n,0,r),is("cn2",e,t,ji,n,0,r),is("cn3",e,t,ji,0,-i,r),is("cn4",e,t,ji,0,i,r),t.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function is(s,t,e,n,i,r,l){vx.set(i,r,l).unproject(n);const u=t[s];if(u!==void 0){const A=e.getAttribute("position");for(let d=0,m=u.length;d<m;d++)A.setXYZ(u[d],vx.x,vx.y,vx.z)}}const Ex=new kn;class eU extends oc{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),r=new Fe;r.setIndex(new Qn(n,1)),r.setAttribute("position",new Qn(i,3)),super(r,new na({color:e,toneMapped:!1})),this.object=t,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(){if(this.object!==void 0&&Ex.setFromObject(this.object),Ex.isEmpty())return;const t=Ex.min,e=Ex.max,n=this.geometry.attributes.position,i=n.array;i[0]=e.x,i[1]=e.y,i[2]=e.z,i[3]=t.x,i[4]=e.y,i[5]=e.z,i[6]=t.x,i[7]=t.y,i[8]=e.z,i[9]=e.x,i[10]=t.y,i[11]=e.z,i[12]=e.x,i[13]=e.y,i[14]=t.z,i[15]=t.x,i[16]=e.y,i[17]=t.z,i[18]=t.x,i[19]=t.y,i[20]=t.z,i[21]=e.x,i[22]=t.y,i[23]=t.z,n.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(t){return this.object=t,this.update(),this}copy(t,e){return super.copy(t,e),this.object=t.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class nU extends oc{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],r=new Fe;r.setIndex(new Qn(n,1)),r.setAttribute("position",new Ce(i,3)),super(r,new na({color:e,toneMapped:!1})),this.box=t,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(t){const e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(t))}dispose(){this.geometry.dispose(),this.material.dispose()}}class iU extends Sn{constructor(t,e=1,n=16776960){const i=n,r=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],l=new Fe;l.setAttribute("position",new Ce(r,3)),l.computeBoundingSphere(),super(l,new na({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=t,this.size=e;const u=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],A=new Fe;A.setAttribute("position",new Ce(u,3)),A.computeBoundingSphere(),this.add(new oe(A,new pl({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(t){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(t)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const I2=new F;let _x,SC;class sU extends gn{constructor(t=new F(0,0,1),e=new F(0,0,0),n=1,i=16776960,r=n*.2,l=r*.2){super(),this.type="ArrowHelper",_x===void 0&&(_x=new Fe,_x.setAttribute("position",new Ce([0,0,0,0,1,0],3)),SC=new o0(.5,1,5,1),SC.translate(0,-.5,0)),this.position.copy(e),this.line=new Sn(_x,new na({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new oe(SC,new pl({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(t),this.setLength(n,r,l)}setDirection(t){if(t.y>.99999)this.quaternion.set(0,0,0,1);else if(t.y<-.99999)this.quaternion.set(1,0,0,0);else{I2.set(t.z,0,-t.x).normalize();const e=Math.acos(t.y);this.quaternion.setFromAxisAngle(I2,e)}}setLength(t,e=t*.2,n=e*.2){this.line.scale.set(1,Math.max(1e-4,t-e),1),this.line.updateMatrix(),this.cone.scale.set(n,e,n),this.cone.position.y=t,this.cone.updateMatrix()}setColor(t){this.line.material.color.set(t),this.cone.material.color.set(t)}copy(t){return super.copy(t,!1),this.line.copy(t.line),this.cone.copy(t.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class aU extends oc{constructor(t=1){const e=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],n=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],i=new Fe;i.setAttribute("position",new Ce(e,3)),i.setAttribute("color",new Ce(n,3));const r=new na({vertexColors:!0,toneMapped:!1});super(i,r),this.type="AxesHelper"}setColors(t,e,n){const i=new le,r=this.geometry.attributes.color.array;return i.set(t),i.toArray(r,0),i.toArray(r,3),i.set(e),i.toArray(r,6),i.toArray(r,9),i.set(n),i.toArray(r,12),i.toArray(r,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class rU{constructor(){this.type="ShapePath",this.color=new le,this.subPaths=[],this.currentPath=null}moveTo(t,e){return this.currentPath=new jv,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e),this}lineTo(t,e){return this.currentPath.lineTo(t,e),this}quadraticCurveTo(t,e,n,i){return this.currentPath.quadraticCurveTo(t,e,n,i),this}bezierCurveTo(t,e,n,i,r,l){return this.currentPath.bezierCurveTo(t,e,n,i,r,l),this}splineThru(t){return this.currentPath.splineThru(t),this}toShapes(t){function e(E){const B=[];for(let w=0,Q=E.length;w<Q;w++){const R=E[w],D=new Vf;D.curves=R.curves,B.push(D)}return B}function n(E,B){const w=B.length;let Q=!1;for(let R=w-1,D=0;D<w;R=D++){let U=B[R],P=B[D],z=P.x-U.x,L=P.y-U.y;if(Math.abs(L)>Number.EPSILON){if(L<0&&(U=B[D],z=-z,P=B[R],L=-L),E.y<U.y||E.y>P.y)continue;if(E.y===U.y){if(E.x===U.x)return!0}else{const k=L*(E.x-U.x)-z*(E.y-U.y);if(k===0)return!0;if(k<0)continue;Q=!Q}}else{if(E.y!==U.y)continue;if(P.x<=E.x&&E.x<=U.x||U.x<=E.x&&E.x<=P.x)return!0}}return Q}const i=cl.isClockWise,r=this.subPaths;if(r.length===0)return[];let l,u,A;const d=[];if(r.length===1)return u=r[0],A=new Vf,A.curves=u.curves,d.push(A),d;let m=!i(r[0].getPoints());m=t?!m:m;const g=[],y=[];let v=[],C=0,I;y[C]=void 0,v[C]=[];for(let E=0,B=r.length;E<B;E++)u=r[E],I=u.getPoints(),l=i(I),l=t?!l:l,l?(!m&&y[C]&&C++,y[C]={s:new Vf,p:I},y[C].s.curves=u.curves,m&&C++,v[C]=[]):v[C].push({h:u,p:I[0]});if(!y[0])return e(r);if(y.length>1){let E=!1,B=0;for(let w=0,Q=y.length;w<Q;w++)g[w]=[];for(let w=0,Q=y.length;w<Q;w++){const R=v[w];for(let D=0;D<R.length;D++){const U=R[D];let P=!0;for(let z=0;z<y.length;z++)n(U.p,y[z].p)&&(w!==z&&B++,P?(P=!1,g[z].push(U)):E=!0);P&&g[w].push(U)}}B>0&&E===!1&&(v=g)}let S;for(let E=0,B=y.length;E<B;E++){A=y[E].s,d.push(A),S=v[E];for(let w=0,Q=S.length;w<Q;w++)A.holes.push(S[w].h)}return d}}class oU extends rc{constructor(t,e=null){super(),this.object=t,this.domElement=e,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(t){if(t===void 0){ge("Controls: connect() now requires an element.");return}this.domElement!==null&&this.disconnect(),this.domElement=t}disconnect(){}dispose(){}update(){}}function lU(s,t){const e=s.image&&s.image.width?s.image.width/s.image.height:1;return e>t?(s.repeat.x=1,s.repeat.y=e/t,s.offset.x=0,s.offset.y=(1-s.repeat.y)/2):(s.repeat.x=t/e,s.repeat.y=1,s.offset.x=(1-s.repeat.x)/2,s.offset.y=0),s}function cU(s,t){const e=s.image&&s.image.width?s.image.width/s.image.height:1;return e>t?(s.repeat.x=t/e,s.repeat.y=1,s.offset.x=(1-s.repeat.x)/2,s.offset.y=0):(s.repeat.x=1,s.repeat.y=e/t,s.offset.x=0,s.offset.y=(1-s.repeat.y)/2),s}function uU(s){return s.repeat.x=1,s.repeat.y=1,s.offset.x=0,s.offset.y=0,s}function Lb(s,t,e,n){const i=hU(n);switch(e){case mS:return s*t;case fE:return s*t/i.components*i.byteLength;case i0:return s*t/i.components*i.byteLength;case AE:return s*t*2/i.components*i.byteLength;case s0:return s*t*2/i.components*i.byteLength;case yS:return s*t*3/i.components*i.byteLength;case Ki:return s*t*4/i.components*i.byteLength;case sc:return s*t*4/i.components*i.byteLength;case ym:case xm:return Math.floor((s+3)/4)*Math.floor((t+3)/4)*8;case vm:case Em:return Math.floor((s+3)/4)*Math.floor((t+3)/4)*16;case vv:case _v:return Math.max(s,16)*Math.max(t,8)/4;case xv:case Ev:return Math.max(s,8)*Math.max(t,8)/2;case Cv:case bv:return Math.floor((s+3)/4)*Math.floor((t+3)/4)*8;case Sv:return Math.floor((s+3)/4)*Math.floor((t+3)/4)*16;case Iv:return Math.floor((s+3)/4)*Math.floor((t+3)/4)*16;case Bv:return Math.floor((s+4)/5)*Math.floor((t+3)/4)*16;case Mv:return Math.floor((s+4)/5)*Math.floor((t+4)/5)*16;case wv:return Math.floor((s+5)/6)*Math.floor((t+4)/5)*16;case Tv:return Math.floor((s+5)/6)*Math.floor((t+5)/6)*16;case Qv:return Math.floor((s+7)/8)*Math.floor((t+4)/5)*16;case Dv:return Math.floor((s+7)/8)*Math.floor((t+5)/6)*16;case Rv:return Math.floor((s+7)/8)*Math.floor((t+7)/8)*16;case Nv:return Math.floor((s+9)/10)*Math.floor((t+4)/5)*16;case Uv:return Math.floor((s+9)/10)*Math.floor((t+5)/6)*16;case Lv:return Math.floor((s+9)/10)*Math.floor((t+7)/8)*16;case zv:return Math.floor((s+9)/10)*Math.floor((t+9)/10)*16;case Ov:return Math.floor((s+11)/12)*Math.floor((t+9)/10)*16;case Fv:return Math.floor((s+11)/12)*Math.floor((t+11)/12)*16;case Pv:case Gv:case kv:return Math.ceil(s/4)*Math.ceil(t/4)*16;case Hv:case Vv:return Math.ceil(s/4)*Math.ceil(t/4)*8;case Yv:case qv:return Math.ceil(s/4)*Math.ceil(t/4)*16}throw new Error(`Unable to determine texture byte length for ${e} format.`)}function hU(s){switch(s){case ea:case AS:return{byteLength:1,components:1};case Jd:case dS:case $f:return{byteLength:2,components:1};case uE:case hE:return{byteLength:2,components:4};case Ca:case cE:case xr:return{byteLength:4,components:1};case pS:case gS:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${s}.`)}class fU{static contain(t,e){return lU(t,e)}static cover(t,e){return cU(t,e)}static fill(t){return uU(t)}static getByteLength(t,e,n,i){return Lb(t,e,n,i)}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Kf}}));typeof window<"u"&&(window.__THREE__?ge("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Kf);function e3(){let s=null,t=!1,e=null,n=null;function i(r,l){e(r,l),n=s.requestAnimationFrame(i)}return{start:function(){t!==!0&&e!==null&&(n=s.requestAnimationFrame(i),t=!0)},stop:function(){s.cancelAnimationFrame(n),t=!1},setAnimationLoop:function(r){e=r},setContext:function(r){s=r}}}function AU(s){const t=new WeakMap;function e(u,A){const d=u.array,m=u.usage,g=d.byteLength,y=s.createBuffer();s.bindBuffer(A,y),s.bufferData(A,d,m),u.onUploadCallback();let v;if(d instanceof Float32Array)v=s.FLOAT;else if(typeof Float16Array<"u"&&d instanceof Float16Array)v=s.HALF_FLOAT;else if(d instanceof Uint16Array)u.isFloat16BufferAttribute?v=s.HALF_FLOAT:v=s.UNSIGNED_SHORT;else if(d instanceof Int16Array)v=s.SHORT;else if(d instanceof Uint32Array)v=s.UNSIGNED_INT;else if(d instanceof Int32Array)v=s.INT;else if(d instanceof Int8Array)v=s.BYTE;else if(d instanceof Uint8Array)v=s.UNSIGNED_BYTE;else if(d instanceof Uint8ClampedArray)v=s.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+d);return{buffer:y,type:v,bytesPerElement:d.BYTES_PER_ELEMENT,version:u.version,size:g}}function n(u,A,d){const m=A.array,g=A.updateRanges;if(s.bindBuffer(d,u),g.length===0)s.bufferSubData(d,0,m);else{g.sort((v,C)=>v.start-C.start);let y=0;for(let v=1;v<g.length;v++){const C=g[y],I=g[v];I.start<=C.start+C.count+1?C.count=Math.max(C.count,I.start+I.count-C.start):(++y,g[y]=I)}g.length=y+1;for(let v=0,C=g.length;v<C;v++){const I=g[v];s.bufferSubData(d,I.start*m.BYTES_PER_ELEMENT,m,I.start,I.count)}A.clearUpdateRanges()}A.onUploadCallback()}function i(u){return u.isInterleavedBufferAttribute&&(u=u.data),t.get(u)}function r(u){u.isInterleavedBufferAttribute&&(u=u.data);const A=t.get(u);A&&(s.deleteBuffer(A.buffer),t.delete(u))}function l(u,A){if(u.isInterleavedBufferAttribute&&(u=u.data),u.isGLBufferAttribute){const m=t.get(u);(!m||m.version<u.version)&&t.set(u,{buffer:u.buffer,type:u.type,bytesPerElement:u.elementSize,version:u.version});return}const d=t.get(u);if(d===void 0)t.set(u,e(u,A));else if(d.version<u.version){if(d.size!==u.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");n(d.buffer,u,A),d.version=u.version}}return{get:i,remove:r,update:l}}var dU=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,pU=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,gU=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,mU=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,yU=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,xU=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,vU=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,EU=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,_U=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,CU=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,bU=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,SU=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,IU=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,BU=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,MU=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,wU=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,TU=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,QU=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,DU=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,RU=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,NU=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,UU=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,LU=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,zU=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,OU=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,FU=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,PU=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,GU=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,kU=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,HU=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,VU="gl_FragColor = linearToOutputTexel( gl_FragColor );",YU=`vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,qU=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,XU=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
#endif`,JU=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,ZU=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,WU=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,jU=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,KU=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,$U=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,tL=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,eL=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,nL=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,iL=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,sL=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,aL=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,rL=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, pow4( roughness ) ) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,oL=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,lL=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,cL=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,uL=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,hL=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,fL=`uniform sampler2D dfgLUT;
struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transpose( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 uv = vec2( roughness, dotNV );
	return texture2D( dfgLUT, uv ).rg;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
vec3 BRDF_GGX_Multiscatter( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 singleScatter = BRDF_GGX( lightDir, viewDir, normal, material );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 dfgV = DFGApprox( vec3(0.0, 0.0, 1.0), vec3(sqrt(1.0 - dotNV * dotNV), 0.0, dotNV), material.roughness );
	vec2 dfgL = DFGApprox( vec3(0.0, 0.0, 1.0), vec3(sqrt(1.0 - dotNL * dotNL), 0.0, dotNL), material.roughness );
	vec3 FssEss_V = material.specularColor * dfgV.x + material.specularF90 * dfgV.y;
	vec3 FssEss_L = material.specularColor * dfgL.x + material.specularF90 * dfgL.y;
	float Ess_V = dfgV.x + dfgV.y;
	float Ess_L = dfgL.x + dfgL.y;
	float Ems_V = 1.0 - Ess_V;
	float Ems_L = 1.0 - Ess_L;
	vec3 Favg = material.specularColor + ( 1.0 - material.specularColor ) * 0.047619;
	vec3 Fms = FssEss_V * FssEss_L * Favg / ( 1.0 - Ems_V * Ems_L * Favg * Favg + EPSILON );
	float compensationFactor = Ems_V * Ems_L;
	vec3 multiScatter = Fms * compensationFactor;
	return singleScatter + multiScatter;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX_Multiscatter( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,AL=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,dL=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,pL=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,gL=`#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,mL=`#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,yL=`#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,xL=`#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,vL=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,EL=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,_L=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,CL=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,bL=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,SL=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,IL=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,BL=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,ML=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,wL=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,TL=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,QL=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,DL=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,RL=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,NL=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,UL=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,LL=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,zL=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,OL=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,FL=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,PL=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,GL=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,kL=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,HL=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,VL=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,YL=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,qL=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,XL=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,JL=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,ZL=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		float depth = unpackRGBAToDepth( texture2D( depths, uv ) );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			return step( depth, compare );
		#else
			return step( compare, depth );
		#endif
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow( sampler2D shadow, vec2 uv, float compare ) {
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			float hard_shadow = step( distribution.x, compare );
		#else
			float hard_shadow = step( compare, distribution.x );
		#endif
		if ( hard_shadow != 1.0 ) {
			float distance = compare - distribution.x;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,WL=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,jL=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,KL=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,$L=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,tz=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,ez=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,nz=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,iz=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,sz=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,az=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,rz=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,oz=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,lz=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,cz=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,uz=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,hz=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,fz=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const Az=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,dz=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,pz=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,gz=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,mz=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,yz=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,xz=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,vz=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSED_DEPTH_BUFFER
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,Ez=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,_z=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,Cz=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,bz=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,Sz=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Iz=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Bz=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,Mz=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,wz=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Tz=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Qz=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,Dz=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Rz=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,Nz=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,Uz=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Lz=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,zz=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,Oz=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Fz=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Pz=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Gz=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,kz=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Hz=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Vz=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,Yz=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,qz=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,An={alphahash_fragment:dU,alphahash_pars_fragment:pU,alphamap_fragment:gU,alphamap_pars_fragment:mU,alphatest_fragment:yU,alphatest_pars_fragment:xU,aomap_fragment:vU,aomap_pars_fragment:EU,batching_pars_vertex:_U,batching_vertex:CU,begin_vertex:bU,beginnormal_vertex:SU,bsdfs:IU,iridescence_fragment:BU,bumpmap_pars_fragment:MU,clipping_planes_fragment:wU,clipping_planes_pars_fragment:TU,clipping_planes_pars_vertex:QU,clipping_planes_vertex:DU,color_fragment:RU,color_pars_fragment:NU,color_pars_vertex:UU,color_vertex:LU,common:zU,cube_uv_reflection_fragment:OU,defaultnormal_vertex:FU,displacementmap_pars_vertex:PU,displacementmap_vertex:GU,emissivemap_fragment:kU,emissivemap_pars_fragment:HU,colorspace_fragment:VU,colorspace_pars_fragment:YU,envmap_fragment:qU,envmap_common_pars_fragment:XU,envmap_pars_fragment:JU,envmap_pars_vertex:ZU,envmap_physical_pars_fragment:rL,envmap_vertex:WU,fog_vertex:jU,fog_pars_vertex:KU,fog_fragment:$U,fog_pars_fragment:tL,gradientmap_pars_fragment:eL,lightmap_pars_fragment:nL,lights_lambert_fragment:iL,lights_lambert_pars_fragment:sL,lights_pars_begin:aL,lights_toon_fragment:oL,lights_toon_pars_fragment:lL,lights_phong_fragment:cL,lights_phong_pars_fragment:uL,lights_physical_fragment:hL,lights_physical_pars_fragment:fL,lights_fragment_begin:AL,lights_fragment_maps:dL,lights_fragment_end:pL,logdepthbuf_fragment:gL,logdepthbuf_pars_fragment:mL,logdepthbuf_pars_vertex:yL,logdepthbuf_vertex:xL,map_fragment:vL,map_pars_fragment:EL,map_particle_fragment:_L,map_particle_pars_fragment:CL,metalnessmap_fragment:bL,metalnessmap_pars_fragment:SL,morphinstance_vertex:IL,morphcolor_vertex:BL,morphnormal_vertex:ML,morphtarget_pars_vertex:wL,morphtarget_vertex:TL,normal_fragment_begin:QL,normal_fragment_maps:DL,normal_pars_fragment:RL,normal_pars_vertex:NL,normal_vertex:UL,normalmap_pars_fragment:LL,clearcoat_normal_fragment_begin:zL,clearcoat_normal_fragment_maps:OL,clearcoat_pars_fragment:FL,iridescence_pars_fragment:PL,opaque_fragment:GL,packing:kL,premultiplied_alpha_fragment:HL,project_vertex:VL,dithering_fragment:YL,dithering_pars_fragment:qL,roughnessmap_fragment:XL,roughnessmap_pars_fragment:JL,shadowmap_pars_fragment:ZL,shadowmap_pars_vertex:WL,shadowmap_vertex:jL,shadowmask_pars_fragment:KL,skinbase_vertex:$L,skinning_pars_vertex:tz,skinning_vertex:ez,skinnormal_vertex:nz,specularmap_fragment:iz,specularmap_pars_fragment:sz,tonemapping_fragment:az,tonemapping_pars_fragment:rz,transmission_fragment:oz,transmission_pars_fragment:lz,uv_pars_fragment:cz,uv_pars_vertex:uz,uv_vertex:hz,worldpos_vertex:fz,background_vert:Az,background_frag:dz,backgroundCube_vert:pz,backgroundCube_frag:gz,cube_vert:mz,cube_frag:yz,depth_vert:xz,depth_frag:vz,distanceRGBA_vert:Ez,distanceRGBA_frag:_z,equirect_vert:Cz,equirect_frag:bz,linedashed_vert:Sz,linedashed_frag:Iz,meshbasic_vert:Bz,meshbasic_frag:Mz,meshlambert_vert:wz,meshlambert_frag:Tz,meshmatcap_vert:Qz,meshmatcap_frag:Dz,meshnormal_vert:Rz,meshnormal_frag:Nz,meshphong_vert:Uz,meshphong_frag:Lz,meshphysical_vert:zz,meshphysical_frag:Oz,meshtoon_vert:Fz,meshtoon_frag:Pz,points_vert:Gz,points_frag:kz,shadow_vert:Hz,shadow_frag:Vz,sprite_vert:Yz,sprite_frag:qz},pe={common:{diffuse:{value:new le(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Ze},alphaMap:{value:null},alphaMapTransform:{value:new Ze},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Ze}},envmap:{envMap:{value:null},envMapRotation:{value:new Ze},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98},dfgLUT:{value:null}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Ze}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Ze}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Ze},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Ze},normalScale:{value:new Dt(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Ze},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Ze}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Ze}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Ze}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new le(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new le(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Ze},alphaTest:{value:0},uvTransform:{value:new Ze}},sprite:{diffuse:{value:new le(16777215)},opacity:{value:1},center:{value:new Dt(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Ze},alphaMap:{value:null},alphaMapTransform:{value:new Ze},alphaTest:{value:0}}},ol={basic:{uniforms:Za([pe.common,pe.specularmap,pe.envmap,pe.aomap,pe.lightmap,pe.fog]),vertexShader:An.meshbasic_vert,fragmentShader:An.meshbasic_frag},lambert:{uniforms:Za([pe.common,pe.specularmap,pe.envmap,pe.aomap,pe.lightmap,pe.emissivemap,pe.bumpmap,pe.normalmap,pe.displacementmap,pe.fog,pe.lights,{emissive:{value:new le(0)}}]),vertexShader:An.meshlambert_vert,fragmentShader:An.meshlambert_frag},phong:{uniforms:Za([pe.common,pe.specularmap,pe.envmap,pe.aomap,pe.lightmap,pe.emissivemap,pe.bumpmap,pe.normalmap,pe.displacementmap,pe.fog,pe.lights,{emissive:{value:new le(0)},specular:{value:new le(1118481)},shininess:{value:30}}]),vertexShader:An.meshphong_vert,fragmentShader:An.meshphong_frag},standard:{uniforms:Za([pe.common,pe.envmap,pe.aomap,pe.lightmap,pe.emissivemap,pe.bumpmap,pe.normalmap,pe.displacementmap,pe.roughnessmap,pe.metalnessmap,pe.fog,pe.lights,{emissive:{value:new le(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:An.meshphysical_vert,fragmentShader:An.meshphysical_frag},toon:{uniforms:Za([pe.common,pe.aomap,pe.lightmap,pe.emissivemap,pe.bumpmap,pe.normalmap,pe.displacementmap,pe.gradientmap,pe.fog,pe.lights,{emissive:{value:new le(0)}}]),vertexShader:An.meshtoon_vert,fragmentShader:An.meshtoon_frag},matcap:{uniforms:Za([pe.common,pe.bumpmap,pe.normalmap,pe.displacementmap,pe.fog,{matcap:{value:null}}]),vertexShader:An.meshmatcap_vert,fragmentShader:An.meshmatcap_frag},points:{uniforms:Za([pe.points,pe.fog]),vertexShader:An.points_vert,fragmentShader:An.points_frag},dashed:{uniforms:Za([pe.common,pe.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:An.linedashed_vert,fragmentShader:An.linedashed_frag},depth:{uniforms:Za([pe.common,pe.displacementmap]),vertexShader:An.depth_vert,fragmentShader:An.depth_frag},normal:{uniforms:Za([pe.common,pe.bumpmap,pe.normalmap,pe.displacementmap,{opacity:{value:1}}]),vertexShader:An.meshnormal_vert,fragmentShader:An.meshnormal_frag},sprite:{uniforms:Za([pe.sprite,pe.fog]),vertexShader:An.sprite_vert,fragmentShader:An.sprite_frag},background:{uniforms:{uvTransform:{value:new Ze},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:An.background_vert,fragmentShader:An.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new Ze}},vertexShader:An.backgroundCube_vert,fragmentShader:An.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:An.cube_vert,fragmentShader:An.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:An.equirect_vert,fragmentShader:An.equirect_frag},distanceRGBA:{uniforms:Za([pe.common,pe.displacementmap,{referencePosition:{value:new F},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:An.distanceRGBA_vert,fragmentShader:An.distanceRGBA_frag},shadow:{uniforms:Za([pe.lights,pe.fog,{color:{value:new le(0)},opacity:{value:1}}]),vertexShader:An.shadow_vert,fragmentShader:An.shadow_frag}};ol.physical={uniforms:Za([ol.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Ze},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Ze},clearcoatNormalScale:{value:new Dt(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Ze},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Ze},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Ze},sheen:{value:0},sheenColor:{value:new le(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Ze},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Ze},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Ze},transmissionSamplerSize:{value:new Dt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Ze},attenuationDistance:{value:0},attenuationColor:{value:new le(0)},specularColor:{value:new le(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Ze},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Ze},anisotropyVector:{value:new Dt},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Ze}}]),vertexShader:An.meshphysical_vert,fragmentShader:An.meshphysical_frag};const Cx={r:0,b:0,g:0},yf=new _r,Xz=new he;function Jz(s,t,e,n,i,r,l){const u=new le(0);let A=r===!0?0:1,d,m,g=null,y=0,v=null;function C(w){let Q=w.isScene===!0?w.background:null;return Q&&Q.isTexture&&(Q=(w.backgroundBlurriness>0?e:t).get(Q)),Q}function I(w){let Q=!1;const R=C(w);R===null?E(u,A):R&&R.isColor&&(E(R,1),Q=!0);const D=s.xr.getEnvironmentBlendMode();D==="additive"?n.buffers.color.setClear(0,0,0,1,l):D==="alpha-blend"&&n.buffers.color.setClear(0,0,0,0,l),(s.autoClear||Q)&&(n.buffers.depth.setTest(!0),n.buffers.depth.setMask(!0),n.buffers.color.setMask(!0),s.clear(s.autoClearColor,s.autoClearDepth,s.autoClearStencil))}function S(w,Q){const R=C(Q);R&&(R.isCubeTexture||R.mapping===rp)?(m===void 0&&(m=new oe(new pr(1,1,1),new $a({name:"BackgroundCubeMaterial",uniforms:np(ol.backgroundCube.uniforms),vertexShader:ol.backgroundCube.vertexShader,fragmentShader:ol.backgroundCube.fragmentShader,side:_a,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),m.geometry.deleteAttribute("normal"),m.geometry.deleteAttribute("uv"),m.onBeforeRender=function(D,U,P){this.matrixWorld.copyPosition(P.matrixWorld)},Object.defineProperty(m.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(m)),yf.copy(Q.backgroundRotation),yf.x*=-1,yf.y*=-1,yf.z*=-1,R.isCubeTexture&&R.isRenderTargetTexture===!1&&(yf.y*=-1,yf.z*=-1),m.material.uniforms.envMap.value=R,m.material.uniforms.flipEnvMap.value=R.isCubeTexture&&R.isRenderTargetTexture===!1?-1:1,m.material.uniforms.backgroundBlurriness.value=Q.backgroundBlurriness,m.material.uniforms.backgroundIntensity.value=Q.backgroundIntensity,m.material.uniforms.backgroundRotation.value.setFromMatrix4(Xz.makeRotationFromEuler(yf)),m.material.toneMapped=Gn.getTransfer(R.colorSpace)!==ui,(g!==R||y!==R.version||v!==s.toneMapping)&&(m.material.needsUpdate=!0,g=R,y=R.version,v=s.toneMapping),m.layers.enableAll(),w.unshift(m,m.geometry,m.material,0,0,null)):R&&R.isTexture&&(d===void 0&&(d=new oe(new kr(2,2),new $a({name:"BackgroundMaterial",uniforms:np(ol.background.uniforms),vertexShader:ol.background.vertexShader,fragmentShader:ol.background.fragmentShader,side:fl,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),d.geometry.deleteAttribute("normal"),Object.defineProperty(d.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(d)),d.material.uniforms.t2D.value=R,d.material.uniforms.backgroundIntensity.value=Q.backgroundIntensity,d.material.toneMapped=Gn.getTransfer(R.colorSpace)!==ui,R.matrixAutoUpdate===!0&&R.updateMatrix(),d.material.uniforms.uvTransform.value.copy(R.matrix),(g!==R||y!==R.version||v!==s.toneMapping)&&(d.material.needsUpdate=!0,g=R,y=R.version,v=s.toneMapping),d.layers.enableAll(),w.unshift(d,d.geometry,d.material,0,0,null))}function E(w,Q){w.getRGB(Cx,lw(s)),n.buffers.color.setClear(Cx.r,Cx.g,Cx.b,Q,l)}function B(){m!==void 0&&(m.geometry.dispose(),m.material.dispose(),m=void 0),d!==void 0&&(d.geometry.dispose(),d.material.dispose(),d=void 0)}return{getClearColor:function(){return u},setClearColor:function(w,Q=1){u.set(w),A=Q,E(u,A)},getClearAlpha:function(){return A},setClearAlpha:function(w){A=w,E(u,A)},render:I,addToRenderList:S,dispose:B}}function Zz(s,t){const e=s.getParameter(s.MAX_VERTEX_ATTRIBS),n={},i=y(null);let r=i,l=!1;function u(L,k,Y,W,K){let nt=!1;const H=g(W,Y,k);r!==H&&(r=H,d(r.object)),nt=v(L,W,Y,K),nt&&C(L,W,Y,K),K!==null&&t.update(K,s.ELEMENT_ARRAY_BUFFER),(nt||l)&&(l=!1,Q(L,k,Y,W),K!==null&&s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,t.get(K).buffer))}function A(){return s.createVertexArray()}function d(L){return s.bindVertexArray(L)}function m(L){return s.deleteVertexArray(L)}function g(L,k,Y){const W=Y.wireframe===!0;let K=n[L.id];K===void 0&&(K={},n[L.id]=K);let nt=K[k.id];nt===void 0&&(nt={},K[k.id]=nt);let H=nt[W];return H===void 0&&(H=y(A()),nt[W]=H),H}function y(L){const k=[],Y=[],W=[];for(let K=0;K<e;K++)k[K]=0,Y[K]=0,W[K]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:k,enabledAttributes:Y,attributeDivisors:W,object:L,attributes:{},index:null}}function v(L,k,Y,W){const K=r.attributes,nt=k.attributes;let H=0;const tt=Y.getAttributes();for(const it in tt)if(tt[it].location>=0){const At=K[it];let V=nt[it];if(V===void 0&&(it==="instanceMatrix"&&L.instanceMatrix&&(V=L.instanceMatrix),it==="instanceColor"&&L.instanceColor&&(V=L.instanceColor)),At===void 0||At.attribute!==V||V&&At.data!==V.data)return!0;H++}return r.attributesNum!==H||r.index!==W}function C(L,k,Y,W){const K={},nt=k.attributes;let H=0;const tt=Y.getAttributes();for(const it in tt)if(tt[it].location>=0){let At=nt[it];At===void 0&&(it==="instanceMatrix"&&L.instanceMatrix&&(At=L.instanceMatrix),it==="instanceColor"&&L.instanceColor&&(At=L.instanceColor));const V={};V.attribute=At,At&&At.data&&(V.data=At.data),K[it]=V,H++}r.attributes=K,r.attributesNum=H,r.index=W}function I(){const L=r.newAttributes;for(let k=0,Y=L.length;k<Y;k++)L[k]=0}function S(L){E(L,0)}function E(L,k){const Y=r.newAttributes,W=r.enabledAttributes,K=r.attributeDivisors;Y[L]=1,W[L]===0&&(s.enableVertexAttribArray(L),W[L]=1),K[L]!==k&&(s.vertexAttribDivisor(L,k),K[L]=k)}function B(){const L=r.newAttributes,k=r.enabledAttributes;for(let Y=0,W=k.length;Y<W;Y++)k[Y]!==L[Y]&&(s.disableVertexAttribArray(Y),k[Y]=0)}function w(L,k,Y,W,K,nt,H){H===!0?s.vertexAttribIPointer(L,k,Y,K,nt):s.vertexAttribPointer(L,k,Y,W,K,nt)}function Q(L,k,Y,W){I();const K=W.attributes,nt=Y.getAttributes(),H=k.defaultAttributeValues;for(const tt in nt){const it=nt[tt];if(it.location>=0){let ot=K[tt];if(ot===void 0&&(tt==="instanceMatrix"&&L.instanceMatrix&&(ot=L.instanceMatrix),tt==="instanceColor"&&L.instanceColor&&(ot=L.instanceColor)),ot!==void 0){const At=ot.normalized,V=ot.itemSize,st=t.get(ot);if(st===void 0)continue;const xt=st.buffer,j=st.type,Rt=st.bytesPerElement,dt=j===s.INT||j===s.UNSIGNED_INT||ot.gpuType===cE;if(ot.isInterleavedBufferAttribute){const pt=ot.data,qt=pt.stride,Wt=ot.offset;if(pt.isInstancedInterleavedBuffer){for(let ce=0;ce<it.locationSize;ce++)E(it.location+ce,pt.meshPerAttribute);L.isInstancedMesh!==!0&&W._maxInstanceCount===void 0&&(W._maxInstanceCount=pt.meshPerAttribute*pt.count)}else for(let ce=0;ce<it.locationSize;ce++)S(it.location+ce);s.bindBuffer(s.ARRAY_BUFFER,xt);for(let ce=0;ce<it.locationSize;ce++)w(it.location+ce,V/it.locationSize,j,At,qt*Rt,(Wt+V/it.locationSize*ce)*Rt,dt)}else{if(ot.isInstancedBufferAttribute){for(let pt=0;pt<it.locationSize;pt++)E(it.location+pt,ot.meshPerAttribute);L.isInstancedMesh!==!0&&W._maxInstanceCount===void 0&&(W._maxInstanceCount=ot.meshPerAttribute*ot.count)}else for(let pt=0;pt<it.locationSize;pt++)S(it.location+pt);s.bindBuffer(s.ARRAY_BUFFER,xt);for(let pt=0;pt<it.locationSize;pt++)w(it.location+pt,V/it.locationSize,j,At,V*Rt,V/it.locationSize*pt*Rt,dt)}}else if(H!==void 0){const At=H[tt];if(At!==void 0)switch(At.length){case 2:s.vertexAttrib2fv(it.location,At);break;case 3:s.vertexAttrib3fv(it.location,At);break;case 4:s.vertexAttrib4fv(it.location,At);break;default:s.vertexAttrib1fv(it.location,At)}}}}B()}function R(){P();for(const L in n){const k=n[L];for(const Y in k){const W=k[Y];for(const K in W)m(W[K].object),delete W[K];delete k[Y]}delete n[L]}}function D(L){if(n[L.id]===void 0)return;const k=n[L.id];for(const Y in k){const W=k[Y];for(const K in W)m(W[K].object),delete W[K];delete k[Y]}delete n[L.id]}function U(L){for(const k in n){const Y=n[k];if(Y[L.id]===void 0)continue;const W=Y[L.id];for(const K in W)m(W[K].object),delete W[K];delete Y[L.id]}}function P(){z(),l=!0,r!==i&&(r=i,d(r.object))}function z(){i.geometry=null,i.program=null,i.wireframe=!1}return{setup:u,reset:P,resetDefaultState:z,dispose:R,releaseStatesOfGeometry:D,releaseStatesOfProgram:U,initAttributes:I,enableAttribute:S,disableUnusedAttributes:B}}function Wz(s,t,e){let n;function i(d){n=d}function r(d,m){s.drawArrays(n,d,m),e.update(m,n,1)}function l(d,m,g){g!==0&&(s.drawArraysInstanced(n,d,m,g),e.update(m,n,g))}function u(d,m,g){if(g===0)return;t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n,d,0,m,0,g);let v=0;for(let C=0;C<g;C++)v+=m[C];e.update(v,n,1)}function A(d,m,g,y){if(g===0)return;const v=t.get("WEBGL_multi_draw");if(v===null)for(let C=0;C<d.length;C++)l(d[C],m[C],y[C]);else{v.multiDrawArraysInstancedWEBGL(n,d,0,m,0,y,0,g);let C=0;for(let I=0;I<g;I++)C+=m[I]*y[I];e.update(C,n,1)}}this.setMode=i,this.render=r,this.renderInstances=l,this.renderMultiDraw=u,this.renderMultiDrawInstances=A}function jz(s,t,e,n){let i;function r(){if(i!==void 0)return i;if(t.has("EXT_texture_filter_anisotropic")===!0){const U=t.get("EXT_texture_filter_anisotropic");i=s.getParameter(U.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}function l(U){return!(U!==Ki&&n.convert(U)!==s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT))}function u(U){const P=U===$f&&(t.has("EXT_color_buffer_half_float")||t.has("EXT_color_buffer_float"));return!(U!==ea&&n.convert(U)!==s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE)&&U!==xr&&!P)}function A(U){if(U==="highp"){if(s.getShaderPrecisionFormat(s.VERTEX_SHADER,s.HIGH_FLOAT).precision>0&&s.getShaderPrecisionFormat(s.FRAGMENT_SHADER,s.HIGH_FLOAT).precision>0)return"highp";U="mediump"}return U==="mediump"&&s.getShaderPrecisionFormat(s.VERTEX_SHADER,s.MEDIUM_FLOAT).precision>0&&s.getShaderPrecisionFormat(s.FRAGMENT_SHADER,s.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let d=e.precision!==void 0?e.precision:"highp";const m=A(d);m!==d&&(ge("WebGLRenderer:",d,"not supported, using",m,"instead."),d=m);const g=e.logarithmicDepthBuffer===!0,y=e.reversedDepthBuffer===!0&&t.has("EXT_clip_control"),v=s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS),C=s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS),I=s.getParameter(s.MAX_TEXTURE_SIZE),S=s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE),E=s.getParameter(s.MAX_VERTEX_ATTRIBS),B=s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS),w=s.getParameter(s.MAX_VARYING_VECTORS),Q=s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS),R=C>0,D=s.getParameter(s.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:r,getMaxPrecision:A,textureFormatReadable:l,textureTypeReadable:u,precision:d,logarithmicDepthBuffer:g,reversedDepthBuffer:y,maxTextures:v,maxVertexTextures:C,maxTextureSize:I,maxCubemapSize:S,maxAttributes:E,maxVertexUniforms:B,maxVaryings:w,maxFragmentUniforms:Q,vertexTextures:R,maxSamples:D}}function Kz(s){const t=this;let e=null,n=0,i=!1,r=!1;const l=new Kl,u=new Ze,A={value:null,needsUpdate:!1};this.uniform=A,this.numPlanes=0,this.numIntersection=0,this.init=function(g,y){const v=g.length!==0||y||n!==0||i;return i=y,n=g.length,v},this.beginShadows=function(){r=!0,m(null)},this.endShadows=function(){r=!1},this.setGlobalState=function(g,y){e=m(g,y,0)},this.setState=function(g,y,v){const C=g.clippingPlanes,I=g.clipIntersection,S=g.clipShadows,E=s.get(g);if(!i||C===null||C.length===0||r&&!S)r?m(null):d();else{const B=r?0:n,w=B*4;let Q=E.clippingState||null;A.value=Q,Q=m(C,y,w,v);for(let R=0;R!==w;++R)Q[R]=e[R];E.clippingState=Q,this.numIntersection=I?this.numPlanes:0,this.numPlanes+=B}};function d(){A.value!==e&&(A.value=e,A.needsUpdate=n>0),t.numPlanes=n,t.numIntersection=0}function m(g,y,v,C){const I=g!==null?g.length:0;let S=null;if(I!==0){if(S=A.value,C!==!0||S===null){const E=v+I*4,B=y.matrixWorldInverse;u.getNormalMatrix(B),(S===null||S.length<E)&&(S=new Float32Array(E));for(let w=0,Q=v;w!==I;++w,Q+=4)l.copy(g[w]).applyMatrix4(B,u),l.normal.toArray(S,Q),S[Q+3]=l.constant}A.value=S,A.needsUpdate=!0}return t.numPlanes=I,t.numIntersection=0,S}}function $z(s){let t=new WeakMap;function e(l,u){return u===Rm?l.mapping=eu:u===Nm&&(l.mapping=fh),l}function n(l){if(l&&l.isTexture){const u=l.mapping;if(u===Rm||u===Nm)if(t.has(l)){const A=t.get(l).texture;return e(A,l.mapping)}else{const A=l.image;if(A&&A.height>0){const d=new wS(A.height);return d.fromEquirectangularTexture(s,l),t.set(l,d),l.addEventListener("dispose",i),e(d.texture,l.mapping)}else return null}}return l}function i(l){const u=l.target;u.removeEventListener("dispose",i);const A=t.get(u);A!==void 0&&(t.delete(u),A.dispose())}function r(){t=new WeakMap}return{get:n,dispose:r}}const uh=4,B2=[.125,.215,.35,.446,.526,.582],Tf=20,t4=256,Jg=new cp,M2=new le;let IC=null,BC=0,MC=0,wC=!1;const e4=new F;class Kv{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._sizeLods=[],this._sigmas=[],this._lodMeshes=[],this._backgroundBox=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._blurMaterial=null,this._ggxMaterial=null}fromScene(t,e=0,n=.1,i=100,r={}){const{size:l=256,position:u=e4}=r;IC=this._renderer.getRenderTarget(),BC=this._renderer.getActiveCubeFace(),MC=this._renderer.getActiveMipmapLevel(),wC=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(l);const A=this._allocateTargets();return A.depthBuffer=!0,this._sceneToCubeUV(t,n,i,A,u),e>0&&this._blur(A,0,0,e),this._applyPMREM(A),this._cleanup(A),A}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=Q2(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=T2(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose(),this._backgroundBox!==null&&(this._backgroundBox.geometry.dispose(),this._backgroundBox.material.dispose())}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._ggxMaterial!==null&&this._ggxMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodMeshes.length;t++)this._lodMeshes[t].geometry.dispose()}_cleanup(t){this._renderer.setRenderTarget(IC,BC,MC),this._renderer.xr.enabled=wC,t.scissorTest=!1,_d(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===eu||t.mapping===fh?this._setSize(t.image.length===0?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),IC=this._renderer.getRenderTarget(),BC=this._renderer.getActiveCubeFace(),MC=this._renderer.getActiveMipmapLevel(),wC=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const n=e||this._allocateTargets();return this._textureToCubeUV(t,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,n={magFilter:as,minFilter:as,generateMipmaps:!1,type:$f,format:Ki,colorSpace:Ah,depthBuffer:!1},i=w2(t,e,n);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==t||this._pingPongRenderTarget.height!==e){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=w2(t,e,n);const{_lodMax:r}=this;({lodMeshes:this._lodMeshes,sizeLods:this._sizeLods,sigmas:this._sigmas}=n4(r)),this._blurMaterial=s4(r,t,e),this._ggxMaterial=i4(r,t,e)}return i}_compileMaterial(t){const e=new oe(new Fe,t);this._renderer.compile(e,Jg)}_sceneToCubeUV(t,e,n,i,r){const A=new As(90,1,e,n),d=[1,-1,1,1,1,1],m=[1,1,1,-1,-1,-1],g=this._renderer,y=g.autoClear,v=g.toneMapping;g.getClearColor(M2),g.toneMapping=ic,g.autoClear=!1,g.state.buffers.depth.getReversed()&&(g.setRenderTarget(i),g.clearDepth(),g.setRenderTarget(null)),this._backgroundBox===null&&(this._backgroundBox=new oe(new pr,new pl({name:"PMREM.Background",side:_a,depthWrite:!1,depthTest:!1})));const I=this._backgroundBox,S=I.material;let E=!1;const B=t.background;B?B.isColor&&(S.color.copy(B),t.background=null,E=!0):(S.color.copy(M2),E=!0);for(let w=0;w<6;w++){const Q=w%3;Q===0?(A.up.set(0,d[w],0),A.position.set(r.x,r.y,r.z),A.lookAt(r.x+m[w],r.y,r.z)):Q===1?(A.up.set(0,0,d[w]),A.position.set(r.x,r.y,r.z),A.lookAt(r.x,r.y+m[w],r.z)):(A.up.set(0,d[w],0),A.position.set(r.x,r.y,r.z),A.lookAt(r.x,r.y,r.z+m[w]));const R=this._cubeSize;_d(i,Q*R,w>2?R:0,R,R),g.setRenderTarget(i),E&&g.render(I,A),g.render(t,A)}g.toneMapping=v,g.autoClear=y,t.background=B}_textureToCubeUV(t,e){const n=this._renderer,i=t.mapping===eu||t.mapping===fh;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=Q2()),this._cubemapMaterial.uniforms.flipEnvMap.value=t.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=T2());const r=i?this._cubemapMaterial:this._equirectMaterial,l=this._lodMeshes[0];l.material=r;const u=r.uniforms;u.envMap.value=t;const A=this._cubeSize;_d(e,0,0,3*A,2*A),n.setRenderTarget(e),n.render(l,Jg)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;const i=this._lodMeshes.length;for(let r=1;r<i;r++)this._applyGGXFilter(t,r-1,r);e.autoClear=n}_applyGGXFilter(t,e,n){const i=this._renderer,r=this._pingPongRenderTarget,l=this._ggxMaterial,u=this._lodMeshes[n];u.material=l;const A=l.uniforms,d=n/(this._lodMeshes.length-1),m=e/(this._lodMeshes.length-1),g=Math.sqrt(d*d-m*m),y=.05+d*.95,v=g*y,{_lodMax:C}=this,I=this._sizeLods[n],S=3*I*(n>C-uh?n-C+uh:0),E=4*(this._cubeSize-I);A.envMap.value=t.texture,A.roughness.value=v,A.mipInt.value=C-e,_d(r,S,E,3*I,2*I),i.setRenderTarget(r),i.render(u,Jg),A.envMap.value=r.texture,A.roughness.value=0,A.mipInt.value=C-n,_d(t,S,E,3*I,2*I),i.setRenderTarget(t),i.render(u,Jg)}_blur(t,e,n,i,r){const l=this._pingPongRenderTarget;this._halfBlur(t,l,e,n,i,"latitudinal",r),this._halfBlur(l,t,n,n,i,"longitudinal",r)}_halfBlur(t,e,n,i,r,l,u){const A=this._renderer,d=this._blurMaterial;l!=="latitudinal"&&l!=="longitudinal"&&nn("blur direction must be either latitudinal or longitudinal!");const m=3,g=this._lodMeshes[i];g.material=d;const y=d.uniforms,v=this._sizeLods[n]-1,C=isFinite(r)?Math.PI/(2*v):2*Math.PI/(2*Tf-1),I=r/C,S=isFinite(r)?1+Math.floor(m*I):Tf;S>Tf&&ge(`sigmaRadians, ${r}, is too large and will clip, as it requested ${S} samples when the maximum is set to ${Tf}`);const E=[];let B=0;for(let U=0;U<Tf;++U){const P=U/I,z=Math.exp(-P*P/2);E.push(z),U===0?B+=z:U<S&&(B+=2*z)}for(let U=0;U<E.length;U++)E[U]=E[U]/B;y.envMap.value=t.texture,y.samples.value=S,y.weights.value=E,y.latitudinal.value=l==="latitudinal",u&&(y.poleAxis.value=u);const{_lodMax:w}=this;y.dTheta.value=C,y.mipInt.value=w-n;const Q=this._sizeLods[i],R=3*Q*(i>w-uh?i-w+uh:0),D=4*(this._cubeSize-Q);_d(e,R,D,3*Q,2*Q),A.setRenderTarget(e),A.render(g,Jg)}}function n4(s){const t=[],e=[],n=[];let i=s;const r=s-uh+1+B2.length;for(let l=0;l<r;l++){const u=Math.pow(2,i);t.push(u);let A=1/u;l>s-uh?A=B2[l-s+uh-1]:l===0&&(A=0),e.push(A);const d=1/(u-2),m=-d,g=1+d,y=[m,m,g,m,g,g,m,m,g,g,m,g],v=6,C=6,I=3,S=2,E=1,B=new Float32Array(I*C*v),w=new Float32Array(S*C*v),Q=new Float32Array(E*C*v);for(let D=0;D<v;D++){const U=D%3*2/3-1,P=D>2?0:-1,z=[U,P,0,U+2/3,P,0,U+2/3,P+1,0,U,P,0,U+2/3,P+1,0,U,P+1,0];B.set(z,I*C*D),w.set(y,S*C*D);const L=[D,D,D,D,D,D];Q.set(L,E*C*D)}const R=new Fe;R.setAttribute("position",new Qn(B,I)),R.setAttribute("uv",new Qn(w,S)),R.setAttribute("faceIndex",new Qn(Q,E)),n.push(new oe(R,null)),i>uh&&i--}return{lodMeshes:n,sizeLods:t,sigmas:e}}function w2(s,t,e){const n=new Io(s,t,e);return n.texture.mapping=rp,n.texture.name="PMREM.cubeUv",n.scissorTest=!0,n}function _d(s,t,e,n,i){s.viewport.set(t,e,n,i),s.scissor.set(t,e,n,i)}function i4(s,t,e){return new $a({name:"PMREMGGXConvolution",defines:{GGX_SAMPLES:t4,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/e,CUBEUV_MAX_MIP:`${s}.0`},uniforms:{envMap:{value:null},roughness:{value:0},mipInt:{value:0}},vertexShader:zE(),fragmentShader:`

			precision highp float;
			precision highp int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform float roughness;
			uniform float mipInt;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			#define PI 3.14159265359

			// Van der Corput radical inverse
			float radicalInverse_VdC(uint bits) {
				bits = (bits << 16u) | (bits >> 16u);
				bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
				bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
				bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
				bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
				return float(bits) * 2.3283064365386963e-10; // / 0x100000000
			}

			// Hammersley sequence
			vec2 hammersley(uint i, uint N) {
				return vec2(float(i) / float(N), radicalInverse_VdC(i));
			}

			// GGX VNDF importance sampling (Eric Heitz 2018)
			// "Sampling the GGX Distribution of Visible Normals"
			// https://jcgt.org/published/0007/04/01/
			vec3 importanceSampleGGX_VNDF(vec2 Xi, vec3 V, float roughness) {
				float alpha = roughness * roughness;

				// Section 3.2: Transform view direction to hemisphere configuration
				vec3 Vh = normalize(vec3(alpha * V.x, alpha * V.y, V.z));

				// Section 4.1: Orthonormal basis
				float lensq = Vh.x * Vh.x + Vh.y * Vh.y;
				vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) / sqrt(lensq) : vec3(1.0, 0.0, 0.0);
				vec3 T2 = cross(Vh, T1);

				// Section 4.2: Parameterization of projected area
				float r = sqrt(Xi.x);
				float phi = 2.0 * PI * Xi.y;
				float t1 = r * cos(phi);
				float t2 = r * sin(phi);
				float s = 0.5 * (1.0 + Vh.z);
				t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;

				// Section 4.3: Reprojection onto hemisphere
				vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;

				// Section 3.4: Transform back to ellipsoid configuration
				return normalize(vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z)));
			}

			void main() {
				vec3 N = normalize(vOutputDirection);
				vec3 V = N; // Assume view direction equals normal for pre-filtering

				vec3 prefilteredColor = vec3(0.0);
				float totalWeight = 0.0;

				// For very low roughness, just sample the environment directly
				if (roughness < 0.001) {
					gl_FragColor = vec4(bilinearCubeUV(envMap, N, mipInt), 1.0);
					return;
				}

				// Tangent space basis for VNDF sampling
				vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
				vec3 tangent = normalize(cross(up, N));
				vec3 bitangent = cross(N, tangent);

				for(uint i = 0u; i < uint(GGX_SAMPLES); i++) {
					vec2 Xi = hammersley(i, uint(GGX_SAMPLES));

					// For PMREM, V = N, so in tangent space V is always (0, 0, 1)
					vec3 H_tangent = importanceSampleGGX_VNDF(Xi, vec3(0.0, 0.0, 1.0), roughness);

					// Transform H back to world space
					vec3 H = normalize(tangent * H_tangent.x + bitangent * H_tangent.y + N * H_tangent.z);
					vec3 L = normalize(2.0 * dot(V, H) * H - V);

					float NdotL = max(dot(N, L), 0.0);

					if(NdotL > 0.0) {
						// Sample environment at fixed mip level
						// VNDF importance sampling handles the distribution filtering
						vec3 sampleColor = bilinearCubeUV(envMap, L, mipInt);

						// Weight by NdotL for the split-sum approximation
						// VNDF PDF naturally accounts for the visible microfacet distribution
						prefilteredColor += sampleColor * NdotL;
						totalWeight += NdotL;
					}
				}

				if (totalWeight > 0.0) {
					prefilteredColor = prefilteredColor / totalWeight;
				}

				gl_FragColor = vec4(prefilteredColor, 1.0);
			}
		`,blending:nc,depthTest:!1,depthWrite:!1})}function s4(s,t,e){const n=new Float32Array(Tf),i=new F(0,1,0);return new $a({name:"SphericalGaussianBlur",defines:{n:Tf,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/e,CUBEUV_MAX_MIP:`${s}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:zE(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:nc,depthTest:!1,depthWrite:!1})}function T2(){return new $a({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:zE(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:nc,depthTest:!1,depthWrite:!1})}function Q2(){return new $a({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:zE(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:nc,depthTest:!1,depthWrite:!1})}function zE(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function a4(s){let t=new WeakMap,e=null;function n(u){if(u&&u.isTexture){const A=u.mapping,d=A===Rm||A===Nm,m=A===eu||A===fh;if(d||m){let g=t.get(u);const y=g!==void 0?g.texture.pmremVersion:0;if(u.isRenderTargetTexture&&u.pmremVersion!==y)return e===null&&(e=new Kv(s)),g=d?e.fromEquirectangular(u,g):e.fromCubemap(u,g),g.texture.pmremVersion=u.pmremVersion,t.set(u,g),g.texture;if(g!==void 0)return g.texture;{const v=u.image;return d&&v&&v.height>0||m&&v&&i(v)?(e===null&&(e=new Kv(s)),g=d?e.fromEquirectangular(u):e.fromCubemap(u),g.texture.pmremVersion=u.pmremVersion,t.set(u,g),u.addEventListener("dispose",r),g.texture):null}}}return u}function i(u){let A=0;const d=6;for(let m=0;m<d;m++)u[m]!==void 0&&A++;return A===d}function r(u){const A=u.target;A.removeEventListener("dispose",r);const d=t.get(A);d!==void 0&&(t.delete(A),d.dispose())}function l(){t=new WeakMap,e!==null&&(e.dispose(),e=null)}return{get:n,dispose:l}}function r4(s){const t={};function e(n){if(t[n]!==void 0)return t[n];const i=s.getExtension(n);return t[n]=i,i}return{has:function(n){return e(n)!==null},init:function(){e("EXT_color_buffer_float"),e("WEBGL_clip_cull_distance"),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float"),e("WEBGL_multisampled_render_to_texture"),e("WEBGL_render_shared_exponent")},get:function(n){const i=e(n);return i===null&&$d("WebGLRenderer: "+n+" extension not supported."),i}}}function o4(s,t,e,n){const i={},r=new WeakMap;function l(g){const y=g.target;y.index!==null&&t.remove(y.index);for(const C in y.attributes)t.remove(y.attributes[C]);y.removeEventListener("dispose",l),delete i[y.id];const v=r.get(y);v&&(t.remove(v),r.delete(y)),n.releaseStatesOfGeometry(y),y.isInstancedBufferGeometry===!0&&delete y._maxInstanceCount,e.memory.geometries--}function u(g,y){return i[y.id]===!0||(y.addEventListener("dispose",l),i[y.id]=!0,e.memory.geometries++),y}function A(g){const y=g.attributes;for(const v in y)t.update(y[v],s.ARRAY_BUFFER)}function d(g){const y=[],v=g.index,C=g.attributes.position;let I=0;if(v!==null){const B=v.array;I=v.version;for(let w=0,Q=B.length;w<Q;w+=3){const R=B[w+0],D=B[w+1],U=B[w+2];y.push(R,D,D,U,U,R)}}else if(C!==void 0){const B=C.array;I=C.version;for(let w=0,Q=B.length/3-1;w<Q;w+=3){const R=w+0,D=w+1,U=w+2;y.push(R,D,D,U,U,R)}}else return;const S=new(sw(y)?IS:SS)(y,1);S.version=I;const E=r.get(g);E&&t.remove(E),r.set(g,S)}function m(g){const y=r.get(g);if(y){const v=g.index;v!==null&&y.version<v.version&&d(g)}else d(g);return r.get(g)}return{get:u,update:A,getWireframeAttribute:m}}function l4(s,t,e){let n;function i(y){n=y}let r,l;function u(y){r=y.type,l=y.bytesPerElement}function A(y,v){s.drawElements(n,v,r,y*l),e.update(v,n,1)}function d(y,v,C){C!==0&&(s.drawElementsInstanced(n,v,r,y*l,C),e.update(v,n,C))}function m(y,v,C){if(C===0)return;t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n,v,0,r,y,0,C);let S=0;for(let E=0;E<C;E++)S+=v[E];e.update(S,n,1)}function g(y,v,C,I){if(C===0)return;const S=t.get("WEBGL_multi_draw");if(S===null)for(let E=0;E<y.length;E++)d(y[E]/l,v[E],I[E]);else{S.multiDrawElementsInstancedWEBGL(n,v,0,r,y,0,I,0,C);let E=0;for(let B=0;B<C;B++)E+=v[B]*I[B];e.update(E,n,1)}}this.setMode=i,this.setIndex=u,this.render=A,this.renderInstances=d,this.renderMultiDraw=m,this.renderMultiDrawInstances=g}function c4(s){const t={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function n(r,l,u){switch(e.calls++,l){case s.TRIANGLES:e.triangles+=u*(r/3);break;case s.LINES:e.lines+=u*(r/2);break;case s.LINE_STRIP:e.lines+=u*(r-1);break;case s.LINE_LOOP:e.lines+=u*r;break;case s.POINTS:e.points+=u*r;break;default:nn("WebGLInfo: Unknown draw mode:",l);break}}function i(){e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:t,render:e,programs:null,autoReset:!0,reset:i,update:n}}function u4(s,t,e){const n=new WeakMap,i=new We;function r(l,u,A){const d=l.morphTargetInfluences,m=u.morphAttributes.position||u.morphAttributes.normal||u.morphAttributes.color,g=m!==void 0?m.length:0;let y=n.get(u);if(y===void 0||y.count!==g){let z=function(){U.dispose(),n.delete(u),u.removeEventListener("dispose",z)};y!==void 0&&y.texture.dispose();const v=u.morphAttributes.position!==void 0,C=u.morphAttributes.normal!==void 0,I=u.morphAttributes.color!==void 0,S=u.morphAttributes.position||[],E=u.morphAttributes.normal||[],B=u.morphAttributes.color||[];let w=0;v===!0&&(w=1),C===!0&&(w=2),I===!0&&(w=3);let Q=u.attributes.position.count*w,R=1;Q>t.maxTextureSize&&(R=Math.ceil(Q/t.maxTextureSize),Q=t.maxTextureSize);const D=new Float32Array(Q*R*4*g),U=new hl(D,Q,R,g);U.type=xr,U.needsUpdate=!0;const P=w*4;for(let L=0;L<g;L++){const k=S[L],Y=E[L],W=B[L],K=Q*R*4*L;for(let nt=0;nt<k.count;nt++){const H=nt*P;v===!0&&(i.fromBufferAttribute(k,nt),D[K+H+0]=i.x,D[K+H+1]=i.y,D[K+H+2]=i.z,D[K+H+3]=0),C===!0&&(i.fromBufferAttribute(Y,nt),D[K+H+4]=i.x,D[K+H+5]=i.y,D[K+H+6]=i.z,D[K+H+7]=0),I===!0&&(i.fromBufferAttribute(W,nt),D[K+H+8]=i.x,D[K+H+9]=i.y,D[K+H+10]=i.z,D[K+H+11]=W.itemSize===4?i.w:1)}}y={count:g,texture:U,size:new Dt(Q,R)},n.set(u,y),u.addEventListener("dispose",z)}if(l.isInstancedMesh===!0&&l.morphTexture!==null)A.getUniforms().setValue(s,"morphTexture",l.morphTexture,e);else{let v=0;for(let I=0;I<d.length;I++)v+=d[I];const C=u.morphTargetsRelative?1:1-v;A.getUniforms().setValue(s,"morphTargetBaseInfluence",C),A.getUniforms().setValue(s,"morphTargetInfluences",d)}A.getUniforms().setValue(s,"morphTargetsTexture",y.texture,e),A.getUniforms().setValue(s,"morphTargetsTextureSize",y.size)}return{update:r}}function h4(s,t,e,n){let i=new WeakMap;function r(A){const d=n.render.frame,m=A.geometry,g=t.get(A,m);if(i.get(g)!==d&&(t.update(g),i.set(g,d)),A.isInstancedMesh&&(A.hasEventListener("dispose",u)===!1&&A.addEventListener("dispose",u),i.get(A)!==d&&(e.update(A.instanceMatrix,s.ARRAY_BUFFER),A.instanceColor!==null&&e.update(A.instanceColor,s.ARRAY_BUFFER),i.set(A,d))),A.isSkinnedMesh){const y=A.skeleton;i.get(y)!==d&&(y.update(),i.set(y,d))}return g}function l(){i=new WeakMap}function u(A){const d=A.target;d.removeEventListener("dispose",u),e.remove(d.instanceMatrix),d.instanceColor!==null&&e.remove(d.instanceColor)}return{update:r,dispose:l}}const n3=new wi,D2=new US(1,1),i3=new hl,s3=new a0,a3=new r0,R2=[],N2=[],U2=new Float32Array(16),L2=new Float32Array(9),z2=new Float32Array(4);function up(s,t,e){const n=s[0];if(n<=0||n>0)return s;const i=t*e;let r=R2[i];if(r===void 0&&(r=new Float32Array(i),R2[i]=r),t!==0){n.toArray(r,0);for(let l=1,u=0;l!==t;++l)u+=e,s[l].toArray(r,u)}return r}function Ms(s,t){if(s.length!==t.length)return!1;for(let e=0,n=s.length;e<n;e++)if(s[e]!==t[e])return!1;return!0}function ws(s,t){for(let e=0,n=t.length;e<n;e++)s[e]=t[e]}function OE(s,t){let e=N2[t];e===void 0&&(e=new Int32Array(t),N2[t]=e);for(let n=0;n!==t;++n)e[n]=s.allocateTextureUnit();return e}function f4(s,t){const e=this.cache;e[0]!==t&&(s.uniform1f(this.addr,t),e[0]=t)}function A4(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(s.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(Ms(e,t))return;s.uniform2fv(this.addr,t),ws(e,t)}}function d4(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(s.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)(e[0]!==t.r||e[1]!==t.g||e[2]!==t.b)&&(s.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(Ms(e,t))return;s.uniform3fv(this.addr,t),ws(e,t)}}function p4(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(s.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(Ms(e,t))return;s.uniform4fv(this.addr,t),ws(e,t)}}function g4(s,t){const e=this.cache,n=t.elements;if(n===void 0){if(Ms(e,t))return;s.uniformMatrix2fv(this.addr,!1,t),ws(e,t)}else{if(Ms(e,n))return;z2.set(n),s.uniformMatrix2fv(this.addr,!1,z2),ws(e,n)}}function m4(s,t){const e=this.cache,n=t.elements;if(n===void 0){if(Ms(e,t))return;s.uniformMatrix3fv(this.addr,!1,t),ws(e,t)}else{if(Ms(e,n))return;L2.set(n),s.uniformMatrix3fv(this.addr,!1,L2),ws(e,n)}}function y4(s,t){const e=this.cache,n=t.elements;if(n===void 0){if(Ms(e,t))return;s.uniformMatrix4fv(this.addr,!1,t),ws(e,t)}else{if(Ms(e,n))return;U2.set(n),s.uniformMatrix4fv(this.addr,!1,U2),ws(e,n)}}function x4(s,t){const e=this.cache;e[0]!==t&&(s.uniform1i(this.addr,t),e[0]=t)}function v4(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(s.uniform2i(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(Ms(e,t))return;s.uniform2iv(this.addr,t),ws(e,t)}}function E4(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(s.uniform3i(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else{if(Ms(e,t))return;s.uniform3iv(this.addr,t),ws(e,t)}}function _4(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(s.uniform4i(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(Ms(e,t))return;s.uniform4iv(this.addr,t),ws(e,t)}}function C4(s,t){const e=this.cache;e[0]!==t&&(s.uniform1ui(this.addr,t),e[0]=t)}function b4(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(s.uniform2ui(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(Ms(e,t))return;s.uniform2uiv(this.addr,t),ws(e,t)}}function S4(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(s.uniform3ui(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else{if(Ms(e,t))return;s.uniform3uiv(this.addr,t),ws(e,t)}}function I4(s,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(s.uniform4ui(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(Ms(e,t))return;s.uniform4uiv(this.addr,t),ws(e,t)}}function B4(s,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i);let r;this.type===s.SAMPLER_2D_SHADOW?(D2.compareFunction=vS,r=D2):r=n3,e.setTexture2D(t||r,i)}function M4(s,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),e.setTexture3D(t||s3,i)}function w4(s,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),e.setTextureCube(t||a3,i)}function T4(s,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(s.uniform1i(this.addr,i),n[0]=i),e.setTexture2DArray(t||i3,i)}function Q4(s){switch(s){case 5126:return f4;case 35664:return A4;case 35665:return d4;case 35666:return p4;case 35674:return g4;case 35675:return m4;case 35676:return y4;case 5124:case 35670:return x4;case 35667:case 35671:return v4;case 35668:case 35672:return E4;case 35669:case 35673:return _4;case 5125:return C4;case 36294:return b4;case 36295:return S4;case 36296:return I4;case 35678:case 36198:case 36298:case 36306:case 35682:return B4;case 35679:case 36299:case 36307:return M4;case 35680:case 36300:case 36308:case 36293:return w4;case 36289:case 36303:case 36311:case 36292:return T4}}function D4(s,t){s.uniform1fv(this.addr,t)}function R4(s,t){const e=up(t,this.size,2);s.uniform2fv(this.addr,e)}function N4(s,t){const e=up(t,this.size,3);s.uniform3fv(this.addr,e)}function U4(s,t){const e=up(t,this.size,4);s.uniform4fv(this.addr,e)}function L4(s,t){const e=up(t,this.size,4);s.uniformMatrix2fv(this.addr,!1,e)}function z4(s,t){const e=up(t,this.size,9);s.uniformMatrix3fv(this.addr,!1,e)}function O4(s,t){const e=up(t,this.size,16);s.uniformMatrix4fv(this.addr,!1,e)}function F4(s,t){s.uniform1iv(this.addr,t)}function P4(s,t){s.uniform2iv(this.addr,t)}function G4(s,t){s.uniform3iv(this.addr,t)}function k4(s,t){s.uniform4iv(this.addr,t)}function H4(s,t){s.uniform1uiv(this.addr,t)}function V4(s,t){s.uniform2uiv(this.addr,t)}function Y4(s,t){s.uniform3uiv(this.addr,t)}function q4(s,t){s.uniform4uiv(this.addr,t)}function X4(s,t,e){const n=this.cache,i=t.length,r=OE(e,i);Ms(n,r)||(s.uniform1iv(this.addr,r),ws(n,r));for(let l=0;l!==i;++l)e.setTexture2D(t[l]||n3,r[l])}function J4(s,t,e){const n=this.cache,i=t.length,r=OE(e,i);Ms(n,r)||(s.uniform1iv(this.addr,r),ws(n,r));for(let l=0;l!==i;++l)e.setTexture3D(t[l]||s3,r[l])}function Z4(s,t,e){const n=this.cache,i=t.length,r=OE(e,i);Ms(n,r)||(s.uniform1iv(this.addr,r),ws(n,r));for(let l=0;l!==i;++l)e.setTextureCube(t[l]||a3,r[l])}function W4(s,t,e){const n=this.cache,i=t.length,r=OE(e,i);Ms(n,r)||(s.uniform1iv(this.addr,r),ws(n,r));for(let l=0;l!==i;++l)e.setTexture2DArray(t[l]||i3,r[l])}function j4(s){switch(s){case 5126:return D4;case 35664:return R4;case 35665:return N4;case 35666:return U4;case 35674:return L4;case 35675:return z4;case 35676:return O4;case 5124:case 35670:return F4;case 35667:case 35671:return P4;case 35668:case 35672:return G4;case 35669:case 35673:return k4;case 5125:return H4;case 36294:return V4;case 36295:return Y4;case 36296:return q4;case 35678:case 36198:case 36298:case 36306:case 35682:return X4;case 35679:case 36299:case 36307:return J4;case 35680:case 36300:case 36308:case 36293:return Z4;case 36289:case 36303:case 36311:case 36292:return W4}}class K4{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.type=e.type,this.setValue=Q4(e.type)}}class $4{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.type=e.type,this.size=e.size,this.setValue=j4(e.type)}}class tO{constructor(t){this.id=t,this.seq=[],this.map={}}setValue(t,e,n){const i=this.seq;for(let r=0,l=i.length;r!==l;++r){const u=i[r];u.setValue(t,e[u.id],n)}}}const TC=/(\w+)(\])?(\[|\.)?/g;function O2(s,t){s.seq.push(t),s.map[t.id]=t}function eO(s,t,e){const n=s.name,i=n.length;for(TC.lastIndex=0;;){const r=TC.exec(n),l=TC.lastIndex;let u=r[1];const A=r[2]==="]",d=r[3];if(A&&(u=u|0),d===void 0||d==="["&&l+2===i){O2(e,d===void 0?new K4(u,s,t):new $4(u,s,t));break}else{let g=e.map[u];g===void 0&&(g=new tO(u),O2(e,g)),e=g}}}class sv{constructor(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,t.ACTIVE_UNIFORMS);for(let i=0;i<n;++i){const r=t.getActiveUniform(e,i),l=t.getUniformLocation(e,r.name);eO(r,l,this)}}setValue(t,e,n,i){const r=this.map[e];r!==void 0&&r.setValue(t,n,i)}setOptional(t,e,n){const i=e[n];i!==void 0&&this.setValue(t,n,i)}static upload(t,e,n,i){for(let r=0,l=e.length;r!==l;++r){const u=e[r],A=n[u.id];A.needsUpdate!==!1&&u.setValue(t,A.value,i)}}static seqWithValue(t,e){const n=[];for(let i=0,r=t.length;i!==r;++i){const l=t[i];l.id in e&&n.push(l)}return n}}function F2(s,t,e){const n=s.createShader(t);return s.shaderSource(n,e),s.compileShader(n),n}const nO=37297;let iO=0;function sO(s,t){const e=s.split(`
`),n=[],i=Math.max(t-6,0),r=Math.min(t+6,e.length);for(let l=i;l<r;l++){const u=l+1;n.push(`${u===t?">":" "} ${u}: ${e[l]}`)}return n.join(`
`)}const P2=new Ze;function aO(s){Gn._getMatrix(P2,Gn.workingColorSpace,s);const t=`mat3( ${P2.elements.map(e=>e.toFixed(4))} )`;switch(Gn.getTransfer(s)){case Fm:return[t,"LinearTransferOETF"];case ui:return[t,"sRGBTransferOETF"];default:return ge("WebGLProgram: Unsupported color space: ",s),[t,"LinearTransferOETF"]}}function G2(s,t,e){const n=s.getShaderParameter(t,s.COMPILE_STATUS),r=(s.getShaderInfoLog(t)||"").trim();if(n&&r==="")return"";const l=/ERROR: 0:(\d+)/.exec(r);if(l){const u=parseInt(l[1]);return e.toUpperCase()+`

`+r+`

`+sO(s.getShaderSource(t),u)}else return r}function rO(s,t){const e=aO(t);return[`vec4 ${s}( vec4 value ) {`,`	return ${e[1]}( vec4( value.rgb * ${e[0]}, value.a ) );`,"}"].join(`
`)}function oO(s,t){let e;switch(t){case LM:e="Linear";break;case zM:e="Reinhard";break;case OM:e="Cineon";break;case hS:e="ACESFilmic";break;case PM:e="AgX";break;case GM:e="Neutral";break;case FM:e="Custom";break;default:ge("WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+s+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}const bx=new F;function lO(){Gn.getLuminanceCoefficients(bx);const s=bx.x.toFixed(4),t=bx.y.toFixed(4),e=bx.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${s}, ${t}, ${e} );`,"	return dot( weights, rgb );","}"].join(`
`)}function cO(s){return[s.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",s.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(um).join(`
`)}function uO(s){const t=[];for(const e in s){const n=s[e];n!==!1&&t.push("#define "+e+" "+n)}return t.join(`
`)}function hO(s,t){const e={},n=s.getProgramParameter(t,s.ACTIVE_ATTRIBUTES);for(let i=0;i<n;i++){const r=s.getActiveAttrib(t,i),l=r.name;let u=1;r.type===s.FLOAT_MAT2&&(u=2),r.type===s.FLOAT_MAT3&&(u=3),r.type===s.FLOAT_MAT4&&(u=4),e[l]={type:r.type,location:s.getAttribLocation(t,l),locationSize:u}}return e}function um(s){return s!==""}function k2(s,t){const e=t.numSpotLightShadows+t.numSpotLightMaps-t.numSpotLightShadowsWithMaps;return s.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,e).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function H2(s,t){return s.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const fO=/^[ \t]*#include +<([\w\d./]+)>/gm;function zb(s){return s.replace(fO,dO)}const AO=new Map;function dO(s,t){let e=An[t];if(e===void 0){const n=AO.get(t);if(n!==void 0)e=An[n],ge('WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',t,n);else throw new Error("Can not resolve #include <"+t+">")}return zb(e)}const pO=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function V2(s){return s.replace(pO,gO)}function gO(s,t,e,n){let i="";for(let r=parseInt(t);r<parseInt(e);r++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return i}function Y2(s){let t=`precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;return s.precision==="highp"?t+=`
#define HIGH_PRECISION`:s.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:s.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function mO(s){let t="SHADOWMAP_TYPE_BASIC";return s.shadowMapType===oE?t="SHADOWMAP_TYPE_PCF":s.shadowMapType===gm?t="SHADOWMAP_TYPE_PCF_SOFT":s.shadowMapType===rl&&(t="SHADOWMAP_TYPE_VSM"),t}function yO(s){let t="ENVMAP_TYPE_CUBE";if(s.envMap)switch(s.envMapMode){case eu:case fh:t="ENVMAP_TYPE_CUBE";break;case rp:t="ENVMAP_TYPE_CUBE_UV";break}return t}function xO(s){let t="ENVMAP_MODE_REFLECTION";return s.envMap&&s.envMapMode===fh&&(t="ENVMAP_MODE_REFRACTION"),t}function vO(s){let t="ENVMAP_BLENDING_NONE";if(s.envMap)switch(s.combine){case n0:t="ENVMAP_BLENDING_MULTIPLY";break;case NM:t="ENVMAP_BLENDING_MIX";break;case UM:t="ENVMAP_BLENDING_ADD";break}return t}function EO(s){const t=s.envMapCubeUVHeight;if(t===null)return null;const e=Math.log2(t)-2,n=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,e),112)),texelHeight:n,maxMip:e}}function _O(s,t,e,n){const i=s.getContext(),r=e.defines;let l=e.vertexShader,u=e.fragmentShader;const A=mO(e),d=yO(e),m=xO(e),g=vO(e),y=EO(e),v=cO(e),C=uO(r),I=i.createProgram();let S,E,B=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(S=["#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,C].filter(um).join(`
`),S.length>0&&(S+=`
`),E=["#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,C].filter(um).join(`
`),E.length>0&&(E+=`
`)):(S=[Y2(e),"#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,C,e.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",e.batching?"#define USE_BATCHING":"",e.batchingColor?"#define USE_BATCHING_COLOR":"",e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.instancingMorph?"#define USE_INSTANCING_MORPH":"",e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+m:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",e.displacementMap?"#define USE_DISPLACEMENTMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.anisotropy?"#define USE_ANISOTROPY":"",e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaHash?"#define USE_ALPHAHASH":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",e.mapUv?"#define MAP_UV "+e.mapUv:"",e.alphaMapUv?"#define ALPHAMAP_UV "+e.alphaMapUv:"",e.lightMapUv?"#define LIGHTMAP_UV "+e.lightMapUv:"",e.aoMapUv?"#define AOMAP_UV "+e.aoMapUv:"",e.emissiveMapUv?"#define EMISSIVEMAP_UV "+e.emissiveMapUv:"",e.bumpMapUv?"#define BUMPMAP_UV "+e.bumpMapUv:"",e.normalMapUv?"#define NORMALMAP_UV "+e.normalMapUv:"",e.displacementMapUv?"#define DISPLACEMENTMAP_UV "+e.displacementMapUv:"",e.metalnessMapUv?"#define METALNESSMAP_UV "+e.metalnessMapUv:"",e.roughnessMapUv?"#define ROUGHNESSMAP_UV "+e.roughnessMapUv:"",e.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+e.anisotropyMapUv:"",e.clearcoatMapUv?"#define CLEARCOATMAP_UV "+e.clearcoatMapUv:"",e.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+e.clearcoatNormalMapUv:"",e.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+e.clearcoatRoughnessMapUv:"",e.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+e.iridescenceMapUv:"",e.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+e.iridescenceThicknessMapUv:"",e.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+e.sheenColorMapUv:"",e.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+e.sheenRoughnessMapUv:"",e.specularMapUv?"#define SPECULARMAP_UV "+e.specularMapUv:"",e.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+e.specularColorMapUv:"",e.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+e.specularIntensityMapUv:"",e.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+e.transmissionMapUv:"",e.thicknessMapUv?"#define THICKNESSMAP_UV "+e.thicknessMapUv:"",e.vertexTangents&&e.flatShading===!1?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUv1s?"#define USE_UV1":"",e.vertexUv2s?"#define USE_UV2":"",e.vertexUv3s?"#define USE_UV3":"",e.pointsUvs?"#define USE_POINTS_UV":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.morphColors?"#define USE_MORPHCOLORS":"",e.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+e.morphTextureStride:"",e.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+e.morphTargetsCount:"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+A:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.numLightProbes>0?"#define USE_LIGHT_PROBES":"",e.logarithmicDepthBuffer?"#define USE_LOGARITHMIC_DEPTH_BUFFER":"",e.reversedDepthBuffer?"#define USE_REVERSED_DEPTH_BUFFER":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(um).join(`
`),E=[Y2(e),"#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,C,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+d:"",e.envMap?"#define "+m:"",e.envMap?"#define "+g:"",y?"#define CUBEUV_TEXEL_WIDTH "+y.texelWidth:"",y?"#define CUBEUV_TEXEL_HEIGHT "+y.texelHeight:"",y?"#define CUBEUV_MAX_MIP "+y.maxMip+".0":"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.anisotropy?"#define USE_ANISOTROPY":"",e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.dispersion?"#define USE_DISPERSION":"",e.iridescence?"#define USE_IRIDESCENCE":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.alphaHash?"#define USE_ALPHAHASH":"",e.sheen?"#define USE_SHEEN":"",e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents&&e.flatShading===!1?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor||e.batchingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUv1s?"#define USE_UV1":"",e.vertexUv2s?"#define USE_UV2":"",e.vertexUv3s?"#define USE_UV3":"",e.pointsUvs?"#define USE_POINTS_UV":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+A:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.numLightProbes>0?"#define USE_LIGHT_PROBES":"",e.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",e.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",e.logarithmicDepthBuffer?"#define USE_LOGARITHMIC_DEPTH_BUFFER":"",e.reversedDepthBuffer?"#define USE_REVERSED_DEPTH_BUFFER":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==ic?"#define TONE_MAPPING":"",e.toneMapping!==ic?An.tonemapping_pars_fragment:"",e.toneMapping!==ic?oO("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.opaque?"#define OPAQUE":"",An.colorspace_pars_fragment,rO("linearToOutputTexel",e.outputColorSpace),lO(),e.useDepthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(um).join(`
`)),l=zb(l),l=k2(l,e),l=H2(l,e),u=zb(u),u=k2(u,e),u=H2(u,e),l=V2(l),u=V2(u),e.isRawShaderMaterial!==!0&&(B=`#version 300 es
`,S=[v,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+S,E=["#define varying in",e.glslVersion===Gm?"":"layout(location = 0) out highp vec4 pc_fragColor;",e.glslVersion===Gm?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+E);const w=B+S+l,Q=B+E+u,R=F2(i,i.VERTEX_SHADER,w),D=F2(i,i.FRAGMENT_SHADER,Q);i.attachShader(I,R),i.attachShader(I,D),e.index0AttributeName!==void 0?i.bindAttribLocation(I,0,e.index0AttributeName):e.morphTargets===!0&&i.bindAttribLocation(I,0,"position"),i.linkProgram(I);function U(k){if(s.debug.checkShaderErrors){const Y=i.getProgramInfoLog(I)||"",W=i.getShaderInfoLog(R)||"",K=i.getShaderInfoLog(D)||"",nt=Y.trim(),H=W.trim(),tt=K.trim();let it=!0,ot=!0;if(i.getProgramParameter(I,i.LINK_STATUS)===!1)if(it=!1,typeof s.debug.onShaderError=="function")s.debug.onShaderError(i,I,R,D);else{const At=G2(i,R,"vertex"),V=G2(i,D,"fragment");nn("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(I,i.VALIDATE_STATUS)+`

Material Name: `+k.name+`
Material Type: `+k.type+`

Program Info Log: `+nt+`
`+At+`
`+V)}else nt!==""?ge("WebGLProgram: Program Info Log:",nt):(H===""||tt==="")&&(ot=!1);ot&&(k.diagnostics={runnable:it,programLog:nt,vertexShader:{log:H,prefix:S},fragmentShader:{log:tt,prefix:E}})}i.deleteShader(R),i.deleteShader(D),P=new sv(i,I),z=hO(i,I)}let P;this.getUniforms=function(){return P===void 0&&U(this),P};let z;this.getAttributes=function(){return z===void 0&&U(this),z};let L=e.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return L===!1&&(L=i.getProgramParameter(I,nO)),L},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(I),this.program=void 0},this.type=e.shaderType,this.name=e.shaderName,this.id=iO++,this.cacheKey=t,this.usedTimes=1,this.program=I,this.vertexShader=R,this.fragmentShader=D,this}let CO=0;class bO{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,n=t.fragmentShader,i=this._getShaderStage(e),r=this._getShaderStage(n),l=this._getShaderCacheForMaterial(t);return l.has(i)===!1&&(l.add(i),i.usedTimes++),l.has(r)===!1&&(l.add(r),r.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const n of e)n.usedTimes--,n.usedTimes===0&&this.shaderCache.delete(n.code);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;let n=e.get(t);return n===void 0&&(n=new Set,e.set(t,n)),n}_getShaderStage(t){const e=this.shaderCache;let n=e.get(t);return n===void 0&&(n=new SO(t),e.set(t,n)),n}}class SO{constructor(t){this.id=CO++,this.code=t,this.usedTimes=0}}function IO(s,t,e,n,i,r,l){const u=new ep,A=new bO,d=new Set,m=[],g=i.logarithmicDepthBuffer,y=i.vertexTextures;let v=i.precision;const C={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function I(z){return d.add(z),z===0?"uv":`uv${z}`}function S(z,L,k,Y,W){const K=Y.fog,nt=W.geometry,H=z.isMeshStandardMaterial?Y.environment:null,tt=(z.isMeshStandardMaterial?e:t).get(z.envMap||H),it=tt&&tt.mapping===rp?tt.image.height:null,ot=C[z.type];z.precision!==null&&(v=i.getMaxPrecision(z.precision),v!==z.precision&&ge("WebGLProgram.getParameters:",z.precision,"not supported, using",v,"instead."));const At=nt.morphAttributes.position||nt.morphAttributes.normal||nt.morphAttributes.color,V=At!==void 0?At.length:0;let st=0;nt.morphAttributes.position!==void 0&&(st=1),nt.morphAttributes.normal!==void 0&&(st=2),nt.morphAttributes.color!==void 0&&(st=3);let xt,j,Rt,dt;if(ot){const ln=ol[ot];xt=ln.vertexShader,j=ln.fragmentShader}else xt=z.vertexShader,j=z.fragmentShader,A.update(z),Rt=A.getVertexShaderID(z),dt=A.getFragmentShaderID(z);const pt=s.getRenderTarget(),qt=s.state.buffers.depth.getReversed(),Wt=W.isInstancedMesh===!0,ce=W.isBatchedMesh===!0,Ie=!!z.map,He=!!z.matcap,be=!!tt,zt=!!z.aoMap,Z=!!z.lightMap,Ot=!!z.bumpMap,Vt=!!z.normalMap,Pt=!!z.displacementMap,kt=!!z.emissiveMap,Zt=!!z.metalnessMap,$t=!!z.roughnessMap,fe=z.anisotropy>0,$=z.clearcoat>0,G=z.dispersion>0,ft=z.iridescence>0,Tt=z.sheen>0,Ht=z.transmission>0,Bt=fe&&!!z.anisotropyMap,Se=$&&!!z.clearcoatMap,ae=$&&!!z.clearcoatNormalMap,we=$&&!!z.clearcoatRoughnessMap,Ee=ft&&!!z.iridescenceMap,Gt=ft&&!!z.iridescenceThicknessMap,Jt=Tt&&!!z.sheenColorMap,Be=Tt&&!!z.sheenRoughnessMap,ve=!!z.specularMap,te=!!z.specularColorMap,Ue=!!z.specularIntensityMap,lt=Ht&&!!z.transmissionMap,re=Ht&&!!z.thicknessMap,ee=!!z.gradientMap,ie=!!z.alphaMap,Xt=z.alphaTest>0,Lt=!!z.alphaHash,Ae=!!z.extensions;let Oe=ic;z.toneMapped&&(pt===null||pt.isXRRenderTarget===!0)&&(Oe=s.toneMapping);const In={shaderID:ot,shaderType:z.type,shaderName:z.name,vertexShader:xt,fragmentShader:j,defines:z.defines,customVertexShaderID:Rt,customFragmentShaderID:dt,isRawShaderMaterial:z.isRawShaderMaterial===!0,glslVersion:z.glslVersion,precision:v,batching:ce,batchingColor:ce&&W._colorsTexture!==null,instancing:Wt,instancingColor:Wt&&W.instanceColor!==null,instancingMorph:Wt&&W.morphTexture!==null,supportsVertexTextures:y,outputColorSpace:pt===null?s.outputColorSpace:pt.isXRRenderTarget===!0?pt.texture.colorSpace:Ah,alphaToCoverage:!!z.alphaToCoverage,map:Ie,matcap:He,envMap:be,envMapMode:be&&tt.mapping,envMapCubeUVHeight:it,aoMap:zt,lightMap:Z,bumpMap:Ot,normalMap:Vt,displacementMap:y&&Pt,emissiveMap:kt,normalMapObjectSpace:Vt&&z.normalMapType===ZM,normalMapTangentSpace:Vt&&z.normalMapType===gh,metalnessMap:Zt,roughnessMap:$t,anisotropy:fe,anisotropyMap:Bt,clearcoat:$,clearcoatMap:Se,clearcoatNormalMap:ae,clearcoatRoughnessMap:we,dispersion:G,iridescence:ft,iridescenceMap:Ee,iridescenceThicknessMap:Gt,sheen:Tt,sheenColorMap:Jt,sheenRoughnessMap:Be,specularMap:ve,specularColorMap:te,specularIntensityMap:Ue,transmission:Ht,transmissionMap:lt,thicknessMap:re,gradientMap:ee,opaque:z.transparent===!1&&z.blending===Gf&&z.alphaToCoverage===!1,alphaMap:ie,alphaTest:Xt,alphaHash:Lt,combine:z.combine,mapUv:Ie&&I(z.map.channel),aoMapUv:zt&&I(z.aoMap.channel),lightMapUv:Z&&I(z.lightMap.channel),bumpMapUv:Ot&&I(z.bumpMap.channel),normalMapUv:Vt&&I(z.normalMap.channel),displacementMapUv:Pt&&I(z.displacementMap.channel),emissiveMapUv:kt&&I(z.emissiveMap.channel),metalnessMapUv:Zt&&I(z.metalnessMap.channel),roughnessMapUv:$t&&I(z.roughnessMap.channel),anisotropyMapUv:Bt&&I(z.anisotropyMap.channel),clearcoatMapUv:Se&&I(z.clearcoatMap.channel),clearcoatNormalMapUv:ae&&I(z.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:we&&I(z.clearcoatRoughnessMap.channel),iridescenceMapUv:Ee&&I(z.iridescenceMap.channel),iridescenceThicknessMapUv:Gt&&I(z.iridescenceThicknessMap.channel),sheenColorMapUv:Jt&&I(z.sheenColorMap.channel),sheenRoughnessMapUv:Be&&I(z.sheenRoughnessMap.channel),specularMapUv:ve&&I(z.specularMap.channel),specularColorMapUv:te&&I(z.specularColorMap.channel),specularIntensityMapUv:Ue&&I(z.specularIntensityMap.channel),transmissionMapUv:lt&&I(z.transmissionMap.channel),thicknessMapUv:re&&I(z.thicknessMap.channel),alphaMapUv:ie&&I(z.alphaMap.channel),vertexTangents:!!nt.attributes.tangent&&(Vt||fe),vertexColors:z.vertexColors,vertexAlphas:z.vertexColors===!0&&!!nt.attributes.color&&nt.attributes.color.itemSize===4,pointsUvs:W.isPoints===!0&&!!nt.attributes.uv&&(Ie||ie),fog:!!K,useFog:z.fog===!0,fogExp2:!!K&&K.isFogExp2,flatShading:z.flatShading===!0&&z.wireframe===!1,sizeAttenuation:z.sizeAttenuation===!0,logarithmicDepthBuffer:g,reversedDepthBuffer:qt,skinning:W.isSkinnedMesh===!0,morphTargets:nt.morphAttributes.position!==void 0,morphNormals:nt.morphAttributes.normal!==void 0,morphColors:nt.morphAttributes.color!==void 0,morphTargetsCount:V,morphTextureStride:st,numDirLights:L.directional.length,numPointLights:L.point.length,numSpotLights:L.spot.length,numSpotLightMaps:L.spotLightMap.length,numRectAreaLights:L.rectArea.length,numHemiLights:L.hemi.length,numDirLightShadows:L.directionalShadowMap.length,numPointLightShadows:L.pointShadowMap.length,numSpotLightShadows:L.spotShadowMap.length,numSpotLightShadowsWithMaps:L.numSpotLightShadowsWithMaps,numLightProbes:L.numLightProbes,numClippingPlanes:l.numPlanes,numClipIntersection:l.numIntersection,dithering:z.dithering,shadowMapEnabled:s.shadowMap.enabled&&k.length>0,shadowMapType:s.shadowMap.type,toneMapping:Oe,decodeVideoTexture:Ie&&z.map.isVideoTexture===!0&&Gn.getTransfer(z.map.colorSpace)===ui,decodeVideoTextureEmissive:kt&&z.emissiveMap.isVideoTexture===!0&&Gn.getTransfer(z.emissiveMap.colorSpace)===ui,premultipliedAlpha:z.premultipliedAlpha,doubleSided:z.side===gr,flipSided:z.side===_a,useDepthPacking:z.depthPacking>=0,depthPacking:z.depthPacking||0,index0AttributeName:z.index0AttributeName,extensionClipCullDistance:Ae&&z.extensions.clipCullDistance===!0&&n.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(Ae&&z.extensions.multiDraw===!0||ce)&&n.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:n.has("KHR_parallel_shader_compile"),customProgramCacheKey:z.customProgramCacheKey()};return In.vertexUv1s=d.has(1),In.vertexUv2s=d.has(2),In.vertexUv3s=d.has(3),d.clear(),In}function E(z){const L=[];if(z.shaderID?L.push(z.shaderID):(L.push(z.customVertexShaderID),L.push(z.customFragmentShaderID)),z.defines!==void 0)for(const k in z.defines)L.push(k),L.push(z.defines[k]);return z.isRawShaderMaterial===!1&&(B(L,z),w(L,z),L.push(s.outputColorSpace)),L.push(z.customProgramCacheKey),L.join()}function B(z,L){z.push(L.precision),z.push(L.outputColorSpace),z.push(L.envMapMode),z.push(L.envMapCubeUVHeight),z.push(L.mapUv),z.push(L.alphaMapUv),z.push(L.lightMapUv),z.push(L.aoMapUv),z.push(L.bumpMapUv),z.push(L.normalMapUv),z.push(L.displacementMapUv),z.push(L.emissiveMapUv),z.push(L.metalnessMapUv),z.push(L.roughnessMapUv),z.push(L.anisotropyMapUv),z.push(L.clearcoatMapUv),z.push(L.clearcoatNormalMapUv),z.push(L.clearcoatRoughnessMapUv),z.push(L.iridescenceMapUv),z.push(L.iridescenceThicknessMapUv),z.push(L.sheenColorMapUv),z.push(L.sheenRoughnessMapUv),z.push(L.specularMapUv),z.push(L.specularColorMapUv),z.push(L.specularIntensityMapUv),z.push(L.transmissionMapUv),z.push(L.thicknessMapUv),z.push(L.combine),z.push(L.fogExp2),z.push(L.sizeAttenuation),z.push(L.morphTargetsCount),z.push(L.morphAttributeCount),z.push(L.numDirLights),z.push(L.numPointLights),z.push(L.numSpotLights),z.push(L.numSpotLightMaps),z.push(L.numHemiLights),z.push(L.numRectAreaLights),z.push(L.numDirLightShadows),z.push(L.numPointLightShadows),z.push(L.numSpotLightShadows),z.push(L.numSpotLightShadowsWithMaps),z.push(L.numLightProbes),z.push(L.shadowMapType),z.push(L.toneMapping),z.push(L.numClippingPlanes),z.push(L.numClipIntersection),z.push(L.depthPacking)}function w(z,L){u.disableAll(),L.supportsVertexTextures&&u.enable(0),L.instancing&&u.enable(1),L.instancingColor&&u.enable(2),L.instancingMorph&&u.enable(3),L.matcap&&u.enable(4),L.envMap&&u.enable(5),L.normalMapObjectSpace&&u.enable(6),L.normalMapTangentSpace&&u.enable(7),L.clearcoat&&u.enable(8),L.iridescence&&u.enable(9),L.alphaTest&&u.enable(10),L.vertexColors&&u.enable(11),L.vertexAlphas&&u.enable(12),L.vertexUv1s&&u.enable(13),L.vertexUv2s&&u.enable(14),L.vertexUv3s&&u.enable(15),L.vertexTangents&&u.enable(16),L.anisotropy&&u.enable(17),L.alphaHash&&u.enable(18),L.batching&&u.enable(19),L.dispersion&&u.enable(20),L.batchingColor&&u.enable(21),L.gradientMap&&u.enable(22),z.push(u.mask),u.disableAll(),L.fog&&u.enable(0),L.useFog&&u.enable(1),L.flatShading&&u.enable(2),L.logarithmicDepthBuffer&&u.enable(3),L.reversedDepthBuffer&&u.enable(4),L.skinning&&u.enable(5),L.morphTargets&&u.enable(6),L.morphNormals&&u.enable(7),L.morphColors&&u.enable(8),L.premultipliedAlpha&&u.enable(9),L.shadowMapEnabled&&u.enable(10),L.doubleSided&&u.enable(11),L.flipSided&&u.enable(12),L.useDepthPacking&&u.enable(13),L.dithering&&u.enable(14),L.transmission&&u.enable(15),L.sheen&&u.enable(16),L.opaque&&u.enable(17),L.pointsUvs&&u.enable(18),L.decodeVideoTexture&&u.enable(19),L.decodeVideoTextureEmissive&&u.enable(20),L.alphaToCoverage&&u.enable(21),z.push(u.mask)}function Q(z){const L=C[z.type];let k;if(L){const Y=ol[L];k=BS.clone(Y.uniforms)}else k=z.uniforms;return k}function R(z,L){let k;for(let Y=0,W=m.length;Y<W;Y++){const K=m[Y];if(K.cacheKey===L){k=K,++k.usedTimes;break}}return k===void 0&&(k=new _O(s,L,z,r),m.push(k)),k}function D(z){if(--z.usedTimes===0){const L=m.indexOf(z);m[L]=m[m.length-1],m.pop(),z.destroy()}}function U(z){A.remove(z)}function P(){A.dispose()}return{getParameters:S,getProgramCacheKey:E,getUniforms:Q,acquireProgram:R,releaseProgram:D,releaseShaderCache:U,programs:m,dispose:P}}function BO(){let s=new WeakMap;function t(l){return s.has(l)}function e(l){let u=s.get(l);return u===void 0&&(u={},s.set(l,u)),u}function n(l){s.delete(l)}function i(l,u,A){s.get(l)[u]=A}function r(){s=new WeakMap}return{has:t,get:e,remove:n,update:i,dispose:r}}function MO(s,t){return s.groupOrder!==t.groupOrder?s.groupOrder-t.groupOrder:s.renderOrder!==t.renderOrder?s.renderOrder-t.renderOrder:s.material.id!==t.material.id?s.material.id-t.material.id:s.z!==t.z?s.z-t.z:s.id-t.id}function q2(s,t){return s.groupOrder!==t.groupOrder?s.groupOrder-t.groupOrder:s.renderOrder!==t.renderOrder?s.renderOrder-t.renderOrder:s.z!==t.z?t.z-s.z:s.id-t.id}function X2(){const s=[];let t=0;const e=[],n=[],i=[];function r(){t=0,e.length=0,n.length=0,i.length=0}function l(g,y,v,C,I,S){let E=s[t];return E===void 0?(E={id:g.id,object:g,geometry:y,material:v,groupOrder:C,renderOrder:g.renderOrder,z:I,group:S},s[t]=E):(E.id=g.id,E.object=g,E.geometry=y,E.material=v,E.groupOrder=C,E.renderOrder=g.renderOrder,E.z=I,E.group=S),t++,E}function u(g,y,v,C,I,S){const E=l(g,y,v,C,I,S);v.transmission>0?n.push(E):v.transparent===!0?i.push(E):e.push(E)}function A(g,y,v,C,I,S){const E=l(g,y,v,C,I,S);v.transmission>0?n.unshift(E):v.transparent===!0?i.unshift(E):e.unshift(E)}function d(g,y){e.length>1&&e.sort(g||MO),n.length>1&&n.sort(y||q2),i.length>1&&i.sort(y||q2)}function m(){for(let g=t,y=s.length;g<y;g++){const v=s[g];if(v.id===null)break;v.id=null,v.object=null,v.geometry=null,v.material=null,v.group=null}}return{opaque:e,transmissive:n,transparent:i,init:r,push:u,unshift:A,finish:m,sort:d}}function wO(){let s=new WeakMap;function t(n,i){const r=s.get(n);let l;return r===void 0?(l=new X2,s.set(n,[l])):i>=r.length?(l=new X2,r.push(l)):l=r[i],l}function e(){s=new WeakMap}return{get:t,dispose:e}}function TO(){const s={};return{get:function(t){if(s[t.id]!==void 0)return s[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new F,color:new le};break;case"SpotLight":e={position:new F,direction:new F,color:new le,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new F,color:new le,distance:0,decay:0};break;case"HemisphereLight":e={direction:new F,skyColor:new le,groundColor:new le};break;case"RectAreaLight":e={color:new le,position:new F,halfWidth:new F,halfHeight:new F};break}return s[t.id]=e,e}}}function QO(){const s={};return{get:function(t){if(s[t.id]!==void 0)return s[t.id];let e;switch(t.type){case"DirectionalLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Dt};break;case"SpotLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Dt};break;case"PointLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Dt,shadowCameraNear:1,shadowCameraFar:1e3};break}return s[t.id]=e,e}}}let DO=0;function RO(s,t){return(t.castShadow?2:0)-(s.castShadow?2:0)+(t.map?1:0)-(s.map?1:0)}function NO(s){const t=new TO,e=QO(),n={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let d=0;d<9;d++)n.probe.push(new F);const i=new F,r=new he,l=new he;function u(d){let m=0,g=0,y=0;for(let z=0;z<9;z++)n.probe[z].set(0,0,0);let v=0,C=0,I=0,S=0,E=0,B=0,w=0,Q=0,R=0,D=0,U=0;d.sort(RO);for(let z=0,L=d.length;z<L;z++){const k=d[z],Y=k.color,W=k.intensity,K=k.distance,nt=k.shadow&&k.shadow.map?k.shadow.map.texture:null;if(k.isAmbientLight)m+=Y.r*W,g+=Y.g*W,y+=Y.b*W;else if(k.isLightProbe){for(let H=0;H<9;H++)n.probe[H].addScaledVector(k.sh.coefficients[H],W);U++}else if(k.isDirectionalLight){const H=t.get(k);if(H.color.copy(k.color).multiplyScalar(k.intensity),k.castShadow){const tt=k.shadow,it=e.get(k);it.shadowIntensity=tt.intensity,it.shadowBias=tt.bias,it.shadowNormalBias=tt.normalBias,it.shadowRadius=tt.radius,it.shadowMapSize=tt.mapSize,n.directionalShadow[v]=it,n.directionalShadowMap[v]=nt,n.directionalShadowMatrix[v]=k.shadow.matrix,B++}n.directional[v]=H,v++}else if(k.isSpotLight){const H=t.get(k);H.position.setFromMatrixPosition(k.matrixWorld),H.color.copy(Y).multiplyScalar(W),H.distance=K,H.coneCos=Math.cos(k.angle),H.penumbraCos=Math.cos(k.angle*(1-k.penumbra)),H.decay=k.decay,n.spot[I]=H;const tt=k.shadow;if(k.map&&(n.spotLightMap[R]=k.map,R++,tt.updateMatrices(k),k.castShadow&&D++),n.spotLightMatrix[I]=tt.matrix,k.castShadow){const it=e.get(k);it.shadowIntensity=tt.intensity,it.shadowBias=tt.bias,it.shadowNormalBias=tt.normalBias,it.shadowRadius=tt.radius,it.shadowMapSize=tt.mapSize,n.spotShadow[I]=it,n.spotShadowMap[I]=nt,Q++}I++}else if(k.isRectAreaLight){const H=t.get(k);H.color.copy(Y).multiplyScalar(W),H.halfWidth.set(k.width*.5,0,0),H.halfHeight.set(0,k.height*.5,0),n.rectArea[S]=H,S++}else if(k.isPointLight){const H=t.get(k);if(H.color.copy(k.color).multiplyScalar(k.intensity),H.distance=k.distance,H.decay=k.decay,k.castShadow){const tt=k.shadow,it=e.get(k);it.shadowIntensity=tt.intensity,it.shadowBias=tt.bias,it.shadowNormalBias=tt.normalBias,it.shadowRadius=tt.radius,it.shadowMapSize=tt.mapSize,it.shadowCameraNear=tt.camera.near,it.shadowCameraFar=tt.camera.far,n.pointShadow[C]=it,n.pointShadowMap[C]=nt,n.pointShadowMatrix[C]=k.shadow.matrix,w++}n.point[C]=H,C++}else if(k.isHemisphereLight){const H=t.get(k);H.skyColor.copy(k.color).multiplyScalar(W),H.groundColor.copy(k.groundColor).multiplyScalar(W),n.hemi[E]=H,E++}}S>0&&(s.has("OES_texture_float_linear")===!0?(n.rectAreaLTC1=pe.LTC_FLOAT_1,n.rectAreaLTC2=pe.LTC_FLOAT_2):(n.rectAreaLTC1=pe.LTC_HALF_1,n.rectAreaLTC2=pe.LTC_HALF_2)),n.ambient[0]=m,n.ambient[1]=g,n.ambient[2]=y;const P=n.hash;(P.directionalLength!==v||P.pointLength!==C||P.spotLength!==I||P.rectAreaLength!==S||P.hemiLength!==E||P.numDirectionalShadows!==B||P.numPointShadows!==w||P.numSpotShadows!==Q||P.numSpotMaps!==R||P.numLightProbes!==U)&&(n.directional.length=v,n.spot.length=I,n.rectArea.length=S,n.point.length=C,n.hemi.length=E,n.directionalShadow.length=B,n.directionalShadowMap.length=B,n.pointShadow.length=w,n.pointShadowMap.length=w,n.spotShadow.length=Q,n.spotShadowMap.length=Q,n.directionalShadowMatrix.length=B,n.pointShadowMatrix.length=w,n.spotLightMatrix.length=Q+R-D,n.spotLightMap.length=R,n.numSpotLightShadowsWithMaps=D,n.numLightProbes=U,P.directionalLength=v,P.pointLength=C,P.spotLength=I,P.rectAreaLength=S,P.hemiLength=E,P.numDirectionalShadows=B,P.numPointShadows=w,P.numSpotShadows=Q,P.numSpotMaps=R,P.numLightProbes=U,n.version=DO++)}function A(d,m){let g=0,y=0,v=0,C=0,I=0;const S=m.matrixWorldInverse;for(let E=0,B=d.length;E<B;E++){const w=d[E];if(w.isDirectionalLight){const Q=n.directional[g];Q.direction.setFromMatrixPosition(w.matrixWorld),i.setFromMatrixPosition(w.target.matrixWorld),Q.direction.sub(i),Q.direction.transformDirection(S),g++}else if(w.isSpotLight){const Q=n.spot[v];Q.position.setFromMatrixPosition(w.matrixWorld),Q.position.applyMatrix4(S),Q.direction.setFromMatrixPosition(w.matrixWorld),i.setFromMatrixPosition(w.target.matrixWorld),Q.direction.sub(i),Q.direction.transformDirection(S),v++}else if(w.isRectAreaLight){const Q=n.rectArea[C];Q.position.setFromMatrixPosition(w.matrixWorld),Q.position.applyMatrix4(S),l.identity(),r.copy(w.matrixWorld),r.premultiply(S),l.extractRotation(r),Q.halfWidth.set(w.width*.5,0,0),Q.halfHeight.set(0,w.height*.5,0),Q.halfWidth.applyMatrix4(l),Q.halfHeight.applyMatrix4(l),C++}else if(w.isPointLight){const Q=n.point[y];Q.position.setFromMatrixPosition(w.matrixWorld),Q.position.applyMatrix4(S),y++}else if(w.isHemisphereLight){const Q=n.hemi[I];Q.direction.setFromMatrixPosition(w.matrixWorld),Q.direction.transformDirection(S),I++}}}return{setup:u,setupView:A,state:n}}function J2(s){const t=new NO(s),e=[],n=[];function i(m){d.camera=m,e.length=0,n.length=0}function r(m){e.push(m)}function l(m){n.push(m)}function u(){t.setup(e)}function A(m){t.setupView(e,m)}const d={lightsArray:e,shadowsArray:n,camera:null,lights:t,transmissionRenderTarget:{}};return{init:i,state:d,setupLights:u,setupLightsView:A,pushLight:r,pushShadow:l}}function UO(s){let t=new WeakMap;function e(i,r=0){const l=t.get(i);let u;return l===void 0?(u=new J2(s),t.set(i,[u])):r>=l.length?(u=new J2(s),l.push(u)):u=l[r],u}function n(){t=new WeakMap}return{get:e,dispose:n}}const LO=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,zO=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function OO(s,t,e){let n=new op;const i=new Dt,r=new Dt,l=new We,u=new HS({depthPacking:JM}),A=new VS,d={},m=e.maxTextureSize,g={[fl]:_a,[_a]:fl,[gr]:gr},y=new $a({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Dt},radius:{value:4}},vertexShader:LO,fragmentShader:zO}),v=y.clone();v.defines.HORIZONTAL_PASS=1;const C=new Fe;C.setAttribute("position",new Qn(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const I=new oe(C,y),S=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=oE;let E=this.type;this.render=function(D,U,P){if(S.enabled===!1||S.autoUpdate===!1&&S.needsUpdate===!1||D.length===0)return;const z=s.getRenderTarget(),L=s.getActiveCubeFace(),k=s.getActiveMipmapLevel(),Y=s.state;Y.setBlending(nc),Y.buffers.depth.getReversed()===!0?Y.buffers.color.setClear(0,0,0,0):Y.buffers.color.setClear(1,1,1,1),Y.buffers.depth.setTest(!0),Y.setScissorTest(!1);const W=E!==rl&&this.type===rl,K=E===rl&&this.type!==rl;for(let nt=0,H=D.length;nt<H;nt++){const tt=D[nt],it=tt.shadow;if(it===void 0){ge("WebGLShadowMap:",tt,"has no shadow.");continue}if(it.autoUpdate===!1&&it.needsUpdate===!1)continue;i.copy(it.mapSize);const ot=it.getFrameExtents();if(i.multiply(ot),r.copy(it.mapSize),(i.x>m||i.y>m)&&(i.x>m&&(r.x=Math.floor(m/ot.x),i.x=r.x*ot.x,it.mapSize.x=r.x),i.y>m&&(r.y=Math.floor(m/ot.y),i.y=r.y*ot.y,it.mapSize.y=r.y)),it.map===null||W===!0||K===!0){const V=this.type!==rl?{minFilter:rs,magFilter:rs}:{};it.map!==null&&it.map.dispose(),it.map=new Io(i.x,i.y,V),it.map.texture.name=tt.name+".shadowMap",it.camera.updateProjectionMatrix()}s.setRenderTarget(it.map),s.clear();const At=it.getViewportCount();for(let V=0;V<At;V++){const st=it.getViewport(V);l.set(r.x*st.x,r.y*st.y,r.x*st.z,r.y*st.w),Y.viewport(l),it.updateMatrices(tt,V),n=it.getFrustum(),Q(U,P,it.camera,tt,this.type)}it.isPointLightShadow!==!0&&this.type===rl&&B(it,P),it.needsUpdate=!1}E=this.type,S.needsUpdate=!1,s.setRenderTarget(z,L,k)};function B(D,U){const P=t.update(I);y.defines.VSM_SAMPLES!==D.blurSamples&&(y.defines.VSM_SAMPLES=D.blurSamples,v.defines.VSM_SAMPLES=D.blurSamples,y.needsUpdate=!0,v.needsUpdate=!0),D.mapPass===null&&(D.mapPass=new Io(i.x,i.y)),y.uniforms.shadow_pass.value=D.map.texture,y.uniforms.resolution.value=D.mapSize,y.uniforms.radius.value=D.radius,s.setRenderTarget(D.mapPass),s.clear(),s.renderBufferDirect(U,null,P,y,I,null),v.uniforms.shadow_pass.value=D.mapPass.texture,v.uniforms.resolution.value=D.mapSize,v.uniforms.radius.value=D.radius,s.setRenderTarget(D.map),s.clear(),s.renderBufferDirect(U,null,P,v,I,null)}function w(D,U,P,z){let L=null;const k=P.isPointLight===!0?D.customDistanceMaterial:D.customDepthMaterial;if(k!==void 0)L=k;else if(L=P.isPointLight===!0?A:u,s.localClippingEnabled&&U.clipShadows===!0&&Array.isArray(U.clippingPlanes)&&U.clippingPlanes.length!==0||U.displacementMap&&U.displacementScale!==0||U.alphaMap&&U.alphaTest>0||U.map&&U.alphaTest>0||U.alphaToCoverage===!0){const Y=L.uuid,W=U.uuid;let K=d[Y];K===void 0&&(K={},d[Y]=K);let nt=K[W];nt===void 0&&(nt=L.clone(),K[W]=nt,U.addEventListener("dispose",R)),L=nt}if(L.visible=U.visible,L.wireframe=U.wireframe,z===rl?L.side=U.shadowSide!==null?U.shadowSide:U.side:L.side=U.shadowSide!==null?U.shadowSide:g[U.side],L.alphaMap=U.alphaMap,L.alphaTest=U.alphaToCoverage===!0?.5:U.alphaTest,L.map=U.map,L.clipShadows=U.clipShadows,L.clippingPlanes=U.clippingPlanes,L.clipIntersection=U.clipIntersection,L.displacementMap=U.displacementMap,L.displacementScale=U.displacementScale,L.displacementBias=U.displacementBias,L.wireframeLinewidth=U.wireframeLinewidth,L.linewidth=U.linewidth,P.isPointLight===!0&&L.isMeshDistanceMaterial===!0){const Y=s.properties.get(L);Y.light=P}return L}function Q(D,U,P,z,L){if(D.visible===!1)return;if(D.layers.test(U.layers)&&(D.isMesh||D.isLine||D.isPoints)&&(D.castShadow||D.receiveShadow&&L===rl)&&(!D.frustumCulled||n.intersectsObject(D))){D.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse,D.matrixWorld);const W=t.update(D),K=D.material;if(Array.isArray(K)){const nt=W.groups;for(let H=0,tt=nt.length;H<tt;H++){const it=nt[H],ot=K[it.materialIndex];if(ot&&ot.visible){const At=w(D,ot,z,L);D.onBeforeShadow(s,D,U,P,W,At,it),s.renderBufferDirect(P,null,W,At,D,it),D.onAfterShadow(s,D,U,P,W,At,it)}}}else if(K.visible){const nt=w(D,K,z,L);D.onBeforeShadow(s,D,U,P,W,nt,null),s.renderBufferDirect(P,null,W,nt,D,null),D.onAfterShadow(s,D,U,P,W,nt,null)}}const Y=D.children;for(let W=0,K=Y.length;W<K;W++)Q(Y[W],U,P,z,L)}function R(D){D.target.removeEventListener("dispose",R);for(const P in d){const z=d[P],L=D.target.uuid;L in z&&(z[L].dispose(),delete z[L])}}}const FO={[fv]:Av,[dv]:mv,[pv]:yv,[Yf]:gv,[Av]:fv,[mv]:dv,[yv]:pv,[gv]:Yf};function PO(s,t){function e(){let lt=!1;const re=new We;let ee=null;const ie=new We(0,0,0,0);return{setMask:function(Xt){ee!==Xt&&!lt&&(s.colorMask(Xt,Xt,Xt,Xt),ee=Xt)},setLocked:function(Xt){lt=Xt},setClear:function(Xt,Lt,Ae,Oe,In){In===!0&&(Xt*=Oe,Lt*=Oe,Ae*=Oe),re.set(Xt,Lt,Ae,Oe),ie.equals(re)===!1&&(s.clearColor(Xt,Lt,Ae,Oe),ie.copy(re))},reset:function(){lt=!1,ee=null,ie.set(-1,0,0,0)}}}function n(){let lt=!1,re=!1,ee=null,ie=null,Xt=null;return{setReversed:function(Lt){if(re!==Lt){const Ae=t.get("EXT_clip_control");Lt?Ae.clipControlEXT(Ae.LOWER_LEFT_EXT,Ae.ZERO_TO_ONE_EXT):Ae.clipControlEXT(Ae.LOWER_LEFT_EXT,Ae.NEGATIVE_ONE_TO_ONE_EXT),re=Lt;const Oe=Xt;Xt=null,this.setClear(Oe)}},getReversed:function(){return re},setTest:function(Lt){Lt?pt(s.DEPTH_TEST):qt(s.DEPTH_TEST)},setMask:function(Lt){ee!==Lt&&!lt&&(s.depthMask(Lt),ee=Lt)},setFunc:function(Lt){if(re&&(Lt=FO[Lt]),ie!==Lt){switch(Lt){case fv:s.depthFunc(s.NEVER);break;case Av:s.depthFunc(s.ALWAYS);break;case dv:s.depthFunc(s.LESS);break;case Yf:s.depthFunc(s.LEQUAL);break;case pv:s.depthFunc(s.EQUAL);break;case gv:s.depthFunc(s.GEQUAL);break;case mv:s.depthFunc(s.GREATER);break;case yv:s.depthFunc(s.NOTEQUAL);break;default:s.depthFunc(s.LEQUAL)}ie=Lt}},setLocked:function(Lt){lt=Lt},setClear:function(Lt){Xt!==Lt&&(re&&(Lt=1-Lt),s.clearDepth(Lt),Xt=Lt)},reset:function(){lt=!1,ee=null,ie=null,Xt=null,re=!1}}}function i(){let lt=!1,re=null,ee=null,ie=null,Xt=null,Lt=null,Ae=null,Oe=null,In=null;return{setTest:function(ln){lt||(ln?pt(s.STENCIL_TEST):qt(s.STENCIL_TEST))},setMask:function(ln){re!==ln&&!lt&&(s.stencilMask(ln),re=ln)},setFunc:function(ln,Ei,$i){(ee!==ln||ie!==Ei||Xt!==$i)&&(s.stencilFunc(ln,Ei,$i),ee=ln,ie=Ei,Xt=$i)},setOp:function(ln,Ei,$i){(Lt!==ln||Ae!==Ei||Oe!==$i)&&(s.stencilOp(ln,Ei,$i),Lt=ln,Ae=Ei,Oe=$i)},setLocked:function(ln){lt=ln},setClear:function(ln){In!==ln&&(s.clearStencil(ln),In=ln)},reset:function(){lt=!1,re=null,ee=null,ie=null,Xt=null,Lt=null,Ae=null,Oe=null,In=null}}}const r=new e,l=new n,u=new i,A=new WeakMap,d=new WeakMap;let m={},g={},y=new WeakMap,v=[],C=null,I=!1,S=null,E=null,B=null,w=null,Q=null,R=null,D=null,U=new le(0,0,0),P=0,z=!1,L=null,k=null,Y=null,W=null,K=null;const nt=s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let H=!1,tt=0;const it=s.getParameter(s.VERSION);it.indexOf("WebGL")!==-1?(tt=parseFloat(/^WebGL (\d)/.exec(it)[1]),H=tt>=1):it.indexOf("OpenGL ES")!==-1&&(tt=parseFloat(/^OpenGL ES (\d)/.exec(it)[1]),H=tt>=2);let ot=null,At={};const V=s.getParameter(s.SCISSOR_BOX),st=s.getParameter(s.VIEWPORT),xt=new We().fromArray(V),j=new We().fromArray(st);function Rt(lt,re,ee,ie){const Xt=new Uint8Array(4),Lt=s.createTexture();s.bindTexture(lt,Lt),s.texParameteri(lt,s.TEXTURE_MIN_FILTER,s.NEAREST),s.texParameteri(lt,s.TEXTURE_MAG_FILTER,s.NEAREST);for(let Ae=0;Ae<ee;Ae++)lt===s.TEXTURE_3D||lt===s.TEXTURE_2D_ARRAY?s.texImage3D(re,0,s.RGBA,1,1,ie,0,s.RGBA,s.UNSIGNED_BYTE,Xt):s.texImage2D(re+Ae,0,s.RGBA,1,1,0,s.RGBA,s.UNSIGNED_BYTE,Xt);return Lt}const dt={};dt[s.TEXTURE_2D]=Rt(s.TEXTURE_2D,s.TEXTURE_2D,1),dt[s.TEXTURE_CUBE_MAP]=Rt(s.TEXTURE_CUBE_MAP,s.TEXTURE_CUBE_MAP_POSITIVE_X,6),dt[s.TEXTURE_2D_ARRAY]=Rt(s.TEXTURE_2D_ARRAY,s.TEXTURE_2D_ARRAY,1,1),dt[s.TEXTURE_3D]=Rt(s.TEXTURE_3D,s.TEXTURE_3D,1,1),r.setClear(0,0,0,1),l.setClear(1),u.setClear(0),pt(s.DEPTH_TEST),l.setFunc(Yf),Ot(!1),Vt(bb),pt(s.CULL_FACE),zt(nc);function pt(lt){m[lt]!==!0&&(s.enable(lt),m[lt]=!0)}function qt(lt){m[lt]!==!1&&(s.disable(lt),m[lt]=!1)}function Wt(lt,re){return g[lt]!==re?(s.bindFramebuffer(lt,re),g[lt]=re,lt===s.DRAW_FRAMEBUFFER&&(g[s.FRAMEBUFFER]=re),lt===s.FRAMEBUFFER&&(g[s.DRAW_FRAMEBUFFER]=re),!0):!1}function ce(lt,re){let ee=v,ie=!1;if(lt){ee=y.get(re),ee===void 0&&(ee=[],y.set(re,ee));const Xt=lt.textures;if(ee.length!==Xt.length||ee[0]!==s.COLOR_ATTACHMENT0){for(let Lt=0,Ae=Xt.length;Lt<Ae;Lt++)ee[Lt]=s.COLOR_ATTACHMENT0+Lt;ee.length=Xt.length,ie=!0}}else ee[0]!==s.BACK&&(ee[0]=s.BACK,ie=!0);ie&&s.drawBuffers(ee)}function Ie(lt){return C!==lt?(s.useProgram(lt),C=lt,!0):!1}const He={[rh]:s.FUNC_ADD,[mM]:s.FUNC_SUBTRACT,[yM]:s.FUNC_REVERSE_SUBTRACT};He[xM]=s.MIN,He[vM]=s.MAX;const be={[EM]:s.ZERO,[_M]:s.ONE,[CM]:s.SRC_COLOR,[uv]:s.SRC_ALPHA,[wM]:s.SRC_ALPHA_SATURATE,[BM]:s.DST_COLOR,[SM]:s.DST_ALPHA,[bM]:s.ONE_MINUS_SRC_COLOR,[hv]:s.ONE_MINUS_SRC_ALPHA,[MM]:s.ONE_MINUS_DST_COLOR,[IM]:s.ONE_MINUS_DST_ALPHA,[TM]:s.CONSTANT_COLOR,[QM]:s.ONE_MINUS_CONSTANT_COLOR,[DM]:s.CONSTANT_ALPHA,[RM]:s.ONE_MINUS_CONSTANT_ALPHA};function zt(lt,re,ee,ie,Xt,Lt,Ae,Oe,In,ln){if(lt===nc){I===!0&&(qt(s.BLEND),I=!1);return}if(I===!1&&(pt(s.BLEND),I=!0),lt!==gM){if(lt!==S||ln!==z){if((E!==rh||Q!==rh)&&(s.blendEquation(s.FUNC_ADD),E=rh,Q=rh),ln)switch(lt){case Gf:s.blendFuncSeparate(s.ONE,s.ONE_MINUS_SRC_ALPHA,s.ONE,s.ONE_MINUS_SRC_ALPHA);break;case Sb:s.blendFunc(s.ONE,s.ONE);break;case Ib:s.blendFuncSeparate(s.ZERO,s.ONE_MINUS_SRC_COLOR,s.ZERO,s.ONE);break;case Bb:s.blendFuncSeparate(s.DST_COLOR,s.ONE_MINUS_SRC_ALPHA,s.ZERO,s.ONE);break;default:nn("WebGLState: Invalid blending: ",lt);break}else switch(lt){case Gf:s.blendFuncSeparate(s.SRC_ALPHA,s.ONE_MINUS_SRC_ALPHA,s.ONE,s.ONE_MINUS_SRC_ALPHA);break;case Sb:s.blendFuncSeparate(s.SRC_ALPHA,s.ONE,s.ONE,s.ONE);break;case Ib:nn("WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");break;case Bb:nn("WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");break;default:nn("WebGLState: Invalid blending: ",lt);break}B=null,w=null,R=null,D=null,U.set(0,0,0),P=0,S=lt,z=ln}return}Xt=Xt||re,Lt=Lt||ee,Ae=Ae||ie,(re!==E||Xt!==Q)&&(s.blendEquationSeparate(He[re],He[Xt]),E=re,Q=Xt),(ee!==B||ie!==w||Lt!==R||Ae!==D)&&(s.blendFuncSeparate(be[ee],be[ie],be[Lt],be[Ae]),B=ee,w=ie,R=Lt,D=Ae),(Oe.equals(U)===!1||In!==P)&&(s.blendColor(Oe.r,Oe.g,Oe.b,In),U.copy(Oe),P=In),S=lt,z=!1}function Z(lt,re){lt.side===gr?qt(s.CULL_FACE):pt(s.CULL_FACE);let ee=lt.side===_a;re&&(ee=!ee),Ot(ee),lt.blending===Gf&&lt.transparent===!1?zt(nc):zt(lt.blending,lt.blendEquation,lt.blendSrc,lt.blendDst,lt.blendEquationAlpha,lt.blendSrcAlpha,lt.blendDstAlpha,lt.blendColor,lt.blendAlpha,lt.premultipliedAlpha),l.setFunc(lt.depthFunc),l.setTest(lt.depthTest),l.setMask(lt.depthWrite),r.setMask(lt.colorWrite);const ie=lt.stencilWrite;u.setTest(ie),ie&&(u.setMask(lt.stencilWriteMask),u.setFunc(lt.stencilFunc,lt.stencilRef,lt.stencilFuncMask),u.setOp(lt.stencilFail,lt.stencilZFail,lt.stencilZPass)),kt(lt.polygonOffset,lt.polygonOffsetFactor,lt.polygonOffsetUnits),lt.alphaToCoverage===!0?pt(s.SAMPLE_ALPHA_TO_COVERAGE):qt(s.SAMPLE_ALPHA_TO_COVERAGE)}function Ot(lt){L!==lt&&(lt?s.frontFace(s.CW):s.frontFace(s.CCW),L=lt)}function Vt(lt){lt!==AM?(pt(s.CULL_FACE),lt!==k&&(lt===bb?s.cullFace(s.BACK):lt===dM?s.cullFace(s.FRONT):s.cullFace(s.FRONT_AND_BACK))):qt(s.CULL_FACE),k=lt}function Pt(lt){lt!==Y&&(H&&s.lineWidth(lt),Y=lt)}function kt(lt,re,ee){lt?(pt(s.POLYGON_OFFSET_FILL),(W!==re||K!==ee)&&(s.polygonOffset(re,ee),W=re,K=ee)):qt(s.POLYGON_OFFSET_FILL)}function Zt(lt){lt?pt(s.SCISSOR_TEST):qt(s.SCISSOR_TEST)}function $t(lt){lt===void 0&&(lt=s.TEXTURE0+nt-1),ot!==lt&&(s.activeTexture(lt),ot=lt)}function fe(lt,re,ee){ee===void 0&&(ot===null?ee=s.TEXTURE0+nt-1:ee=ot);let ie=At[ee];ie===void 0&&(ie={type:void 0,texture:void 0},At[ee]=ie),(ie.type!==lt||ie.texture!==re)&&(ot!==ee&&(s.activeTexture(ee),ot=ee),s.bindTexture(lt,re||dt[lt]),ie.type=lt,ie.texture=re)}function $(){const lt=At[ot];lt!==void 0&&lt.type!==void 0&&(s.bindTexture(lt.type,null),lt.type=void 0,lt.texture=void 0)}function G(){try{s.compressedTexImage2D(...arguments)}catch(lt){lt("WebGLState:",lt)}}function ft(){try{s.compressedTexImage3D(...arguments)}catch(lt){lt("WebGLState:",lt)}}function Tt(){try{s.texSubImage2D(...arguments)}catch(lt){lt("WebGLState:",lt)}}function Ht(){try{s.texSubImage3D(...arguments)}catch(lt){lt("WebGLState:",lt)}}function Bt(){try{s.compressedTexSubImage2D(...arguments)}catch(lt){lt("WebGLState:",lt)}}function Se(){try{s.compressedTexSubImage3D(...arguments)}catch(lt){lt("WebGLState:",lt)}}function ae(){try{s.texStorage2D(...arguments)}catch(lt){lt("WebGLState:",lt)}}function we(){try{s.texStorage3D(...arguments)}catch(lt){lt("WebGLState:",lt)}}function Ee(){try{s.texImage2D(...arguments)}catch(lt){lt("WebGLState:",lt)}}function Gt(){try{s.texImage3D(...arguments)}catch(lt){lt("WebGLState:",lt)}}function Jt(lt){xt.equals(lt)===!1&&(s.scissor(lt.x,lt.y,lt.z,lt.w),xt.copy(lt))}function Be(lt){j.equals(lt)===!1&&(s.viewport(lt.x,lt.y,lt.z,lt.w),j.copy(lt))}function ve(lt,re){let ee=d.get(re);ee===void 0&&(ee=new WeakMap,d.set(re,ee));let ie=ee.get(lt);ie===void 0&&(ie=s.getUniformBlockIndex(re,lt.name),ee.set(lt,ie))}function te(lt,re){const ie=d.get(re).get(lt);A.get(re)!==ie&&(s.uniformBlockBinding(re,ie,lt.__bindingPointIndex),A.set(re,ie))}function Ue(){s.disable(s.BLEND),s.disable(s.CULL_FACE),s.disable(s.DEPTH_TEST),s.disable(s.POLYGON_OFFSET_FILL),s.disable(s.SCISSOR_TEST),s.disable(s.STENCIL_TEST),s.disable(s.SAMPLE_ALPHA_TO_COVERAGE),s.blendEquation(s.FUNC_ADD),s.blendFunc(s.ONE,s.ZERO),s.blendFuncSeparate(s.ONE,s.ZERO,s.ONE,s.ZERO),s.blendColor(0,0,0,0),s.colorMask(!0,!0,!0,!0),s.clearColor(0,0,0,0),s.depthMask(!0),s.depthFunc(s.LESS),l.setReversed(!1),s.clearDepth(1),s.stencilMask(4294967295),s.stencilFunc(s.ALWAYS,0,4294967295),s.stencilOp(s.KEEP,s.KEEP,s.KEEP),s.clearStencil(0),s.cullFace(s.BACK),s.frontFace(s.CCW),s.polygonOffset(0,0),s.activeTexture(s.TEXTURE0),s.bindFramebuffer(s.FRAMEBUFFER,null),s.bindFramebuffer(s.DRAW_FRAMEBUFFER,null),s.bindFramebuffer(s.READ_FRAMEBUFFER,null),s.useProgram(null),s.lineWidth(1),s.scissor(0,0,s.canvas.width,s.canvas.height),s.viewport(0,0,s.canvas.width,s.canvas.height),m={},ot=null,At={},g={},y=new WeakMap,v=[],C=null,I=!1,S=null,E=null,B=null,w=null,Q=null,R=null,D=null,U=new le(0,0,0),P=0,z=!1,L=null,k=null,Y=null,W=null,K=null,xt.set(0,0,s.canvas.width,s.canvas.height),j.set(0,0,s.canvas.width,s.canvas.height),r.reset(),l.reset(),u.reset()}return{buffers:{color:r,depth:l,stencil:u},enable:pt,disable:qt,bindFramebuffer:Wt,drawBuffers:ce,useProgram:Ie,setBlending:zt,setMaterial:Z,setFlipSided:Ot,setCullFace:Vt,setLineWidth:Pt,setPolygonOffset:kt,setScissorTest:Zt,activeTexture:$t,bindTexture:fe,unbindTexture:$,compressedTexImage2D:G,compressedTexImage3D:ft,texImage2D:Ee,texImage3D:Gt,updateUBOMapping:ve,uniformBlockBinding:te,texStorage2D:ae,texStorage3D:we,texSubImage2D:Tt,texSubImage3D:Ht,compressedTexSubImage2D:Bt,compressedTexSubImage3D:Se,scissor:Jt,viewport:Be,reset:Ue}}function GO(s,t,e,n,i,r,l){const u=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):null,A=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),d=new Dt,m=new WeakMap;let g;const y=new WeakMap;let v=!1;try{v=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function C($,G){return v?new OffscreenCanvas($,G):km("canvas")}function I($,G,ft){let Tt=1;const Ht=fe($);if((Ht.width>ft||Ht.height>ft)&&(Tt=ft/Math.max(Ht.width,Ht.height)),Tt<1)if(typeof HTMLImageElement<"u"&&$ instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&$ instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&$ instanceof ImageBitmap||typeof VideoFrame<"u"&&$ instanceof VideoFrame){const Bt=Math.floor(Tt*Ht.width),Se=Math.floor(Tt*Ht.height);g===void 0&&(g=C(Bt,Se));const ae=G?C(Bt,Se):g;return ae.width=Bt,ae.height=Se,ae.getContext("2d").drawImage($,0,0,Bt,Se),ge("WebGLRenderer: Texture has been resized from ("+Ht.width+"x"+Ht.height+") to ("+Bt+"x"+Se+")."),ae}else return"data"in $&&ge("WebGLRenderer: Image in DataTexture is too big ("+Ht.width+"x"+Ht.height+")."),$;return $}function S($){return $.generateMipmaps}function E($){s.generateMipmap($)}function B($){return $.isWebGLCubeRenderTarget?s.TEXTURE_CUBE_MAP:$.isWebGL3DRenderTarget?s.TEXTURE_3D:$.isWebGLArrayRenderTarget||$.isCompressedArrayTexture?s.TEXTURE_2D_ARRAY:s.TEXTURE_2D}function w($,G,ft,Tt,Ht=!1){if($!==null){if(s[$]!==void 0)return s[$];ge("WebGLRenderer: Attempt to use non-existing WebGL internal format '"+$+"'")}let Bt=G;if(G===s.RED&&(ft===s.FLOAT&&(Bt=s.R32F),ft===s.HALF_FLOAT&&(Bt=s.R16F),ft===s.UNSIGNED_BYTE&&(Bt=s.R8)),G===s.RED_INTEGER&&(ft===s.UNSIGNED_BYTE&&(Bt=s.R8UI),ft===s.UNSIGNED_SHORT&&(Bt=s.R16UI),ft===s.UNSIGNED_INT&&(Bt=s.R32UI),ft===s.BYTE&&(Bt=s.R8I),ft===s.SHORT&&(Bt=s.R16I),ft===s.INT&&(Bt=s.R32I)),G===s.RG&&(ft===s.FLOAT&&(Bt=s.RG32F),ft===s.HALF_FLOAT&&(Bt=s.RG16F),ft===s.UNSIGNED_BYTE&&(Bt=s.RG8)),G===s.RG_INTEGER&&(ft===s.UNSIGNED_BYTE&&(Bt=s.RG8UI),ft===s.UNSIGNED_SHORT&&(Bt=s.RG16UI),ft===s.UNSIGNED_INT&&(Bt=s.RG32UI),ft===s.BYTE&&(Bt=s.RG8I),ft===s.SHORT&&(Bt=s.RG16I),ft===s.INT&&(Bt=s.RG32I)),G===s.RGB_INTEGER&&(ft===s.UNSIGNED_BYTE&&(Bt=s.RGB8UI),ft===s.UNSIGNED_SHORT&&(Bt=s.RGB16UI),ft===s.UNSIGNED_INT&&(Bt=s.RGB32UI),ft===s.BYTE&&(Bt=s.RGB8I),ft===s.SHORT&&(Bt=s.RGB16I),ft===s.INT&&(Bt=s.RGB32I)),G===s.RGBA_INTEGER&&(ft===s.UNSIGNED_BYTE&&(Bt=s.RGBA8UI),ft===s.UNSIGNED_SHORT&&(Bt=s.RGBA16UI),ft===s.UNSIGNED_INT&&(Bt=s.RGBA32UI),ft===s.BYTE&&(Bt=s.RGBA8I),ft===s.SHORT&&(Bt=s.RGBA16I),ft===s.INT&&(Bt=s.RGBA32I)),G===s.RGB&&(ft===s.UNSIGNED_INT_5_9_9_9_REV&&(Bt=s.RGB9_E5),ft===s.UNSIGNED_INT_10F_11F_11F_REV&&(Bt=s.R11F_G11F_B10F)),G===s.RGBA){const Se=Ht?Fm:Gn.getTransfer(Tt);ft===s.FLOAT&&(Bt=s.RGBA32F),ft===s.HALF_FLOAT&&(Bt=s.RGBA16F),ft===s.UNSIGNED_BYTE&&(Bt=Se===ui?s.SRGB8_ALPHA8:s.RGBA8),ft===s.UNSIGNED_SHORT_4_4_4_4&&(Bt=s.RGBA4),ft===s.UNSIGNED_SHORT_5_5_5_1&&(Bt=s.RGB5_A1)}return(Bt===s.R16F||Bt===s.R32F||Bt===s.RG16F||Bt===s.RG32F||Bt===s.RGBA16F||Bt===s.RGBA32F)&&t.get("EXT_color_buffer_float"),Bt}function Q($,G){let ft;return $?G===null||G===Ca||G===Zd?ft=s.DEPTH24_STENCIL8:G===xr?ft=s.DEPTH32F_STENCIL8:G===Jd&&(ft=s.DEPTH24_STENCIL8,ge("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):G===null||G===Ca||G===Zd?ft=s.DEPTH_COMPONENT24:G===xr?ft=s.DEPTH_COMPONENT32F:G===Jd&&(ft=s.DEPTH_COMPONENT16),ft}function R($,G){return S($)===!0||$.isFramebufferTexture&&$.minFilter!==rs&&$.minFilter!==as?Math.log2(Math.max(G.width,G.height))+1:$.mipmaps!==void 0&&$.mipmaps.length>0?$.mipmaps.length:$.isCompressedTexture&&Array.isArray($.image)?G.mipmaps.length:1}function D($){const G=$.target;G.removeEventListener("dispose",D),P(G),G.isVideoTexture&&m.delete(G)}function U($){const G=$.target;G.removeEventListener("dispose",U),L(G)}function P($){const G=n.get($);if(G.__webglInit===void 0)return;const ft=$.source,Tt=y.get(ft);if(Tt){const Ht=Tt[G.__cacheKey];Ht.usedTimes--,Ht.usedTimes===0&&z($),Object.keys(Tt).length===0&&y.delete(ft)}n.remove($)}function z($){const G=n.get($);s.deleteTexture(G.__webglTexture);const ft=$.source,Tt=y.get(ft);delete Tt[G.__cacheKey],l.memory.textures--}function L($){const G=n.get($);if($.depthTexture&&($.depthTexture.dispose(),n.remove($.depthTexture)),$.isWebGLCubeRenderTarget)for(let Tt=0;Tt<6;Tt++){if(Array.isArray(G.__webglFramebuffer[Tt]))for(let Ht=0;Ht<G.__webglFramebuffer[Tt].length;Ht++)s.deleteFramebuffer(G.__webglFramebuffer[Tt][Ht]);else s.deleteFramebuffer(G.__webglFramebuffer[Tt]);G.__webglDepthbuffer&&s.deleteRenderbuffer(G.__webglDepthbuffer[Tt])}else{if(Array.isArray(G.__webglFramebuffer))for(let Tt=0;Tt<G.__webglFramebuffer.length;Tt++)s.deleteFramebuffer(G.__webglFramebuffer[Tt]);else s.deleteFramebuffer(G.__webglFramebuffer);if(G.__webglDepthbuffer&&s.deleteRenderbuffer(G.__webglDepthbuffer),G.__webglMultisampledFramebuffer&&s.deleteFramebuffer(G.__webglMultisampledFramebuffer),G.__webglColorRenderbuffer)for(let Tt=0;Tt<G.__webglColorRenderbuffer.length;Tt++)G.__webglColorRenderbuffer[Tt]&&s.deleteRenderbuffer(G.__webglColorRenderbuffer[Tt]);G.__webglDepthRenderbuffer&&s.deleteRenderbuffer(G.__webglDepthRenderbuffer)}const ft=$.textures;for(let Tt=0,Ht=ft.length;Tt<Ht;Tt++){const Bt=n.get(ft[Tt]);Bt.__webglTexture&&(s.deleteTexture(Bt.__webglTexture),l.memory.textures--),n.remove(ft[Tt])}n.remove($)}let k=0;function Y(){k=0}function W(){const $=k;return $>=i.maxTextures&&ge("WebGLTextures: Trying to use "+$+" texture units while this GPU supports only "+i.maxTextures),k+=1,$}function K($){const G=[];return G.push($.wrapS),G.push($.wrapT),G.push($.wrapR||0),G.push($.magFilter),G.push($.minFilter),G.push($.anisotropy),G.push($.internalFormat),G.push($.format),G.push($.type),G.push($.generateMipmaps),G.push($.premultiplyAlpha),G.push($.flipY),G.push($.unpackAlignment),G.push($.colorSpace),G.join()}function nt($,G){const ft=n.get($);if($.isVideoTexture&&Zt($),$.isRenderTargetTexture===!1&&$.isExternalTexture!==!0&&$.version>0&&ft.__version!==$.version){const Tt=$.image;if(Tt===null)ge("WebGLRenderer: Texture marked for update but no image data found.");else if(Tt.complete===!1)ge("WebGLRenderer: Texture marked for update but image is incomplete");else{dt(ft,$,G);return}}else $.isExternalTexture&&(ft.__webglTexture=$.sourceTexture?$.sourceTexture:null);e.bindTexture(s.TEXTURE_2D,ft.__webglTexture,s.TEXTURE0+G)}function H($,G){const ft=n.get($);if($.isRenderTargetTexture===!1&&$.version>0&&ft.__version!==$.version){dt(ft,$,G);return}else $.isExternalTexture&&(ft.__webglTexture=$.sourceTexture?$.sourceTexture:null);e.bindTexture(s.TEXTURE_2D_ARRAY,ft.__webglTexture,s.TEXTURE0+G)}function tt($,G){const ft=n.get($);if($.isRenderTargetTexture===!1&&$.version>0&&ft.__version!==$.version){dt(ft,$,G);return}e.bindTexture(s.TEXTURE_3D,ft.__webglTexture,s.TEXTURE0+G)}function it($,G){const ft=n.get($);if($.version>0&&ft.__version!==$.version){pt(ft,$,G);return}e.bindTexture(s.TEXTURE_CUBE_MAP,ft.__webglTexture,s.TEXTURE0+G)}const ot={[Um]:s.REPEAT,[yr]:s.CLAMP_TO_EDGE,[Lm]:s.MIRRORED_REPEAT},At={[rs]:s.NEAREST,[fS]:s.NEAREST_MIPMAP_NEAREST,[Gd]:s.NEAREST_MIPMAP_LINEAR,[as]:s.LINEAR,[mm]:s.LINEAR_MIPMAP_NEAREST,[tc]:s.LINEAR_MIPMAP_LINEAR},V={[WM]:s.NEVER,[nw]:s.ALWAYS,[jM]:s.LESS,[vS]:s.LEQUAL,[KM]:s.EQUAL,[ew]:s.GEQUAL,[$M]:s.GREATER,[tw]:s.NOTEQUAL};function st($,G){if(G.type===xr&&t.has("OES_texture_float_linear")===!1&&(G.magFilter===as||G.magFilter===mm||G.magFilter===Gd||G.magFilter===tc||G.minFilter===as||G.minFilter===mm||G.minFilter===Gd||G.minFilter===tc)&&ge("WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),s.texParameteri($,s.TEXTURE_WRAP_S,ot[G.wrapS]),s.texParameteri($,s.TEXTURE_WRAP_T,ot[G.wrapT]),($===s.TEXTURE_3D||$===s.TEXTURE_2D_ARRAY)&&s.texParameteri($,s.TEXTURE_WRAP_R,ot[G.wrapR]),s.texParameteri($,s.TEXTURE_MAG_FILTER,At[G.magFilter]),s.texParameteri($,s.TEXTURE_MIN_FILTER,At[G.minFilter]),G.compareFunction&&(s.texParameteri($,s.TEXTURE_COMPARE_MODE,s.COMPARE_REF_TO_TEXTURE),s.texParameteri($,s.TEXTURE_COMPARE_FUNC,V[G.compareFunction])),t.has("EXT_texture_filter_anisotropic")===!0){if(G.magFilter===rs||G.minFilter!==Gd&&G.minFilter!==tc||G.type===xr&&t.has("OES_texture_float_linear")===!1)return;if(G.anisotropy>1||n.get(G).__currentAnisotropy){const ft=t.get("EXT_texture_filter_anisotropic");s.texParameterf($,ft.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(G.anisotropy,i.getMaxAnisotropy())),n.get(G).__currentAnisotropy=G.anisotropy}}}function xt($,G){let ft=!1;$.__webglInit===void 0&&($.__webglInit=!0,G.addEventListener("dispose",D));const Tt=G.source;let Ht=y.get(Tt);Ht===void 0&&(Ht={},y.set(Tt,Ht));const Bt=K(G);if(Bt!==$.__cacheKey){Ht[Bt]===void 0&&(Ht[Bt]={texture:s.createTexture(),usedTimes:0},l.memory.textures++,ft=!0),Ht[Bt].usedTimes++;const Se=Ht[$.__cacheKey];Se!==void 0&&(Ht[$.__cacheKey].usedTimes--,Se.usedTimes===0&&z(G)),$.__cacheKey=Bt,$.__webglTexture=Ht[Bt].texture}return ft}function j($,G,ft){return Math.floor(Math.floor($/ft)/G)}function Rt($,G,ft,Tt){const Bt=$.updateRanges;if(Bt.length===0)e.texSubImage2D(s.TEXTURE_2D,0,0,0,G.width,G.height,ft,Tt,G.data);else{Bt.sort((Gt,Jt)=>Gt.start-Jt.start);let Se=0;for(let Gt=1;Gt<Bt.length;Gt++){const Jt=Bt[Se],Be=Bt[Gt],ve=Jt.start+Jt.count,te=j(Be.start,G.width,4),Ue=j(Jt.start,G.width,4);Be.start<=ve+1&&te===Ue&&j(Be.start+Be.count-1,G.width,4)===te?Jt.count=Math.max(Jt.count,Be.start+Be.count-Jt.start):(++Se,Bt[Se]=Be)}Bt.length=Se+1;const ae=s.getParameter(s.UNPACK_ROW_LENGTH),we=s.getParameter(s.UNPACK_SKIP_PIXELS),Ee=s.getParameter(s.UNPACK_SKIP_ROWS);s.pixelStorei(s.UNPACK_ROW_LENGTH,G.width);for(let Gt=0,Jt=Bt.length;Gt<Jt;Gt++){const Be=Bt[Gt],ve=Math.floor(Be.start/4),te=Math.ceil(Be.count/4),Ue=ve%G.width,lt=Math.floor(ve/G.width),re=te,ee=1;s.pixelStorei(s.UNPACK_SKIP_PIXELS,Ue),s.pixelStorei(s.UNPACK_SKIP_ROWS,lt),e.texSubImage2D(s.TEXTURE_2D,0,Ue,lt,re,ee,ft,Tt,G.data)}$.clearUpdateRanges(),s.pixelStorei(s.UNPACK_ROW_LENGTH,ae),s.pixelStorei(s.UNPACK_SKIP_PIXELS,we),s.pixelStorei(s.UNPACK_SKIP_ROWS,Ee)}}function dt($,G,ft){let Tt=s.TEXTURE_2D;(G.isDataArrayTexture||G.isCompressedArrayTexture)&&(Tt=s.TEXTURE_2D_ARRAY),G.isData3DTexture&&(Tt=s.TEXTURE_3D);const Ht=xt($,G),Bt=G.source;e.bindTexture(Tt,$.__webglTexture,s.TEXTURE0+ft);const Se=n.get(Bt);if(Bt.version!==Se.__version||Ht===!0){e.activeTexture(s.TEXTURE0+ft);const ae=Gn.getPrimaries(Gn.workingColorSpace),we=G.colorSpace===Wc?null:Gn.getPrimaries(G.colorSpace),Ee=G.colorSpace===Wc||ae===we?s.NONE:s.BROWSER_DEFAULT_WEBGL;s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL,G.flipY),s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,G.premultiplyAlpha),s.pixelStorei(s.UNPACK_ALIGNMENT,G.unpackAlignment),s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL,Ee);let Gt=I(G.image,!1,i.maxTextureSize);Gt=$t(G,Gt);const Jt=r.convert(G.format,G.colorSpace),Be=r.convert(G.type);let ve=w(G.internalFormat,Jt,Be,G.colorSpace,G.isVideoTexture);st(Tt,G);let te;const Ue=G.mipmaps,lt=G.isVideoTexture!==!0,re=Se.__version===void 0||Ht===!0,ee=Bt.dataReady,ie=R(G,Gt);if(G.isDepthTexture)ve=Q(G.format===jd,G.type),re&&(lt?e.texStorage2D(s.TEXTURE_2D,1,ve,Gt.width,Gt.height):e.texImage2D(s.TEXTURE_2D,0,ve,Gt.width,Gt.height,0,Jt,Be,null));else if(G.isDataTexture)if(Ue.length>0){lt&&re&&e.texStorage2D(s.TEXTURE_2D,ie,ve,Ue[0].width,Ue[0].height);for(let Xt=0,Lt=Ue.length;Xt<Lt;Xt++)te=Ue[Xt],lt?ee&&e.texSubImage2D(s.TEXTURE_2D,Xt,0,0,te.width,te.height,Jt,Be,te.data):e.texImage2D(s.TEXTURE_2D,Xt,ve,te.width,te.height,0,Jt,Be,te.data);G.generateMipmaps=!1}else lt?(re&&e.texStorage2D(s.TEXTURE_2D,ie,ve,Gt.width,Gt.height),ee&&Rt(G,Gt,Jt,Be)):e.texImage2D(s.TEXTURE_2D,0,ve,Gt.width,Gt.height,0,Jt,Be,Gt.data);else if(G.isCompressedTexture)if(G.isCompressedArrayTexture){lt&&re&&e.texStorage3D(s.TEXTURE_2D_ARRAY,ie,ve,Ue[0].width,Ue[0].height,Gt.depth);for(let Xt=0,Lt=Ue.length;Xt<Lt;Xt++)if(te=Ue[Xt],G.format!==Ki)if(Jt!==null)if(lt){if(ee)if(G.layerUpdates.size>0){const Ae=Lb(te.width,te.height,G.format,G.type);for(const Oe of G.layerUpdates){const In=te.data.subarray(Oe*Ae/te.data.BYTES_PER_ELEMENT,(Oe+1)*Ae/te.data.BYTES_PER_ELEMENT);e.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY,Xt,0,0,Oe,te.width,te.height,1,Jt,In)}G.clearLayerUpdates()}else e.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY,Xt,0,0,0,te.width,te.height,Gt.depth,Jt,te.data)}else e.compressedTexImage3D(s.TEXTURE_2D_ARRAY,Xt,ve,te.width,te.height,Gt.depth,0,te.data,0,0);else ge("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else lt?ee&&e.texSubImage3D(s.TEXTURE_2D_ARRAY,Xt,0,0,0,te.width,te.height,Gt.depth,Jt,Be,te.data):e.texImage3D(s.TEXTURE_2D_ARRAY,Xt,ve,te.width,te.height,Gt.depth,0,Jt,Be,te.data)}else{lt&&re&&e.texStorage2D(s.TEXTURE_2D,ie,ve,Ue[0].width,Ue[0].height);for(let Xt=0,Lt=Ue.length;Xt<Lt;Xt++)te=Ue[Xt],G.format!==Ki?Jt!==null?lt?ee&&e.compressedTexSubImage2D(s.TEXTURE_2D,Xt,0,0,te.width,te.height,Jt,te.data):e.compressedTexImage2D(s.TEXTURE_2D,Xt,ve,te.width,te.height,0,te.data):ge("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):lt?ee&&e.texSubImage2D(s.TEXTURE_2D,Xt,0,0,te.width,te.height,Jt,Be,te.data):e.texImage2D(s.TEXTURE_2D,Xt,ve,te.width,te.height,0,Jt,Be,te.data)}else if(G.isDataArrayTexture)if(lt){if(re&&e.texStorage3D(s.TEXTURE_2D_ARRAY,ie,ve,Gt.width,Gt.height,Gt.depth),ee)if(G.layerUpdates.size>0){const Xt=Lb(Gt.width,Gt.height,G.format,G.type);for(const Lt of G.layerUpdates){const Ae=Gt.data.subarray(Lt*Xt/Gt.data.BYTES_PER_ELEMENT,(Lt+1)*Xt/Gt.data.BYTES_PER_ELEMENT);e.texSubImage3D(s.TEXTURE_2D_ARRAY,0,0,0,Lt,Gt.width,Gt.height,1,Jt,Be,Ae)}G.clearLayerUpdates()}else e.texSubImage3D(s.TEXTURE_2D_ARRAY,0,0,0,0,Gt.width,Gt.height,Gt.depth,Jt,Be,Gt.data)}else e.texImage3D(s.TEXTURE_2D_ARRAY,0,ve,Gt.width,Gt.height,Gt.depth,0,Jt,Be,Gt.data);else if(G.isData3DTexture)lt?(re&&e.texStorage3D(s.TEXTURE_3D,ie,ve,Gt.width,Gt.height,Gt.depth),ee&&e.texSubImage3D(s.TEXTURE_3D,0,0,0,0,Gt.width,Gt.height,Gt.depth,Jt,Be,Gt.data)):e.texImage3D(s.TEXTURE_3D,0,ve,Gt.width,Gt.height,Gt.depth,0,Jt,Be,Gt.data);else if(G.isFramebufferTexture){if(re)if(lt)e.texStorage2D(s.TEXTURE_2D,ie,ve,Gt.width,Gt.height);else{let Xt=Gt.width,Lt=Gt.height;for(let Ae=0;Ae<ie;Ae++)e.texImage2D(s.TEXTURE_2D,Ae,ve,Xt,Lt,0,Jt,Be,null),Xt>>=1,Lt>>=1}}else if(Ue.length>0){if(lt&&re){const Xt=fe(Ue[0]);e.texStorage2D(s.TEXTURE_2D,ie,ve,Xt.width,Xt.height)}for(let Xt=0,Lt=Ue.length;Xt<Lt;Xt++)te=Ue[Xt],lt?ee&&e.texSubImage2D(s.TEXTURE_2D,Xt,0,0,Jt,Be,te):e.texImage2D(s.TEXTURE_2D,Xt,ve,Jt,Be,te);G.generateMipmaps=!1}else if(lt){if(re){const Xt=fe(Gt);e.texStorage2D(s.TEXTURE_2D,ie,ve,Xt.width,Xt.height)}ee&&e.texSubImage2D(s.TEXTURE_2D,0,0,0,Jt,Be,Gt)}else e.texImage2D(s.TEXTURE_2D,0,ve,Jt,Be,Gt);S(G)&&E(Tt),Se.__version=Bt.version,G.onUpdate&&G.onUpdate(G)}$.__version=G.version}function pt($,G,ft){if(G.image.length!==6)return;const Tt=xt($,G),Ht=G.source;e.bindTexture(s.TEXTURE_CUBE_MAP,$.__webglTexture,s.TEXTURE0+ft);const Bt=n.get(Ht);if(Ht.version!==Bt.__version||Tt===!0){e.activeTexture(s.TEXTURE0+ft);const Se=Gn.getPrimaries(Gn.workingColorSpace),ae=G.colorSpace===Wc?null:Gn.getPrimaries(G.colorSpace),we=G.colorSpace===Wc||Se===ae?s.NONE:s.BROWSER_DEFAULT_WEBGL;s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL,G.flipY),s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,G.premultiplyAlpha),s.pixelStorei(s.UNPACK_ALIGNMENT,G.unpackAlignment),s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL,we);const Ee=G.isCompressedTexture||G.image[0].isCompressedTexture,Gt=G.image[0]&&G.image[0].isDataTexture,Jt=[];for(let Lt=0;Lt<6;Lt++)!Ee&&!Gt?Jt[Lt]=I(G.image[Lt],!0,i.maxCubemapSize):Jt[Lt]=Gt?G.image[Lt].image:G.image[Lt],Jt[Lt]=$t(G,Jt[Lt]);const Be=Jt[0],ve=r.convert(G.format,G.colorSpace),te=r.convert(G.type),Ue=w(G.internalFormat,ve,te,G.colorSpace),lt=G.isVideoTexture!==!0,re=Bt.__version===void 0||Tt===!0,ee=Ht.dataReady;let ie=R(G,Be);st(s.TEXTURE_CUBE_MAP,G);let Xt;if(Ee){lt&&re&&e.texStorage2D(s.TEXTURE_CUBE_MAP,ie,Ue,Be.width,Be.height);for(let Lt=0;Lt<6;Lt++){Xt=Jt[Lt].mipmaps;for(let Ae=0;Ae<Xt.length;Ae++){const Oe=Xt[Ae];G.format!==Ki?ve!==null?lt?ee&&e.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Lt,Ae,0,0,Oe.width,Oe.height,ve,Oe.data):e.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Lt,Ae,Ue,Oe.width,Oe.height,0,Oe.data):ge("WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):lt?ee&&e.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Lt,Ae,0,0,Oe.width,Oe.height,ve,te,Oe.data):e.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Lt,Ae,Ue,Oe.width,Oe.height,0,ve,te,Oe.data)}}}else{if(Xt=G.mipmaps,lt&&re){Xt.length>0&&ie++;const Lt=fe(Jt[0]);e.texStorage2D(s.TEXTURE_CUBE_MAP,ie,Ue,Lt.width,Lt.height)}for(let Lt=0;Lt<6;Lt++)if(Gt){lt?ee&&e.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Lt,0,0,0,Jt[Lt].width,Jt[Lt].height,ve,te,Jt[Lt].data):e.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Lt,0,Ue,Jt[Lt].width,Jt[Lt].height,0,ve,te,Jt[Lt].data);for(let Ae=0;Ae<Xt.length;Ae++){const In=Xt[Ae].image[Lt].image;lt?ee&&e.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Lt,Ae+1,0,0,In.width,In.height,ve,te,In.data):e.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Lt,Ae+1,Ue,In.width,In.height,0,ve,te,In.data)}}else{lt?ee&&e.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Lt,0,0,0,ve,te,Jt[Lt]):e.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Lt,0,Ue,ve,te,Jt[Lt]);for(let Ae=0;Ae<Xt.length;Ae++){const Oe=Xt[Ae];lt?ee&&e.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Lt,Ae+1,0,0,ve,te,Oe.image[Lt]):e.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+Lt,Ae+1,Ue,ve,te,Oe.image[Lt])}}}S(G)&&E(s.TEXTURE_CUBE_MAP),Bt.__version=Ht.version,G.onUpdate&&G.onUpdate(G)}$.__version=G.version}function qt($,G,ft,Tt,Ht,Bt){const Se=r.convert(ft.format,ft.colorSpace),ae=r.convert(ft.type),we=w(ft.internalFormat,Se,ae,ft.colorSpace),Ee=n.get(G),Gt=n.get(ft);if(Gt.__renderTarget=G,!Ee.__hasExternalTextures){const Jt=Math.max(1,G.width>>Bt),Be=Math.max(1,G.height>>Bt);Ht===s.TEXTURE_3D||Ht===s.TEXTURE_2D_ARRAY?e.texImage3D(Ht,Bt,we,Jt,Be,G.depth,0,Se,ae,null):e.texImage2D(Ht,Bt,we,Jt,Be,0,Se,ae,null)}e.bindFramebuffer(s.FRAMEBUFFER,$),kt(G)?u.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER,Tt,Ht,Gt.__webglTexture,0,Pt(G)):(Ht===s.TEXTURE_2D||Ht>=s.TEXTURE_CUBE_MAP_POSITIVE_X&&Ht<=s.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&s.framebufferTexture2D(s.FRAMEBUFFER,Tt,Ht,Gt.__webglTexture,Bt),e.bindFramebuffer(s.FRAMEBUFFER,null)}function Wt($,G,ft){if(s.bindRenderbuffer(s.RENDERBUFFER,$),G.depthBuffer){const Tt=G.depthTexture,Ht=Tt&&Tt.isDepthTexture?Tt.type:null,Bt=Q(G.stencilBuffer,Ht),Se=G.stencilBuffer?s.DEPTH_STENCIL_ATTACHMENT:s.DEPTH_ATTACHMENT,ae=Pt(G);kt(G)?u.renderbufferStorageMultisampleEXT(s.RENDERBUFFER,ae,Bt,G.width,G.height):ft?s.renderbufferStorageMultisample(s.RENDERBUFFER,ae,Bt,G.width,G.height):s.renderbufferStorage(s.RENDERBUFFER,Bt,G.width,G.height),s.framebufferRenderbuffer(s.FRAMEBUFFER,Se,s.RENDERBUFFER,$)}else{const Tt=G.textures;for(let Ht=0;Ht<Tt.length;Ht++){const Bt=Tt[Ht],Se=r.convert(Bt.format,Bt.colorSpace),ae=r.convert(Bt.type),we=w(Bt.internalFormat,Se,ae,Bt.colorSpace),Ee=Pt(G);ft&&kt(G)===!1?s.renderbufferStorageMultisample(s.RENDERBUFFER,Ee,we,G.width,G.height):kt(G)?u.renderbufferStorageMultisampleEXT(s.RENDERBUFFER,Ee,we,G.width,G.height):s.renderbufferStorage(s.RENDERBUFFER,we,G.width,G.height)}}s.bindRenderbuffer(s.RENDERBUFFER,null)}function ce($,G){if(G&&G.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(s.FRAMEBUFFER,$),!(G.depthTexture&&G.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const Tt=n.get(G.depthTexture);Tt.__renderTarget=G,(!Tt.__webglTexture||G.depthTexture.image.width!==G.width||G.depthTexture.image.height!==G.height)&&(G.depthTexture.image.width=G.width,G.depthTexture.image.height=G.height,G.depthTexture.needsUpdate=!0),nt(G.depthTexture,0);const Ht=Tt.__webglTexture,Bt=Pt(G);if(G.depthTexture.format===Wd)kt(G)?u.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER,s.DEPTH_ATTACHMENT,s.TEXTURE_2D,Ht,0,Bt):s.framebufferTexture2D(s.FRAMEBUFFER,s.DEPTH_ATTACHMENT,s.TEXTURE_2D,Ht,0);else if(G.depthTexture.format===jd)kt(G)?u.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER,s.DEPTH_STENCIL_ATTACHMENT,s.TEXTURE_2D,Ht,0,Bt):s.framebufferTexture2D(s.FRAMEBUFFER,s.DEPTH_STENCIL_ATTACHMENT,s.TEXTURE_2D,Ht,0);else throw new Error("Unknown depthTexture format")}function Ie($){const G=n.get($),ft=$.isWebGLCubeRenderTarget===!0;if(G.__boundDepthTexture!==$.depthTexture){const Tt=$.depthTexture;if(G.__depthDisposeCallback&&G.__depthDisposeCallback(),Tt){const Ht=()=>{delete G.__boundDepthTexture,delete G.__depthDisposeCallback,Tt.removeEventListener("dispose",Ht)};Tt.addEventListener("dispose",Ht),G.__depthDisposeCallback=Ht}G.__boundDepthTexture=Tt}if($.depthTexture&&!G.__autoAllocateDepthBuffer){if(ft)throw new Error("target.depthTexture not supported in Cube render targets");const Tt=$.texture.mipmaps;Tt&&Tt.length>0?ce(G.__webglFramebuffer[0],$):ce(G.__webglFramebuffer,$)}else if(ft){G.__webglDepthbuffer=[];for(let Tt=0;Tt<6;Tt++)if(e.bindFramebuffer(s.FRAMEBUFFER,G.__webglFramebuffer[Tt]),G.__webglDepthbuffer[Tt]===void 0)G.__webglDepthbuffer[Tt]=s.createRenderbuffer(),Wt(G.__webglDepthbuffer[Tt],$,!1);else{const Ht=$.stencilBuffer?s.DEPTH_STENCIL_ATTACHMENT:s.DEPTH_ATTACHMENT,Bt=G.__webglDepthbuffer[Tt];s.bindRenderbuffer(s.RENDERBUFFER,Bt),s.framebufferRenderbuffer(s.FRAMEBUFFER,Ht,s.RENDERBUFFER,Bt)}}else{const Tt=$.texture.mipmaps;if(Tt&&Tt.length>0?e.bindFramebuffer(s.FRAMEBUFFER,G.__webglFramebuffer[0]):e.bindFramebuffer(s.FRAMEBUFFER,G.__webglFramebuffer),G.__webglDepthbuffer===void 0)G.__webglDepthbuffer=s.createRenderbuffer(),Wt(G.__webglDepthbuffer,$,!1);else{const Ht=$.stencilBuffer?s.DEPTH_STENCIL_ATTACHMENT:s.DEPTH_ATTACHMENT,Bt=G.__webglDepthbuffer;s.bindRenderbuffer(s.RENDERBUFFER,Bt),s.framebufferRenderbuffer(s.FRAMEBUFFER,Ht,s.RENDERBUFFER,Bt)}}e.bindFramebuffer(s.FRAMEBUFFER,null)}function He($,G,ft){const Tt=n.get($);G!==void 0&&qt(Tt.__webglFramebuffer,$,$.texture,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,0),ft!==void 0&&Ie($)}function be($){const G=$.texture,ft=n.get($),Tt=n.get(G);$.addEventListener("dispose",U);const Ht=$.textures,Bt=$.isWebGLCubeRenderTarget===!0,Se=Ht.length>1;if(Se||(Tt.__webglTexture===void 0&&(Tt.__webglTexture=s.createTexture()),Tt.__version=G.version,l.memory.textures++),Bt){ft.__webglFramebuffer=[];for(let ae=0;ae<6;ae++)if(G.mipmaps&&G.mipmaps.length>0){ft.__webglFramebuffer[ae]=[];for(let we=0;we<G.mipmaps.length;we++)ft.__webglFramebuffer[ae][we]=s.createFramebuffer()}else ft.__webglFramebuffer[ae]=s.createFramebuffer()}else{if(G.mipmaps&&G.mipmaps.length>0){ft.__webglFramebuffer=[];for(let ae=0;ae<G.mipmaps.length;ae++)ft.__webglFramebuffer[ae]=s.createFramebuffer()}else ft.__webglFramebuffer=s.createFramebuffer();if(Se)for(let ae=0,we=Ht.length;ae<we;ae++){const Ee=n.get(Ht[ae]);Ee.__webglTexture===void 0&&(Ee.__webglTexture=s.createTexture(),l.memory.textures++)}if($.samples>0&&kt($)===!1){ft.__webglMultisampledFramebuffer=s.createFramebuffer(),ft.__webglColorRenderbuffer=[],e.bindFramebuffer(s.FRAMEBUFFER,ft.__webglMultisampledFramebuffer);for(let ae=0;ae<Ht.length;ae++){const we=Ht[ae];ft.__webglColorRenderbuffer[ae]=s.createRenderbuffer(),s.bindRenderbuffer(s.RENDERBUFFER,ft.__webglColorRenderbuffer[ae]);const Ee=r.convert(we.format,we.colorSpace),Gt=r.convert(we.type),Jt=w(we.internalFormat,Ee,Gt,we.colorSpace,$.isXRRenderTarget===!0),Be=Pt($);s.renderbufferStorageMultisample(s.RENDERBUFFER,Be,Jt,$.width,$.height),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0+ae,s.RENDERBUFFER,ft.__webglColorRenderbuffer[ae])}s.bindRenderbuffer(s.RENDERBUFFER,null),$.depthBuffer&&(ft.__webglDepthRenderbuffer=s.createRenderbuffer(),Wt(ft.__webglDepthRenderbuffer,$,!0)),e.bindFramebuffer(s.FRAMEBUFFER,null)}}if(Bt){e.bindTexture(s.TEXTURE_CUBE_MAP,Tt.__webglTexture),st(s.TEXTURE_CUBE_MAP,G);for(let ae=0;ae<6;ae++)if(G.mipmaps&&G.mipmaps.length>0)for(let we=0;we<G.mipmaps.length;we++)qt(ft.__webglFramebuffer[ae][we],$,G,s.COLOR_ATTACHMENT0,s.TEXTURE_CUBE_MAP_POSITIVE_X+ae,we);else qt(ft.__webglFramebuffer[ae],$,G,s.COLOR_ATTACHMENT0,s.TEXTURE_CUBE_MAP_POSITIVE_X+ae,0);S(G)&&E(s.TEXTURE_CUBE_MAP),e.unbindTexture()}else if(Se){for(let ae=0,we=Ht.length;ae<we;ae++){const Ee=Ht[ae],Gt=n.get(Ee);let Jt=s.TEXTURE_2D;($.isWebGL3DRenderTarget||$.isWebGLArrayRenderTarget)&&(Jt=$.isWebGL3DRenderTarget?s.TEXTURE_3D:s.TEXTURE_2D_ARRAY),e.bindTexture(Jt,Gt.__webglTexture),st(Jt,Ee),qt(ft.__webglFramebuffer,$,Ee,s.COLOR_ATTACHMENT0+ae,Jt,0),S(Ee)&&E(Jt)}e.unbindTexture()}else{let ae=s.TEXTURE_2D;if(($.isWebGL3DRenderTarget||$.isWebGLArrayRenderTarget)&&(ae=$.isWebGL3DRenderTarget?s.TEXTURE_3D:s.TEXTURE_2D_ARRAY),e.bindTexture(ae,Tt.__webglTexture),st(ae,G),G.mipmaps&&G.mipmaps.length>0)for(let we=0;we<G.mipmaps.length;we++)qt(ft.__webglFramebuffer[we],$,G,s.COLOR_ATTACHMENT0,ae,we);else qt(ft.__webglFramebuffer,$,G,s.COLOR_ATTACHMENT0,ae,0);S(G)&&E(ae),e.unbindTexture()}$.depthBuffer&&Ie($)}function zt($){const G=$.textures;for(let ft=0,Tt=G.length;ft<Tt;ft++){const Ht=G[ft];if(S(Ht)){const Bt=B($),Se=n.get(Ht).__webglTexture;e.bindTexture(Bt,Se),E(Bt),e.unbindTexture()}}}const Z=[],Ot=[];function Vt($){if($.samples>0){if(kt($)===!1){const G=$.textures,ft=$.width,Tt=$.height;let Ht=s.COLOR_BUFFER_BIT;const Bt=$.stencilBuffer?s.DEPTH_STENCIL_ATTACHMENT:s.DEPTH_ATTACHMENT,Se=n.get($),ae=G.length>1;if(ae)for(let Ee=0;Ee<G.length;Ee++)e.bindFramebuffer(s.FRAMEBUFFER,Se.__webglMultisampledFramebuffer),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0+Ee,s.RENDERBUFFER,null),e.bindFramebuffer(s.FRAMEBUFFER,Se.__webglFramebuffer),s.framebufferTexture2D(s.DRAW_FRAMEBUFFER,s.COLOR_ATTACHMENT0+Ee,s.TEXTURE_2D,null,0);e.bindFramebuffer(s.READ_FRAMEBUFFER,Se.__webglMultisampledFramebuffer);const we=$.texture.mipmaps;we&&we.length>0?e.bindFramebuffer(s.DRAW_FRAMEBUFFER,Se.__webglFramebuffer[0]):e.bindFramebuffer(s.DRAW_FRAMEBUFFER,Se.__webglFramebuffer);for(let Ee=0;Ee<G.length;Ee++){if($.resolveDepthBuffer&&($.depthBuffer&&(Ht|=s.DEPTH_BUFFER_BIT),$.stencilBuffer&&$.resolveStencilBuffer&&(Ht|=s.STENCIL_BUFFER_BIT)),ae){s.framebufferRenderbuffer(s.READ_FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.RENDERBUFFER,Se.__webglColorRenderbuffer[Ee]);const Gt=n.get(G[Ee]).__webglTexture;s.framebufferTexture2D(s.DRAW_FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,Gt,0)}s.blitFramebuffer(0,0,ft,Tt,0,0,ft,Tt,Ht,s.NEAREST),A===!0&&(Z.length=0,Ot.length=0,Z.push(s.COLOR_ATTACHMENT0+Ee),$.depthBuffer&&$.resolveDepthBuffer===!1&&(Z.push(Bt),Ot.push(Bt),s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER,Ot)),s.invalidateFramebuffer(s.READ_FRAMEBUFFER,Z))}if(e.bindFramebuffer(s.READ_FRAMEBUFFER,null),e.bindFramebuffer(s.DRAW_FRAMEBUFFER,null),ae)for(let Ee=0;Ee<G.length;Ee++){e.bindFramebuffer(s.FRAMEBUFFER,Se.__webglMultisampledFramebuffer),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0+Ee,s.RENDERBUFFER,Se.__webglColorRenderbuffer[Ee]);const Gt=n.get(G[Ee]).__webglTexture;e.bindFramebuffer(s.FRAMEBUFFER,Se.__webglFramebuffer),s.framebufferTexture2D(s.DRAW_FRAMEBUFFER,s.COLOR_ATTACHMENT0+Ee,s.TEXTURE_2D,Gt,0)}e.bindFramebuffer(s.DRAW_FRAMEBUFFER,Se.__webglMultisampledFramebuffer)}else if($.depthBuffer&&$.resolveDepthBuffer===!1&&A){const G=$.stencilBuffer?s.DEPTH_STENCIL_ATTACHMENT:s.DEPTH_ATTACHMENT;s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER,[G])}}}function Pt($){return Math.min(i.maxSamples,$.samples)}function kt($){const G=n.get($);return $.samples>0&&t.has("WEBGL_multisampled_render_to_texture")===!0&&G.__useRenderToTexture!==!1}function Zt($){const G=l.render.frame;m.get($)!==G&&(m.set($,G),$.update())}function $t($,G){const ft=$.colorSpace,Tt=$.format,Ht=$.type;return $.isCompressedTexture===!0||$.isVideoTexture===!0||ft!==Ah&&ft!==Wc&&(Gn.getTransfer(ft)===ui?(Tt!==Ki||Ht!==ea)&&ge("WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):nn("WebGLTextures: Unsupported texture color space:",ft)),G}function fe($){return typeof HTMLImageElement<"u"&&$ instanceof HTMLImageElement?(d.width=$.naturalWidth||$.width,d.height=$.naturalHeight||$.height):typeof VideoFrame<"u"&&$ instanceof VideoFrame?(d.width=$.displayWidth,d.height=$.displayHeight):(d.width=$.width,d.height=$.height),d}this.allocateTextureUnit=W,this.resetTextureUnits=Y,this.setTexture2D=nt,this.setTexture2DArray=H,this.setTexture3D=tt,this.setTextureCube=it,this.rebindTextures=He,this.setupRenderTarget=be,this.updateRenderTargetMipmap=zt,this.updateMultisampleRenderTarget=Vt,this.setupDepthRenderbuffer=Ie,this.setupFrameBufferTexture=qt,this.useMultisampledRTT=kt}function r3(s,t){function e(n,i=Wc){let r;const l=Gn.getTransfer(i);if(n===ea)return s.UNSIGNED_BYTE;if(n===uE)return s.UNSIGNED_SHORT_4_4_4_4;if(n===hE)return s.UNSIGNED_SHORT_5_5_5_1;if(n===pS)return s.UNSIGNED_INT_5_9_9_9_REV;if(n===gS)return s.UNSIGNED_INT_10F_11F_11F_REV;if(n===AS)return s.BYTE;if(n===dS)return s.SHORT;if(n===Jd)return s.UNSIGNED_SHORT;if(n===cE)return s.INT;if(n===Ca)return s.UNSIGNED_INT;if(n===xr)return s.FLOAT;if(n===$f)return s.HALF_FLOAT;if(n===mS)return s.ALPHA;if(n===yS)return s.RGB;if(n===Ki)return s.RGBA;if(n===Wd)return s.DEPTH_COMPONENT;if(n===jd)return s.DEPTH_STENCIL;if(n===fE)return s.RED;if(n===i0)return s.RED_INTEGER;if(n===AE)return s.RG;if(n===s0)return s.RG_INTEGER;if(n===sc)return s.RGBA_INTEGER;if(n===ym||n===xm||n===vm||n===Em)if(l===ui)if(r=t.get("WEBGL_compressed_texture_s3tc_srgb"),r!==null){if(n===ym)return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===xm)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===vm)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===Em)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(r=t.get("WEBGL_compressed_texture_s3tc"),r!==null){if(n===ym)return r.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===xm)return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===vm)return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===Em)return r.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(n===xv||n===vv||n===Ev||n===_v)if(r=t.get("WEBGL_compressed_texture_pvrtc"),r!==null){if(n===xv)return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===vv)return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===Ev)return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===_v)return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(n===Cv||n===bv||n===Sv)if(r=t.get("WEBGL_compressed_texture_etc"),r!==null){if(n===Cv||n===bv)return l===ui?r.COMPRESSED_SRGB8_ETC2:r.COMPRESSED_RGB8_ETC2;if(n===Sv)return l===ui?r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:r.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(n===Iv||n===Bv||n===Mv||n===wv||n===Tv||n===Qv||n===Dv||n===Rv||n===Nv||n===Uv||n===Lv||n===zv||n===Ov||n===Fv)if(r=t.get("WEBGL_compressed_texture_astc"),r!==null){if(n===Iv)return l===ui?r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:r.COMPRESSED_RGBA_ASTC_4x4_KHR;if(n===Bv)return l===ui?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:r.COMPRESSED_RGBA_ASTC_5x4_KHR;if(n===Mv)return l===ui?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:r.COMPRESSED_RGBA_ASTC_5x5_KHR;if(n===wv)return l===ui?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:r.COMPRESSED_RGBA_ASTC_6x5_KHR;if(n===Tv)return l===ui?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:r.COMPRESSED_RGBA_ASTC_6x6_KHR;if(n===Qv)return l===ui?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:r.COMPRESSED_RGBA_ASTC_8x5_KHR;if(n===Dv)return l===ui?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:r.COMPRESSED_RGBA_ASTC_8x6_KHR;if(n===Rv)return l===ui?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:r.COMPRESSED_RGBA_ASTC_8x8_KHR;if(n===Nv)return l===ui?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:r.COMPRESSED_RGBA_ASTC_10x5_KHR;if(n===Uv)return l===ui?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:r.COMPRESSED_RGBA_ASTC_10x6_KHR;if(n===Lv)return l===ui?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:r.COMPRESSED_RGBA_ASTC_10x8_KHR;if(n===zv)return l===ui?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:r.COMPRESSED_RGBA_ASTC_10x10_KHR;if(n===Ov)return l===ui?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:r.COMPRESSED_RGBA_ASTC_12x10_KHR;if(n===Fv)return l===ui?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:r.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(n===Pv||n===Gv||n===kv)if(r=t.get("EXT_texture_compression_bptc"),r!==null){if(n===Pv)return l===ui?r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:r.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(n===Gv)return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(n===kv)return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(n===Hv||n===Vv||n===Yv||n===qv)if(r=t.get("EXT_texture_compression_rgtc"),r!==null){if(n===Hv)return r.COMPRESSED_RED_RGTC1_EXT;if(n===Vv)return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(n===Yv)return r.COMPRESSED_RED_GREEN_RGTC2_EXT;if(n===qv)return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return n===Zd?s.UNSIGNED_INT_24_8:s[n]!==void 0?s[n]:null}return{convert:e}}const kO=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,HO=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class VO{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(t,e){if(this.texture===null){const n=new LS(t.texture);(t.depthNear!==e.depthNear||t.depthFar!==e.depthFar)&&(this.depthNear=t.depthNear,this.depthFar=t.depthFar),this.texture=n}}getMesh(t){if(this.texture!==null&&this.mesh===null){const e=t.cameras[0].viewport,n=new $a({vertexShader:kO,fragmentShader:HO,uniforms:{depthColor:{value:this.texture},depthWidth:{value:e.z},depthHeight:{value:e.w}}});this.mesh=new oe(new kr(20,20),n)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class YO extends rc{constructor(t,e){super();const n=this;let i=null,r=1,l=null,u="local-floor",A=1,d=null,m=null,g=null,y=null,v=null,C=null;const I=typeof XRWebGLBinding<"u",S=new VO,E={},B=e.getContextAttributes();let w=null,Q=null;const R=[],D=[],U=new Dt;let P=null;const z=new As;z.viewport=new We;const L=new As;L.viewport=new We;const k=[z,L],Y=new Zw;let W=null,K=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(dt){let pt=R[dt];return pt===void 0&&(pt=new iv,R[dt]=pt),pt.getTargetRaySpace()},this.getControllerGrip=function(dt){let pt=R[dt];return pt===void 0&&(pt=new iv,R[dt]=pt),pt.getGripSpace()},this.getHand=function(dt){let pt=R[dt];return pt===void 0&&(pt=new iv,R[dt]=pt),pt.getHandSpace()};function nt(dt){const pt=D.indexOf(dt.inputSource);if(pt===-1)return;const qt=R[pt];qt!==void 0&&(qt.update(dt.inputSource,dt.frame,d||l),qt.dispatchEvent({type:dt.type,data:dt.inputSource}))}function H(){i.removeEventListener("select",nt),i.removeEventListener("selectstart",nt),i.removeEventListener("selectend",nt),i.removeEventListener("squeeze",nt),i.removeEventListener("squeezestart",nt),i.removeEventListener("squeezeend",nt),i.removeEventListener("end",H),i.removeEventListener("inputsourceschange",tt);for(let dt=0;dt<R.length;dt++){const pt=D[dt];pt!==null&&(D[dt]=null,R[dt].disconnect(pt))}W=null,K=null,S.reset();for(const dt in E)delete E[dt];t.setRenderTarget(w),v=null,y=null,g=null,i=null,Q=null,Rt.stop(),n.isPresenting=!1,t.setPixelRatio(P),t.setSize(U.width,U.height,!1),n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(dt){r=dt,n.isPresenting===!0&&ge("WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(dt){u=dt,n.isPresenting===!0&&ge("WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return d||l},this.setReferenceSpace=function(dt){d=dt},this.getBaseLayer=function(){return y!==null?y:v},this.getBinding=function(){return g===null&&I&&(g=new XRWebGLBinding(i,e)),g},this.getFrame=function(){return C},this.getSession=function(){return i},this.setSession=async function(dt){if(i=dt,i!==null){if(w=t.getRenderTarget(),i.addEventListener("select",nt),i.addEventListener("selectstart",nt),i.addEventListener("selectend",nt),i.addEventListener("squeeze",nt),i.addEventListener("squeezestart",nt),i.addEventListener("squeezeend",nt),i.addEventListener("end",H),i.addEventListener("inputsourceschange",tt),B.xrCompatible!==!0&&await e.makeXRCompatible(),P=t.getPixelRatio(),t.getSize(U),I&&"createProjectionLayer"in XRWebGLBinding.prototype){let qt=null,Wt=null,ce=null;B.depth&&(ce=B.stencil?e.DEPTH24_STENCIL8:e.DEPTH_COMPONENT24,qt=B.stencil?jd:Wd,Wt=B.stencil?Zd:Ca);const Ie={colorFormat:e.RGBA8,depthFormat:ce,scaleFactor:r};g=this.getBinding(),y=g.createProjectionLayer(Ie),i.updateRenderState({layers:[y]}),t.setPixelRatio(1),t.setSize(y.textureWidth,y.textureHeight,!1),Q=new Io(y.textureWidth,y.textureHeight,{format:Ki,type:ea,depthTexture:new US(y.textureWidth,y.textureHeight,Wt,void 0,void 0,void 0,void 0,void 0,void 0,qt),stencilBuffer:B.stencil,colorSpace:t.outputColorSpace,samples:B.antialias?4:0,resolveDepthBuffer:y.ignoreDepthValues===!1,resolveStencilBuffer:y.ignoreDepthValues===!1})}else{const qt={antialias:B.antialias,alpha:!0,depth:B.depth,stencil:B.stencil,framebufferScaleFactor:r};v=new XRWebGLLayer(i,e,qt),i.updateRenderState({baseLayer:v}),t.setPixelRatio(1),t.setSize(v.framebufferWidth,v.framebufferHeight,!1),Q=new Io(v.framebufferWidth,v.framebufferHeight,{format:Ki,type:ea,colorSpace:t.outputColorSpace,stencilBuffer:B.stencil,resolveDepthBuffer:v.ignoreDepthValues===!1,resolveStencilBuffer:v.ignoreDepthValues===!1})}Q.isXRRenderTarget=!0,this.setFoveation(A),d=null,l=await i.requestReferenceSpace(u),Rt.setContext(i),Rt.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(i!==null)return i.environmentBlendMode},this.getDepthTexture=function(){return S.getDepthTexture()};function tt(dt){for(let pt=0;pt<dt.removed.length;pt++){const qt=dt.removed[pt],Wt=D.indexOf(qt);Wt>=0&&(D[Wt]=null,R[Wt].disconnect(qt))}for(let pt=0;pt<dt.added.length;pt++){const qt=dt.added[pt];let Wt=D.indexOf(qt);if(Wt===-1){for(let Ie=0;Ie<R.length;Ie++)if(Ie>=D.length){D.push(qt),Wt=Ie;break}else if(D[Ie]===null){D[Ie]=qt,Wt=Ie;break}if(Wt===-1)break}const ce=R[Wt];ce&&ce.connect(qt)}}const it=new F,ot=new F;function At(dt,pt,qt){it.setFromMatrixPosition(pt.matrixWorld),ot.setFromMatrixPosition(qt.matrixWorld);const Wt=it.distanceTo(ot),ce=pt.projectionMatrix.elements,Ie=qt.projectionMatrix.elements,He=ce[14]/(ce[10]-1),be=ce[14]/(ce[10]+1),zt=(ce[9]+1)/ce[5],Z=(ce[9]-1)/ce[5],Ot=(ce[8]-1)/ce[0],Vt=(Ie[8]+1)/Ie[0],Pt=He*Ot,kt=He*Vt,Zt=Wt/(-Ot+Vt),$t=Zt*-Ot;if(pt.matrixWorld.decompose(dt.position,dt.quaternion,dt.scale),dt.translateX($t),dt.translateZ(Zt),dt.matrixWorld.compose(dt.position,dt.quaternion,dt.scale),dt.matrixWorldInverse.copy(dt.matrixWorld).invert(),ce[10]===-1)dt.projectionMatrix.copy(pt.projectionMatrix),dt.projectionMatrixInverse.copy(pt.projectionMatrixInverse);else{const fe=He+Zt,$=be+Zt,G=Pt-$t,ft=kt+(Wt-$t),Tt=zt*be/$*fe,Ht=Z*be/$*fe;dt.projectionMatrix.makePerspective(G,ft,Tt,Ht,fe,$),dt.projectionMatrixInverse.copy(dt.projectionMatrix).invert()}}function V(dt,pt){pt===null?dt.matrixWorld.copy(dt.matrix):dt.matrixWorld.multiplyMatrices(pt.matrixWorld,dt.matrix),dt.matrixWorldInverse.copy(dt.matrixWorld).invert()}this.updateCamera=function(dt){if(i===null)return;let pt=dt.near,qt=dt.far;S.texture!==null&&(S.depthNear>0&&(pt=S.depthNear),S.depthFar>0&&(qt=S.depthFar)),Y.near=L.near=z.near=pt,Y.far=L.far=z.far=qt,(W!==Y.near||K!==Y.far)&&(i.updateRenderState({depthNear:Y.near,depthFar:Y.far}),W=Y.near,K=Y.far),Y.layers.mask=dt.layers.mask|6,z.layers.mask=Y.layers.mask&3,L.layers.mask=Y.layers.mask&5;const Wt=dt.parent,ce=Y.cameras;V(Y,Wt);for(let Ie=0;Ie<ce.length;Ie++)V(ce[Ie],Wt);ce.length===2?At(Y,z,L):Y.projectionMatrix.copy(z.projectionMatrix),st(dt,Y,Wt)};function st(dt,pt,qt){qt===null?dt.matrix.copy(pt.matrixWorld):(dt.matrix.copy(qt.matrixWorld),dt.matrix.invert(),dt.matrix.multiply(pt.matrixWorld)),dt.matrix.decompose(dt.position,dt.quaternion,dt.scale),dt.updateMatrixWorld(!0),dt.projectionMatrix.copy(pt.projectionMatrix),dt.projectionMatrixInverse.copy(pt.projectionMatrixInverse),dt.isPerspectiveCamera&&(dt.fov=tp*2*Math.atan(1/dt.projectionMatrix.elements[5]),dt.zoom=1)}this.getCamera=function(){return Y},this.getFoveation=function(){if(!(y===null&&v===null))return A},this.setFoveation=function(dt){A=dt,y!==null&&(y.fixedFoveation=dt),v!==null&&v.fixedFoveation!==void 0&&(v.fixedFoveation=dt)},this.hasDepthSensing=function(){return S.texture!==null},this.getDepthSensingMesh=function(){return S.getMesh(Y)},this.getCameraTexture=function(dt){return E[dt]};let xt=null;function j(dt,pt){if(m=pt.getViewerPose(d||l),C=pt,m!==null){const qt=m.views;v!==null&&(t.setRenderTargetFramebuffer(Q,v.framebuffer),t.setRenderTarget(Q));let Wt=!1;qt.length!==Y.cameras.length&&(Y.cameras.length=0,Wt=!0);for(let be=0;be<qt.length;be++){const zt=qt[be];let Z=null;if(v!==null)Z=v.getViewport(zt);else{const Vt=g.getViewSubImage(y,zt);Z=Vt.viewport,be===0&&(t.setRenderTargetTextures(Q,Vt.colorTexture,Vt.depthStencilTexture),t.setRenderTarget(Q))}let Ot=k[be];Ot===void 0&&(Ot=new As,Ot.layers.enable(be),Ot.viewport=new We,k[be]=Ot),Ot.matrix.fromArray(zt.transform.matrix),Ot.matrix.decompose(Ot.position,Ot.quaternion,Ot.scale),Ot.projectionMatrix.fromArray(zt.projectionMatrix),Ot.projectionMatrixInverse.copy(Ot.projectionMatrix).invert(),Ot.viewport.set(Z.x,Z.y,Z.width,Z.height),be===0&&(Y.matrix.copy(Ot.matrix),Y.matrix.decompose(Y.position,Y.quaternion,Y.scale)),Wt===!0&&Y.cameras.push(Ot)}const ce=i.enabledFeatures;if(ce&&ce.includes("depth-sensing")&&i.depthUsage=="gpu-optimized"&&I){g=n.getBinding();const be=g.getDepthInformation(qt[0]);be&&be.isValid&&be.texture&&S.init(be,i.renderState)}if(ce&&ce.includes("camera-access")&&I){t.state.unbindTexture(),g=n.getBinding();for(let be=0;be<qt.length;be++){const zt=qt[be].camera;if(zt){let Z=E[zt];Z||(Z=new LS,E[zt]=Z);const Ot=g.getCameraImage(zt);Z.sourceTexture=Ot}}}}for(let qt=0;qt<R.length;qt++){const Wt=D[qt],ce=R[qt];Wt!==null&&ce!==void 0&&ce.update(Wt,pt,d||l)}xt&&xt(dt,pt),pt.detectedPlanes&&n.dispatchEvent({type:"planesdetected",data:pt}),C=null}const Rt=new e3;Rt.setAnimationLoop(j),this.setAnimationLoop=function(dt){xt=dt},this.dispose=function(){}}}const xf=new _r,qO=new he;function XO(s,t){function e(S,E){S.matrixAutoUpdate===!0&&S.updateMatrix(),E.value.copy(S.matrix)}function n(S,E){E.color.getRGB(S.fogColor.value,lw(s)),E.isFog?(S.fogNear.value=E.near,S.fogFar.value=E.far):E.isFogExp2&&(S.fogDensity.value=E.density)}function i(S,E,B,w,Q){E.isMeshBasicMaterial||E.isMeshLambertMaterial?r(S,E):E.isMeshToonMaterial?(r(S,E),g(S,E)):E.isMeshPhongMaterial?(r(S,E),m(S,E)):E.isMeshStandardMaterial?(r(S,E),y(S,E),E.isMeshPhysicalMaterial&&v(S,E,Q)):E.isMeshMatcapMaterial?(r(S,E),C(S,E)):E.isMeshDepthMaterial?r(S,E):E.isMeshDistanceMaterial?(r(S,E),I(S,E)):E.isMeshNormalMaterial?r(S,E):E.isLineBasicMaterial?(l(S,E),E.isLineDashedMaterial&&u(S,E)):E.isPointsMaterial?A(S,E,B,w):E.isSpriteMaterial?d(S,E):E.isShadowMaterial?(S.color.value.copy(E.color),S.opacity.value=E.opacity):E.isShaderMaterial&&(E.uniformsNeedUpdate=!1)}function r(S,E){S.opacity.value=E.opacity,E.color&&S.diffuse.value.copy(E.color),E.emissive&&S.emissive.value.copy(E.emissive).multiplyScalar(E.emissiveIntensity),E.map&&(S.map.value=E.map,e(E.map,S.mapTransform)),E.alphaMap&&(S.alphaMap.value=E.alphaMap,e(E.alphaMap,S.alphaMapTransform)),E.bumpMap&&(S.bumpMap.value=E.bumpMap,e(E.bumpMap,S.bumpMapTransform),S.bumpScale.value=E.bumpScale,E.side===_a&&(S.bumpScale.value*=-1)),E.normalMap&&(S.normalMap.value=E.normalMap,e(E.normalMap,S.normalMapTransform),S.normalScale.value.copy(E.normalScale),E.side===_a&&S.normalScale.value.negate()),E.displacementMap&&(S.displacementMap.value=E.displacementMap,e(E.displacementMap,S.displacementMapTransform),S.displacementScale.value=E.displacementScale,S.displacementBias.value=E.displacementBias),E.emissiveMap&&(S.emissiveMap.value=E.emissiveMap,e(E.emissiveMap,S.emissiveMapTransform)),E.specularMap&&(S.specularMap.value=E.specularMap,e(E.specularMap,S.specularMapTransform)),E.alphaTest>0&&(S.alphaTest.value=E.alphaTest);const B=t.get(E),w=B.envMap,Q=B.envMapRotation;w&&(S.envMap.value=w,xf.copy(Q),xf.x*=-1,xf.y*=-1,xf.z*=-1,w.isCubeTexture&&w.isRenderTargetTexture===!1&&(xf.y*=-1,xf.z*=-1),S.envMapRotation.value.setFromMatrix4(qO.makeRotationFromEuler(xf)),S.flipEnvMap.value=w.isCubeTexture&&w.isRenderTargetTexture===!1?-1:1,S.reflectivity.value=E.reflectivity,S.ior.value=E.ior,S.refractionRatio.value=E.refractionRatio),E.lightMap&&(S.lightMap.value=E.lightMap,S.lightMapIntensity.value=E.lightMapIntensity,e(E.lightMap,S.lightMapTransform)),E.aoMap&&(S.aoMap.value=E.aoMap,S.aoMapIntensity.value=E.aoMapIntensity,e(E.aoMap,S.aoMapTransform))}function l(S,E){S.diffuse.value.copy(E.color),S.opacity.value=E.opacity,E.map&&(S.map.value=E.map,e(E.map,S.mapTransform))}function u(S,E){S.dashSize.value=E.dashSize,S.totalSize.value=E.dashSize+E.gapSize,S.scale.value=E.scale}function A(S,E,B,w){S.diffuse.value.copy(E.color),S.opacity.value=E.opacity,S.size.value=E.size*B,S.scale.value=w*.5,E.map&&(S.map.value=E.map,e(E.map,S.uvTransform)),E.alphaMap&&(S.alphaMap.value=E.alphaMap,e(E.alphaMap,S.alphaMapTransform)),E.alphaTest>0&&(S.alphaTest.value=E.alphaTest)}function d(S,E){S.diffuse.value.copy(E.color),S.opacity.value=E.opacity,S.rotation.value=E.rotation,E.map&&(S.map.value=E.map,e(E.map,S.mapTransform)),E.alphaMap&&(S.alphaMap.value=E.alphaMap,e(E.alphaMap,S.alphaMapTransform)),E.alphaTest>0&&(S.alphaTest.value=E.alphaTest)}function m(S,E){S.specular.value.copy(E.specular),S.shininess.value=Math.max(E.shininess,1e-4)}function g(S,E){E.gradientMap&&(S.gradientMap.value=E.gradientMap)}function y(S,E){S.metalness.value=E.metalness,E.metalnessMap&&(S.metalnessMap.value=E.metalnessMap,e(E.metalnessMap,S.metalnessMapTransform)),S.roughness.value=E.roughness,E.roughnessMap&&(S.roughnessMap.value=E.roughnessMap,e(E.roughnessMap,S.roughnessMapTransform)),E.envMap&&(S.envMapIntensity.value=E.envMapIntensity)}function v(S,E,B){S.ior.value=E.ior,E.sheen>0&&(S.sheenColor.value.copy(E.sheenColor).multiplyScalar(E.sheen),S.sheenRoughness.value=E.sheenRoughness,E.sheenColorMap&&(S.sheenColorMap.value=E.sheenColorMap,e(E.sheenColorMap,S.sheenColorMapTransform)),E.sheenRoughnessMap&&(S.sheenRoughnessMap.value=E.sheenRoughnessMap,e(E.sheenRoughnessMap,S.sheenRoughnessMapTransform))),E.clearcoat>0&&(S.clearcoat.value=E.clearcoat,S.clearcoatRoughness.value=E.clearcoatRoughness,E.clearcoatMap&&(S.clearcoatMap.value=E.clearcoatMap,e(E.clearcoatMap,S.clearcoatMapTransform)),E.clearcoatRoughnessMap&&(S.clearcoatRoughnessMap.value=E.clearcoatRoughnessMap,e(E.clearcoatRoughnessMap,S.clearcoatRoughnessMapTransform)),E.clearcoatNormalMap&&(S.clearcoatNormalMap.value=E.clearcoatNormalMap,e(E.clearcoatNormalMap,S.clearcoatNormalMapTransform),S.clearcoatNormalScale.value.copy(E.clearcoatNormalScale),E.side===_a&&S.clearcoatNormalScale.value.negate())),E.dispersion>0&&(S.dispersion.value=E.dispersion),E.iridescence>0&&(S.iridescence.value=E.iridescence,S.iridescenceIOR.value=E.iridescenceIOR,S.iridescenceThicknessMinimum.value=E.iridescenceThicknessRange[0],S.iridescenceThicknessMaximum.value=E.iridescenceThicknessRange[1],E.iridescenceMap&&(S.iridescenceMap.value=E.iridescenceMap,e(E.iridescenceMap,S.iridescenceMapTransform)),E.iridescenceThicknessMap&&(S.iridescenceThicknessMap.value=E.iridescenceThicknessMap,e(E.iridescenceThicknessMap,S.iridescenceThicknessMapTransform))),E.transmission>0&&(S.transmission.value=E.transmission,S.transmissionSamplerMap.value=B.texture,S.transmissionSamplerSize.value.set(B.width,B.height),E.transmissionMap&&(S.transmissionMap.value=E.transmissionMap,e(E.transmissionMap,S.transmissionMapTransform)),S.thickness.value=E.thickness,E.thicknessMap&&(S.thicknessMap.value=E.thicknessMap,e(E.thicknessMap,S.thicknessMapTransform)),S.attenuationDistance.value=E.attenuationDistance,S.attenuationColor.value.copy(E.attenuationColor)),E.anisotropy>0&&(S.anisotropyVector.value.set(E.anisotropy*Math.cos(E.anisotropyRotation),E.anisotropy*Math.sin(E.anisotropyRotation)),E.anisotropyMap&&(S.anisotropyMap.value=E.anisotropyMap,e(E.anisotropyMap,S.anisotropyMapTransform))),S.specularIntensity.value=E.specularIntensity,S.specularColor.value.copy(E.specularColor),E.specularColorMap&&(S.specularColorMap.value=E.specularColorMap,e(E.specularColorMap,S.specularColorMapTransform)),E.specularIntensityMap&&(S.specularIntensityMap.value=E.specularIntensityMap,e(E.specularIntensityMap,S.specularIntensityMapTransform))}function C(S,E){E.matcap&&(S.matcap.value=E.matcap)}function I(S,E){const B=t.get(E).light;S.referencePosition.value.setFromMatrixPosition(B.matrixWorld),S.nearDistance.value=B.shadow.camera.near,S.farDistance.value=B.shadow.camera.far}return{refreshFogUniforms:n,refreshMaterialUniforms:i}}function JO(s,t,e,n){let i={},r={},l=[];const u=s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);function A(B,w){const Q=w.program;n.uniformBlockBinding(B,Q)}function d(B,w){let Q=i[B.id];Q===void 0&&(C(B),Q=m(B),i[B.id]=Q,B.addEventListener("dispose",S));const R=w.program;n.updateUBOMapping(B,R);const D=t.render.frame;r[B.id]!==D&&(y(B),r[B.id]=D)}function m(B){const w=g();B.__bindingPointIndex=w;const Q=s.createBuffer(),R=B.__size,D=B.usage;return s.bindBuffer(s.UNIFORM_BUFFER,Q),s.bufferData(s.UNIFORM_BUFFER,R,D),s.bindBuffer(s.UNIFORM_BUFFER,null),s.bindBufferBase(s.UNIFORM_BUFFER,w,Q),Q}function g(){for(let B=0;B<u;B++)if(l.indexOf(B)===-1)return l.push(B),B;return nn("WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function y(B){const w=i[B.id],Q=B.uniforms,R=B.__cache;s.bindBuffer(s.UNIFORM_BUFFER,w);for(let D=0,U=Q.length;D<U;D++){const P=Array.isArray(Q[D])?Q[D]:[Q[D]];for(let z=0,L=P.length;z<L;z++){const k=P[z];if(v(k,D,z,R)===!0){const Y=k.__offset,W=Array.isArray(k.value)?k.value:[k.value];let K=0;for(let nt=0;nt<W.length;nt++){const H=W[nt],tt=I(H);typeof H=="number"||typeof H=="boolean"?(k.__data[0]=H,s.bufferSubData(s.UNIFORM_BUFFER,Y+K,k.__data)):H.isMatrix3?(k.__data[0]=H.elements[0],k.__data[1]=H.elements[1],k.__data[2]=H.elements[2],k.__data[3]=0,k.__data[4]=H.elements[3],k.__data[5]=H.elements[4],k.__data[6]=H.elements[5],k.__data[7]=0,k.__data[8]=H.elements[6],k.__data[9]=H.elements[7],k.__data[10]=H.elements[8],k.__data[11]=0):(H.toArray(k.__data,K),K+=tt.storage/Float32Array.BYTES_PER_ELEMENT)}s.bufferSubData(s.UNIFORM_BUFFER,Y,k.__data)}}}s.bindBuffer(s.UNIFORM_BUFFER,null)}function v(B,w,Q,R){const D=B.value,U=w+"_"+Q;if(R[U]===void 0)return typeof D=="number"||typeof D=="boolean"?R[U]=D:R[U]=D.clone(),!0;{const P=R[U];if(typeof D=="number"||typeof D=="boolean"){if(P!==D)return R[U]=D,!0}else if(P.equals(D)===!1)return P.copy(D),!0}return!1}function C(B){const w=B.uniforms;let Q=0;const R=16;for(let U=0,P=w.length;U<P;U++){const z=Array.isArray(w[U])?w[U]:[w[U]];for(let L=0,k=z.length;L<k;L++){const Y=z[L],W=Array.isArray(Y.value)?Y.value:[Y.value];for(let K=0,nt=W.length;K<nt;K++){const H=W[K],tt=I(H),it=Q%R,ot=it%tt.boundary,At=it+ot;Q+=ot,At!==0&&R-At<tt.storage&&(Q+=R-At),Y.__data=new Float32Array(tt.storage/Float32Array.BYTES_PER_ELEMENT),Y.__offset=Q,Q+=tt.storage}}}const D=Q%R;return D>0&&(Q+=R-D),B.__size=Q,B.__cache={},this}function I(B){const w={boundary:0,storage:0};return typeof B=="number"||typeof B=="boolean"?(w.boundary=4,w.storage=4):B.isVector2?(w.boundary=8,w.storage=8):B.isVector3||B.isColor?(w.boundary=16,w.storage=12):B.isVector4?(w.boundary=16,w.storage=16):B.isMatrix3?(w.boundary=48,w.storage=48):B.isMatrix4?(w.boundary=64,w.storage=64):B.isTexture?ge("WebGLRenderer: Texture samplers can not be part of an uniforms group."):ge("WebGLRenderer: Unsupported uniform value type.",B),w}function S(B){const w=B.target;w.removeEventListener("dispose",S);const Q=l.indexOf(w.__bindingPointIndex);l.splice(Q,1),s.deleteBuffer(i[w.id]),delete i[w.id],delete r[w.id]}function E(){for(const B in i)s.deleteBuffer(i[B]);l=[],i={},r={}}return{bind:A,update:d,dispose:E}}const ZO=new Uint16Array([11481,15204,11534,15171,11808,15015,12385,14843,12894,14716,13396,14600,13693,14483,13976,14366,14237,14171,14405,13961,14511,13770,14605,13598,14687,13444,14760,13305,14822,13066,14876,12857,14923,12675,14963,12517,14997,12379,15025,12230,15049,12023,15070,11843,15086,11687,15100,11551,15111,11433,15120,11330,15127,11217,15132,11060,15135,10922,15138,10801,15139,10695,15139,10600,13012,14923,13020,14917,13064,14886,13176,14800,13349,14666,13513,14526,13724,14398,13960,14230,14200,14020,14383,13827,14488,13651,14583,13491,14667,13348,14740,13132,14803,12908,14856,12713,14901,12542,14938,12394,14968,12241,14992,12017,15010,11822,15024,11654,15034,11507,15041,11380,15044,11269,15044,11081,15042,10913,15037,10764,15031,10635,15023,10520,15014,10419,15003,10330,13657,14676,13658,14673,13670,14660,13698,14622,13750,14547,13834,14442,13956,14317,14112,14093,14291,13889,14407,13704,14499,13538,14586,13389,14664,13201,14733,12966,14792,12758,14842,12577,14882,12418,14915,12272,14940,12033,14959,11826,14972,11646,14980,11490,14983,11355,14983,11212,14979,11008,14971,10830,14961,10675,14950,10540,14936,10420,14923,10315,14909,10204,14894,10041,14089,14460,14090,14459,14096,14452,14112,14431,14141,14388,14186,14305,14252,14130,14341,13941,14399,13756,14467,13585,14539,13430,14610,13272,14677,13026,14737,12808,14790,12617,14833,12449,14869,12303,14896,12065,14916,11845,14929,11655,14937,11490,14939,11347,14936,11184,14930,10970,14921,10783,14912,10621,14900,10480,14885,10356,14867,10247,14848,10062,14827,9894,14805,9745,14400,14208,14400,14206,14402,14198,14406,14174,14415,14122,14427,14035,14444,13913,14469,13767,14504,13613,14548,13463,14598,13324,14651,13082,14704,12858,14752,12658,14795,12483,14831,12330,14860,12106,14881,11875,14895,11675,14903,11501,14905,11351,14903,11178,14900,10953,14892,10757,14880,10589,14865,10442,14847,10313,14827,10162,14805,9965,14782,9792,14757,9642,14731,9507,14562,13883,14562,13883,14563,13877,14566,13862,14570,13830,14576,13773,14584,13689,14595,13582,14613,13461,14637,13336,14668,13120,14704,12897,14741,12695,14776,12516,14808,12358,14835,12150,14856,11910,14870,11701,14878,11519,14882,11361,14884,11187,14880,10951,14871,10748,14858,10572,14842,10418,14823,10286,14801,10099,14777,9897,14751,9722,14725,9567,14696,9430,14666,9309,14702,13604,14702,13604,14702,13600,14703,13591,14705,13570,14707,13533,14709,13477,14712,13400,14718,13305,14727,13106,14743,12907,14762,12716,14784,12539,14807,12380,14827,12190,14844,11943,14855,11727,14863,11539,14870,11376,14871,11204,14868,10960,14858,10748,14845,10565,14829,10406,14809,10269,14786,10058,14761,9852,14734,9671,14705,9512,14674,9374,14641,9253,14608,9076,14821,13366,14821,13365,14821,13364,14821,13358,14821,13344,14821,13320,14819,13252,14817,13145,14815,13011,14814,12858,14817,12698,14823,12539,14832,12389,14841,12214,14850,11968,14856,11750,14861,11558,14866,11390,14867,11226,14862,10972,14853,10754,14840,10565,14823,10401,14803,10259,14780,10032,14754,9820,14725,9635,14694,9473,14661,9333,14627,9203,14593,8988,14557,8798,14923,13014,14922,13014,14922,13012,14922,13004,14920,12987,14919,12957,14915,12907,14909,12834,14902,12738,14894,12623,14888,12498,14883,12370,14880,12203,14878,11970,14875,11759,14873,11569,14874,11401,14872,11243,14865,10986,14855,10762,14842,10568,14825,10401,14804,10255,14781,10017,14754,9799,14725,9611,14692,9445,14658,9301,14623,9139,14587,8920,14548,8729,14509,8562,15008,12672,15008,12672,15008,12671,15007,12667,15005,12656,15001,12637,14997,12605,14989,12556,14978,12490,14966,12407,14953,12313,14940,12136,14927,11934,14914,11742,14903,11563,14896,11401,14889,11247,14879,10992,14866,10767,14851,10570,14833,10400,14812,10252,14789,10007,14761,9784,14731,9592,14698,9424,14663,9279,14627,9088,14588,8868,14548,8676,14508,8508,14467,8360,15080,12386,15080,12386,15079,12385,15078,12383,15076,12378,15072,12367,15066,12347,15057,12315,15045,12253,15030,12138,15012,11998,14993,11845,14972,11685,14951,11530,14935,11383,14920,11228,14904,10981,14887,10762,14870,10567,14850,10397,14827,10248,14803,9997,14774,9771,14743,9578,14710,9407,14674,9259,14637,9048,14596,8826,14555,8632,14514,8464,14471,8317,14427,8182,15139,12008,15139,12008,15138,12008,15137,12007,15135,12003,15130,11990,15124,11969,15115,11929,15102,11872,15086,11794,15064,11693,15041,11581,15013,11459,14987,11336,14966,11170,14944,10944,14921,10738,14898,10552,14875,10387,14850,10239,14824,9983,14794,9758,14762,9563,14728,9392,14692,9244,14653,9014,14611,8791,14569,8597,14526,8427,14481,8281,14436,8110,14391,7885,15188,11617,15188,11617,15187,11617,15186,11618,15183,11617,15179,11612,15173,11601,15163,11581,15150,11546,15133,11495,15110,11427,15083,11346,15051,11246,15024,11057,14996,10868,14967,10687,14938,10517,14911,10362,14882,10206,14853,9956,14821,9737,14787,9543,14752,9375,14715,9228,14675,8980,14632,8760,14589,8565,14544,8395,14498,8248,14451,8049,14404,7824,14357,7630,15228,11298,15228,11298,15227,11299,15226,11301,15223,11303,15219,11302,15213,11299,15204,11290,15191,11271,15174,11217,15150,11129,15119,11015,15087,10886,15057,10744,15024,10599,14990,10455,14957,10318,14924,10143,14891,9911,14856,9701,14820,9516,14782,9352,14744,9200,14703,8946,14659,8725,14615,8533,14568,8366,14521,8220,14472,7992,14423,7770,14374,7578,14315,7408,15260,10819,15260,10819,15259,10822,15258,10826,15256,10832,15251,10836,15246,10841,15237,10838,15225,10821,15207,10788,15183,10734,15151,10660,15120,10571,15087,10469,15049,10359,15012,10249,14974,10041,14937,9837,14900,9647,14860,9475,14820,9320,14779,9147,14736,8902,14691,8688,14646,8499,14598,8335,14549,8189,14499,7940,14448,7720,14397,7529,14347,7363,14256,7218,15285,10410,15285,10411,15285,10413,15284,10418,15282,10425,15278,10434,15272,10442,15264,10449,15252,10445,15235,10433,15210,10403,15179,10358,15149,10301,15113,10218,15073,10059,15033,9894,14991,9726,14951,9565,14909,9413,14865,9273,14822,9073,14777,8845,14730,8641,14682,8459,14633,8300,14583,8129,14531,7883,14479,7670,14426,7482,14373,7321,14305,7176,14201,6939,15305,9939,15305,9940,15305,9945,15304,9955,15302,9967,15298,9989,15293,10010,15286,10033,15274,10044,15258,10045,15233,10022,15205,9975,15174,9903,15136,9808,15095,9697,15053,9578,15009,9451,14965,9327,14918,9198,14871,8973,14825,8766,14775,8579,14725,8408,14675,8259,14622,8058,14569,7821,14515,7615,14460,7435,14405,7276,14350,7108,14256,6866,14149,6653,15321,9444,15321,9445,15321,9448,15320,9458,15317,9470,15314,9490,15310,9515,15302,9540,15292,9562,15276,9579,15251,9577,15226,9559,15195,9519,15156,9463,15116,9389,15071,9304,15025,9208,14978,9023,14927,8838,14878,8661,14827,8496,14774,8344,14722,8206,14667,7973,14612,7749,14556,7555,14499,7382,14443,7229,14385,7025,14322,6791,14210,6588,14100,6409,15333,8920,15333,8921,15332,8927,15332,8943,15329,8965,15326,9002,15322,9048,15316,9106,15307,9162,15291,9204,15267,9221,15244,9221,15212,9196,15175,9134,15133,9043,15088,8930,15040,8801,14990,8665,14938,8526,14886,8391,14830,8261,14775,8087,14719,7866,14661,7664,14603,7482,14544,7322,14485,7178,14426,6936,14367,6713,14281,6517,14166,6348,14054,6198,15341,8360,15341,8361,15341,8366,15341,8379,15339,8399,15336,8431,15332,8473,15326,8527,15318,8585,15302,8632,15281,8670,15258,8690,15227,8690,15191,8664,15149,8612,15104,8543,15055,8456,15001,8360,14948,8259,14892,8122,14834,7923,14776,7734,14716,7558,14656,7397,14595,7250,14534,7070,14472,6835,14410,6628,14350,6443,14243,6283,14125,6135,14010,5889,15348,7715,15348,7717,15348,7725,15347,7745,15345,7780,15343,7836,15339,7905,15334,8e3,15326,8103,15310,8193,15293,8239,15270,8270,15240,8287,15204,8283,15163,8260,15118,8223,15067,8143,15014,8014,14958,7873,14899,7723,14839,7573,14778,7430,14715,7293,14652,7164,14588,6931,14524,6720,14460,6531,14396,6362,14330,6210,14207,6015,14086,5781,13969,5576,15352,7114,15352,7116,15352,7128,15352,7159,15350,7195,15348,7237,15345,7299,15340,7374,15332,7457,15317,7544,15301,7633,15280,7703,15251,7754,15216,7775,15176,7767,15131,7733,15079,7670,15026,7588,14967,7492,14906,7387,14844,7278,14779,7171,14714,6965,14648,6770,14581,6587,14515,6420,14448,6269,14382,6123,14299,5881,14172,5665,14049,5477,13929,5310,15355,6329,15355,6330,15355,6339,15355,6362,15353,6410,15351,6472,15349,6572,15344,6688,15337,6835,15323,6985,15309,7142,15287,7220,15260,7277,15226,7310,15188,7326,15142,7318,15090,7285,15036,7239,14976,7177,14914,7045,14849,6892,14782,6736,14714,6581,14645,6433,14576,6293,14506,6164,14438,5946,14369,5733,14270,5540,14140,5369,14014,5216,13892,5043,15357,5483,15357,5484,15357,5496,15357,5528,15356,5597,15354,5692,15351,5835,15347,6011,15339,6195,15328,6317,15314,6446,15293,6566,15268,6668,15235,6746,15197,6796,15152,6811,15101,6790,15046,6748,14985,6673,14921,6583,14854,6479,14785,6371,14714,6259,14643,6149,14571,5946,14499,5750,14428,5567,14358,5401,14242,5250,14109,5111,13980,4870,13856,4657,15359,4555,15359,4557,15358,4573,15358,4633,15357,4715,15355,4841,15353,5061,15349,5216,15342,5391,15331,5577,15318,5770,15299,5967,15274,6150,15243,6223,15206,6280,15161,6310,15111,6317,15055,6300,14994,6262,14928,6208,14860,6141,14788,5994,14715,5838,14641,5684,14566,5529,14492,5384,14418,5247,14346,5121,14216,4892,14079,4682,13948,4496,13822,4330,15359,3498,15359,3501,15359,3520,15359,3598,15358,3719,15356,3860,15355,4137,15351,4305,15344,4563,15334,4809,15321,5116,15303,5273,15280,5418,15250,5547,15214,5653,15170,5722,15120,5761,15064,5763,15002,5733,14935,5673,14865,5597,14792,5504,14716,5400,14640,5294,14563,5185,14486,5041,14410,4841,14335,4655,14191,4482,14051,4325,13918,4183,13790,4012,15360,2282,15360,2285,15360,2306,15360,2401,15359,2547,15357,2748,15355,3103,15352,3349,15345,3675,15336,4020,15324,4272,15307,4496,15285,4716,15255,4908,15220,5086,15178,5170,15128,5214,15072,5234,15010,5231,14943,5206,14871,5166,14796,5102,14718,4971,14639,4833,14559,4687,14480,4541,14402,4401,14315,4268,14167,4142,14025,3958,13888,3747,13759,3556,15360,923,15360,925,15360,946,15360,1052,15359,1214,15357,1494,15356,1892,15352,2274,15346,2663,15338,3099,15326,3393,15309,3679,15288,3980,15260,4183,15226,4325,15185,4437,15136,4517,15080,4570,15018,4591,14950,4581,14877,4545,14800,4485,14720,4411,14638,4325,14556,4231,14475,4136,14395,3988,14297,3803,14145,3628,13999,3465,13861,3314,13729,3177,15360,263,15360,264,15360,272,15360,325,15359,407,15358,548,15356,780,15352,1144,15347,1580,15339,2099,15328,2425,15312,2795,15292,3133,15264,3329,15232,3517,15191,3689,15143,3819,15088,3923,15025,3978,14956,3999,14882,3979,14804,3931,14722,3855,14639,3756,14554,3645,14470,3529,14388,3409,14279,3289,14124,3173,13975,3055,13834,2848,13701,2658,15360,49,15360,49,15360,52,15360,75,15359,111,15358,201,15356,283,15353,519,15348,726,15340,1045,15329,1415,15314,1795,15295,2173,15269,2410,15237,2649,15197,2866,15150,3054,15095,3140,15032,3196,14963,3228,14888,3236,14808,3224,14725,3191,14639,3146,14553,3088,14466,2976,14382,2836,14262,2692,14103,2549,13952,2409,13808,2278,13674,2154,15360,4,15360,4,15360,4,15360,13,15359,33,15358,59,15357,112,15353,199,15348,302,15341,456,15331,628,15316,827,15297,1082,15272,1332,15241,1601,15202,1851,15156,2069,15101,2172,15039,2256,14970,2314,14894,2348,14813,2358,14728,2344,14640,2311,14551,2263,14463,2203,14376,2133,14247,2059,14084,1915,13930,1761,13784,1609,13648,1464,15360,0,15360,0,15360,0,15360,3,15359,18,15358,26,15357,53,15354,80,15348,97,15341,165,15332,238,15318,326,15299,427,15275,529,15245,654,15207,771,15161,885,15108,994,15046,1089,14976,1170,14900,1229,14817,1266,14731,1284,14641,1282,14550,1260,14460,1223,14370,1174,14232,1116,14066,1050,13909,981,13761,910,13623,839]);let Xc=null;function WO(){return Xc===null&&(Xc=new So(ZO,32,32,AE,$f),Xc.minFilter=as,Xc.magFilter=as,Xc.wrapS=yr,Xc.wrapT=yr,Xc.generateMipmaps=!1,Xc.needsUpdate=!0),Xc}class o3{constructor(t={}){const{canvas:e=aw(),context:n=null,depth:i=!0,stencil:r=!1,alpha:l=!1,antialias:u=!1,premultipliedAlpha:A=!0,preserveDrawingBuffer:d=!1,powerPreference:m="default",failIfMajorPerformanceCaveat:g=!1,reversedDepthBuffer:y=!1}=t;this.isWebGLRenderer=!0;let v;if(n!==null){if(typeof WebGLRenderingContext<"u"&&n instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");v=n.getContextAttributes().alpha}else v=l;const C=new Set([sc,s0,i0]),I=new Set([ea,Ca,Jd,Zd,uE,hE]),S=new Uint32Array(4),E=new Int32Array(4);let B=null,w=null;const Q=[],R=[];this.domElement=e,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.toneMapping=ic,this.toneMappingExposure=1,this.transmissionResolutionScale=1;const D=this;let U=!1;this._outputColorSpace=ks;let P=0,z=0,L=null,k=-1,Y=null;const W=new We,K=new We;let nt=null;const H=new le(0);let tt=0,it=e.width,ot=e.height,At=1,V=null,st=null;const xt=new We(0,0,it,ot),j=new We(0,0,it,ot);let Rt=!1;const dt=new op;let pt=!1,qt=!1;const Wt=new he,ce=new F,Ie=new We,He={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let be=!1;function zt(){return L===null?At:1}let Z=n;function Ot(q,ut){return e.getContext(q,ut)}try{const q={alpha:!0,depth:i,stencil:r,antialias:u,premultipliedAlpha:A,preserveDrawingBuffer:d,powerPreference:m,failIfMajorPerformanceCaveat:g};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${Kf}`),e.addEventListener("webglcontextlost",Xt,!1),e.addEventListener("webglcontextrestored",Lt,!1),e.addEventListener("webglcontextcreationerror",Ae,!1),Z===null){const ut="webgl2";if(Z=Ot(ut,q),Z===null)throw Ot(ut)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(q){throw q("WebGLRenderer: "+q.message),q}let Vt,Pt,kt,Zt,$t,fe,$,G,ft,Tt,Ht,Bt,Se,ae,we,Ee,Gt,Jt,Be,ve,te,Ue,lt,re;function ee(){Vt=new r4(Z),Vt.init(),Ue=new r3(Z,Vt),Pt=new jz(Z,Vt,t,Ue),kt=new PO(Z,Vt),Pt.reversedDepthBuffer&&y&&kt.buffers.depth.setReversed(!0),Zt=new c4(Z),$t=new BO,fe=new GO(Z,Vt,kt,$t,Pt,Ue,Zt),$=new $z(D),G=new a4(D),ft=new AU(Z),lt=new Zz(Z,ft),Tt=new o4(Z,ft,Zt,lt),Ht=new h4(Z,Tt,ft,Zt),Be=new u4(Z,Pt,fe),Ee=new Kz($t),Bt=new IO(D,$,G,Vt,Pt,lt,Ee),Se=new XO(D,$t),ae=new wO,we=new UO(Vt),Jt=new Jz(D,$,G,kt,Ht,v,A),Gt=new OO(D,Ht,Pt),re=new JO(Z,Zt,Pt,kt),ve=new Wz(Z,Vt,Zt),te=new l4(Z,Vt,Zt),Zt.programs=Bt.programs,D.capabilities=Pt,D.extensions=Vt,D.properties=$t,D.renderLists=ae,D.shadowMap=Gt,D.state=kt,D.info=Zt}ee();const ie=new YO(D,Z);this.xr=ie,this.getContext=function(){return Z},this.getContextAttributes=function(){return Z.getContextAttributes()},this.forceContextLoss=function(){const q=Vt.get("WEBGL_lose_context");q&&q.loseContext()},this.forceContextRestore=function(){const q=Vt.get("WEBGL_lose_context");q&&q.restoreContext()},this.getPixelRatio=function(){return At},this.setPixelRatio=function(q){q!==void 0&&(At=q,this.setSize(it,ot,!1))},this.getSize=function(q){return q.set(it,ot)},this.setSize=function(q,ut,Ct=!0){if(ie.isPresenting){ge("WebGLRenderer: Can't change size while VR device is presenting.");return}it=q,ot=ut,e.width=Math.floor(q*At),e.height=Math.floor(ut*At),Ct===!0&&(e.style.width=q+"px",e.style.height=ut+"px"),this.setViewport(0,0,q,ut)},this.getDrawingBufferSize=function(q){return q.set(it*At,ot*At).floor()},this.setDrawingBufferSize=function(q,ut,Ct){it=q,ot=ut,At=Ct,e.width=Math.floor(q*Ct),e.height=Math.floor(ut*Ct),this.setViewport(0,0,q,ut)},this.getCurrentViewport=function(q){return q.copy(W)},this.getViewport=function(q){return q.copy(xt)},this.setViewport=function(q,ut,Ct,vt){q.isVector4?xt.set(q.x,q.y,q.z,q.w):xt.set(q,ut,Ct,vt),kt.viewport(W.copy(xt).multiplyScalar(At).round())},this.getScissor=function(q){return q.copy(j)},this.setScissor=function(q,ut,Ct,vt){q.isVector4?j.set(q.x,q.y,q.z,q.w):j.set(q,ut,Ct,vt),kt.scissor(K.copy(j).multiplyScalar(At).round())},this.getScissorTest=function(){return Rt},this.setScissorTest=function(q){kt.setScissorTest(Rt=q)},this.setOpaqueSort=function(q){V=q},this.setTransparentSort=function(q){st=q},this.getClearColor=function(q){return q.copy(Jt.getClearColor())},this.setClearColor=function(){Jt.setClearColor(...arguments)},this.getClearAlpha=function(){return Jt.getClearAlpha()},this.setClearAlpha=function(){Jt.setClearAlpha(...arguments)},this.clear=function(q=!0,ut=!0,Ct=!0){let vt=0;if(q){let ht=!1;if(L!==null){const Kt=L.texture.format;ht=C.has(Kt)}if(ht){const Kt=L.texture.type,se=I.has(Kt),me=Jt.getClearColor(),ye=Jt.getClearAlpha(),Te=me.r,_e=me.g,Qe=me.b;se?(S[0]=Te,S[1]=_e,S[2]=Qe,S[3]=ye,Z.clearBufferuiv(Z.COLOR,0,S)):(E[0]=Te,E[1]=_e,E[2]=Qe,E[3]=ye,Z.clearBufferiv(Z.COLOR,0,E))}else vt|=Z.COLOR_BUFFER_BIT}ut&&(vt|=Z.DEPTH_BUFFER_BIT),Ct&&(vt|=Z.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),Z.clear(vt)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Xt,!1),e.removeEventListener("webglcontextrestored",Lt,!1),e.removeEventListener("webglcontextcreationerror",Ae,!1),Jt.dispose(),ae.dispose(),we.dispose(),$t.dispose(),$.dispose(),G.dispose(),Ht.dispose(),lt.dispose(),re.dispose(),Bt.dispose(),ie.dispose(),ie.removeEventListener("sessionstart",br),ie.removeEventListener("sessionend",qr),ei.stop()};function Xt(q){q.preventDefault(),Hm("WebGLRenderer: Context Lost."),U=!0}function Lt(){Hm("WebGLRenderer: Context Restored."),U=!1;const q=Zt.autoReset,ut=Gt.enabled,Ct=Gt.autoUpdate,vt=Gt.needsUpdate,ht=Gt.type;ee(),Zt.autoReset=q,Gt.enabled=ut,Gt.autoUpdate=Ct,Gt.needsUpdate=vt,Gt.type=ht}function Ae(q){nn("WebGLRenderer: A WebGL context could not be created. Reason: ",q.statusMessage)}function Oe(q){const ut=q.target;ut.removeEventListener("dispose",Oe),In(ut)}function In(q){ln(q),$t.remove(q)}function ln(q){const ut=$t.get(q).programs;ut!==void 0&&(ut.forEach(function(Ct){Bt.releaseProgram(Ct)}),q.isShaderMaterial&&Bt.releaseShaderCache(q))}this.renderBufferDirect=function(q,ut,Ct,vt,ht,Kt){ut===null&&(ut=He);const se=ht.isMesh&&ht.matrixWorld.determinant()<0,me=ou(q,ut,Ct,vt,ht);kt.setMaterial(vt,se);let ye=Ct.index,Te=1;if(vt.wireframe===!0){if(ye=Tt.getWireframeAttribute(Ct),ye===void 0)return;Te=2}const _e=Ct.drawRange,Qe=Ct.attributes.position;let je=_e.start*Te,En=(_e.start+_e.count)*Te;Kt!==null&&(je=Math.max(je,Kt.start*Te),En=Math.min(En,(Kt.start+Kt.count)*Te)),ye!==null?(je=Math.max(je,0),En=Math.min(En,ye.count)):Qe!=null&&(je=Math.max(je,0),En=Math.min(En,Qe.count));const Ke=En-je;if(Ke<0||Ke===1/0)return;lt.setup(ht,vt,me,Ct,ye);let cn,Un=ve;if(ye!==null&&(cn=ft.get(ye),Un=te,Un.setIndex(cn)),ht.isMesh)vt.wireframe===!0?(kt.setLineWidth(vt.wireframeLinewidth*zt()),Un.setMode(Z.LINES)):Un.setMode(Z.TRIANGLES);else if(ht.isLine){let De=vt.linewidth;De===void 0&&(De=1),kt.setLineWidth(De*zt()),ht.isLineSegments?Un.setMode(Z.LINES):ht.isLineLoop?Un.setMode(Z.LINE_LOOP):Un.setMode(Z.LINE_STRIP)}else ht.isPoints?Un.setMode(Z.POINTS):ht.isSprite&&Un.setMode(Z.TRIANGLES);if(ht.isBatchedMesh)if(ht._multiDrawInstances!==null)$d("WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),Un.renderMultiDrawInstances(ht._multiDrawStarts,ht._multiDrawCounts,ht._multiDrawCount,ht._multiDrawInstances);else if(Vt.get("WEBGL_multi_draw"))Un.renderMultiDraw(ht._multiDrawStarts,ht._multiDrawCounts,ht._multiDrawCount);else{const De=ht._multiDrawStarts,Ln=ht._multiDrawCounts,mn=ht._multiDrawCount,ri=ye?ft.get(ye).bytesPerElement:1,Ia=$t.get(vt).currentProgram.getUniforms();for(let Vn=0;Vn<mn;Vn++)Ia.setValue(Z,"_gl_DrawID",Vn),Un.render(De[Vn]/ri,Ln[Vn])}else if(ht.isInstancedMesh)Un.renderInstances(je,Ke,ht.count);else if(Ct.isInstancedBufferGeometry){const De=Ct._maxInstanceCount!==void 0?Ct._maxInstanceCount:1/0,Ln=Math.min(Ct.instanceCount,De);Un.renderInstances(je,Ke,Ln)}else Un.render(je,Ke)};function Ei(q,ut,Ct){q.transparent===!0&&q.side===gr&&q.forceSinglePass===!1?(q.side=_a,q.needsUpdate=!0,_i(q,ut,Ct),q.side=fl,q.needsUpdate=!0,_i(q,ut,Ct),q.side=gr):_i(q,ut,Ct)}this.compile=function(q,ut,Ct=null){Ct===null&&(Ct=q),w=we.get(Ct),w.init(ut),R.push(w),Ct.traverseVisible(function(ht){ht.isLight&&ht.layers.test(ut.layers)&&(w.pushLight(ht),ht.castShadow&&w.pushShadow(ht))}),q!==Ct&&q.traverseVisible(function(ht){ht.isLight&&ht.layers.test(ut.layers)&&(w.pushLight(ht),ht.castShadow&&w.pushShadow(ht))}),w.setupLights();const vt=new Set;return q.traverse(function(ht){if(!(ht.isMesh||ht.isPoints||ht.isLine||ht.isSprite))return;const Kt=ht.material;if(Kt)if(Array.isArray(Kt))for(let se=0;se<Kt.length;se++){const me=Kt[se];Ei(me,Ct,ht),vt.add(me)}else Ei(Kt,Ct,ht),vt.add(Kt)}),w=R.pop(),vt},this.compileAsync=function(q,ut,Ct=null){const vt=this.compile(q,ut,Ct);return new Promise(ht=>{function Kt(){if(vt.forEach(function(se){$t.get(se).currentProgram.isReady()&&vt.delete(se)}),vt.size===0){ht(q);return}setTimeout(Kt,10)}Vt.get("KHR_parallel_shader_compile")!==null?Kt():setTimeout(Kt,10)})};let $i=null;function Mo(q){$i&&$i(q)}function br(){ei.stop()}function qr(){ei.start()}const ei=new e3;ei.setAnimationLoop(Mo),typeof self<"u"&&ei.setContext(self),this.setAnimationLoop=function(q){$i=q,ie.setAnimationLoop(q),q===null?ei.stop():ei.start()},ie.addEventListener("sessionstart",br),ie.addEventListener("sessionend",qr),this.render=function(q,ut){if(ut!==void 0&&ut.isCamera!==!0){nn("WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(U===!0)return;if(q.matrixWorldAutoUpdate===!0&&q.updateMatrixWorld(),ut.parent===null&&ut.matrixWorldAutoUpdate===!0&&ut.updateMatrixWorld(),ie.enabled===!0&&ie.isPresenting===!0&&(ie.cameraAutoUpdate===!0&&ie.updateCamera(ut),ut=ie.getCamera()),q.isScene===!0&&q.onBeforeRender(D,q,ut,L),w=we.get(q,R.length),w.init(ut),R.push(w),Wt.multiplyMatrices(ut.projectionMatrix,ut.matrixWorldInverse),dt.setFromProjectionMatrix(Wt,Hr,ut.reversedDepth),qt=this.localClippingEnabled,pt=Ee.init(this.clippingPlanes,qt),B=ae.get(q,Q.length),B.init(),Q.push(B),ie.enabled===!0&&ie.isPresenting===!0){const Kt=D.xr.getDepthSensingMesh();Kt!==null&&Sa(Kt,ut,-1/0,D.sortObjects)}Sa(q,ut,0,D.sortObjects),B.finish(),D.sortObjects===!0&&B.sort(V,st),be=ie.enabled===!1||ie.isPresenting===!1||ie.hasDepthSensing()===!1,be&&Jt.addToRenderList(B,q),this.info.render.frame++,pt===!0&&Ee.beginShadows();const Ct=w.state.shadowsArray;Gt.render(Ct,q,ut),pt===!0&&Ee.endShadows(),this.info.autoReset===!0&&this.info.reset();const vt=B.opaque,ht=B.transmissive;if(w.setupLights(),ut.isArrayCamera){const Kt=ut.cameras;if(ht.length>0)for(let se=0,me=Kt.length;se<me;se++){const ye=Kt[se];Qs(vt,ht,q,ye)}be&&Jt.render(q);for(let se=0,me=Kt.length;se<me;se++){const ye=Kt[se];gs(B,q,ye,ye.viewport)}}else ht.length>0&&Qs(vt,ht,q,ut),be&&Jt.render(q),gs(B,q,ut);L!==null&&z===0&&(fe.updateMultisampleRenderTarget(L),fe.updateRenderTargetMipmap(L)),q.isScene===!0&&q.onAfterRender(D,q,ut),lt.resetDefaultState(),k=-1,Y=null,R.pop(),R.length>0?(w=R[R.length-1],pt===!0&&Ee.setGlobalState(D.clippingPlanes,w.state.camera)):w=null,Q.pop(),Q.length>0?B=Q[Q.length-1]:B=null};function Sa(q,ut,Ct,vt){if(q.visible===!1)return;if(q.layers.test(ut.layers)){if(q.isGroup)Ct=q.renderOrder;else if(q.isLOD)q.autoUpdate===!0&&q.update(ut);else if(q.isLight)w.pushLight(q),q.castShadow&&w.pushShadow(q);else if(q.isSprite){if(!q.frustumCulled||dt.intersectsSprite(q)){vt&&Ie.setFromMatrixPosition(q.matrixWorld).applyMatrix4(Wt);const se=Ht.update(q),me=q.material;me.visible&&B.push(q,se,me,Ct,Ie.z,null)}}else if((q.isMesh||q.isLine||q.isPoints)&&(!q.frustumCulled||dt.intersectsObject(q))){const se=Ht.update(q),me=q.material;if(vt&&(q.boundingSphere!==void 0?(q.boundingSphere===null&&q.computeBoundingSphere(),Ie.copy(q.boundingSphere.center)):(se.boundingSphere===null&&se.computeBoundingSphere(),Ie.copy(se.boundingSphere.center)),Ie.applyMatrix4(q.matrixWorld).applyMatrix4(Wt)),Array.isArray(me)){const ye=se.groups;for(let Te=0,_e=ye.length;Te<_e;Te++){const Qe=ye[Te],je=me[Qe.materialIndex];je&&je.visible&&B.push(q,se,je,Ct,Ie.z,Qe)}}else me.visible&&B.push(q,se,me,Ct,Ie.z,null)}}const Kt=q.children;for(let se=0,me=Kt.length;se<me;se++)Sa(Kt[se],ut,Ct,vt)}function gs(q,ut,Ct,vt){const{opaque:ht,transmissive:Kt,transparent:se}=q;w.setupLightsView(Ct),pt===!0&&Ee.setGlobalState(D.clippingPlanes,Ct),vt&&kt.viewport(W.copy(vt)),ht.length>0&&Fi(ht,ut,Ct),Kt.length>0&&Fi(Kt,ut,Ct),se.length>0&&Fi(se,ut,Ct),kt.buffers.depth.setTest(!0),kt.buffers.depth.setMask(!0),kt.buffers.color.setMask(!0),kt.setPolygonOffset(!1)}function Qs(q,ut,Ct,vt){if((Ct.isScene===!0?Ct.overrideMaterial:null)!==null)return;w.state.transmissionRenderTarget[vt.id]===void 0&&(w.state.transmissionRenderTarget[vt.id]=new Io(1,1,{generateMipmaps:!0,type:Vt.has("EXT_color_buffer_half_float")||Vt.has("EXT_color_buffer_float")?$f:ea,minFilter:tc,samples:4,stencilBuffer:r,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:Gn.workingColorSpace}));const Kt=w.state.transmissionRenderTarget[vt.id],se=vt.viewport||W;Kt.setSize(se.z*D.transmissionResolutionScale,se.w*D.transmissionResolutionScale);const me=D.getRenderTarget(),ye=D.getActiveCubeFace(),Te=D.getActiveMipmapLevel();D.setRenderTarget(Kt),D.getClearColor(H),tt=D.getClearAlpha(),tt<1&&D.setClearColor(16777215,.5),D.clear(),be&&Jt.render(Ct);const _e=D.toneMapping;D.toneMapping=ic;const Qe=vt.viewport;if(vt.viewport!==void 0&&(vt.viewport=void 0),w.setupLightsView(vt),pt===!0&&Ee.setGlobalState(D.clippingPlanes,vt),Fi(q,Ct,vt),fe.updateMultisampleRenderTarget(Kt),fe.updateRenderTargetMipmap(Kt),Vt.has("WEBGL_multisampled_render_to_texture")===!1){let je=!1;for(let En=0,Ke=ut.length;En<Ke;En++){const cn=ut[En],{object:Un,geometry:De,material:Ln,group:mn}=cn;if(Ln.side===gr&&Un.layers.test(vt.layers)){const ri=Ln.side;Ln.side=_a,Ln.needsUpdate=!0,an(Un,Ct,vt,De,Ln,mn),Ln.side=ri,Ln.needsUpdate=!0,je=!0}}je===!0&&(fe.updateMultisampleRenderTarget(Kt),fe.updateRenderTargetMipmap(Kt))}D.setRenderTarget(me,ye,Te),D.setClearColor(H,tt),Qe!==void 0&&(vt.viewport=Qe),D.toneMapping=_e}function Fi(q,ut,Ct){const vt=ut.isScene===!0?ut.overrideMaterial:null;for(let ht=0,Kt=q.length;ht<Kt;ht++){const se=q[ht],{object:me,geometry:ye,group:Te}=se;let _e=se.material;_e.allowOverride===!0&&vt!==null&&(_e=vt),me.layers.test(Ct.layers)&&an(me,ut,Ct,ye,_e,Te)}}function an(q,ut,Ct,vt,ht,Kt){q.onBeforeRender(D,ut,Ct,vt,ht,Kt),q.modelViewMatrix.multiplyMatrices(Ct.matrixWorldInverse,q.matrixWorld),q.normalMatrix.getNormalMatrix(q.modelViewMatrix),ht.onBeforeRender(D,ut,Ct,vt,q,Kt),ht.transparent===!0&&ht.side===gr&&ht.forceSinglePass===!1?(ht.side=_a,ht.needsUpdate=!0,D.renderBufferDirect(Ct,ut,vt,ht,q,Kt),ht.side=fl,ht.needsUpdate=!0,D.renderBufferDirect(Ct,ut,vt,ht,q,Kt),ht.side=gr):D.renderBufferDirect(Ct,ut,vt,ht,q,Kt),q.onAfterRender(D,ut,Ct,vt,ht,Kt)}function _i(q,ut,Ct){ut.isScene!==!0&&(ut=He);const vt=$t.get(q),ht=w.state.lights,Kt=w.state.shadowsArray,se=ht.state.version,me=Bt.getParameters(q,ht.state,Kt,ut,Ct),ye=Bt.getProgramCacheKey(me);let Te=vt.programs;vt.environment=q.isMeshStandardMaterial?ut.environment:null,vt.fog=ut.fog,vt.envMap=(q.isMeshStandardMaterial?G:$).get(q.envMap||vt.environment),vt.envMapRotation=vt.environment!==null&&q.envMap===null?ut.environmentRotation:q.envMapRotation,Te===void 0&&(q.addEventListener("dispose",Oe),Te=new Map,vt.programs=Te);let _e=Te.get(ye);if(_e!==void 0){if(vt.currentProgram===_e&&vt.lightsStateVersion===se)return Xr(q,me),_e}else me.uniforms=Bt.getUniforms(q),q.onBeforeCompile(me,D),_e=Bt.acquireProgram(me,ye),Te.set(ye,_e),vt.uniforms=me.uniforms;const Qe=vt.uniforms;return(!q.isShaderMaterial&&!q.isRawShaderMaterial||q.clipping===!0)&&(Qe.clippingPlanes=Ee.uniform),Xr(q,me),vt.needsLights=Sr(q),vt.lightsStateVersion=se,vt.needsLights&&(Qe.ambientLightColor.value=ht.state.ambient,Qe.lightProbe.value=ht.state.probe,Qe.directionalLights.value=ht.state.directional,Qe.directionalLightShadows.value=ht.state.directionalShadow,Qe.spotLights.value=ht.state.spot,Qe.spotLightShadows.value=ht.state.spotShadow,Qe.rectAreaLights.value=ht.state.rectArea,Qe.ltc_1.value=ht.state.rectAreaLTC1,Qe.ltc_2.value=ht.state.rectAreaLTC2,Qe.pointLights.value=ht.state.point,Qe.pointLightShadows.value=ht.state.pointShadow,Qe.hemisphereLights.value=ht.state.hemi,Qe.directionalShadowMap.value=ht.state.directionalShadowMap,Qe.directionalShadowMatrix.value=ht.state.directionalShadowMatrix,Qe.spotShadowMap.value=ht.state.spotShadowMap,Qe.spotLightMatrix.value=ht.state.spotLightMatrix,Qe.spotLightMap.value=ht.state.spotLightMap,Qe.pointShadowMap.value=ht.state.pointShadowMap,Qe.pointShadowMatrix.value=ht.state.pointShadowMatrix),vt.currentProgram=_e,vt.uniformsList=null,_e}function Ys(q){if(q.uniformsList===null){const ut=q.currentProgram.getUniforms();q.uniformsList=sv.seqWithValue(ut.seq,q.uniforms)}return q.uniformsList}function Xr(q,ut){const Ct=$t.get(q);Ct.outputColorSpace=ut.outputColorSpace,Ct.batching=ut.batching,Ct.batchingColor=ut.batchingColor,Ct.instancing=ut.instancing,Ct.instancingColor=ut.instancingColor,Ct.instancingMorph=ut.instancingMorph,Ct.skinning=ut.skinning,Ct.morphTargets=ut.morphTargets,Ct.morphNormals=ut.morphNormals,Ct.morphColors=ut.morphColors,Ct.morphTargetsCount=ut.morphTargetsCount,Ct.numClippingPlanes=ut.numClippingPlanes,Ct.numIntersection=ut.numClipIntersection,Ct.vertexAlphas=ut.vertexAlphas,Ct.vertexTangents=ut.vertexTangents,Ct.toneMapping=ut.toneMapping}function ou(q,ut,Ct,vt,ht){ut.isScene!==!0&&(ut=He),fe.resetTextureUnits();const Kt=ut.fog,se=vt.isMeshStandardMaterial?ut.environment:null,me=L===null?D.outputColorSpace:L.isXRRenderTarget===!0?L.texture.colorSpace:Ah,ye=(vt.isMeshStandardMaterial?G:$).get(vt.envMap||se),Te=vt.vertexColors===!0&&!!Ct.attributes.color&&Ct.attributes.color.itemSize===4,_e=!!Ct.attributes.tangent&&(!!vt.normalMap||vt.anisotropy>0),Qe=!!Ct.morphAttributes.position,je=!!Ct.morphAttributes.normal,En=!!Ct.morphAttributes.color;let Ke=ic;vt.toneMapped&&(L===null||L.isXRRenderTarget===!0)&&(Ke=D.toneMapping);const cn=Ct.morphAttributes.position||Ct.morphAttributes.normal||Ct.morphAttributes.color,Un=cn!==void 0?cn.length:0,De=$t.get(vt),Ln=w.state.lights;if(pt===!0&&(qt===!0||q!==Y)){const Qi=q===Y&&vt.id===k;Ee.setState(vt,q,Qi)}let mn=!1;vt.version===De.__version?(De.needsLights&&De.lightsStateVersion!==Ln.state.version||De.outputColorSpace!==me||ht.isBatchedMesh&&De.batching===!1||!ht.isBatchedMesh&&De.batching===!0||ht.isBatchedMesh&&De.batchingColor===!0&&ht.colorTexture===null||ht.isBatchedMesh&&De.batchingColor===!1&&ht.colorTexture!==null||ht.isInstancedMesh&&De.instancing===!1||!ht.isInstancedMesh&&De.instancing===!0||ht.isSkinnedMesh&&De.skinning===!1||!ht.isSkinnedMesh&&De.skinning===!0||ht.isInstancedMesh&&De.instancingColor===!0&&ht.instanceColor===null||ht.isInstancedMesh&&De.instancingColor===!1&&ht.instanceColor!==null||ht.isInstancedMesh&&De.instancingMorph===!0&&ht.morphTexture===null||ht.isInstancedMesh&&De.instancingMorph===!1&&ht.morphTexture!==null||De.envMap!==ye||vt.fog===!0&&De.fog!==Kt||De.numClippingPlanes!==void 0&&(De.numClippingPlanes!==Ee.numPlanes||De.numIntersection!==Ee.numIntersection)||De.vertexAlphas!==Te||De.vertexTangents!==_e||De.morphTargets!==Qe||De.morphNormals!==je||De.morphColors!==En||De.toneMapping!==Ke||De.morphTargetsCount!==Un)&&(mn=!0):(mn=!0,De.__version=vt.version);let ri=De.currentProgram;mn===!0&&(ri=_i(vt,ut,ht));let Ia=!1,Vn=!1,Ba=!1;const Xn=ri.getUniforms(),oi=De.uniforms;if(kt.useProgram(ri.program)&&(Ia=!0,Vn=!0,Ba=!0),vt.id!==k&&(k=vt.id,Vn=!0),Ia||Y!==q){kt.buffers.depth.getReversed()&&q.reversedDepth!==!0&&(q._reversedDepth=!0,q.updateProjectionMatrix()),Xn.setValue(Z,"projectionMatrix",q.projectionMatrix),Xn.setValue(Z,"viewMatrix",q.matrixWorldInverse);const bi=Xn.map.cameraPosition;bi!==void 0&&bi.setValue(Z,ce.setFromMatrixPosition(q.matrixWorld)),Pt.logarithmicDepthBuffer&&Xn.setValue(Z,"logDepthBufFC",2/(Math.log(q.far+1)/Math.LN2)),(vt.isMeshPhongMaterial||vt.isMeshToonMaterial||vt.isMeshLambertMaterial||vt.isMeshBasicMaterial||vt.isMeshStandardMaterial||vt.isShaderMaterial)&&Xn.setValue(Z,"isOrthographic",q.isOrthographicCamera===!0),Y!==q&&(Y=q,Vn=!0,Ba=!0)}if(ht.isSkinnedMesh){Xn.setOptional(Z,ht,"bindMatrix"),Xn.setOptional(Z,ht,"bindMatrixInverse");const Qi=ht.skeleton;Qi&&(Qi.boneTexture===null&&Qi.computeBoneTexture(),Xn.setValue(Z,"boneTexture",Qi.boneTexture,fe))}ht.isBatchedMesh&&(Xn.setOptional(Z,ht,"batchingTexture"),Xn.setValue(Z,"batchingTexture",ht._matricesTexture,fe),Xn.setOptional(Z,ht,"batchingIdTexture"),Xn.setValue(Z,"batchingIdTexture",ht._indirectTexture,fe),Xn.setOptional(Z,ht,"batchingColorTexture"),ht._colorsTexture!==null&&Xn.setValue(Z,"batchingColorTexture",ht._colorsTexture,fe));const Ci=Ct.morphAttributes;if((Ci.position!==void 0||Ci.normal!==void 0||Ci.color!==void 0)&&Be.update(ht,Ct,ri),(Vn||De.receiveShadow!==ht.receiveShadow)&&(De.receiveShadow=ht.receiveShadow,Xn.setValue(Z,"receiveShadow",ht.receiveShadow)),vt.isMeshGouraudMaterial&&vt.envMap!==null&&(oi.envMap.value=ye,oi.flipEnvMap.value=ye.isCubeTexture&&ye.isRenderTargetTexture===!1?-1:1),vt.isMeshStandardMaterial&&vt.envMap===null&&ut.environment!==null&&(oi.envMapIntensity.value=ut.environmentIntensity),oi.dfgLUT!==void 0&&(oi.dfgLUT.value=WO()),Vn&&(Xn.setValue(Z,"toneMappingExposure",D.toneMappingExposure),De.needsLights&&xh(oi,Ba),Kt&&vt.fog===!0&&Se.refreshFogUniforms(oi,Kt),Se.refreshMaterialUniforms(oi,vt,At,ot,w.state.transmissionRenderTarget[q.id]),sv.upload(Z,Ys(De),oi,fe)),vt.isShaderMaterial&&vt.uniformsNeedUpdate===!0&&(sv.upload(Z,Ys(De),oi,fe),vt.uniformsNeedUpdate=!1),vt.isSpriteMaterial&&Xn.setValue(Z,"center",ht.center),Xn.setValue(Z,"modelViewMatrix",ht.modelViewMatrix),Xn.setValue(Z,"normalMatrix",ht.normalMatrix),Xn.setValue(Z,"modelMatrix",ht.matrixWorld),vt.isShaderMaterial||vt.isRawShaderMaterial){const Qi=vt.uniformsGroups;for(let bi=0,Ma=Qi.length;bi<Ma;bi++){const ms=Qi[bi];re.update(ms,ri),re.bind(ms,ri)}}return ri}function xh(q,ut){q.ambientLightColor.needsUpdate=ut,q.lightProbe.needsUpdate=ut,q.directionalLights.needsUpdate=ut,q.directionalLightShadows.needsUpdate=ut,q.pointLights.needsUpdate=ut,q.pointLightShadows.needsUpdate=ut,q.spotLights.needsUpdate=ut,q.spotLightShadows.needsUpdate=ut,q.rectAreaLights.needsUpdate=ut,q.hemisphereLights.needsUpdate=ut}function Sr(q){return q.isMeshLambertMaterial||q.isMeshToonMaterial||q.isMeshPhongMaterial||q.isMeshStandardMaterial||q.isShadowMaterial||q.isShaderMaterial&&q.lights===!0}this.getActiveCubeFace=function(){return P},this.getActiveMipmapLevel=function(){return z},this.getRenderTarget=function(){return L},this.setRenderTargetTextures=function(q,ut,Ct){const vt=$t.get(q);vt.__autoAllocateDepthBuffer=q.resolveDepthBuffer===!1,vt.__autoAllocateDepthBuffer===!1&&(vt.__useRenderToTexture=!1),$t.get(q.texture).__webglTexture=ut,$t.get(q.depthTexture).__webglTexture=vt.__autoAllocateDepthBuffer?void 0:Ct,vt.__hasExternalTextures=!0},this.setRenderTargetFramebuffer=function(q,ut){const Ct=$t.get(q);Ct.__webglFramebuffer=ut,Ct.__useDefaultFramebuffer=ut===void 0};const ia=Z.createFramebuffer();this.setRenderTarget=function(q,ut=0,Ct=0){L=q,P=ut,z=Ct;let vt=!0,ht=null,Kt=!1,se=!1;if(q){const ye=$t.get(q);if(ye.__useDefaultFramebuffer!==void 0)kt.bindFramebuffer(Z.FRAMEBUFFER,null),vt=!1;else if(ye.__webglFramebuffer===void 0)fe.setupRenderTarget(q);else if(ye.__hasExternalTextures)fe.rebindTextures(q,$t.get(q.texture).__webglTexture,$t.get(q.depthTexture).__webglTexture);else if(q.depthBuffer){const Qe=q.depthTexture;if(ye.__boundDepthTexture!==Qe){if(Qe!==null&&$t.has(Qe)&&(q.width!==Qe.image.width||q.height!==Qe.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");fe.setupDepthRenderbuffer(q)}}const Te=q.texture;(Te.isData3DTexture||Te.isDataArrayTexture||Te.isCompressedArrayTexture)&&(se=!0);const _e=$t.get(q).__webglFramebuffer;q.isWebGLCubeRenderTarget?(Array.isArray(_e[ut])?ht=_e[ut][Ct]:ht=_e[ut],Kt=!0):q.samples>0&&fe.useMultisampledRTT(q)===!1?ht=$t.get(q).__webglMultisampledFramebuffer:Array.isArray(_e)?ht=_e[Ct]:ht=_e,W.copy(q.viewport),K.copy(q.scissor),nt=q.scissorTest}else W.copy(xt).multiplyScalar(At).floor(),K.copy(j).multiplyScalar(At).floor(),nt=Rt;if(Ct!==0&&(ht=ia),kt.bindFramebuffer(Z.FRAMEBUFFER,ht)&&vt&&kt.drawBuffers(q,ht),kt.viewport(W),kt.scissor(K),kt.setScissorTest(nt),Kt){const ye=$t.get(q.texture);Z.framebufferTexture2D(Z.FRAMEBUFFER,Z.COLOR_ATTACHMENT0,Z.TEXTURE_CUBE_MAP_POSITIVE_X+ut,ye.__webglTexture,Ct)}else if(se){const ye=ut;for(let Te=0;Te<q.textures.length;Te++){const _e=$t.get(q.textures[Te]);Z.framebufferTextureLayer(Z.FRAMEBUFFER,Z.COLOR_ATTACHMENT0+Te,_e.__webglTexture,Ct,ye)}}else if(q!==null&&Ct!==0){const ye=$t.get(q.texture);Z.framebufferTexture2D(Z.FRAMEBUFFER,Z.COLOR_ATTACHMENT0,Z.TEXTURE_2D,ye.__webglTexture,Ct)}k=-1},this.readRenderTargetPixels=function(q,ut,Ct,vt,ht,Kt,se,me=0){if(!(q&&q.isWebGLRenderTarget)){nn("WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let ye=$t.get(q).__webglFramebuffer;if(q.isWebGLCubeRenderTarget&&se!==void 0&&(ye=ye[se]),ye){kt.bindFramebuffer(Z.FRAMEBUFFER,ye);try{const Te=q.textures[me],_e=Te.format,Qe=Te.type;if(!Pt.textureFormatReadable(_e)){nn("WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!Pt.textureTypeReadable(Qe)){nn("WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}ut>=0&&ut<=q.width-vt&&Ct>=0&&Ct<=q.height-ht&&(q.textures.length>1&&Z.readBuffer(Z.COLOR_ATTACHMENT0+me),Z.readPixels(ut,Ct,vt,ht,Ue.convert(_e),Ue.convert(Qe),Kt))}finally{const Te=L!==null?$t.get(L).__webglFramebuffer:null;kt.bindFramebuffer(Z.FRAMEBUFFER,Te)}}},this.readRenderTargetPixelsAsync=async function(q,ut,Ct,vt,ht,Kt,se,me=0){if(!(q&&q.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let ye=$t.get(q).__webglFramebuffer;if(q.isWebGLCubeRenderTarget&&se!==void 0&&(ye=ye[se]),ye)if(ut>=0&&ut<=q.width-vt&&Ct>=0&&Ct<=q.height-ht){kt.bindFramebuffer(Z.FRAMEBUFFER,ye);const Te=q.textures[me],_e=Te.format,Qe=Te.type;if(!Pt.textureFormatReadable(_e))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!Pt.textureTypeReadable(Qe))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");const je=Z.createBuffer();Z.bindBuffer(Z.PIXEL_PACK_BUFFER,je),Z.bufferData(Z.PIXEL_PACK_BUFFER,Kt.byteLength,Z.STREAM_READ),q.textures.length>1&&Z.readBuffer(Z.COLOR_ATTACHMENT0+me),Z.readPixels(ut,Ct,vt,ht,Ue.convert(_e),Ue.convert(Qe),0);const En=L!==null?$t.get(L).__webglFramebuffer:null;kt.bindFramebuffer(Z.FRAMEBUFFER,En);const Ke=Z.fenceSync(Z.SYNC_GPU_COMMANDS_COMPLETE,0);return Z.flush(),await yD(Z,Ke,4),Z.bindBuffer(Z.PIXEL_PACK_BUFFER,je),Z.getBufferSubData(Z.PIXEL_PACK_BUFFER,0,Kt),Z.deleteBuffer(je),Z.deleteSync(Ke),Kt}else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")},this.copyFramebufferToTexture=function(q,ut=null,Ct=0){const vt=Math.pow(2,-Ct),ht=Math.floor(q.image.width*vt),Kt=Math.floor(q.image.height*vt),se=ut!==null?ut.x:0,me=ut!==null?ut.y:0;fe.setTexture2D(q,0),Z.copyTexSubImage2D(Z.TEXTURE_2D,Ct,0,0,se,me,ht,Kt),kt.unbindTexture()};const Ir=Z.createFramebuffer(),pi=Z.createFramebuffer();this.copyTextureToTexture=function(q,ut,Ct=null,vt=null,ht=0,Kt=null){Kt===null&&(ht!==0?($d("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),Kt=ht,ht=0):Kt=0);let se,me,ye,Te,_e,Qe,je,En,Ke;const cn=q.isCompressedTexture?q.mipmaps[Kt]:q.image;if(Ct!==null)se=Ct.max.x-Ct.min.x,me=Ct.max.y-Ct.min.y,ye=Ct.isBox3?Ct.max.z-Ct.min.z:1,Te=Ct.min.x,_e=Ct.min.y,Qe=Ct.isBox3?Ct.min.z:0;else{const Ci=Math.pow(2,-ht);se=Math.floor(cn.width*Ci),me=Math.floor(cn.height*Ci),q.isDataArrayTexture?ye=cn.depth:q.isData3DTexture?ye=Math.floor(cn.depth*Ci):ye=1,Te=0,_e=0,Qe=0}vt!==null?(je=vt.x,En=vt.y,Ke=vt.z):(je=0,En=0,Ke=0);const Un=Ue.convert(ut.format),De=Ue.convert(ut.type);let Ln;ut.isData3DTexture?(fe.setTexture3D(ut,0),Ln=Z.TEXTURE_3D):ut.isDataArrayTexture||ut.isCompressedArrayTexture?(fe.setTexture2DArray(ut,0),Ln=Z.TEXTURE_2D_ARRAY):(fe.setTexture2D(ut,0),Ln=Z.TEXTURE_2D),Z.pixelStorei(Z.UNPACK_FLIP_Y_WEBGL,ut.flipY),Z.pixelStorei(Z.UNPACK_PREMULTIPLY_ALPHA_WEBGL,ut.premultiplyAlpha),Z.pixelStorei(Z.UNPACK_ALIGNMENT,ut.unpackAlignment);const mn=Z.getParameter(Z.UNPACK_ROW_LENGTH),ri=Z.getParameter(Z.UNPACK_IMAGE_HEIGHT),Ia=Z.getParameter(Z.UNPACK_SKIP_PIXELS),Vn=Z.getParameter(Z.UNPACK_SKIP_ROWS),Ba=Z.getParameter(Z.UNPACK_SKIP_IMAGES);Z.pixelStorei(Z.UNPACK_ROW_LENGTH,cn.width),Z.pixelStorei(Z.UNPACK_IMAGE_HEIGHT,cn.height),Z.pixelStorei(Z.UNPACK_SKIP_PIXELS,Te),Z.pixelStorei(Z.UNPACK_SKIP_ROWS,_e),Z.pixelStorei(Z.UNPACK_SKIP_IMAGES,Qe);const Xn=q.isDataArrayTexture||q.isData3DTexture,oi=ut.isDataArrayTexture||ut.isData3DTexture;if(q.isDepthTexture){const Ci=$t.get(q),Qi=$t.get(ut),bi=$t.get(Ci.__renderTarget),Ma=$t.get(Qi.__renderTarget);kt.bindFramebuffer(Z.READ_FRAMEBUFFER,bi.__webglFramebuffer),kt.bindFramebuffer(Z.DRAW_FRAMEBUFFER,Ma.__webglFramebuffer);for(let ms=0;ms<ye;ms++)Xn&&(Z.framebufferTextureLayer(Z.READ_FRAMEBUFFER,Z.COLOR_ATTACHMENT0,$t.get(q).__webglTexture,ht,Qe+ms),Z.framebufferTextureLayer(Z.DRAW_FRAMEBUFFER,Z.COLOR_ATTACHMENT0,$t.get(ut).__webglTexture,Kt,Ke+ms)),Z.blitFramebuffer(Te,_e,se,me,je,En,se,me,Z.DEPTH_BUFFER_BIT,Z.NEAREST);kt.bindFramebuffer(Z.READ_FRAMEBUFFER,null),kt.bindFramebuffer(Z.DRAW_FRAMEBUFFER,null)}else if(ht!==0||q.isRenderTargetTexture||$t.has(q)){const Ci=$t.get(q),Qi=$t.get(ut);kt.bindFramebuffer(Z.READ_FRAMEBUFFER,Ir),kt.bindFramebuffer(Z.DRAW_FRAMEBUFFER,pi);for(let bi=0;bi<ye;bi++)Xn?Z.framebufferTextureLayer(Z.READ_FRAMEBUFFER,Z.COLOR_ATTACHMENT0,Ci.__webglTexture,ht,Qe+bi):Z.framebufferTexture2D(Z.READ_FRAMEBUFFER,Z.COLOR_ATTACHMENT0,Z.TEXTURE_2D,Ci.__webglTexture,ht),oi?Z.framebufferTextureLayer(Z.DRAW_FRAMEBUFFER,Z.COLOR_ATTACHMENT0,Qi.__webglTexture,Kt,Ke+bi):Z.framebufferTexture2D(Z.DRAW_FRAMEBUFFER,Z.COLOR_ATTACHMENT0,Z.TEXTURE_2D,Qi.__webglTexture,Kt),ht!==0?Z.blitFramebuffer(Te,_e,se,me,je,En,se,me,Z.COLOR_BUFFER_BIT,Z.NEAREST):oi?Z.copyTexSubImage3D(Ln,Kt,je,En,Ke+bi,Te,_e,se,me):Z.copyTexSubImage2D(Ln,Kt,je,En,Te,_e,se,me);kt.bindFramebuffer(Z.READ_FRAMEBUFFER,null),kt.bindFramebuffer(Z.DRAW_FRAMEBUFFER,null)}else oi?q.isDataTexture||q.isData3DTexture?Z.texSubImage3D(Ln,Kt,je,En,Ke,se,me,ye,Un,De,cn.data):ut.isCompressedArrayTexture?Z.compressedTexSubImage3D(Ln,Kt,je,En,Ke,se,me,ye,Un,cn.data):Z.texSubImage3D(Ln,Kt,je,En,Ke,se,me,ye,Un,De,cn):q.isDataTexture?Z.texSubImage2D(Z.TEXTURE_2D,Kt,je,En,se,me,Un,De,cn.data):q.isCompressedTexture?Z.compressedTexSubImage2D(Z.TEXTURE_2D,Kt,je,En,cn.width,cn.height,Un,cn.data):Z.texSubImage2D(Z.TEXTURE_2D,Kt,je,En,se,me,Un,De,cn);Z.pixelStorei(Z.UNPACK_ROW_LENGTH,mn),Z.pixelStorei(Z.UNPACK_IMAGE_HEIGHT,ri),Z.pixelStorei(Z.UNPACK_SKIP_PIXELS,Ia),Z.pixelStorei(Z.UNPACK_SKIP_ROWS,Vn),Z.pixelStorei(Z.UNPACK_SKIP_IMAGES,Ba),Kt===0&&ut.generateMipmaps&&Z.generateMipmap(Ln),kt.unbindTexture()},this.initRenderTarget=function(q){$t.get(q).__webglFramebuffer===void 0&&fe.setupRenderTarget(q)},this.initTexture=function(q){q.isCubeTexture?fe.setTextureCube(q,0):q.isData3DTexture?fe.setTexture3D(q,0):q.isDataArrayTexture||q.isCompressedArrayTexture?fe.setTexture2DArray(q,0):fe.setTexture2D(q,0),kt.unbindTexture()},this.resetState=function(){P=0,z=0,L=null,kt.reset(),lt.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return Hr}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(t){this._outputColorSpace=t;const e=this.getContext();e.drawingBufferColorSpace=Gn._getDrawingBufferColorSpace(t),e.unpackColorSpace=Gn._getUnpackColorSpace()}}const jO=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:hS,AddEquation:rh,AddOperation:UM,AdditiveAnimationBlendMode:xS,AdditiveBlending:Sb,AgXToneMapping:PM,AlphaFormat:mS,AlwaysCompare:nw,AlwaysDepth:Av,AlwaysStencilFunc:wb,AmbientLight:Vw,AnimationAction:Kw,AnimationClip:Wm,AnimationLoader:rN,AnimationMixer:NN,AnimationObjectGroup:DN,AnimationUtils:nN,ArcCurve:mw,ArrayCamera:Zw,ArrowHelper:sU,AttachedBindMode:Mb,Audio:Ww,AudioAnalyser:_N,AudioContext:jS,AudioListener:xN,AudioLoader:gN,AxesHelper:aU,BackSide:_a,BasicDepthPacking:XM,BasicShadowMap:pM,BatchedMesh:RS,Bone:DS,BooleanKeyframeTrack:eA,Box2:HN,Box3:kn,Box3Helper:nU,BoxGeometry:pr,BoxHelper:eU,BufferAttribute:Qn,BufferGeometry:Fe,BufferGeometryLoader:Jw,ByteType:AS,Cache:ec,Camera:pE,CameraHelper:tU,CanvasTexture:SR,CapsuleGeometry:_E,CatmullRomCurve3:yw,CineonToneMapping:OM,CircleGeometry:CE,ClampToEdgeWrapping:yr,Clock:h0,Color:le,ColorKeyframeTrack:XS,ColorManagement:Gn,CompressedArrayTexture:CR,CompressedCubeTexture:bR,CompressedTexture:EE,CompressedTextureLoader:oN,ConeGeometry:o0,ConstantAlphaFactor:DM,ConstantColorFactor:TM,Controls:oU,CubeCamera:MS,CubeReflectionMapping:eu,CubeRefractionMapping:fh,CubeTexture:r0,CubeTextureLoader:lN,CubeUVReflectionMapping:rp,CubicBezierCurve:OS,CubicBezierCurve3:xw,CubicInterpolant:zw,CullFaceBack:bb,CullFaceFront:dM,CullFaceFrontBack:NQ,CullFaceNone:AM,Curve:gl,CurvePath:Ew,CustomBlending:gM,CustomToneMapping:FM,CylinderGeometry:Ea,Cylindrical:kN,Data3DTexture:a0,DataArrayTexture:hl,DataTexture:So,DataTextureLoader:cN,DataUtils:JD,DecrementStencilOp:XQ,DecrementWrapStencilOp:ZQ,DefaultLoadingManager:Hd,DepthFormat:Wd,DepthStencilFormat:jd,DepthTexture:US,DetachedBindMode:kM,DirectionalLight:Hw,DirectionalLightHelper:$N,DiscreteInterpolant:Ow,DodecahedronGeometry:bE,DoubleSide:gr,DstAlphaFactor:SM,DstColorFactor:BM,DynamicCopyUsage:cD,DynamicDrawUsage:iw,DynamicReadUsage:rD,EdgesGeometry:gw,EllipseCurve:SE,EqualCompare:KM,EqualDepth:pv,EqualStencilFunc:$Q,EquirectangularReflectionMapping:Rm,EquirectangularRefractionMapping:Nm,Euler:_r,EventDispatcher:rc,ExternalTexture:LS,ExtrudeGeometry:IE,FileLoader:ac,Float16BufferAttribute:eR,Float32BufferAttribute:Ce,FloatType:xr,Fog:mE,FogExp2:gE,FramebufferTexture:_R,FrontSide:fl,Frustum:op,FrustumArray:vE,GLBufferAttribute:FN,GLSL1:hD,GLSL3:Gm,GreaterCompare:$M,GreaterDepth:mv,GreaterEqualCompare:ew,GreaterEqualDepth:gv,GreaterEqualStencilFunc:iD,GreaterStencilFunc:eD,GridHelper:jN,Group:Nf,HalfFloatType:$f,HemisphereLight:Pw,HemisphereLightHelper:WN,IcosahedronGeometry:BE,ImageBitmapLoader:pN,ImageLoader:jm,ImageUtils:rw,IncrementStencilOp:qQ,IncrementWrapStencilOp:JQ,InstancedBufferAttribute:Xf,InstancedBufferGeometry:WS,InstancedInterleavedBuffer:ON,InstancedMesh:Hf,Int16BufferAttribute:$D,Int32BufferAttribute:tR,Int8BufferAttribute:WD,IntType:cE,InterleavedBuffer:yE,InterleavedBufferAttribute:qf,Interpolant:c0,InterpolateDiscrete:zm,InterpolateLinear:Xv,InterpolateSmooth:nv,InterpolationSamplingMode:dD,InterpolationSamplingType:AD,InvertStencilOp:WQ,KeepStencilOp:Mf,KeyframeTrack:Bo,LOD:hw,LatheGeometry:ME,Layers:ep,LessCompare:jM,LessDepth:dv,LessEqualCompare:vS,LessEqualDepth:Yf,LessEqualStencilFunc:tD,LessStencilFunc:KQ,Light:yh,LightProbe:Xw,Line:Sn,Line3:vr,LineBasicMaterial:na,LineCurve:FS,LineCurve3:vw,LineDashedMaterial:Nw,LineLoop:Aw,LineSegments:oc,LinearFilter:as,LinearInterpolant:qS,LinearMipMapLinearFilter:HM,LinearMipMapNearestFilter:zQ,LinearMipmapLinearFilter:tc,LinearMipmapNearestFilter:mm,LinearSRGBColorSpace:Ah,LinearToneMapping:LM,LinearTransfer:Fm,Loader:tr,LoaderUtils:Nb,LoadingManager:JS,LoopOnce:VM,LoopPingPong:qM,LoopRepeat:YM,MOUSE:DQ,Material:ba,MaterialLoader:UE,MathUtils:_S,Matrix2:A0,Matrix3:Ze,Matrix4:he,MaxEquation:vM,Mesh:oe,MeshBasicMaterial:pl,MeshDepthMaterial:HS,MeshDistanceMaterial:VS,MeshLambertMaterial:Dw,MeshMatcapMaterial:Rw,MeshNormalMaterial:Qw,MeshPhongMaterial:ww,MeshPhysicalMaterial:Mw,MeshStandardMaterial:Xm,MeshToonMaterial:Tw,MinEquation:xM,MirroredRepeatWrapping:Lm,MixOperation:NM,MultiplyBlending:Bb,MultiplyOperation:n0,NearestFilter:rs,NearestMipMapLinearFilter:LQ,NearestMipMapNearestFilter:UQ,NearestMipmapLinearFilter:Gd,NearestMipmapNearestFilter:fS,NeutralToneMapping:GM,NeverCompare:WM,NeverDepth:fv,NeverStencilFunc:jQ,NoBlending:nc,NoColorSpace:Wc,NoToneMapping:ic,NormalAnimationBlendMode:dE,NormalBlending:Gf,NotEqualCompare:tw,NotEqualDepth:yv,NotEqualStencilFunc:nD,NumberKeyframeTrack:Jm,Object3D:gn,ObjectLoader:AN,ObjectSpaceNormalMap:ZM,OctahedronGeometry:xo,OneFactor:_M,OneMinusConstantAlphaFactor:RM,OneMinusConstantColorFactor:QM,OneMinusDstAlphaFactor:IM,OneMinusDstColorFactor:MM,OneMinusSrcAlphaFactor:hv,OneMinusSrcColorFactor:bM,OrthographicCamera:cp,PCFShadowMap:oE,PCFSoftShadowMap:gm,PMREMGenerator:Kv,Path:jv,PerspectiveCamera:As,Plane:Kl,PlaneGeometry:kr,PlaneHelper:iU,PointLight:kw,PointLightHelper:JN,Points:dw,PointsMaterial:NS,PolarGridHelper:KN,PolyhedronGeometry:mh,PositionalAudio:EN,PropertyBinding:qn,PropertyMixer:jw,QuadraticBezierCurve:PS,QuadraticBezierCurve3:GS,Quaternion:Ge,QuaternionKeyframeTrack:u0,QuaternionLinearInterpolant:Fw,RED_GREEN_RGTC2_Format:Yv,RED_RGTC1_Format:Hv,REVISION:Kf,RGBADepthPacking:JM,RGBAFormat:Ki,RGBAIntegerFormat:sc,RGBA_ASTC_10x10_Format:zv,RGBA_ASTC_10x5_Format:Nv,RGBA_ASTC_10x6_Format:Uv,RGBA_ASTC_10x8_Format:Lv,RGBA_ASTC_12x10_Format:Ov,RGBA_ASTC_12x12_Format:Fv,RGBA_ASTC_4x4_Format:Iv,RGBA_ASTC_5x4_Format:Bv,RGBA_ASTC_5x5_Format:Mv,RGBA_ASTC_6x5_Format:wv,RGBA_ASTC_6x6_Format:Tv,RGBA_ASTC_8x5_Format:Qv,RGBA_ASTC_8x6_Format:Dv,RGBA_ASTC_8x8_Format:Rv,RGBA_BPTC_Format:Pv,RGBA_ETC2_EAC_Format:Sv,RGBA_PVRTC_2BPPV1_Format:_v,RGBA_PVRTC_4BPPV1_Format:Ev,RGBA_S3TC_DXT1_Format:xm,RGBA_S3TC_DXT3_Format:vm,RGBA_S3TC_DXT5_Format:Em,RGBDepthPacking:kQ,RGBFormat:yS,RGBIntegerFormat:OQ,RGB_BPTC_SIGNED_Format:Gv,RGB_BPTC_UNSIGNED_Format:kv,RGB_ETC1_Format:Cv,RGB_ETC2_Format:bv,RGB_PVRTC_2BPPV1_Format:vv,RGB_PVRTC_4BPPV1_Format:xv,RGB_S3TC_DXT1_Format:ym,RGDepthPacking:HQ,RGFormat:AE,RGIntegerFormat:s0,RawShaderMaterial:l0,Ray:tA,Raycaster:f0,RectAreaLight:Yw,RedFormat:fE,RedIntegerFormat:i0,ReinhardToneMapping:zM,RenderTarget:CS,RenderTarget3D:UN,RepeatWrapping:Um,ReplaceStencilOp:YQ,ReverseSubtractEquation:yM,RingGeometry:wE,SIGNED_RED_GREEN_RGTC2_Format:qv,SIGNED_RED_RGTC1_Format:Vv,SRGBColorSpace:ks,SRGBTransfer:ui,Scene:TS,ShaderChunk:An,ShaderLib:ol,ShaderMaterial:$a,ShadowMaterial:Bw,Shape:Vf,ShapeGeometry:TE,ShapePath:rU,ShapeUtils:cl,ShortType:dS,Skeleton:xE,SkeletonHelper:XN,SkinnedMesh:fw,Source:lh,Sphere:Bs,SphereGeometry:lp,Spherical:$w,SphericalHarmonics3:qw,SplineCurve:kS,SpotLight:Gw,SpotLightHelper:qN,Sprite:uw,SpriteMaterial:QS,SrcAlphaFactor:uv,SrcAlphaSaturateFactor:wM,SrcColorFactor:CM,StaticCopyUsage:lD,StaticDrawUsage:Pm,StaticReadUsage:aD,StereoCamera:mN,StreamCopyUsage:uD,StreamDrawUsage:sD,StreamReadUsage:oD,StringKeyframeTrack:nA,SubtractEquation:mM,SubtractiveBlending:Ib,TOUCH:RQ,TangentSpaceNormalMap:gh,TetrahedronGeometry:QE,Texture:wi,TextureLoader:NE,TextureUtils:fU,Timer:PN,TimestampQuery:fD,TorusGeometry:ch,TorusKnotGeometry:DE,Triangle:ds,TriangleFanDrawMode:GQ,TriangleStripDrawMode:PQ,TrianglesDrawMode:FQ,TubeGeometry:RE,UVMapping:lE,Uint16BufferAttribute:SS,Uint32BufferAttribute:IS,Uint8BufferAttribute:jD,Uint8ClampedBufferAttribute:KD,Uniform:LE,UniformsGroup:zN,UniformsLib:pe,UniformsUtils:BS,UnsignedByteType:ea,UnsignedInt101111Type:gS,UnsignedInt248Type:Zd,UnsignedInt5999Type:pS,UnsignedIntType:Ca,UnsignedShort4444Type:uE,UnsignedShort5551Type:hE,UnsignedShortType:Jd,VSMShadowMap:rl,Vector2:Dt,Vector3:F,Vector4:We,VectorKeyframeTrack:Zm,VideoFrameTexture:ER,VideoTexture:pw,WebGL3DRenderTarget:OD,WebGLArrayRenderTarget:bS,WebGLCoordinateSystem:Hr,WebGLCubeRenderTarget:wS,WebGLRenderTarget:Io,WebGLRenderer:o3,WebGLUtils:r3,WebGPUCoordinateSystem:Kd,WebXRController:iv,WireframeGeometry:Iw,WrapAroundEnding:Om,ZeroCurvatureEnding:Df,ZeroFactor:EM,ZeroSlopeEnding:Rf,ZeroStencilOp:VQ,createCanvasElement:aw,error:nn,getConsoleFunction:mD,log:Hm,setConsoleFunction:gD,warn:ge,warnOnce:$d},Symbol.toStringTag,{value:"Module"}));var QC={exports:{}},DC={},RC={exports:{}},NC={};var Z2;function KO(){if(Z2)return NC;Z2=1;var s=ap();function t(g,y){return g===y&&(g!==0||1/g===1/y)||g!==g&&y!==y}var e=typeof Object.is=="function"?Object.is:t,n=s.useState,i=s.useEffect,r=s.useLayoutEffect,l=s.useDebugValue;function u(g,y){var v=y(),C=n({inst:{value:v,getSnapshot:y}}),I=C[0].inst,S=C[1];return r(function(){I.value=v,I.getSnapshot=y,A(I)&&S({inst:I})},[g,v,y]),i(function(){return A(I)&&S({inst:I}),g(function(){A(I)&&S({inst:I})})},[g]),l(v),v}function A(g){var y=g.getSnapshot;g=g.value;try{var v=y();return!e(g,v)}catch{return!0}}function d(g,y){return y()}var m=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?d:u;return NC.useSyncExternalStore=s.useSyncExternalStore!==void 0?s.useSyncExternalStore:m,NC}var W2;function $O(){return W2||(W2=1,RC.exports=KO()),RC.exports}var j2;function tF(){if(j2)return DC;j2=1;var s=ap(),t=$O();function e(d,m){return d===m&&(d!==0||1/d===1/m)||d!==d&&m!==m}var n=typeof Object.is=="function"?Object.is:e,i=t.useSyncExternalStore,r=s.useRef,l=s.useEffect,u=s.useMemo,A=s.useDebugValue;return DC.useSyncExternalStoreWithSelector=function(d,m,g,y,v){var C=r(null);if(C.current===null){var I={hasValue:!1,value:null};C.current=I}else I=C.current;C=u(function(){function E(D){if(!B){if(B=!0,w=D,D=y(D),v!==void 0&&I.hasValue){var U=I.value;if(v(U,D))return Q=U}return Q=D}if(U=Q,n(w,D))return U;var P=y(D);return v!==void 0&&v(U,P)?(w=D,U):(w=D,Q=P)}var B=!1,w,Q,R=g===void 0?null:g;return[function(){return E(m())},R===null?void 0:function(){return E(R())}]},[m,g,y,v]);var S=i(d,C[0],C[1]);return l(function(){I.hasValue=!0,I.value=S},[S]),A(S),S},DC}var K2;function eF(){return K2||(K2=1,QC.exports=tF()),QC.exports}var nF=eF();const iF=uS(nF),$2=s=>{let t;const e=new Set,n=(d,m)=>{const g=typeof d=="function"?d(t):d;if(!Object.is(g,t)){const y=t;t=m??(typeof g!="object"||g===null)?g:Object.assign({},t,g),e.forEach(v=>v(t,y))}},i=()=>t,u={setState:n,getState:i,getInitialState:()=>A,subscribe:d=>(e.add(d),()=>e.delete(d))},A=t=s(n,i,u);return u},l3=(s=>s?$2(s):$2),{useSyncExternalStoreWithSelector:sF}=iF,aF=s=>s;function rF(s,t=aF,e){const n=sF(s.subscribe,s.getState,s.getInitialState,t,e);return Xe.useDebugValue(n),n}const tB=(s,t)=>{const e=l3(s),n=(i,r=t)=>rF(e,i,r);return Object.assign(n,e),n},oF=((s,t)=>s?tB(s,t):tB),lF=s=>typeof s=="object"&&typeof s.then=="function",Lf=[];function c3(s,t,e=(n,i)=>n===i){if(s===t)return!0;if(!s||!t)return!1;const n=s.length;if(t.length!==n)return!1;for(let i=0;i<n;i++)if(!e(s[i],t[i]))return!1;return!0}function u3(s,t=null,e=!1,n={}){t===null&&(t=[s]);for(const r of Lf)if(c3(t,r.keys,r.equal)){if(e)return;if(Object.prototype.hasOwnProperty.call(r,"error"))throw r.error;if(Object.prototype.hasOwnProperty.call(r,"response"))return n.lifespan&&n.lifespan>0&&(r.timeout&&clearTimeout(r.timeout),r.timeout=setTimeout(r.remove,n.lifespan)),r.response;if(!e)throw r.promise}const i={keys:t,equal:n.equal,remove:()=>{const r=Lf.indexOf(i);r!==-1&&Lf.splice(r,1)},promise:(lF(s)?s:s(...t)).then(r=>{i.response=r,n.lifespan&&n.lifespan>0&&(i.timeout=setTimeout(i.remove,n.lifespan))}).catch(r=>i.error=r)};if(Lf.push(i),!e)throw i.promise}const cF=(s,t,e)=>u3(s,t,!1,e),uF=(s,t,e)=>{u3(s,t,!0,e)},hF=s=>{if(s===void 0||s.length===0)Lf.splice(0,Lf.length);else{const t=Lf.find(e=>c3(s,e.keys,e.equal));t&&t.remove()}};var UC={exports:{}},LC={exports:{}},zC={exports:{}},OC={};var eB;function fF(){return eB||(eB=1,(function(s){function t(H,tt){var it=H.length;H.push(tt);t:for(;0<it;){var ot=it-1>>>1,At=H[ot];if(0<i(At,tt))H[ot]=tt,H[it]=At,it=ot;else break t}}function e(H){return H.length===0?null:H[0]}function n(H){if(H.length===0)return null;var tt=H[0],it=H.pop();if(it!==tt){H[0]=it;t:for(var ot=0,At=H.length,V=At>>>1;ot<V;){var st=2*(ot+1)-1,xt=H[st],j=st+1,Rt=H[j];if(0>i(xt,it))j<At&&0>i(Rt,xt)?(H[ot]=Rt,H[j]=it,ot=j):(H[ot]=xt,H[st]=it,ot=st);else if(j<At&&0>i(Rt,it))H[ot]=Rt,H[j]=it,ot=j;else break t}}return tt}function i(H,tt){var it=H.sortIndex-tt.sortIndex;return it!==0?it:H.id-tt.id}if(s.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var r=performance;s.unstable_now=function(){return r.now()}}else{var l=Date,u=l.now();s.unstable_now=function(){return l.now()-u}}var A=[],d=[],m=1,g=null,y=3,v=!1,C=!1,I=!1,S=typeof setTimeout=="function"?setTimeout:null,E=typeof clearTimeout=="function"?clearTimeout:null,B=typeof setImmediate<"u"?setImmediate:null;function w(H){for(var tt=e(d);tt!==null;){if(tt.callback===null)n(d);else if(tt.startTime<=H)n(d),tt.sortIndex=tt.expirationTime,t(A,tt);else break;tt=e(d)}}function Q(H){if(I=!1,w(H),!C)if(e(A)!==null)C=!0,K();else{var tt=e(d);tt!==null&&nt(Q,tt.startTime-H)}}var R=!1,D=-1,U=5,P=-1;function z(){return!(s.unstable_now()-P<U)}function L(){if(R){var H=s.unstable_now();P=H;var tt=!0;try{t:{C=!1,I&&(I=!1,E(D),D=-1),v=!0;var it=y;try{e:{for(w(H),g=e(A);g!==null&&!(g.expirationTime>H&&z());){var ot=g.callback;if(typeof ot=="function"){g.callback=null,y=g.priorityLevel;var At=ot(g.expirationTime<=H);if(H=s.unstable_now(),typeof At=="function"){g.callback=At,w(H),tt=!0;break e}g===e(A)&&n(A),w(H)}else n(A);g=e(A)}if(g!==null)tt=!0;else{var V=e(d);V!==null&&nt(Q,V.startTime-H),tt=!1}}break t}finally{g=null,y=it,v=!1}tt=void 0}}finally{tt?k():R=!1}}}var k;if(typeof B=="function")k=function(){B(L)};else if(typeof MessageChannel<"u"){var Y=new MessageChannel,W=Y.port2;Y.port1.onmessage=L,k=function(){W.postMessage(null)}}else k=function(){S(L,0)};function K(){R||(R=!0,k())}function nt(H,tt){D=S(function(){H(s.unstable_now())},tt)}s.unstable_IdlePriority=5,s.unstable_ImmediatePriority=1,s.unstable_LowPriority=4,s.unstable_NormalPriority=3,s.unstable_Profiling=null,s.unstable_UserBlockingPriority=2,s.unstable_cancelCallback=function(H){H.callback=null},s.unstable_continueExecution=function(){C||v||(C=!0,K())},s.unstable_forceFrameRate=function(H){0>H||125<H?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):U=0<H?Math.floor(1e3/H):5},s.unstable_getCurrentPriorityLevel=function(){return y},s.unstable_getFirstCallbackNode=function(){return e(A)},s.unstable_next=function(H){switch(y){case 1:case 2:case 3:var tt=3;break;default:tt=y}var it=y;y=tt;try{return H()}finally{y=it}},s.unstable_pauseExecution=function(){},s.unstable_requestPaint=function(){},s.unstable_runWithPriority=function(H,tt){switch(H){case 1:case 2:case 3:case 4:case 5:break;default:H=3}var it=y;y=H;try{return tt()}finally{y=it}},s.unstable_scheduleCallback=function(H,tt,it){var ot=s.unstable_now();switch(typeof it=="object"&&it!==null?(it=it.delay,it=typeof it=="number"&&0<it?ot+it:ot):it=ot,H){case 1:var At=-1;break;case 2:At=250;break;case 5:At=1073741823;break;case 4:At=1e4;break;default:At=5e3}return At=it+At,H={id:m++,callback:tt,priorityLevel:H,startTime:it,expirationTime:At,sortIndex:-1},it>ot?(H.sortIndex=it,t(d,H),e(A)===null&&H===e(d)&&(I?(E(D),D=-1):I=!0,nt(Q,it-ot))):(H.sortIndex=At,t(A,H),C||v||(C=!0,K())),H},s.unstable_shouldYield=z,s.unstable_wrapCallback=function(H){var tt=y;return function(){var it=y;y=tt;try{return H.apply(this,arguments)}finally{y=it}}}})(OC)),OC}var nB;function h3(){return nB||(nB=1,zC.exports=fF()),zC.exports}var iB;function AF(){return iB||(iB=1,(function(s){s.exports=function(t){function e(c,h,x,b){return new Up(c,h,x,b)}function n(){}function i(c){var h="https://react.dev/errors/"+c;if(1<arguments.length){h+="?args[]="+encodeURIComponent(arguments[1]);for(var x=2;x<arguments.length;x++)h+="&args[]="+encodeURIComponent(arguments[x])}return"Minified React error #"+c+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function r(c){return c===null||typeof c!="object"?null:(c=kp&&c[kp]||c["@@iterator"],typeof c=="function"?c:null)}function l(c){if(c==null)return null;if(typeof c=="function")return c.$$typeof===Sc?null:c.displayName||c.name||null;if(typeof c=="string")return c;switch(c){case bu:return"Fragment";case Qr:return"Portal";case Gp:return"Profiler";case Pp:return"StrictMode";case _A:return"Suspense";case Nl:return"SuspenseList"}if(typeof c=="object")switch(c.$$typeof){case so:return(c.displayName||"Context")+".Provider";case Rl:return(c._context.displayName||"Context")+".Consumer";case Su:var h=c.render;return c=c.displayName,c||(c=h.displayName||h.name||"",c=c!==""?"ForwardRef("+c+")":"ForwardRef"),c;case Uh:return h=c.displayName||null,h!==null?h:l(c.type)||"Memo";case Dr:h=c._payload,c=c._init;try{return l(c(h))}catch{}}return null}function u(c){if(CA===void 0)try{throw Error()}catch(x){var h=x.stack.trim().match(/\n( *(at )?)/);CA=h&&h[1]||"",Hp=-1<x.stack.indexOf(`
    at`)?" (<anonymous>)":-1<x.stack.indexOf("@")?"@unknown:0:0":""}return`
`+CA+c+Hp}function A(c,h){if(!c||Ul)return"";Ul=!0;var x=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var b={DetermineComponentFrameRoot:function(){try{if(h){var de=function(){throw Error()};if(Object.defineProperty(de.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(de,[])}catch(tn){var xe=tn}Reflect.construct(c,[],de)}else{try{de.call()}catch(tn){xe=tn}c.call(de.prototype)}}else{try{throw Error()}catch(tn){xe=tn}(de=c())&&typeof de.catch=="function"&&de.catch(function(){})}}catch(tn){if(tn&&xe&&typeof tn.stack=="string")return[tn.stack,xe.stack]}return[null,null]}};b.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var T=Object.getOwnPropertyDescriptor(b.DetermineComponentFrameRoot,"name");T&&T.configurable&&Object.defineProperty(b.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var N=b.DetermineComponentFrameRoot(),J=N[0],at=N[1];if(J&&at){var yt=J.split(`
`),Ut=at.split(`
`);for(T=b=0;b<yt.length&&!yt[b].includes("DetermineComponentFrameRoot");)b++;for(;T<Ut.length&&!Ut[T].includes("DetermineComponentFrameRoot");)T++;if(b===yt.length||T===Ut.length)for(b=yt.length-1,T=Ut.length-1;1<=b&&0<=T&&yt[b]!==Ut[T];)T--;for(;1<=b&&0<=T;b--,T--)if(yt[b]!==Ut[T]){if(b!==1||T!==1)do if(b--,T--,0>T||yt[b]!==Ut[T]){var ne=`
`+yt[b].replace(" at new "," at ");return c.displayName&&ne.includes("<anonymous>")&&(ne=ne.replace("<anonymous>",c.displayName)),ne}while(1<=b&&0<=T);break}}}finally{Ul=!1,Error.prepareStackTrace=x}return(x=c?c.displayName||c.name:"")?u(x):""}function d(c){switch(c.tag){case 26:case 27:case 5:return u(c.type);case 16:return u("Lazy");case 13:return u("Suspense");case 19:return u("SuspenseList");case 0:case 15:return c=A(c.type,!1),c;case 11:return c=A(c.type.render,!1),c;case 1:return c=A(c.type,!0),c;default:return""}}function m(c){try{var h="";do h+=d(c),c=c.return;while(c);return h}catch(x){return`
Error generating stack: `+x.message+`
`+x.stack}}function g(c){var h=c,x=c;if(c.alternate)for(;h.return;)h=h.return;else{c=h;do h=c,(h.flags&4098)!==0&&(x=h.return),c=h.return;while(c)}return h.tag===3?x:null}function y(c){if(g(c)!==c)throw Error(i(188))}function v(c){var h=c.alternate;if(!h){if(h=g(c),h===null)throw Error(i(188));return h!==c?null:c}for(var x=c,b=h;;){var T=x.return;if(T===null)break;var N=T.alternate;if(N===null){if(b=T.return,b!==null){x=b;continue}break}if(T.child===N.child){for(N=T.child;N;){if(N===x)return y(T),c;if(N===b)return y(T),h;N=N.sibling}throw Error(i(188))}if(x.return!==b.return)x=T,b=N;else{for(var J=!1,at=T.child;at;){if(at===x){J=!0,x=T,b=N;break}if(at===b){J=!0,b=T,x=N;break}at=at.sibling}if(!J){for(at=N.child;at;){if(at===x){J=!0,x=N,b=T;break}if(at===b){J=!0,b=N,x=T;break}at=at.sibling}if(!J)throw Error(i(189))}}if(x.alternate!==b)throw Error(i(190))}if(x.tag!==3)throw Error(i(188));return x.stateNode.current===x?c:h}function C(c){var h=c.tag;if(h===5||h===26||h===27||h===6)return c;for(c=c.child;c!==null;){if(h=C(c),h!==null)return h;c=c.sibling}return null}function I(c){var h=c.tag;if(h===5||h===26||h===27||h===6)return c;for(c=c.child;c!==null;){if(c.tag!==4&&(h=I(c),h!==null))return h;c=c.sibling}return null}function S(c){return{current:c}}function E(c){0>Vo||(c.current=Vh[Vo],Vh[Vo]=null,Vo--)}function B(c,h){Vo++,Vh[Vo]=c.current,c.current=h}function w(c){return c>>>=0,c===0?32:31-(Yh(c)/cy|0)|0}function Q(c){var h=c&42;if(h!==0)return h;switch(c&-c){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return c&4194176;case 4194304:case 8388608:case 16777216:case 33554432:return c&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return c}}function R(c,h){var x=c.pendingLanes;if(x===0)return 0;var b=0,T=c.suspendedLanes,N=c.pingedLanes,J=c.warmLanes;c=c.finishedLanes!==0;var at=x&134217727;return at!==0?(x=at&~T,x!==0?b=Q(x):(N&=at,N!==0?b=Q(N):c||(J=at&~J,J!==0&&(b=Q(J))))):(at=x&~T,at!==0?b=Q(at):N!==0?b=Q(N):c||(J=x&~J,J!==0&&(b=Q(J)))),b===0?0:h!==0&&h!==b&&(h&T)===0&&(T=b&-b,J=h&-h,T>=J||T===32&&(J&4194176)!==0)?h:b}function D(c,h){return(c.pendingLanes&~(c.suspendedLanes&~c.pingedLanes)&h)===0}function U(c,h){switch(c){case 1:case 2:case 4:case 8:return h+250;case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return h+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function P(){var c=wu;return wu<<=1,(wu&4194176)===0&&(wu=128),c}function z(){var c=qh;return qh<<=1,(qh&62914560)===0&&(qh=4194304),c}function L(c){for(var h=[],x=0;31>x;x++)h.push(c);return h}function k(c,h){c.pendingLanes|=h,h!==268435456&&(c.suspendedLanes=0,c.pingedLanes=0,c.warmLanes=0)}function Y(c,h,x,b,T,N){var J=c.pendingLanes;c.pendingLanes=x,c.suspendedLanes=0,c.pingedLanes=0,c.warmLanes=0,c.expiredLanes&=x,c.entangledLanes&=x,c.errorRecoveryDisabledLanes&=x,c.shellSuspendCounter=0;var at=c.entanglements,yt=c.expirationTimes,Ut=c.hiddenUpdates;for(x=J&~x;0<x;){var ne=31-la(x),de=1<<ne;at[ne]=0,yt[ne]=-1;var xe=Ut[ne];if(xe!==null)for(Ut[ne]=null,ne=0;ne<xe.length;ne++){var tn=xe[ne];tn!==null&&(tn.lane&=-536870913)}x&=~de}b!==0&&W(c,b,0),N!==0&&T===0&&c.tag!==0&&(c.suspendedLanes|=N&~(J&~h))}function W(c,h,x){c.pendingLanes|=h,c.suspendedLanes&=~h;var b=31-la(h);c.entangledLanes|=h,c.entanglements[b]=c.entanglements[b]|1073741824|x&4194218}function K(c,h){var x=c.entangledLanes|=h;for(c=c.entanglements;x;){var b=31-la(x),T=1<<b;T&h|c[b]&h&&(c[b]|=h),x&=~T}}function nt(c){return c&=-c,2<c?8<c?(c&134217727)!==0?32:268435456:8:2}function H(c){if(ca&&typeof ca.onCommitFiberRoot=="function")try{ca.onCommitFiberRoot(Qu,c,void 0,(c.current.flags&128)===128)}catch{}}function tt(c){if(typeof Ay=="function"&&vg(c),ca&&typeof ca.setStrictMode=="function")try{ca.setStrictMode(Qu,c)}catch{}}function it(c,h){return c===h&&(c!==0||1/c===1/h)||c!==c&&h!==h}function ot(c,h){if(typeof c=="object"&&c!==null){var x=PA.get(c);return x!==void 0?x:(h={value:c,source:h,stack:m(h)},PA.set(c,h),h)}return{value:c,source:h,stack:m(h)}}function At(c,h){yi[Ni++]=Zh,yi[Ni++]=Jh,Jh=c,Zh=h}function V(c,h,x){za[Oa++]=co,za[Oa++]=rr,za[Oa++]=Rr,Rr=c;var b=co;c=rr;var T=32-la(b)-1;b&=~(1<<T),x+=1;var N=32-la(h)+T;if(30<N){var J=T-T%5;N=(b&(1<<J)-1).toString(32),b>>=J,T-=J,co=1<<32-la(h)+T|x<<T|b,rr=N+c}else co=1<<N|x<<T|b,rr=c}function st(c){c.return!==null&&(At(c,1),V(c,1,0))}function xt(c){for(;c===Jh;)Jh=yi[--Ni],yi[Ni]=null,Zh=yi[--Ni],yi[Ni]=null;for(;c===Rr;)Rr=za[--Oa],za[Oa]=null,rr=za[--Oa],za[Oa]=null,co=za[--Oa],za[Oa]=null}function j(c,h){B(Nr,h),B(Wh,c),B(hs,null),c=Ic(h),E(hs),B(hs,c)}function Rt(){E(hs),E(Wh),E(Nr)}function dt(c){c.memoizedState!==null&&B(Du,c);var h=hs.current,x=k0(h,c.type);h!==x&&(B(Wh,c),B(hs,x))}function pt(c){Wh.current===c&&(E(hs),E(Wh)),Du.current===c&&(E(Du),ro?Ye._currentValue=oa:Ye._currentValue2=oa)}function qt(c){var h=Error(i(418,""));throw be(ot(h,c)),jh}function Wt(c,h){if(!Zs)throw Error(i(175));s_(c.stateNode,c.type,c.memoizedProps,h,c)||qt(c)}function ce(c){for(zs=c.return;zs;)switch(zs.tag){case 3:case 27:or=!0;return;case 5:case 13:or=!1;return;default:zs=zs.return}}function Ie(c){if(!Zs||c!==zs)return!1;if(!zn)return ce(c),zn=!0,!1;var h=!1;if(_s?c.tag!==3&&c.tag!==27&&(c.tag!==5||sy(c.type)&&!Ol(c.type,c.memoizedProps))&&(h=!0):c.tag!==3&&(c.tag!==5||sy(c.type)&&!Ol(c.type,c.memoizedProps))&&(h=!0),h&&bs&&qt(c),ce(c),c.tag===13){if(!Zs)throw Error(i(316));if(c=c.memoizedState,c=c!==null?c.dehydrated:null,!c)throw Error(i(317));bs=ny(c)}else bs=zs?og(c.stateNode):null;return!0}function He(){Zs&&(bs=zs=null,zn=!1)}function be(c){Fa===null?Fa=[c]:Fa.push(c)}function zt(){for(var c=Pl,h=Ru=Pl=0;h<c;){var x=Pa[h];Pa[h++]=null;var b=Pa[h];Pa[h++]=null;var T=Pa[h];Pa[h++]=null;var N=Pa[h];if(Pa[h++]=null,b!==null&&T!==null){var J=b.pending;J===null?T.next=T:(T.next=J.next,J.next=T),b.pending=T}N!==0&&Pt(x,T,N)}}function Z(c,h,x,b){Pa[Pl++]=c,Pa[Pl++]=h,Pa[Pl++]=x,Pa[Pl++]=b,Ru|=b,c.lanes|=b,c=c.alternate,c!==null&&(c.lanes|=b)}function Ot(c,h,x,b){return Z(c,h,x,b),kt(c)}function Vt(c,h){return Z(c,null,null,h),kt(c)}function Pt(c,h,x){c.lanes|=x;var b=c.alternate;b!==null&&(b.lanes|=x);for(var T=!1,N=c.return;N!==null;)N.childLanes|=x,b=N.alternate,b!==null&&(b.childLanes|=x),N.tag===22&&(c=N.stateNode,c===null||c._visibility&1||(T=!0)),c=N,N=N.return;T&&h!==null&&c.tag===3&&(N=c.stateNode,T=31-la(x),N=N.hiddenUpdates,c=N[T],c===null?N[T]=[h]:c.push(h),h.lane=x|536870912)}function kt(c){if(50<zc)throw zc=0,Ks=null,Error(i(185));for(var h=c.return;h!==null;)c=h,h=c.return;return c.tag===3?c.stateNode:null}function Zt(c){c!==Tc&&c.next===null&&(Tc===null?Nu=Tc=c:Tc=Tc.next=c),$h=!0,Kh||(Kh=!0,Tt(fe))}function $t(c,h){if(!Ur&&$h){Ur=!0;do for(var x=!1,b=Nu;b!==null;){if(c!==0){var T=b.pendingLanes;if(T===0)var N=0;else{var J=b.suspendedLanes,at=b.pingedLanes;N=(1<<31-la(42|c)+1)-1,N&=T&~(J&~at),N=N&201326677?N&201326677|1:N?N|2:0}N!==0&&(x=!0,ft(b,N))}else N=yn,N=R(b,b===Cn?N:0),(N&3)===0||D(b,N)||(x=!0,ft(b,N));b=b.next}while(x);Ur=!1}}function fe(){$h=Kh=!1;var c=0;Gl!==0&&(Fl()&&(c=Gl),Gl=0);for(var h=Cs(),x=null,b=Nu;b!==null;){var T=b.next,N=$(b,h);N===0?(b.next=null,x===null?Nu=T:x.next=T,T===null&&(Tc=x)):(x=b,(c!==0||(N&3)!==0)&&($h=!0)),b=T}$t(c)}function $(c,h){for(var x=c.suspendedLanes,b=c.pingedLanes,T=c.expirationTimes,N=c.pendingLanes&-62914561;0<N;){var J=31-la(N),at=1<<J,yt=T[J];yt===-1?((at&x)===0||(at&b)!==0)&&(T[J]=U(at,h)):yt<=h&&(c.expiredLanes|=at),N&=~at}if(h=Cn,x=yn,x=R(c,c===h?x:0),b=c.callbackNode,x===0||c===h&&si===2||c.cancelPendingCommit!==null)return b!==null&&b!==null&&Xh(b),c.callbackNode=null,c.callbackPriority=0;if((x&3)===0||D(c,x)){if(h=x&-x,h===c.callbackPriority)return h;switch(b!==null&&Xh(b),nt(x)){case 2:case 8:x=fy;break;case 32:x=OA;break;case 268435456:x=FA;break;default:x=OA}return b=G.bind(null,c),x=Tu(x,b),c.callbackPriority=h,c.callbackNode=x,h}return b!==null&&b!==null&&Xh(b),c.callbackPriority=2,c.callbackNode=null,2}function G(c,h){var x=c.callbackNode;if(cs()&&c.callbackNode!==x)return null;var b=yn;return b=R(c,c===Cn?b:0),b===0?null:(Th(c,b,h),$(c,Cs()),c.callbackNode!=null&&c.callbackNode===x?G.bind(null,c):null)}function ft(c,h){if(cs())return null;Th(c,h,!0)}function Tt(c){Ji?BA(function(){(ze&6)!==0?Tu(xg,c):c()}):Tu(xg,c)}function Ht(){return Gl===0&&(Gl=P()),Gl}function Bt(c,h){if(tf===null){var x=tf=[];GA=0,ua=Ht(),kl={status:"pending",value:void 0,then:function(b){x.push(b)}}}return GA++,h.then(Se,Se),h}function Se(){if(--GA===0&&tf!==null){kl!==null&&(kl.status="fulfilled");var c=tf;tf=null,ua=0,kl=null;for(var h=0;h<c.length;h++)(0,c[h])()}}function ae(c,h){var x=[],b={status:"pending",value:null,reason:null,then:function(T){x.push(T)}};return c.then(function(){b.status="fulfilled",b.value=h;for(var T=0;T<x.length;T++)(0,x[T])(h)},function(T){for(b.status="rejected",b.reason=T,T=0;T<x.length;T++)(0,x[T])(void 0)}),b}function we(c){c.updateQueue={baseState:c.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function Ee(c,h){c=c.updateQueue,h.updateQueue===c&&(h.updateQueue={baseState:c.baseState,firstBaseUpdate:c.firstBaseUpdate,lastBaseUpdate:c.lastBaseUpdate,shared:c.shared,callbacks:null})}function Gt(c){return{lane:c,tag:0,payload:null,callback:null,next:null}}function Jt(c,h,x){var b=c.updateQueue;if(b===null)return null;if(b=b.shared,(ze&2)!==0){var T=b.pending;return T===null?h.next=h:(h.next=T.next,T.next=h),b.pending=h,h=kt(c),Pt(c,null,x),h}return Z(c,b,h,x),kt(c)}function Be(c,h,x){if(h=h.updateQueue,h!==null&&(h=h.shared,(x&4194176)!==0)){var b=h.lanes;b&=c.pendingLanes,x|=b,h.lanes=x,K(c,x)}}function ve(c,h){var x=c.updateQueue,b=c.alternate;if(b!==null&&(b=b.updateQueue,x===b)){var T=null,N=null;if(x=x.firstBaseUpdate,x!==null){do{var J={lane:x.lane,tag:x.tag,payload:x.payload,callback:null,next:null};N===null?T=N=J:N=N.next=J,x=x.next}while(x!==null);N===null?T=N=h:N=N.next=h}else T=N=h;x={baseState:b.baseState,firstBaseUpdate:T,lastBaseUpdate:N,shared:b.shared,callbacks:b.callbacks},c.updateQueue=x;return}c=x.lastBaseUpdate,c===null?x.firstBaseUpdate=h:c.next=h,x.lastBaseUpdate=h}function te(){if(Uu){var c=kl;if(c!==null)throw c}}function Ue(c,h,x,b){Uu=!1;var T=c.updateQueue;Yo=!1;var N=T.firstBaseUpdate,J=T.lastBaseUpdate,at=T.shared.pending;if(at!==null){T.shared.pending=null;var yt=at,Ut=yt.next;yt.next=null,J===null?N=Ut:J.next=Ut,J=yt;var ne=c.alternate;ne!==null&&(ne=ne.updateQueue,at=ne.lastBaseUpdate,at!==J&&(at===null?ne.firstBaseUpdate=Ut:at.next=Ut,ne.lastBaseUpdate=yt))}if(N!==null){var de=T.baseState;J=0,ne=Ut=yt=null,at=N;do{var xe=at.lane&-536870913,tn=xe!==at.lane;if(tn?(yn&xe)===xe:(b&xe)===xe){xe!==0&&xe===ua&&(Uu=!0),ne!==null&&(ne=ne.next={lane:0,tag:at.tag,payload:at.payload,callback:null,next:null});t:{var da=c,af=at;xe=h;var Oc=x;switch(af.tag){case 1:if(da=af.payload,typeof da=="function"){de=da.call(Oc,de,xe);break t}de=da;break t;case 3:da.flags=da.flags&-65537|128;case 0:if(da=af.payload,xe=typeof da=="function"?da.call(Oc,de,xe):da,xe==null)break t;de=bc({},de,xe);break t;case 2:Yo=!0}}xe=at.callback,xe!==null&&(c.flags|=64,tn&&(c.flags|=8192),tn=T.callbacks,tn===null?T.callbacks=[xe]:tn.push(xe))}else tn={lane:xe,tag:at.tag,payload:at.payload,callback:at.callback,next:null},ne===null?(Ut=ne=tn,yt=de):ne=ne.next=tn,J|=xe;if(at=at.next,at===null){if(at=T.shared.pending,at===null)break;tn=at,at=tn.next,tn.next=null,T.lastBaseUpdate=tn,T.shared.pending=null}}while(!0);ne===null&&(yt=de),T.baseState=yt,T.firstBaseUpdate=Ut,T.lastBaseUpdate=ne,N===null&&(T.shared.lanes=0),Va|=J,c.lanes=J,c.memoizedState=de}}function lt(c,h){if(typeof c!="function")throw Error(i(191,c));c.call(h)}function re(c,h){var x=c.callbacks;if(x!==null)for(c.callbacks=null,c=0;c<x.length;c++)lt(x[c],h)}function ee(c,h){if(La(c,h))return!0;if(typeof c!="object"||c===null||typeof h!="object"||h===null)return!1;var x=Object.keys(c),b=Object.keys(h);if(x.length!==b.length)return!1;for(b=0;b<x.length;b++){var T=x[b];if(!ef.call(h,T)||!La(c[T],h[T]))return!1}return!0}function ie(c){return c=c.status,c==="fulfilled"||c==="rejected"}function Xt(){}function Lt(c,h,x){switch(x=c[x],x===void 0?c.push(h):x!==h&&(h.then(Xt,Xt),h=x),h.status){case"fulfilled":return h.value;case"rejected":throw c=h.reason,c===ni?Error(i(483)):c;default:if(typeof h.status=="string")h.then(Xt,Xt);else{if(c=Cn,c!==null&&100<c.shellSuspendCounter)throw Error(i(482));c=h,c.status="pending",c.then(function(b){if(h.status==="pending"){var T=h;T.status="fulfilled",T.value=b}},function(b){if(h.status==="pending"){var T=h;T.status="rejected",T.reason=b}})}switch(h.status){case"fulfilled":return h.value;case"rejected":throw c=h.reason,c===ni?Error(i(483)):c}throw Qc=h,ni}}function Ae(){if(Qc===null)throw Error(i(459));var c=Qc;return Qc=null,c}function Oe(c){var h=lr;return lr+=1,uo===null&&(uo=[]),Lt(uo,c,h)}function In(c,h){h=h.props.ref,c.ref=h!==void 0?h:null}function ln(c,h){throw h.$$typeof===Fp?Error(i(525)):(c=Object.prototype.toString.call(h),Error(i(31,c==="[object Object]"?"object with keys {"+Object.keys(h).join(", ")+"}":c)))}function Ei(c){var h=c._init;return h(c._payload)}function $i(c){function h(bt,gt){if(c){var Mt=bt.deletions;Mt===null?(bt.deletions=[gt],bt.flags|=16):Mt.push(gt)}}function x(bt,gt){if(!c)return null;for(;gt!==null;)h(bt,gt),gt=gt.sibling;return null}function b(bt){for(var gt=new Map;bt!==null;)bt.key!==null?gt.set(bt.key,bt):gt.set(bt.index,bt),bt=bt.sibling;return gt}function T(bt,gt){return bt=Us(bt,gt),bt.index=0,bt.sibling=null,bt}function N(bt,gt,Mt){return bt.index=Mt,c?(Mt=bt.alternate,Mt!==null?(Mt=Mt.index,Mt<gt?(bt.flags|=33554434,gt):Mt):(bt.flags|=33554434,gt)):(bt.flags|=1048576,gt)}function J(bt){return c&&bt.alternate===null&&(bt.flags|=33554434),bt}function at(bt,gt,Mt,jt){return gt===null||gt.tag!==6?(gt=Dl(Mt,bt.mode,jt),gt.return=bt,gt):(gt=T(gt,Mt),gt.return=bt,gt)}function yt(bt,gt,Mt,jt){var Ne=Mt.type;return Ne===bu?ne(bt,gt,Mt.props.children,jt,Mt.key):gt!==null&&(gt.elementType===Ne||typeof Ne=="object"&&Ne!==null&&Ne.$$typeof===Dr&&Ei(Ne)===gt.type)?(gt=T(gt,Mt.props),In(gt,Mt),gt.return=bt,gt):(gt=sr(Mt.type,Mt.key,Mt.props,null,bt.mode,jt),In(gt,Mt),gt.return=bt,gt)}function Ut(bt,gt,Mt,jt){return gt===null||gt.tag!==4||gt.stateNode.containerInfo!==Mt.containerInfo||gt.stateNode.implementation!==Mt.implementation?(gt=Cu(Mt,bt.mode,jt),gt.return=bt,gt):(gt=T(gt,Mt.children||[]),gt.return=bt,gt)}function ne(bt,gt,Mt,jt,Ne){return gt===null||gt.tag!==7?(gt=Fo(Mt,bt.mode,jt,Ne),gt.return=bt,gt):(gt=T(gt,Mt),gt.return=bt,gt)}function de(bt,gt,Mt){if(typeof gt=="string"&&gt!==""||typeof gt=="number"||typeof gt=="bigint")return gt=Dl(""+gt,bt.mode,Mt),gt.return=bt,gt;if(typeof gt=="object"&&gt!==null){switch(gt.$$typeof){case Po:return Mt=sr(gt.type,gt.key,gt.props,null,bt.mode,Mt),In(Mt,gt),Mt.return=bt,Mt;case Qr:return gt=Cu(gt,bt.mode,Mt),gt.return=bt,gt;case Dr:var jt=gt._init;return gt=jt(gt._payload),de(bt,gt,Mt)}if(Ll(gt)||r(gt))return gt=Fo(gt,bt.mode,Mt,null),gt.return=bt,gt;if(typeof gt.then=="function")return de(bt,Oe(gt),Mt);if(gt.$$typeof===so)return de(bt,Sh(bt,gt),Mt);ln(bt,gt)}return null}function xe(bt,gt,Mt,jt){var Ne=gt!==null?gt.key:null;if(typeof Mt=="string"&&Mt!==""||typeof Mt=="number"||typeof Mt=="bigint")return Ne!==null?null:at(bt,gt,""+Mt,jt);if(typeof Mt=="object"&&Mt!==null){switch(Mt.$$typeof){case Po:return Mt.key===Ne?yt(bt,gt,Mt,jt):null;case Qr:return Mt.key===Ne?Ut(bt,gt,Mt,jt):null;case Dr:return Ne=Mt._init,Mt=Ne(Mt._payload),xe(bt,gt,Mt,jt)}if(Ll(Mt)||r(Mt))return Ne!==null?null:ne(bt,gt,Mt,jt,null);if(typeof Mt.then=="function")return xe(bt,gt,Oe(Mt),jt);if(Mt.$$typeof===so)return xe(bt,gt,Sh(bt,Mt),jt);ln(bt,Mt)}return null}function tn(bt,gt,Mt,jt,Ne){if(typeof jt=="string"&&jt!==""||typeof jt=="number"||typeof jt=="bigint")return bt=bt.get(Mt)||null,at(gt,bt,""+jt,Ne);if(typeof jt=="object"&&jt!==null){switch(jt.$$typeof){case Po:return bt=bt.get(jt.key===null?Mt:jt.key)||null,yt(gt,bt,jt,Ne);case Qr:return bt=bt.get(jt.key===null?Mt:jt.key)||null,Ut(gt,bt,jt,Ne);case Dr:var fi=jt._init;return jt=fi(jt._payload),tn(bt,gt,Mt,jt,Ne)}if(Ll(jt)||r(jt))return bt=bt.get(Mt)||null,ne(gt,bt,jt,Ne,null);if(typeof jt.then=="function")return tn(bt,gt,Mt,Oe(jt),Ne);if(jt.$$typeof===so)return tn(bt,gt,Mt,Sh(gt,jt),Ne);ln(gt,jt)}return null}function da(bt,gt,Mt,jt){for(var Ne=null,fi=null,qe=gt,Fn=gt=0,ns=null;qe!==null&&Fn<Mt.length;Fn++){qe.index>Fn?(ns=qe,qe=null):ns=qe.sibling;var Pn=xe(bt,qe,Mt[Fn],jt);if(Pn===null){qe===null&&(qe=ns);break}c&&qe&&Pn.alternate===null&&h(bt,qe),gt=N(Pn,gt,Fn),fi===null?Ne=Pn:fi.sibling=Pn,fi=Pn,qe=ns}if(Fn===Mt.length)return x(bt,qe),zn&&At(bt,Fn),Ne;if(qe===null){for(;Fn<Mt.length;Fn++)qe=de(bt,Mt[Fn],jt),qe!==null&&(gt=N(qe,gt,Fn),fi===null?Ne=qe:fi.sibling=qe,fi=qe);return zn&&At(bt,Fn),Ne}for(qe=b(qe);Fn<Mt.length;Fn++)ns=tn(qe,bt,Fn,Mt[Fn],jt),ns!==null&&(c&&ns.alternate!==null&&qe.delete(ns.key===null?Fn:ns.key),gt=N(ns,gt,Fn),fi===null?Ne=ns:fi.sibling=ns,fi=ns);return c&&qe.forEach(function(Ko){return h(bt,Ko)}),zn&&At(bt,Fn),Ne}function af(bt,gt,Mt,jt){if(Mt==null)throw Error(i(151));for(var Ne=null,fi=null,qe=gt,Fn=gt=0,ns=null,Pn=Mt.next();qe!==null&&!Pn.done;Fn++,Pn=Mt.next()){qe.index>Fn?(ns=qe,qe=null):ns=qe.sibling;var Ko=xe(bt,qe,Pn.value,jt);if(Ko===null){qe===null&&(qe=ns);break}c&&qe&&Ko.alternate===null&&h(bt,qe),gt=N(Ko,gt,Fn),fi===null?Ne=Ko:fi.sibling=Ko,fi=Ko,qe=ns}if(Pn.done)return x(bt,qe),zn&&At(bt,Fn),Ne;if(qe===null){for(;!Pn.done;Fn++,Pn=Mt.next())Pn=de(bt,Pn.value,jt),Pn!==null&&(gt=N(Pn,gt,Fn),fi===null?Ne=Pn:fi.sibling=Pn,fi=Pn);return zn&&At(bt,Fn),Ne}for(qe=b(qe);!Pn.done;Fn++,Pn=Mt.next())Pn=tn(qe,bt,Fn,Pn.value,jt),Pn!==null&&(c&&Pn.alternate!==null&&qe.delete(Pn.key===null?Fn:Pn.key),gt=N(Pn,gt,Fn),fi===null?Ne=Pn:fi.sibling=Pn,fi=Pn);return c&&qe.forEach(function(WA){return h(bt,WA)}),zn&&At(bt,Fn),Ne}function Oc(bt,gt,Mt,jt){if(typeof Mt=="object"&&Mt!==null&&Mt.type===bu&&Mt.key===null&&(Mt=Mt.props.children),typeof Mt=="object"&&Mt!==null){switch(Mt.$$typeof){case Po:t:{for(var Ne=Mt.key;gt!==null;){if(gt.key===Ne){if(Ne=Mt.type,Ne===bu){if(gt.tag===7){x(bt,gt.sibling),jt=T(gt,Mt.props.children),jt.return=bt,bt=jt;break t}}else if(gt.elementType===Ne||typeof Ne=="object"&&Ne!==null&&Ne.$$typeof===Dr&&Ei(Ne)===gt.type){x(bt,gt.sibling),jt=T(gt,Mt.props),In(jt,Mt),jt.return=bt,bt=jt;break t}x(bt,gt);break}else h(bt,gt);gt=gt.sibling}Mt.type===bu?(jt=Fo(Mt.props.children,bt.mode,jt,Mt.key),jt.return=bt,bt=jt):(jt=sr(Mt.type,Mt.key,Mt.props,null,bt.mode,jt),In(jt,Mt),jt.return=bt,bt=jt)}return J(bt);case Qr:t:{for(Ne=Mt.key;gt!==null;){if(gt.key===Ne)if(gt.tag===4&&gt.stateNode.containerInfo===Mt.containerInfo&&gt.stateNode.implementation===Mt.implementation){x(bt,gt.sibling),jt=T(gt,Mt.children||[]),jt.return=bt,bt=jt;break t}else{x(bt,gt);break}else h(bt,gt);gt=gt.sibling}jt=Cu(Mt,bt.mode,jt),jt.return=bt,bt=jt}return J(bt);case Dr:return Ne=Mt._init,Mt=Ne(Mt._payload),Oc(bt,gt,Mt,jt)}if(Ll(Mt))return da(bt,gt,Mt,jt);if(r(Mt)){if(Ne=r(Mt),typeof Ne!="function")throw Error(i(150));return Mt=Ne.call(Mt),af(bt,gt,Mt,jt)}if(typeof Mt.then=="function")return Oc(bt,gt,Oe(Mt),jt);if(Mt.$$typeof===so)return Oc(bt,gt,Sh(bt,Mt),jt);ln(bt,Mt)}return typeof Mt=="string"&&Mt!==""||typeof Mt=="number"||typeof Mt=="bigint"?(Mt=""+Mt,gt!==null&&gt.tag===6?(x(bt,gt.sibling),jt=T(gt,Mt),jt.return=bt,bt=jt):(x(bt,gt),jt=Dl(Mt,bt.mode,jt),jt.return=bt,bt=jt),J(bt)):x(bt,gt)}return function(bt,gt,Mt,jt){try{lr=0;var Ne=Oc(bt,gt,Mt,jt);return uo=null,Ne}catch(qe){if(qe===ni)throw qe;var fi=e(29,qe,null,bt.mode);return fi.lanes=jt,fi.return=bt,fi}}}function Mo(c,h){c=Lr,B(Ga,c),B(ho,h),Lr=c|h.baseLanes}function br(){B(Ga,Lr),B(ho,ho.current)}function qr(){Lr=Ga.current,E(ho),E(Ga)}function ei(c){var h=c.alternate;B(Zi,Zi.current&1),B(ka,c),cr===null&&(h===null||ho.current!==null||h.memoizedState!==null)&&(cr=c)}function Sa(c){if(c.tag===22){if(B(Zi,Zi.current),B(ka,c),cr===null){var h=c.alternate;h!==null&&h.memoizedState!==null&&(cr=c)}}else gs()}function gs(){B(Zi,Zi.current),B(ka,ka.current)}function Qs(c){E(ka),cr===c&&(cr=null),E(Zi)}function Fi(c){for(var h=c;h!==null;){if(h.tag===13){var x=h.memoizedState;if(x!==null&&(x=x.dehydrated,x===null||DA(x)||Hh(x)))return h}else if(h.tag===19&&h.memoizedProps.revealOrder!==void 0){if((h.flags&128)!==0)return h}else if(h.child!==null){h.child.return=h,h=h.child;continue}if(h===c)break;for(;h.sibling===null;){if(h.return===null||h.return===c)return null;h=h.return}h.sibling.return=h.return,h=h.sibling}return null}function an(){throw Error(i(321))}function _i(c,h){if(h===null)return!1;for(var x=0;x<h.length&&x<c.length;x++)if(!La(c[x],h[x]))return!1;return!0}function Ys(c,h,x,b,T,N){return fo=N,un=h,h.memoizedState=null,h.updateQueue=null,h.lanes=0,ke.H=c===null||c.memoizedState===null?Wi:Os,qo=!1,N=x(b,T),qo=!1,xi&&(N=ou(h,x,b,T)),Xr(c),N}function Xr(c){ke.H=On;var h=Yn!==null&&Yn.next!==null;if(fo=0,Gi=Yn=un=null,ur=!1,Ui=0,Lu=null,h)throw Error(i(300));c===null||ki||(c=c.dependencies,c!==null&&El(c)&&(ki=!0))}function ou(c,h,x,b){un=c;var T=0;do{if(xi&&(Lu=null),Ui=0,xi=!1,25<=T)throw Error(i(301));if(T+=1,Gi=Yn=null,c.updateQueue!=null){var N=c.updateQueue;N.lastEffect=null,N.events=null,N.stores=null,N.memoCache!=null&&(N.memoCache.index=0)}ke.H=Vl,N=h(x,b)}while(xi);return N}function xh(){var c=ke.H,h=c.useState()[0];return h=typeof h.then=="function"?ut(h):h,c=c.useState()[0],(Yn!==null?Yn.memoizedState:null)!==c&&(un.flags|=1024),h}function Sr(){var c=nf!==0;return nf=0,c}function ia(c,h,x){h.updateQueue=c.updateQueue,h.flags&=-2053,c.lanes&=~x}function Ir(c){if(ur){for(c=c.memoizedState;c!==null;){var h=c.queue;h!==null&&(h.pending=null),c=c.next}ur=!1}fo=0,Gi=Yn=un=null,xi=!1,Ui=nf=0,Lu=null}function pi(){var c={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Gi===null?un.memoizedState=Gi=c:Gi=Gi.next=c,Gi}function q(){if(Yn===null){var c=un.alternate;c=c!==null?c.memoizedState:null}else c=Yn.next;var h=Gi===null?un.memoizedState:Gi.next;if(h!==null)Gi=h,Yn=c;else{if(c===null)throw un.alternate===null?Error(i(467)):Error(i(310));Yn=c,c={memoizedState:Yn.memoizedState,baseState:Yn.baseState,baseQueue:Yn.baseQueue,queue:Yn.queue,next:null},Gi===null?un.memoizedState=Gi=c:Gi=Gi.next=c}return Gi}function ut(c){var h=Ui;return Ui+=1,Lu===null&&(Lu=[]),c=Lt(Lu,c,h),h=un,(Gi===null?h.memoizedState:Gi.next)===null&&(h=h.alternate,ke.H=h===null||h.memoizedState===null?Wi:Os),c}function Ct(c){if(c!==null&&typeof c=="object"){if(typeof c.then=="function")return ut(c);if(c.$$typeof===so)return xs(c)}throw Error(i(438,String(c)))}function vt(c){var h=null,x=un.updateQueue;if(x!==null&&(h=x.memoCache),h==null){var b=un.alternate;b!==null&&(b=b.updateQueue,b!==null&&(b=b.memoCache,b!=null&&(h={data:b.data.map(function(T){return T.slice()}),index:0})))}if(h==null&&(h={data:[],index:0}),x===null&&(x=HA(),un.updateQueue=x),x.memoCache=h,x=h.data[h.index],x===void 0)for(x=h.data[h.index]=Array(c),b=0;b<c;b++)x[b]=G0;return h.index++,x}function ht(c,h){return typeof h=="function"?h(c):h}function Kt(c){var h=q();return se(h,Yn,c)}function se(c,h,x){var b=c.queue;if(b===null)throw Error(i(311));b.lastRenderedReducer=x;var T=c.baseQueue,N=b.pending;if(N!==null){if(T!==null){var J=T.next;T.next=N.next,N.next=J}h.baseQueue=T=N,b.pending=null}if(N=c.baseState,T===null)c.memoizedState=N;else{h=T.next;var at=J=null,yt=null,Ut=h,ne=!1;do{var de=Ut.lane&-536870913;if(de!==Ut.lane?(yn&de)===de:(fo&de)===de){var xe=Ut.revertLane;if(xe===0)yt!==null&&(yt=yt.next={lane:0,revertLane:0,action:Ut.action,hasEagerState:Ut.hasEagerState,eagerState:Ut.eagerState,next:null}),de===ua&&(ne=!0);else if((fo&xe)===xe){Ut=Ut.next,xe===ua&&(ne=!0);continue}else de={lane:0,revertLane:Ut.revertLane,action:Ut.action,hasEagerState:Ut.hasEagerState,eagerState:Ut.eagerState,next:null},yt===null?(at=yt=de,J=N):yt=yt.next=de,un.lanes|=xe,Va|=xe;de=Ut.action,qo&&x(N,de),N=Ut.hasEagerState?Ut.eagerState:x(N,de)}else xe={lane:de,revertLane:Ut.revertLane,action:Ut.action,hasEagerState:Ut.hasEagerState,eagerState:Ut.eagerState,next:null},yt===null?(at=yt=xe,J=N):yt=yt.next=xe,un.lanes|=de,Va|=de;Ut=Ut.next}while(Ut!==null&&Ut!==h);if(yt===null?J=N:yt.next=at,!La(N,c.memoizedState)&&(ki=!0,ne&&(x=kl,x!==null)))throw x;c.memoizedState=N,c.baseState=J,c.baseQueue=yt,b.lastRenderedState=N}return T===null&&(b.lanes=0),[c.memoizedState,b.dispatch]}function me(c){var h=q(),x=h.queue;if(x===null)throw Error(i(311));x.lastRenderedReducer=c;var b=x.dispatch,T=x.pending,N=h.memoizedState;if(T!==null){x.pending=null;var J=T=T.next;do N=c(N,J.action),J=J.next;while(J!==T);La(N,h.memoizedState)||(ki=!0),h.memoizedState=N,h.baseQueue===null&&(h.baseState=N),x.lastRenderedState=N}return[N,b]}function ye(c,h,x){var b=un,T=q(),N=zn;if(N){if(x===void 0)throw Error(i(407));x=x()}else x=h();var J=!La((Yn||T).memoizedState,x);if(J&&(T.memoizedState=x,ki=!0),T=T.queue,Zr(Qe.bind(null,b,T,c),[c]),T.getSnapshot!==h||J||Gi!==null&&Gi.memoizedState.tag&1){if(b.flags|=2048,bi(9,_e.bind(null,b,T,x,h),{destroy:void 0},null),Cn===null)throw Error(i(349));N||(fo&60)!==0||Te(b,h,x)}return x}function Te(c,h,x){c.flags|=16384,c={getSnapshot:h,value:x},h=un.updateQueue,h===null?(h=HA(),un.updateQueue=h,h.stores=[c]):(x=h.stores,x===null?h.stores=[c]:x.push(c))}function _e(c,h,x,b){h.value=x,h.getSnapshot=b,je(h)&&En(c)}function Qe(c,h,x){return x(function(){je(h)&&En(c)})}function je(c){var h=c.getSnapshot;c=c.value;try{var x=h();return!La(c,x)}catch{return!0}}function En(c){var h=Vt(c,2);h!==null&&Ns(h,c,2)}function Ke(c){var h=pi();if(typeof c=="function"){var x=c;if(c=x(),qo){tt(!0);try{x()}finally{tt(!1)}}}return h.memoizedState=h.baseState=c,h.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:ht,lastRenderedState:c},h}function cn(c,h,x,b){return c.baseState=x,se(c,Yn,typeof b=="function"?b:ht)}function Un(c,h,x,b,T){if($e(c))throw Error(i(485));if(c=h.action,c!==null){var N={payload:T,action:c,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(J){N.listeners.push(J)}};ke.T!==null?x(!0):N.isTransition=!1,b(N),x=h.pending,x===null?(N.next=h.pending=N,De(h,N)):(N.next=x.next,h.pending=x.next=N)}}function De(c,h){var x=h.action,b=h.payload,T=c.state;if(h.isTransition){var N=ke.T,J={};ke.T=J;try{var at=x(T,b),yt=ke.S;yt!==null&&yt(J,at),Ln(c,h,at)}catch(Ut){ri(c,h,Ut)}finally{ke.T=N}}else try{N=x(T,b),Ln(c,h,N)}catch(Ut){ri(c,h,Ut)}}function Ln(c,h,x){x!==null&&typeof x=="object"&&typeof x.then=="function"?x.then(function(b){mn(c,h,b)},function(b){return ri(c,h,b)}):mn(c,h,x)}function mn(c,h,x){h.status="fulfilled",h.value=x,Ia(h),c.state=x,h=c.pending,h!==null&&(x=h.next,x===h?c.pending=null:(x=x.next,h.next=x,De(c,x)))}function ri(c,h,x){var b=c.pending;if(c.pending=null,b!==null){b=b.next;do h.status="rejected",h.reason=x,Ia(h),h=h.next;while(h!==b)}c.action=null}function Ia(c){c=c.listeners;for(var h=0;h<c.length;h++)(0,c[h])()}function Vn(c,h){return h}function Ba(c,h){if(zn){var x=Cn.formState;if(x!==null){t:{var b=un;if(zn){if(bs){var T=J0(bs,or);if(T){bs=og(T),b=Z0(T);break t}}qt(b)}b=!1}b&&(h=x[0])}}x=pi(),x.memoizedState=x.baseState=h,b={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Vn,lastRenderedState:h},x.queue=b,x=dc.bind(null,un,b),b.dispatch=x,b=Ke(!1);var N=ue.bind(null,un,!1,b.queue);return b=pi(),T={state:h,dispatch:null,action:c,pending:null},b.queue=T,x=Un.bind(null,un,T,N,x),T.dispatch=x,b.memoizedState=c,[h,x,!1]}function Xn(c){var h=q();return oi(h,Yn,c)}function oi(c,h,x){h=se(c,h,Vn)[0],c=Kt(ht)[0],h=typeof h=="object"&&h!==null&&typeof h.then=="function"?ut(h):h;var b=q(),T=b.queue,N=T.dispatch;return x!==b.memoizedState&&(un.flags|=2048,bi(9,Ci.bind(null,T,x),{destroy:void 0},null)),[h,N,c]}function Ci(c,h){c.action=h}function Qi(c){var h=q(),x=Yn;if(x!==null)return oi(h,x,c);q(),h=h.memoizedState,x=q();var b=x.queue.dispatch;return x.memoizedState=c,[h,b,!1]}function bi(c,h,x,b){return c={tag:c,create:h,inst:x,deps:b,next:null},h=un.updateQueue,h===null&&(h=HA(),un.updateQueue=h),x=h.lastEffect,x===null?h.lastEffect=c.next=c:(b=x.next,x.next=c,c.next=b,h.lastEffect=c),c}function Ma(){return q().memoizedState}function ms(c,h,x,b){var T=pi();un.flags|=c,T.memoizedState=bi(1|h,x,{destroy:void 0},b===void 0?null:b)}function Jr(c,h,x,b){var T=q();b=b===void 0?null:b;var N=T.memoizedState.inst;Yn!==null&&b!==null&&_i(b,Yn.memoizedState.deps)?T.memoizedState=bi(h,x,N,b):(un.flags|=c,T.memoizedState=bi(1|h,x,N,b))}function ml(c,h){ms(8390656,8,c,h)}function Zr(c,h){Jr(2048,8,c,h)}function vh(c,h){return Jr(4,2,c,h)}function iA(c,h){return Jr(4,4,c,h)}function uc(c,h){if(typeof h=="function"){c=c();var x=h(c);return function(){typeof x=="function"?x():h(null)}}if(h!=null)return c=c(),h.current=c,function(){h.current=null}}function nr(c,h,x){x=x!=null?x.concat([c]):null,Jr(4,4,uc.bind(null,h,c),x)}function hc(){}function lu(c,h){var x=q();h=h===void 0?null:h;var b=x.memoizedState;return h!==null&&_i(h,b[1])?b[0]:(x.memoizedState=[c,h],c)}function Br(c,h){var x=q();h=h===void 0?null:h;var b=x.memoizedState;if(h!==null&&_i(h,b[1]))return b[0];if(b=c(),qo){tt(!0);try{c()}finally{tt(!1)}}return x.memoizedState=[b,h],b}function Wr(c,h,x){return x===void 0||(fo&1073741824)!==0?c.memoizedState=h:(c.memoizedState=x,c=to(),un.lanes|=c,Va|=c,x)}function fc(c,h,x,b){return La(x,h)?x:ho.current!==null?(c=Wr(c,x,b),La(c,h)||(ki=!0),c):(fo&42)===0?(ki=!0,c.memoizedState=x):(c=to(),un.lanes|=c,Va|=c,h)}function cu(c,h,x,b,T){var N=ts();Ls(N!==0&&8>N?N:8);var J=ke.T,at={};ke.T=at,ue(c,!1,h,x);try{var yt=T(),Ut=ke.S;if(Ut!==null&&Ut(at,yt),yt!==null&&typeof yt=="object"&&typeof yt.then=="function"){var ne=ae(yt,b);jr(c,h,ne,Js(c))}else jr(c,h,b,Js(c))}catch(de){jr(c,h,{then:function(){},status:"rejected",reason:de},Js())}finally{Ls(N),ke.T=J}}function Eh(c){var h=c.memoizedState;if(h!==null)return h;h={memoizedState:oa,baseState:oa,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:ht,lastRenderedState:oa},next:null};var x={};return h.next={memoizedState:x,baseState:x,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:ht,lastRenderedState:x},next:null},c.memoizedState=h,c=c.alternate,c!==null&&(c.memoizedState=h),h}function wo(){return xs(Ye)}function ir(){return q().memoizedState}function Ac(){return q().memoizedState}function yl(c){for(var h=c.return;h!==null;){switch(h.tag){case 24:case 3:var x=Js();c=Gt(x);var b=Jt(h,c,x);b!==null&&(Ns(b,h,x),Be(b,h,x)),h={cache:rA()},c.payload=h;return}h=h.return}}function Mr(c,h,x){var b=Js();x={lane:b,revertLane:0,action:x,hasEagerState:!1,eagerState:null,next:null},$e(c)?bn(h,x):(x=Ot(c,h,x,b),x!==null&&(Ns(x,c,b),fn(x,h,b)))}function dc(c,h,x){var b=Js();jr(c,h,x,b)}function jr(c,h,x,b){var T={lane:b,revertLane:0,action:x,hasEagerState:!1,eagerState:null,next:null};if($e(c))bn(h,T);else{var N=c.alternate;if(c.lanes===0&&(N===null||N.lanes===0)&&(N=h.lastRenderedReducer,N!==null))try{var J=h.lastRenderedState,at=N(J,x);if(T.hasEagerState=!0,T.eagerState=at,La(at,J))return Z(c,h,T,0),Cn===null&&zt(),!1}catch{}if(x=Ot(c,h,T,b),x!==null)return Ns(x,c,b),fn(x,h,b),!0}return!1}function ue(c,h,x,b){if(b={lane:2,revertLane:Ht(),action:b,hasEagerState:!1,eagerState:null,next:null},$e(c)){if(h)throw Error(i(479))}else h=Ot(c,x,b,2),h!==null&&Ns(h,c,2)}function $e(c){var h=c.alternate;return c===un||h!==null&&h===un}function bn(c,h){xi=ur=!0;var x=c.pending;x===null?h.next=h:(h.next=x.next,x.next=h),c.pending=h}function fn(c,h,x){if((x&4194176)!==0){var b=h.lanes;b&=c.pendingLanes,x|=b,h.lanes=x,K(c,x)}}function rn(c,h,x,b){h=c.memoizedState,x=x(b,h),x=x==null?h:bc({},h,x),c.memoizedState=x,c.lanes===0&&(c.updateQueue.baseState=x)}function _n(c,h,x,b,T,N,J){return c=c.stateNode,typeof c.shouldComponentUpdate=="function"?c.shouldComponentUpdate(b,N,J):h.prototype&&h.prototype.isPureReactComponent?!ee(x,b)||!ee(T,N):!0}function Hn(c,h,x,b){c=h.state,typeof h.componentWillReceiveProps=="function"&&h.componentWillReceiveProps(x,b),typeof h.UNSAFE_componentWillReceiveProps=="function"&&h.UNSAFE_componentWillReceiveProps(x,b),h.state!==c&&VA.enqueueReplaceState(h,h.state,null)}function li(c,h){var x=h;if("ref"in h){x={};for(var b in h)b!=="ref"&&(x[b]=h[b])}if(c=c.defaultProps){x===h&&(x=bc({},x));for(var T in c)x[T]===void 0&&(x[T]=c[T])}return x}function Ds(c,h){try{var x=c.onUncaughtError;x(h.value,{componentStack:h.stack})}catch(b){setTimeout(function(){throw b})}}function Kr(c,h,x){try{var b=c.onCaughtError;b(x.value,{componentStack:x.stack,errorBoundary:h.tag===1?h.stateNode:null})}catch(T){setTimeout(function(){throw T})}}function wa(c,h,x){return x=Gt(x),x.tag=3,x.payload={element:null},x.callback=function(){Ds(c,h)},x}function To(c){return c=Gt(c),c.tag=3,c}function xl(c,h,x,b){var T=x.type.getDerivedStateFromError;if(typeof T=="function"){var N=b.value;c.payload=function(){return T(N)},c.callback=function(){Kr(h,x,b)}}var J=x.stateNode;J!==null&&typeof J.componentDidCatch=="function"&&(c.callback=function(){Kr(h,x,b),typeof T!="function"&&(qa===null?qa=new Set([this]):qa.add(this));var at=b.stack;this.componentDidCatch(b.value,{componentStack:at!==null?at:""})})}function _h(c,h,x,b,T){if(x.flags|=32768,b!==null&&typeof b=="object"&&typeof b.then=="function"){if(h=x.alternate,h!==null&&pc(h,x,T,!0),x=ka.current,x!==null){switch(x.tag){case 13:return cr===null?ra():x.alternate===null&&Rn===0&&(Rn=3),x.flags&=-257,x.flags|=65536,x.lanes=T,b===kA?x.flags|=16384:(h=x.updateQueue,h===null?x.updateQueue=new Set([b]):h.add(b),vA(c,b,T)),!1;case 22:return x.flags|=65536,b===kA?x.flags|=16384:(h=x.updateQueue,h===null?(h={transitions:null,markerInstances:null,retryQueue:new Set([b])},x.updateQueue=h):(x=h.retryQueue,x===null?h.retryQueue=new Set([b]):x.add(b)),vA(c,b,T)),!1}throw Error(i(435,x.tag))}return vA(c,b,T),ra(),!1}if(zn)return h=ka.current,h!==null?((h.flags&65536)===0&&(h.flags|=256),h.flags|=65536,h.lanes=T,b!==jh&&(c=Error(i(422),{cause:b}),be(ot(c,x)))):(b!==jh&&(h=Error(i(423),{cause:b}),be(ot(h,x))),c=c.current.alternate,c.flags|=65536,T&=-T,c.lanes|=T,b=ot(b,x),T=wa(c.stateNode,b,T),ve(c,T),Rn!==4&&(Rn=2)),!1;var N=Error(i(520),{cause:b});if(N=ot(N,x),Ou===null?Ou=[N]:Ou.push(N),Rn!==4&&(Rn=2),h===null)return!0;b=ot(b,x),x=h;do{switch(x.tag){case 3:return x.flags|=65536,c=T&-T,x.lanes|=c,c=wa(x.stateNode,b,c),ve(x,c),!1;case 1:if(h=x.type,N=x.stateNode,(x.flags&128)===0&&(typeof h.getDerivedStateFromError=="function"||N!==null&&typeof N.componentDidCatch=="function"&&(qa===null||!qa.has(N))))return x.flags|=65536,T&=-T,x.lanes|=T,T=To(T),xl(T,c,x,b),ve(x,T),!1}x=x.return}while(x!==null);return!1}function ys(c,h,x,b){h.child=c===null?_g(h,null,x,b):Hl(h,c.child,x,b)}function x0(c,h,x,b,T){x=x.render;var N=h.ref;if("ref"in b){var J={};for(var at in b)at!=="ref"&&(J[at]=b[at])}else J=b;return gc(h),b=Ys(c,h,x,J,N,T),at=Sr(),c!==null&&!ki?(ia(c,h,T),Qo(c,h,T)):(zn&&at&&st(h),h.flags|=1,ys(c,h,b,T),h.child)}function v0(c,h,x,b,T){if(c===null){var N=x.type;return typeof N=="function"&&!zo(N)&&N.defaultProps===void 0&&x.compare===null?(h.tag=15,h.type=N,sA(c,h,N,b,T)):(c=sr(x.type,null,b,h,h.mode,T),c.ref=h.ref,c.return=h,h.child=c)}if(N=c.child,!vp(c,T)){var J=N.memoizedProps;if(x=x.compare,x=x!==null?x:ee,x(J,b)&&c.ref===h.ref)return Qo(c,h,T)}return h.flags|=1,c=Us(N,b),c.ref=h.ref,c.return=h,h.child=c}function sA(c,h,x,b,T){if(c!==null){var N=c.memoizedProps;if(ee(N,b)&&c.ref===h.ref)if(ki=!1,h.pendingProps=b=N,vp(c,T))(c.flags&131072)!==0&&(ki=!0);else return h.lanes=c.lanes,Qo(c,h,T)}return dp(c,h,x,b,T)}function E0(c,h,x){var b=h.pendingProps,T=b.children,N=(h.stateNode._pendingVisibility&2)!==0,J=c!==null?c.memoizedState:null;if(Ch(c,h),b.mode==="hidden"||N){if((h.flags&128)!==0){if(b=J!==null?J.baseLanes|x:x,c!==null){for(T=h.child=c.child,N=0;T!==null;)N=N|T.lanes|T.childLanes,T=T.sibling;h.childLanes=N&~b}else h.childLanes=0,h.child=null;return _0(c,h,b,x)}if((x&536870912)!==0)h.memoizedState={baseLanes:0,cachePool:null},c!==null&&oA(h,J!==null?J.cachePool:null),J!==null?Mo(h,J):br(),Sa(h);else return h.lanes=h.childLanes=536870912,_0(c,h,J!==null?J.baseLanes|x:x,x)}else J!==null?(oA(h,J.cachePool),Mo(h,J),gs(),h.memoizedState=null):(c!==null&&oA(h,null),br(),gs());return ys(c,h,T,x),h.child}function _0(c,h,x,b){var T=_l();return T=T===null?null:{parent:ro?Jn._currentValue:Jn._currentValue2,pool:T},h.memoizedState={baseLanes:x,cachePool:T},c!==null&&oA(h,null),br(),Sa(h),c!==null&&pc(c,h,b,!0),null}function Ch(c,h){var x=h.ref;if(x===null)c!==null&&c.ref!==null&&(h.flags|=2097664);else{if(typeof x!="function"&&typeof x!="object")throw Error(i(284));(c===null||c.ref!==x)&&(h.flags|=2097664)}}function dp(c,h,x,b,T){return gc(h),x=Ys(c,h,x,b,void 0,T),b=Sr(),c!==null&&!ki?(ia(c,h,T),Qo(c,h,T)):(zn&&b&&st(h),h.flags|=1,ys(c,h,x,T),h.child)}function C0(c,h,x,b,T,N){return gc(h),h.updateQueue=null,x=ou(h,b,x,T),Xr(c),b=Sr(),c!==null&&!ki?(ia(c,h,N),Qo(c,h,N)):(zn&&b&&st(h),h.flags|=1,ys(c,h,x,N),h.child)}function pp(c,h,x,b,T){if(gc(h),h.stateNode===null){var N=wc,J=x.contextType;typeof J=="object"&&J!==null&&(N=xs(J)),N=new x(b,N),h.memoizedState=N.state!==null&&N.state!==void 0?N.state:null,N.updater=VA,h.stateNode=N,N._reactInternals=h,N=h.stateNode,N.props=b,N.state=h.memoizedState,N.refs={},we(h),J=x.contextType,N.context=typeof J=="object"&&J!==null?xs(J):wc,N.state=h.memoizedState,J=x.getDerivedStateFromProps,typeof J=="function"&&(rn(h,x,J,b),N.state=h.memoizedState),typeof x.getDerivedStateFromProps=="function"||typeof N.getSnapshotBeforeUpdate=="function"||typeof N.UNSAFE_componentWillMount!="function"&&typeof N.componentWillMount!="function"||(J=N.state,typeof N.componentWillMount=="function"&&N.componentWillMount(),typeof N.UNSAFE_componentWillMount=="function"&&N.UNSAFE_componentWillMount(),J!==N.state&&VA.enqueueReplaceState(N,N.state,null),Ue(h,b,N,T),te(),N.state=h.memoizedState),typeof N.componentDidMount=="function"&&(h.flags|=4194308),b=!0}else if(c===null){N=h.stateNode;var at=h.memoizedProps,yt=li(x,at);N.props=yt;var Ut=N.context,ne=x.contextType;J=wc,typeof ne=="object"&&ne!==null&&(J=xs(ne));var de=x.getDerivedStateFromProps;ne=typeof de=="function"||typeof N.getSnapshotBeforeUpdate=="function",at=h.pendingProps!==at,ne||typeof N.UNSAFE_componentWillReceiveProps!="function"&&typeof N.componentWillReceiveProps!="function"||(at||Ut!==J)&&Hn(h,N,b,J),Yo=!1;var xe=h.memoizedState;N.state=xe,Ue(h,b,N,T),te(),Ut=h.memoizedState,at||xe!==Ut||Yo?(typeof de=="function"&&(rn(h,x,de,b),Ut=h.memoizedState),(yt=Yo||_n(h,x,yt,b,xe,Ut,J))?(ne||typeof N.UNSAFE_componentWillMount!="function"&&typeof N.componentWillMount!="function"||(typeof N.componentWillMount=="function"&&N.componentWillMount(),typeof N.UNSAFE_componentWillMount=="function"&&N.UNSAFE_componentWillMount()),typeof N.componentDidMount=="function"&&(h.flags|=4194308)):(typeof N.componentDidMount=="function"&&(h.flags|=4194308),h.memoizedProps=b,h.memoizedState=Ut),N.props=b,N.state=Ut,N.context=J,b=yt):(typeof N.componentDidMount=="function"&&(h.flags|=4194308),b=!1)}else{N=h.stateNode,Ee(c,h),J=h.memoizedProps,ne=li(x,J),N.props=ne,de=h.pendingProps,xe=N.context,Ut=x.contextType,yt=wc,typeof Ut=="object"&&Ut!==null&&(yt=xs(Ut)),at=x.getDerivedStateFromProps,(Ut=typeof at=="function"||typeof N.getSnapshotBeforeUpdate=="function")||typeof N.UNSAFE_componentWillReceiveProps!="function"&&typeof N.componentWillReceiveProps!="function"||(J!==de||xe!==yt)&&Hn(h,N,b,yt),Yo=!1,xe=h.memoizedState,N.state=xe,Ue(h,b,N,T),te();var tn=h.memoizedState;J!==de||xe!==tn||Yo||c!==null&&c.dependencies!==null&&El(c.dependencies)?(typeof at=="function"&&(rn(h,x,at,b),tn=h.memoizedState),(ne=Yo||_n(h,x,ne,b,xe,tn,yt)||c!==null&&c.dependencies!==null&&El(c.dependencies))?(Ut||typeof N.UNSAFE_componentWillUpdate!="function"&&typeof N.componentWillUpdate!="function"||(typeof N.componentWillUpdate=="function"&&N.componentWillUpdate(b,tn,yt),typeof N.UNSAFE_componentWillUpdate=="function"&&N.UNSAFE_componentWillUpdate(b,tn,yt)),typeof N.componentDidUpdate=="function"&&(h.flags|=4),typeof N.getSnapshotBeforeUpdate=="function"&&(h.flags|=1024)):(typeof N.componentDidUpdate!="function"||J===c.memoizedProps&&xe===c.memoizedState||(h.flags|=4),typeof N.getSnapshotBeforeUpdate!="function"||J===c.memoizedProps&&xe===c.memoizedState||(h.flags|=1024),h.memoizedProps=b,h.memoizedState=tn),N.props=b,N.state=tn,N.context=yt,b=ne):(typeof N.componentDidUpdate!="function"||J===c.memoizedProps&&xe===c.memoizedState||(h.flags|=4),typeof N.getSnapshotBeforeUpdate!="function"||J===c.memoizedProps&&xe===c.memoizedState||(h.flags|=1024),b=!1)}return N=b,Ch(c,h),b=(h.flags&128)!==0,N||b?(N=h.stateNode,x=b&&typeof x.getDerivedStateFromError!="function"?null:N.render(),h.flags|=1,c!==null&&b?(h.child=Hl(h,c.child,null,T),h.child=Hl(h,null,x,T)):ys(c,h,x,T),h.memoizedState=N.state,c=h.child):c=Qo(c,h,T),c}function b0(c,h,x,b){return He(),h.flags|=256,ys(c,h,x,b),h.child}function gp(c){return{baseLanes:c,cachePool:w0()}}function mp(c,h,x){return c=c!==null?c.childLanes&~x:0,h&&(c|=Aa),c}function S0(c,h,x){var b=h.pendingProps,T=!1,N=(h.flags&128)!==0,J;if((J=N)||(J=c!==null&&c.memoizedState===null?!1:(Zi.current&2)!==0),J&&(T=!0,h.flags&=-129),J=(h.flags&32)!==0,h.flags&=-33,c===null){if(zn){if(T?ei(h):gs(),zn){var at=bs,yt;(yt=at)&&(at=ty(at,or),at!==null?(h.memoizedState={dehydrated:at,treeContext:Rr!==null?{id:co,overflow:rr}:null,retryLane:536870912},yt=e(18,null,null,0),yt.stateNode=at,yt.return=h,h.child=yt,zs=h,bs=null,yt=!0):yt=!1),yt||qt(h)}if(at=h.memoizedState,at!==null&&(at=at.dehydrated,at!==null))return Hh(at)?h.lanes=16:h.lanes=536870912,null;Qs(h)}return at=b.children,b=b.fallback,T?(gs(),T=h.mode,at=yp({mode:"hidden",children:at},T),b=Fo(b,T,x,null),at.return=h,b.return=h,at.sibling=b,h.child=at,T=h.child,T.memoizedState=gp(x),T.childLanes=mp(c,J,x),h.memoizedState=Fs,b):(ei(h),bh(h,at))}if(yt=c.memoizedState,yt!==null&&(at=yt.dehydrated,at!==null)){if(N)h.flags&256?(ei(h),h.flags&=-257,h=xp(c,h,x)):h.memoizedState!==null?(gs(),h.child=c.child,h.flags|=128,h=null):(gs(),T=b.fallback,at=h.mode,b=yp({mode:"visible",children:b.children},at),T=Fo(T,at,x,null),T.flags|=2,b.return=h,T.return=h,b.sibling=T,h.child=b,Hl(h,c.child,null,x),b=h.child,b.memoizedState=gp(x),b.childLanes=mp(c,J,x),h.memoizedState=Fs,h=T);else if(ei(h),Hh(at))J=X0(at).digest,b=Error(i(419)),b.stack="",b.digest=J,be({value:b,source:null,stack:null}),h=xp(c,h,x);else if(ki||pc(c,h,x,!1),J=(x&c.childLanes)!==0,ki||J){if(J=Cn,J!==null){if(b=x&-x,(b&42)!==0)b=1;else switch(b){case 2:b=1;break;case 8:b=4;break;case 32:b=16;break;case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:b=64;break;case 268435456:b=134217728;break;default:b=0}if(b=(b&(J.suspendedLanes|x))!==0?0:b,b!==0&&b!==yt.retryLane)throw yt.retryLane=b,Vt(c,b),Ns(J,c,b),py}DA(at)||ra(),h=xp(c,h,x)}else DA(at)?(h.flags|=128,h.child=c.child,h=_c.bind(null,c),i_(at,h),h=null):(c=yt.treeContext,Zs&&(bs=j0(at),zs=h,zn=!0,Fa=null,or=!1,c!==null&&(za[Oa++]=co,za[Oa++]=rr,za[Oa++]=Rr,co=c.id,rr=c.overflow,Rr=h)),h=bh(h,b.children),h.flags|=4096);return h}return T?(gs(),T=b.fallback,at=h.mode,yt=c.child,N=yt.sibling,b=Us(yt,{mode:"hidden",children:b.children}),b.subtreeFlags=yt.subtreeFlags&31457280,N!==null?T=Us(N,T):(T=Fo(T,at,x,null),T.flags|=2),T.return=h,b.return=h,b.sibling=T,h.child=b,b=T,T=h.child,at=c.child.memoizedState,at===null?at=gp(x):(yt=at.cachePool,yt!==null?(N=ro?Jn._currentValue:Jn._currentValue2,yt=yt.parent!==N?{parent:N,pool:N}:yt):yt=w0(),at={baseLanes:at.baseLanes|x,cachePool:yt}),T.memoizedState=at,T.childLanes=mp(c,J,x),h.memoizedState=Fs,b):(ei(h),x=c.child,c=x.sibling,x=Us(x,{mode:"visible",children:b.children}),x.return=h,x.sibling=null,c!==null&&(J=h.deletions,J===null?(h.deletions=[c],h.flags|=16):J.push(c)),h.child=x,h.memoizedState=null,x)}function bh(c,h){return h=yp({mode:"visible",children:h},c.mode),h.return=c,c.child=h}function yp(c,h){return EA(c,h,0,null)}function xp(c,h,x){return Hl(h,c.child,null,x),c=bh(h,h.pendingProps.children),c.flags|=2,h.memoizedState=null,c}function I0(c,h,x){c.lanes|=h;var b=c.alternate;b!==null&&(b.lanes|=h),Ep(c.return,h,x)}function aA(c,h,x,b,T){var N=c.memoizedState;N===null?c.memoizedState={isBackwards:h,rendering:null,renderingStartTime:0,last:b,tail:x,tailMode:T}:(N.isBackwards=h,N.rendering=null,N.renderingStartTime=0,N.last=b,N.tail=x,N.tailMode=T)}function B0(c,h,x){var b=h.pendingProps,T=b.revealOrder,N=b.tail;if(ys(c,h,b.children,x),b=Zi.current,(b&2)!==0)b=b&1|2,h.flags|=128;else{if(c!==null&&(c.flags&128)!==0)t:for(c=h.child;c!==null;){if(c.tag===13)c.memoizedState!==null&&I0(c,x,h);else if(c.tag===19)I0(c,x,h);else if(c.child!==null){c.child.return=c,c=c.child;continue}if(c===h)break t;for(;c.sibling===null;){if(c.return===null||c.return===h)break t;c=c.return}c.sibling.return=c.return,c=c.sibling}b&=1}switch(B(Zi,b),T){case"forwards":for(x=h.child,T=null;x!==null;)c=x.alternate,c!==null&&Fi(c)===null&&(T=x),x=x.sibling;x=T,x===null?(T=h.child,h.child=null):(T=x.sibling,x.sibling=null),aA(h,!1,T,x,N);break;case"backwards":for(x=null,T=h.child,h.child=null;T!==null;){if(c=T.alternate,c!==null&&Fi(c)===null){h.child=T;break}c=T.sibling,T.sibling=x,x=T,T=c}aA(h,!0,x,null,N);break;case"together":aA(h,!1,null,null,void 0);break;default:h.memoizedState=null}return h.child}function Qo(c,h,x){if(c!==null&&(h.dependencies=c.dependencies),Va|=h.lanes,(x&h.childLanes)===0)if(c!==null){if(pc(c,h,x,!1),(x&h.childLanes)===0)return null}else return null;if(c!==null&&h.child!==c.child)throw Error(i(153));if(h.child!==null){for(c=h.child,x=Us(c,c.pendingProps),h.child=x,x.return=h;c.sibling!==null;)c=c.sibling,x=x.sibling=Us(c,c.pendingProps),x.return=h;x.sibling=null}return h.child}function vp(c,h){return(c.lanes&h)!==0?!0:(c=c.dependencies,!!(c!==null&&El(c)))}function t_(c,h,x){switch(h.tag){case 3:j(h,h.stateNode.containerInfo),vl(h,Jn,c.memoizedState.cache),He();break;case 27:case 5:dt(h);break;case 4:j(h,h.stateNode.containerInfo);break;case 10:vl(h,h.type,h.memoizedProps.value);break;case 13:var b=h.memoizedState;if(b!==null)return b.dehydrated!==null?(ei(h),h.flags|=128,null):(x&h.child.childLanes)!==0?S0(c,h,x):(ei(h),c=Qo(c,h,x),c!==null?c.sibling:null);ei(h);break;case 19:var T=(c.flags&128)!==0;if(b=(x&h.childLanes)!==0,b||(pc(c,h,x,!1),b=(x&h.childLanes)!==0),T){if(b)return B0(c,h,x);h.flags|=128}if(T=h.memoizedState,T!==null&&(T.rendering=null,T.tail=null,T.lastEffect=null),B(Zi,Zi.current),b)break;return null;case 22:case 23:return h.lanes=0,E0(c,h,x);case 24:vl(h,Jn,c.memoizedState.cache)}return Qo(c,h,x)}function M0(c,h,x){if(c!==null)if(c.memoizedProps!==h.pendingProps)ki=!0;else{if(!vp(c,x)&&(h.flags&128)===0)return ki=!1,t_(c,h,x);ki=(c.flags&131072)!==0}else ki=!1,zn&&(h.flags&1048576)!==0&&V(h,Zh,h.index);switch(h.lanes=0,h.tag){case 16:t:{c=h.pendingProps;var b=h.elementType,T=b._init;if(b=T(b._payload),h.type=b,typeof b=="function")zo(b)?(c=li(b,c),h.tag=1,h=pp(null,h,b,c,x)):(h.tag=0,h=dp(null,h,b,c,x));else{if(b!=null){if(T=b.$$typeof,T===Su){h.tag=11,h=x0(null,h,b,c,x);break t}else if(T===Uh){h.tag=14,h=v0(null,h,b,c,x);break t}}throw h=l(b)||b,Error(i(306,h,""))}}return h;case 0:return dp(c,h,h.type,h.pendingProps,x);case 1:return b=h.type,T=li(b,h.pendingProps),pp(c,h,b,T,x);case 3:t:{if(j(h,h.stateNode.containerInfo),c===null)throw Error(i(387));var N=h.pendingProps;T=h.memoizedState,b=T.element,Ee(c,h),Ue(h,N,null,x);var J=h.memoizedState;if(N=J.cache,vl(h,Jn,N),N!==T.cache&&_p(h,[Jn],x,!0),te(),N=J.element,Zs&&T.isDehydrated)if(T={element:N,isDehydrated:!1,cache:J.cache},h.updateQueue.baseState=T,h.memoizedState=T,h.flags&256){h=b0(c,h,N,x);break t}else if(N!==b){b=ot(Error(i(424)),h),be(b),h=b0(c,h,N,x);break t}else for(Zs&&(bs=W0(h.stateNode.containerInfo),zs=h,zn=!0,Fa=null,or=!0),x=_g(h,null,N,x),h.child=x;x;)x.flags=x.flags&-3|4096,x=x.sibling;else{if(He(),N===b){h=Qo(c,h,x);break t}ys(c,h,N,x)}h=h.child}return h;case 26:if(Ua)return Ch(c,h),c===null?(x=zA(h.type,null,h.pendingProps,null))?h.memoizedState=x:zn||(h.stateNode=a_(h.type,h.pendingProps,Nr.current,h)):h.memoizedState=zA(h.type,c.memoizedProps,h.pendingProps,c.memoizedState),null;case 27:if(_s)return dt(h),c===null&&_s&&zn&&(b=h.stateNode=yg(h.type,h.pendingProps,Nr.current,hs.current,!1),zs=h,or=!0,bs=RA(b)),b=h.pendingProps.children,c!==null||zn?ys(c,h,b,x):h.child=Hl(h,null,b,x),Ch(c,h),h.child;case 5:return c===null&&zn&&(ay(h.type,h.pendingProps,hs.current),(T=b=bs)&&(b=K0(b,h.type,h.pendingProps,or),b!==null?(h.stateNode=b,zs=h,bs=RA(b),or=!1,T=!0):T=!1),T||qt(h)),dt(h),T=h.type,N=h.pendingProps,J=c!==null?c.memoizedProps:null,b=N.children,Ol(T,N)?b=null:J!==null&&Ol(T,J)&&(h.flags|=32),h.memoizedState!==null&&(T=Ys(c,h,xh,null,null,x),ro?Ye._currentValue=T:Ye._currentValue2=T),Ch(c,h),ys(c,h,b,x),h.child;case 6:return c===null&&zn&&(ry(h.pendingProps,hs.current),(c=x=bs)&&(x=$0(x,h.pendingProps,or),x!==null?(h.stateNode=x,zs=h,bs=null,c=!0):c=!1),c||qt(h)),null;case 13:return S0(c,h,x);case 4:return j(h,h.stateNode.containerInfo),b=h.pendingProps,c===null?h.child=Hl(h,null,b,x):ys(c,h,b,x),h.child;case 11:return x0(c,h,h.type,h.pendingProps,x);case 7:return ys(c,h,h.pendingProps,x),h.child;case 8:return ys(c,h,h.pendingProps.children,x),h.child;case 12:return ys(c,h,h.pendingProps.children,x),h.child;case 10:return b=h.pendingProps,vl(h,h.type,b.value),ys(c,h,b.children,x),h.child;case 9:return T=h.type._context,b=h.pendingProps.children,gc(h),T=xs(T),b=b(T),h.flags|=1,ys(c,h,b,x),h.child;case 14:return v0(c,h,h.type,h.pendingProps,x);case 15:return sA(c,h,h.type,h.pendingProps,x);case 19:return B0(c,h,x);case 22:return E0(c,h,x);case 24:return gc(h),b=xs(Jn),c===null?(T=_l(),T===null&&(T=Cn,N=rA(),T.pooledCache=N,N.refCount++,N!==null&&(T.pooledCacheLanes|=x),T=N),h.memoizedState={parent:b,cache:T},we(h),vl(h,Jn,T)):((c.lanes&x)!==0&&(Ee(c,h),Ue(h,null,null,x),te()),T=c.memoizedState,N=h.memoizedState,T.parent!==b?(T={parent:b,cache:b},h.memoizedState=T,h.lanes===0&&(h.memoizedState=h.updateQueue.baseState=T),vl(h,Jn,b)):(b=N.cache,vl(h,Jn,b),b!==T.cache&&_p(h,[Jn],x,!0))),ys(c,h,h.pendingProps.children,x),h.child;case 29:throw h.pendingProps}throw Error(i(156,h.tag))}function vl(c,h,x){ro?(B(ha,h._currentValue),h._currentValue=x):(B(ha,h._currentValue2),h._currentValue2=x)}function Do(c){var h=ha.current;ro?c._currentValue=h:c._currentValue2=h,E(ha)}function Ep(c,h,x){for(;c!==null;){var b=c.alternate;if((c.childLanes&h)!==h?(c.childLanes|=h,b!==null&&(b.childLanes|=h)):b!==null&&(b.childLanes&h)!==h&&(b.childLanes|=h),c===x)break;c=c.return}}function _p(c,h,x,b){var T=c.child;for(T!==null&&(T.return=c);T!==null;){var N=T.dependencies;if(N!==null){var J=T.child;N=N.firstContext;t:for(;N!==null;){var at=N;N=T;for(var yt=0;yt<h.length;yt++)if(at.context===h[yt]){N.lanes|=x,at=N.alternate,at!==null&&(at.lanes|=x),Ep(N.return,x,c),b||(J=null);break t}N=at.next}}else if(T.tag===18){if(J=T.return,J===null)throw Error(i(341));J.lanes|=x,N=J.alternate,N!==null&&(N.lanes|=x),Ep(J,x,c),J=null}else J=T.child;if(J!==null)J.return=T;else for(J=T;J!==null;){if(J===c){J=null;break}if(T=J.sibling,T!==null){T.return=J.return,J=T;break}J=J.return}T=J}}function pc(c,h,x,b){c=null;for(var T=h,N=!1;T!==null;){if(!N){if((T.flags&524288)!==0)N=!0;else if((T.flags&262144)!==0)break}if(T.tag===10){var J=T.alternate;if(J===null)throw Error(i(387));if(J=J.memoizedProps,J!==null){var at=T.type;La(T.pendingProps.value,J.value)||(c!==null?c.push(at):c=[at])}}else if(T===Du.current){if(J=T.alternate,J===null)throw Error(i(387));J.memoizedState.memoizedState!==T.memoizedState.memoizedState&&(c!==null?c.push(Ye):c=[Ye])}T=T.return}c!==null&&_p(h,c,x,b),h.flags|=262144}function El(c){for(c=c.firstContext;c!==null;){var h=c.context;if(!La(ro?h._currentValue:h._currentValue2,c.memoizedValue))return!0;c=c.next}return!1}function gc(c){Yl=c,Li=null,c=c.dependencies,c!==null&&(c.firstContext=null)}function xs(c){return Cp(Yl,c)}function Sh(c,h){return Yl===null&&gc(c),Cp(c,h)}function Cp(c,h){var x=ro?h._currentValue:h._currentValue2;if(h={context:h,memoizedValue:x,next:null},Li===null){if(c===null)throw Error(i(308));Li=h,c.dependencies={lanes:0,firstContext:h},c.flags|=524288}else Li=Li.next=h;return x}function rA(){return{controller:new gy,data:new Map,refCount:0}}function uu(c){c.refCount--,c.refCount===0&&Xo(Dc,function(){c.controller.abort()})}function _l(){var c=Jo.current;return c!==null?c:Cn.pooledCache}function oA(c,h){h===null?B(Jo,Jo.current):B(Jo,h.pool)}function w0(){var c=_l();return c===null?null:{parent:ro?Jn._currentValue:Jn._currentValue2,pool:c}}function Ta(c){c.flags|=4}function bp(c,h){if(c!==null&&c.child===h.child)return!1;if((h.flags&16)!==0)return!0;for(c=h.child;c!==null;){if((c.flags&13878)!==0||(c.subtreeFlags&13878)!==0)return!0;c=c.sibling}return!1}function lA(c,h,x,b){if(Es)for(x=h.child;x!==null;){if(x.tag===5||x.tag===6)ao(c,x.stateNode);else if(!(x.tag===4||_s&&x.tag===27)&&x.child!==null){x.child.return=x,x=x.child;continue}if(x===h)break;for(;x.sibling===null;){if(x.return===null||x.return===h)return;x=x.return}x.sibling.return=x.return,x=x.sibling}else if(Ra)for(var T=h.child;T!==null;){if(T.tag===5){var N=T.stateNode;x&&b&&(N=ag(N,T.type,T.memoizedProps)),ao(c,N)}else if(T.tag===6)N=T.stateNode,x&&b&&(N=rg(N,T.memoizedProps)),ao(c,N);else if(T.tag!==4){if(T.tag===22&&T.memoizedState!==null)N=T.child,N!==null&&(N.return=T),lA(c,T,!0,!0);else if(T.child!==null){T.child.return=T,T=T.child;continue}}if(T===h)break;for(;T.sibling===null;){if(T.return===null||T.return===h)return;T=T.return}T.sibling.return=T.return,T=T.sibling}}function hu(c,h,x,b){if(Ra)for(var T=h.child;T!==null;){if(T.tag===5){var N=T.stateNode;x&&b&&(N=ag(N,T.type,T.memoizedProps)),ig(c,N)}else if(T.tag===6)N=T.stateNode,x&&b&&(N=rg(N,T.memoizedProps)),ig(c,N);else if(T.tag!==4){if(T.tag===22&&T.memoizedState!==null)N=T.child,N!==null&&(N.return=T),hu(c,T,!(T.memoizedProps!==null&&T.memoizedProps.mode==="manual"),!0);else if(T.child!==null){T.child.return=T,T=T.child;continue}}if(T===h)break;for(;T.sibling===null;){if(T.return===null||T.return===h)return;T=T.return}T.sibling.return=T.return,T=T.sibling}}function fu(c,h){if(Ra&&bp(c,h)){c=h.stateNode;var x=c.containerInfo,b=QA();hu(b,h,!1,!1),c.pendingChildren=b,Ta(h),q0(x,b)}}function Sp(c,h,x,b){if(Es)c.memoizedProps!==b&&Ta(h);else if(Ra){var T=c.stateNode,N=c.memoizedProps;if((c=bp(c,h))||N!==b){var J=hs.current;N=ng(T,x,N,b,!c,null),N===T?h.stateNode=T:(Go(N,x,b,J)&&Ta(h),h.stateNode=N,c?lA(N,h,!1,!1):Ta(h))}else h.stateNode=T}}function Au(c,h,x){if(H0(h,x)){if(c.flags|=16777216,!ko(h,x))if(Qh())c.flags|=8192;else throw Qc=kA,Eg}else c.flags&=-16777217}function Ip(c,h){if(oy(h)){if(c.flags|=16777216,!gg(h))if(Qh())c.flags|=8192;else throw Qc=kA,Eg}else c.flags&=-16777217}function Ih(c,h){h!==null&&(c.flags|=4),c.flags&16384&&(h=c.tag!==22?z():536870912,c.lanes|=h,Wo|=h)}function mc(c,h){if(!zn)switch(c.tailMode){case"hidden":h=c.tail;for(var x=null;h!==null;)h.alternate!==null&&(x=h),h=h.sibling;x===null?c.tail=null:x.sibling=null;break;case"collapsed":x=c.tail;for(var b=null;x!==null;)x.alternate!==null&&(b=x),x=x.sibling;b===null?h||c.tail===null?c.tail=null:c.tail.sibling=null:b.sibling=null}}function gi(c){var h=c.alternate!==null&&c.alternate.child===c.child,x=0,b=0;if(h)for(var T=c.child;T!==null;)x|=T.lanes|T.childLanes,b|=T.subtreeFlags&31457280,b|=T.flags&31457280,T.return=c,T=T.sibling;else for(T=c.child;T!==null;)x|=T.lanes|T.childLanes,b|=T.subtreeFlags,b|=T.flags,T.return=c,T=T.sibling;return c.subtreeFlags|=b,c.childLanes=x,h}function T0(c,h,x){var b=h.pendingProps;switch(xt(h),h.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return gi(h),null;case 1:return gi(h),null;case 3:return x=h.stateNode,b=null,c!==null&&(b=c.memoizedState.cache),h.memoizedState.cache!==b&&(h.flags|=2048),Do(Jn),Rt(),x.pendingContext&&(x.context=x.pendingContext,x.pendingContext=null),(c===null||c.child===null)&&(Ie(h)?Ta(h):c===null||c.memoizedState.isDehydrated&&(h.flags&256)===0||(h.flags|=1024,Fa!==null&&(No(Fa),Fa=null))),fu(c,h),gi(h),null;case 26:if(Ua){x=h.type;var T=h.memoizedState;return c===null?(Ta(h),T!==null?(gi(h),Ip(h,T)):(gi(h),Au(h,x,b))):T?T!==c.memoizedState?(Ta(h),gi(h),Ip(h,T)):(gi(h),h.flags&=-16777217):(Es?c.memoizedProps!==b&&Ta(h):Sp(c,h,x,b),gi(h),Au(h,x,b)),null}case 27:if(_s){if(pt(h),x=Nr.current,T=h.type,c!==null&&h.stateNode!=null)Es?c.memoizedProps!==b&&Ta(h):Sp(c,h,T,b);else{if(!b){if(h.stateNode===null)throw Error(i(166));return gi(h),null}c=hs.current,Ie(h)?Wt(h,c):(c=yg(T,b,x,c,!0),h.stateNode=c,Ta(h))}return gi(h),null}case 5:if(pt(h),x=h.type,c!==null&&h.stateNode!=null)Sp(c,h,x,b);else{if(!b){if(h.stateNode===null)throw Error(i(166));return gi(h),null}c=hs.current,Ie(h)?Wt(h,c):(T=Yp(x,b,Nr.current,c,h),lA(T,h,!1,!1),h.stateNode=T,Go(T,x,b,c)&&Ta(h))}return gi(h),Au(h,h.type,h.pendingProps),null;case 6:if(c&&h.stateNode!=null)x=c.memoizedProps,Es?x!==b&&Ta(h):Ra&&(x!==b?(h.stateNode=SA(b,Nr.current,hs.current,h),Ta(h)):h.stateNode=c.stateNode);else{if(typeof b!="string"&&h.stateNode===null)throw Error(i(166));if(c=Nr.current,x=hs.current,Ie(h)){if(!Zs)throw Error(i(176));if(c=h.stateNode,x=h.memoizedProps,b=null,T=zs,T!==null)switch(T.tag){case 27:case 5:b=T.memoizedProps}ey(c,x,h,b)||qt(h)}else h.stateNode=SA(b,c,x,h)}return gi(h),null;case 13:if(b=h.memoizedState,c===null||c.memoizedState!==null&&c.memoizedState.dehydrated!==null){if(T=Ie(h),b!==null&&b.dehydrated!==null){if(c===null){if(!T)throw Error(i(318));if(!Zs)throw Error(i(344));if(T=h.memoizedState,T=T!==null?T.dehydrated:null,!T)throw Error(i(317));Bu(T,h)}else He(),(h.flags&128)===0&&(h.memoizedState=null),h.flags|=4;gi(h),T=!1}else Fa!==null&&(No(Fa),Fa=null),T=!0;if(!T)return h.flags&256?(Qs(h),h):(Qs(h),null)}if(Qs(h),(h.flags&128)!==0)return h.lanes=x,h;if(x=b!==null,c=c!==null&&c.memoizedState!==null,x){b=h.child,T=null,b.alternate!==null&&b.alternate.memoizedState!==null&&b.alternate.memoizedState.cachePool!==null&&(T=b.alternate.memoizedState.cachePool.pool);var N=null;b.memoizedState!==null&&b.memoizedState.cachePool!==null&&(N=b.memoizedState.cachePool.pool),N!==T&&(b.flags|=2048)}return x!==c&&x&&(h.child.flags|=8192),Ih(h,h.updateQueue),gi(h),null;case 4:return Rt(),fu(c,h),c===null&&Jp(h.stateNode.containerInfo),gi(h),null;case 10:return Do(h.type),gi(h),null;case 19:if(E(Zi),T=h.memoizedState,T===null)return gi(h),null;if(b=(h.flags&128)!==0,N=T.rendering,N===null)if(b)mc(T,!1);else{if(Rn!==0||c!==null&&(c.flags&128)!==0)for(c=h.child;c!==null;){if(N=Fi(c),N!==null){for(h.flags|=128,mc(T,!1),c=N.updateQueue,h.updateQueue=c,Ih(h,c),h.subtreeFlags=0,c=x,x=h.child;x!==null;)Oo(x,c),x=x.sibling;return B(Zi,Zi.current&1|2),h.child}c=c.sibling}T.tail!==null&&Cs()>Bi&&(h.flags|=128,b=!0,mc(T,!1),h.lanes=4194304)}else{if(!b)if(c=Fi(N),c!==null){if(h.flags|=128,b=!0,c=c.updateQueue,h.updateQueue=c,Ih(h,c),mc(T,!0),T.tail===null&&T.tailMode==="hidden"&&!N.alternate&&!zn)return gi(h),null}else 2*Cs()-T.renderingStartTime>Bi&&x!==536870912&&(h.flags|=128,b=!0,mc(T,!1),h.lanes=4194304);T.isBackwards?(N.sibling=h.child,h.child=N):(c=T.last,c!==null?c.sibling=N:h.child=N,T.last=N)}return T.tail!==null?(h=T.tail,T.rendering=h,T.tail=h.sibling,T.renderingStartTime=Cs(),h.sibling=null,c=Zi.current,B(Zi,b?c&1|2:c&1),h):(gi(h),null);case 22:case 23:return Qs(h),qr(),b=h.memoizedState!==null,c!==null?c.memoizedState!==null!==b&&(h.flags|=8192):b&&(h.flags|=8192),b?(x&536870912)!==0&&(h.flags&128)===0&&(gi(h),h.subtreeFlags&6&&(h.flags|=8192)):gi(h),x=h.updateQueue,x!==null&&Ih(h,x.retryQueue),x=null,c!==null&&c.memoizedState!==null&&c.memoizedState.cachePool!==null&&(x=c.memoizedState.cachePool.pool),b=null,h.memoizedState!==null&&h.memoizedState.cachePool!==null&&(b=h.memoizedState.cachePool.pool),b!==x&&(h.flags|=2048),c!==null&&E(Jo),null;case 24:return x=null,c!==null&&(x=c.memoizedState.cache),h.memoizedState.cache!==x&&(h.flags|=2048),Do(Jn),gi(h),null;case 25:return null}throw Error(i(156,h.tag))}function Q0(c,h){switch(xt(h),h.tag){case 1:return c=h.flags,c&65536?(h.flags=c&-65537|128,h):null;case 3:return Do(Jn),Rt(),c=h.flags,(c&65536)!==0&&(c&128)===0?(h.flags=c&-65537|128,h):null;case 26:case 27:case 5:return pt(h),null;case 13:if(Qs(h),c=h.memoizedState,c!==null&&c.dehydrated!==null){if(h.alternate===null)throw Error(i(340));He()}return c=h.flags,c&65536?(h.flags=c&-65537|128,h):null;case 19:return E(Zi),null;case 4:return Rt(),null;case 10:return Do(h.type),null;case 22:case 23:return Qs(h),qr(),c!==null&&E(Jo),c=h.flags,c&65536?(h.flags=c&-65537|128,h):null;case 24:return Do(Jn),null;case 25:return null;default:return null}}function Bp(c,h){switch(xt(h),h.tag){case 3:Do(Jn),Rt();break;case 26:case 27:case 5:pt(h);break;case 4:Rt();break;case 13:Qs(h);break;case 19:E(Zi);break;case 10:Do(h.type);break;case 22:case 23:Qs(h),qr(),c!==null&&E(Jo);break;case 24:Do(Jn)}}function Bh(c,h){try{var x=h.updateQueue,b=x!==null?x.lastEffect:null;if(b!==null){var T=b.next;x=T;do{if((x.tag&c)===c){b=void 0;var N=x.create,J=x.inst;b=N(),J.destroy=b}x=x.next}while(x!==T)}}catch(at){Bn(h,h.return,at)}}function Cl(c,h,x){try{var b=h.updateQueue,T=b!==null?b.lastEffect:null;if(T!==null){var N=T.next;b=N;do{if((b.tag&c)===c){var J=b.inst,at=J.destroy;if(at!==void 0){J.destroy=void 0,T=h;var yt=x;try{at()}catch(Ut){Bn(T,yt,Ut)}}}b=b.next}while(b!==N)}}catch(Ut){Bn(h,h.return,Ut)}}function D0(c){var h=c.updateQueue;if(h!==null){var x=c.stateNode;try{re(h,x)}catch(b){Bn(c,c.return,b)}}}function R0(c,h,x){x.props=li(c.type,c.memoizedProps),x.state=c.memoizedState;try{x.componentWillUnmount()}catch(b){Bn(c,h,b)}}function yc(c,h){try{var x=c.ref;if(x!==null){var b=c.stateNode;switch(c.tag){case 26:case 27:case 5:var T=Iu(b);break;default:T=b}typeof x=="function"?c.refCleanup=x(T):x.current=T}}catch(N){Bn(c,h,N)}}function mi(c,h){var x=c.ref,b=c.refCleanup;if(x!==null)if(typeof b=="function")try{b()}catch(T){Bn(c,h,T)}finally{c.refCleanup=null,c=c.alternate,c!=null&&(c.refCleanup=null)}else if(typeof x=="function")try{x(null)}catch(T){Bn(c,h,T)}else x.current=null}function du(c){var h=c.type,x=c.memoizedProps,b=c.stateNode;try{n_(b,h,x,c)}catch(T){Bn(c,c.return,T)}}function Mp(c,h,x){try{Kp(c.stateNode,c.type,x,h,c)}catch(b){Bn(c,c.return,b)}}function wp(c){return c.tag===5||c.tag===3||(Ua?c.tag===26:!1)||(_s?c.tag===27:!1)||c.tag===4}function cA(c){t:for(;;){for(;c.sibling===null;){if(c.return===null||wp(c.return))return null;c=c.return}for(c.sibling.return=c.return,c=c.sibling;c.tag!==5&&c.tag!==6&&(!_s||c.tag!==27)&&c.tag!==18;){if(c.flags&2||c.child===null||c.tag===4)continue t;c.child.return=c,c=c.child}if(!(c.flags&2))return c.stateNode}}function uA(c,h,x){var b=c.tag;if(b===5||b===6)c=c.stateNode,h?tg(x,c,h):V0(x,c);else if(!(b===4||_s&&b===27)&&(c=c.child,c!==null))for(uA(c,h,x),c=c.sibling;c!==null;)uA(c,h,x),c=c.sibling}function pu(c,h,x){var b=c.tag;if(b===5||b===6)c=c.stateNode,h?$p(x,c,h):jp(x,c);else if(!(b===4||_s&&b===27)&&(c=c.child,c!==null))for(pu(c,h,x),c=c.sibling;c!==null;)pu(c,h,x),c=c.sibling}function N0(c,h,x){c=c.containerInfo;try{sg(c,x)}catch(b){Bn(h,h.return,b)}}function gu(c,h){for(zl(c.containerInfo),zi=h;zi!==null;)if(c=zi,h=c.child,(c.subtreeFlags&1028)!==0&&h!==null)h.return=c,zi=h;else for(;zi!==null;){c=zi;var x=c.alternate;switch(h=c.flags,c.tag){case 0:break;case 11:case 15:break;case 1:if((h&1024)!==0&&x!==null){h=void 0;var b=c,T=x.memoizedProps;x=x.memoizedState;var N=b.stateNode;try{var J=li(b.type,T,b.elementType===b.type);h=N.getSnapshotBeforeUpdate(J,x),N.__reactInternalSnapshotBeforeUpdate=h}catch(at){Bn(b,b.return,at)}}break;case 3:(h&1024)!==0&&Es&&TA(c.stateNode.containerInfo);break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((h&1024)!==0)throw Error(i(163))}if(h=c.sibling,h!==null){h.return=c.return,zi=h;break}zi=c.return}return J=Rc,Rc=!1,J}function hA(c,h,x){var b=x.flags;switch(x.tag){case 0:case 11:case 15:$r(c,x),b&4&&Bh(5,x);break;case 1:if($r(c,x),b&4)if(c=x.stateNode,h===null)try{c.componentDidMount()}catch(at){Bn(x,x.return,at)}else{var T=li(x.type,h.memoizedProps);h=h.memoizedState;try{c.componentDidUpdate(T,h,c.__reactInternalSnapshotBeforeUpdate)}catch(at){Bn(x,x.return,at)}}b&64&&D0(x),b&512&&yc(x,x.return);break;case 3:if($r(c,x),b&64&&(b=x.updateQueue,b!==null)){if(c=null,x.child!==null)switch(x.child.tag){case 27:case 5:c=Iu(x.child.stateNode);break;case 1:c=x.child.stateNode}try{re(b,c)}catch(at){Bn(x,x.return,at)}}break;case 26:if(Ua){$r(c,x),b&512&&yc(x,x.return);break}case 27:case 5:$r(c,x),h===null&&b&4&&du(x),b&512&&yc(x,x.return);break;case 12:$r(c,x);break;case 13:$r(c,x),b&4&&bl(c,x);break;case 22:if(T=x.memoizedState!==null||es,!T){h=h!==null&&h.memoizedState!==null||Ii;var N=es,J=Ii;es=T,(Ii=h)&&!J?Il(c,x,(x.subtreeFlags&8772)!==0):$r(c,x),es=N,Ii=J}b&512&&(x.memoizedProps.mode==="manual"?yc(x,x.return):mi(x,x.return));break;default:$r(c,x)}}function mu(c){var h=c.alternate;h!==null&&(c.alternate=null,mu(h)),c.child=null,c.deletions=null,c.sibling=null,c.tag===5&&(h=c.stateNode,h!==null&&Zp(h)),c.stateNode=null,c.return=null,c.dependencies=null,c.memoizedProps=null,c.memoizedState=null,c.pendingProps=null,c.stateNode=null,c.updateQueue=null}function Qa(c,h,x){for(x=x.child;x!==null;)fA(c,h,x),x=x.sibling}function fA(c,h,x){if(ca&&typeof ca.onCommitFiberUnmount=="function")try{ca.onCommitFiberUnmount(Qu,x)}catch{}switch(x.tag){case 26:if(Ua){Ii||mi(x,h),Qa(c,h,x),x.memoizedState?hg(x.memoizedState):x.stateNode&&dg(x.stateNode);break}case 27:if(_s){Ii||mi(x,h);var b=Hi,T=fa;Hi=x.stateNode,Qa(c,h,x),ly(x.stateNode),Hi=b,fa=T;break}case 5:Ii||mi(x,h);case 6:if(Es){if(b=Hi,T=fa,Hi=null,Qa(c,h,x),Hi=b,fa=T,Hi!==null)if(fa)try{Pi(Hi,x.stateNode)}catch(N){Bn(x,h,N)}else try{Ws(Hi,x.stateNode)}catch(N){Bn(x,h,N)}}else Qa(c,h,x);break;case 18:Es&&Hi!==null&&(fa?lg(Hi,x.stateNode):iy(Hi,x.stateNode));break;case 4:Es?(b=Hi,T=fa,Hi=x.stateNode.containerInfo,fa=!0,Qa(c,h,x),Hi=b,fa=T):(Ra&&N0(x.stateNode,x,QA()),Qa(c,h,x));break;case 0:case 11:case 14:case 15:Ii||Cl(2,x,h),Ii||Cl(4,x,h),Qa(c,h,x);break;case 1:Ii||(mi(x,h),b=x.stateNode,typeof b.componentWillUnmount=="function"&&R0(x,h,b)),Qa(c,h,x);break;case 21:Qa(c,h,x);break;case 22:Ii||mi(x,h),Ii=(b=Ii)||x.memoizedState!==null,Qa(c,h,x),Ii=b;break;default:Qa(c,h,x)}}function bl(c,h){if(Zs&&h.memoizedState===null&&(c=h.alternate,c!==null&&(c=c.memoizedState,c!==null&&(c=c.dehydrated,c!==null))))try{UA(c)}catch(x){Bn(h,h.return,x)}}function yu(c){switch(c.tag){case 13:case 19:var h=c.stateNode;return h===null&&(h=c.stateNode=new zu),h;case 22:return c=c.stateNode,h=c._retryCache,h===null&&(h=c._retryCache=new zu),h;default:throw Error(i(435,c.tag))}}function Mh(c,h){var x=yu(c);h.forEach(function(b){var T=Np.bind(null,c,b);x.has(b)||(x.add(b),b.then(T,T))})}function qs(c,h){var x=h.deletions;if(x!==null)for(var b=0;b<x.length;b++){var T=x[b],N=c,J=h;if(Es){var at=J;t:for(;at!==null;){switch(at.tag){case 27:case 5:Hi=at.stateNode,fa=!1;break t;case 3:Hi=at.stateNode.containerInfo,fa=!0;break t;case 4:Hi=at.stateNode.containerInfo,fa=!0;break t}at=at.return}if(Hi===null)throw Error(i(160));fA(N,J,T),Hi=null,fa=!1}else fA(N,J,T);N=T.alternate,N!==null&&(N.return=null),T.return=null}if(h.subtreeFlags&13878)for(h=h.child;h!==null;)Sl(h,c),h=h.sibling}function Sl(c,h){var x=c.alternate,b=c.flags;switch(c.tag){case 0:case 11:case 14:case 15:qs(h,c),sa(c),b&4&&(Cl(3,c,c.return),Bh(3,c),Cl(5,c,c.return));break;case 1:qs(h,c),sa(c),b&512&&(Ii||x===null||mi(x,x.return)),b&64&&es&&(c=c.updateQueue,c!==null&&(b=c.callbacks,b!==null&&(x=c.shared.hiddenCallbacks,c.shared.hiddenCallbacks=x===null?b:x.concat(b))));break;case 26:if(Ua){var T=js;qs(h,c),sa(c),b&512&&(Ii||x===null||mi(x,x.return)),b&4&&(b=x!==null?x.memoizedState:null,h=c.memoizedState,x===null?h===null?c.stateNode===null?c.stateNode=fg(T,c.type,c.memoizedProps,c):Ag(T,c.type,c.stateNode):c.stateNode=ug(T,h,c.memoizedProps):b!==h?(b===null?x.stateNode!==null&&dg(x.stateNode):hg(b),h===null?Ag(T,c.type,c.stateNode):ug(T,h,c.memoizedProps)):h===null&&c.stateNode!==null&&Mp(c,c.memoizedProps,x.memoizedProps));break}case 27:if(_s&&b&4&&c.alternate===null){T=c.stateNode;var N=c.memoizedProps;try{r_(T),o_(c.type,N,T,c)}catch(ne){Bn(c,c.return,ne)}}case 5:if(qs(h,c),sa(c),b&512&&(Ii||x===null||mi(x,x.return)),Es){if(c.flags&32){h=c.stateNode;try{Gh(h)}catch(ne){Bn(c,c.return,ne)}}b&4&&c.stateNode!=null&&(h=c.memoizedProps,Mp(c,h,x!==null?x.memoizedProps:h)),b&1024&&(ql=!0)}break;case 6:if(qs(h,c),sa(c),b&4&&Es){if(c.stateNode===null)throw Error(i(162));b=c.memoizedProps,x=x!==null?x.memoizedProps:b,h=c.stateNode;try{Y0(h,x,b)}catch(ne){Bn(c,c.return,ne)}}break;case 3:if(Ua?(pg(),T=js,js=LA(h.containerInfo),qs(h,c),js=T):qs(h,c),sa(c),b&4){if(Es&&Zs&&x!==null&&x.memoizedState.isDehydrated)try{NA(h.containerInfo)}catch(ne){Bn(c,c.return,ne)}if(Ra){b=h.containerInfo,x=h.pendingChildren;try{sg(b,x)}catch(ne){Bn(c,c.return,ne)}}}ql&&(ql=!1,Tp(c));break;case 4:Ua?(x=js,js=LA(c.stateNode.containerInfo),qs(h,c),sa(c),js=x):(qs(h,c),sa(c)),b&4&&Ra&&N0(c.stateNode,c,c.stateNode.pendingChildren);break;case 12:qs(h,c),sa(c);break;case 13:qs(h,c),sa(c),c.child.flags&8192&&c.memoizedState!==null!=(x!==null&&x.memoizedState!==null)&&(Ao=Cs()),b&4&&(b=c.updateQueue,b!==null&&(c.updateQueue=null,Mh(c,b)));break;case 22:b&512&&(Ii||x===null||mi(x,x.return)),T=c.memoizedState!==null;var J=x!==null&&x.memoizedState!==null,at=es,yt=Ii;if(es=at||T,Ii=yt||J,qs(h,c),Ii=yt,es=at,sa(c),h=c.stateNode,h._current=c,h._visibility&=-3,h._visibility|=h._pendingVisibility&2,b&8192&&(h._visibility=T?h._visibility&-2:h._visibility|1,T&&(h=es||Ii,x===null||J||h||xu(c)),Es&&(c.memoizedProps===null||c.memoizedProps.mode!=="manual"))){t:if(x=null,Es)for(h=c;;){if(h.tag===5||Ua&&h.tag===26||_s&&h.tag===27){if(x===null){J=x=h;try{N=J.stateNode,T?kh(N):eg(J.stateNode,J.memoizedProps)}catch(ne){Bn(J,J.return,ne)}}}else if(h.tag===6){if(x===null){J=h;try{var Ut=J.stateNode;T?wA(Ut):Ho(Ut,J.memoizedProps)}catch(ne){Bn(J,J.return,ne)}}}else if((h.tag!==22&&h.tag!==23||h.memoizedState===null||h===c)&&h.child!==null){h.child.return=h,h=h.child;continue}if(h===c)break t;for(;h.sibling===null;){if(h.return===null||h.return===c)break t;x===h&&(x=null),h=h.return}x===h&&(x=null),h.sibling.return=h.return,h=h.sibling}}b&4&&(b=c.updateQueue,b!==null&&(x=b.retryQueue,x!==null&&(b.retryQueue=null,Mh(c,x))));break;case 19:qs(h,c),sa(c),b&4&&(b=c.updateQueue,b!==null&&(c.updateQueue=null,Mh(c,b)));break;case 21:break;default:qs(h,c),sa(c)}}function sa(c){var h=c.flags;if(h&2){try{if(Es&&(!_s||c.tag!==27)){t:{for(var x=c.return;x!==null;){if(wp(x)){var b=x;break t}x=x.return}throw Error(i(160))}switch(b.tag){case 27:if(_s){var T=b.stateNode,N=cA(c);pu(c,N,T);break}case 5:var J=b.stateNode;b.flags&32&&(Gh(J),b.flags&=-33);var at=cA(c);pu(c,at,J);break;case 3:case 4:var yt=b.stateNode.containerInfo,Ut=cA(c);uA(c,Ut,yt);break;default:throw Error(i(161))}}}catch(ne){Bn(c,c.return,ne)}c.flags&=-3}h&4096&&(c.flags&=-4097)}function Tp(c){if(c.subtreeFlags&1024)for(c=c.child;c!==null;){var h=c;Tp(h),h.tag===5&&h.flags&1024&&ii(h.stateNode),c=c.sibling}}function $r(c,h){if(h.subtreeFlags&8772)for(h=h.child;h!==null;)hA(c,h.alternate,h),h=h.sibling}function xu(c){for(c=c.child;c!==null;){var h=c;switch(h.tag){case 0:case 11:case 14:case 15:Cl(4,h,h.return),xu(h);break;case 1:mi(h,h.return);var x=h.stateNode;typeof x.componentWillUnmount=="function"&&R0(h,h.return,x),xu(h);break;case 26:case 27:case 5:mi(h,h.return),xu(h);break;case 22:mi(h,h.return),h.memoizedState===null&&xu(h);break;default:xu(h)}c=c.sibling}}function Il(c,h,x){for(x=x&&(h.subtreeFlags&8772)!==0,h=h.child;h!==null;){var b=h.alternate,T=c,N=h,J=N.flags;switch(N.tag){case 0:case 11:case 15:Il(T,N,x),Bh(4,N);break;case 1:if(Il(T,N,x),b=N,T=b.stateNode,typeof T.componentDidMount=="function")try{T.componentDidMount()}catch(Ut){Bn(b,b.return,Ut)}if(b=N,T=b.updateQueue,T!==null){var at=b.stateNode;try{var yt=T.shared.hiddenCallbacks;if(yt!==null)for(T.shared.hiddenCallbacks=null,T=0;T<yt.length;T++)lt(yt[T],at)}catch(Ut){Bn(b,b.return,Ut)}}x&&J&64&&D0(N),yc(N,N.return);break;case 26:case 27:case 5:Il(T,N,x),x&&b===null&&J&4&&du(N),yc(N,N.return);break;case 12:Il(T,N,x);break;case 13:Il(T,N,x),x&&J&4&&bl(T,N);break;case 22:N.memoizedState===null&&Il(T,N,x),yc(N,N.return);break;default:Il(T,N,x)}h=h.sibling}}function Qp(c,h){var x=null;c!==null&&c.memoizedState!==null&&c.memoizedState.cachePool!==null&&(x=c.memoizedState.cachePool.pool),c=null,h.memoizedState!==null&&h.memoizedState.cachePool!==null&&(c=h.memoizedState.cachePool.pool),c!==x&&(c!=null&&c.refCount++,x!=null&&uu(x))}function AA(c,h){c=null,h.alternate!==null&&(c=h.alternate.memoizedState.cache),h=h.memoizedState.cache,h!==c&&(h.refCount++,c!=null&&uu(c))}function Ro(c,h,x,b){if(h.subtreeFlags&10256)for(h=h.child;h!==null;)dA(c,h,x,b),h=h.sibling}function dA(c,h,x,b){var T=h.flags;switch(h.tag){case 0:case 11:case 15:Ro(c,h,x,b),T&2048&&Bh(9,h);break;case 3:Ro(c,h,x,b),T&2048&&(c=null,h.alternate!==null&&(c=h.alternate.memoizedState.cache),h=h.memoizedState.cache,h!==c&&(h.refCount++,c!=null&&uu(c)));break;case 12:if(T&2048){Ro(c,h,x,b),c=h.stateNode;try{var N=h.memoizedProps,J=N.id,at=N.onPostCommit;typeof at=="function"&&at(J,h.alternate===null?"mount":"update",c.passiveEffectDuration,-0)}catch(yt){Bn(h,h.return,yt)}}else Ro(c,h,x,b);break;case 23:break;case 22:N=h.stateNode,h.memoizedState!==null?N._visibility&4?Ro(c,h,x,b):Bl(c,h):N._visibility&4?Ro(c,h,x,b):(N._visibility|=4,Rs(c,h,x,b,(h.subtreeFlags&10256)!==0)),T&2048&&Qp(h.alternate,h);break;case 24:Ro(c,h,x,b),T&2048&&AA(h.alternate,h);break;default:Ro(c,h,x,b)}}function Rs(c,h,x,b,T){for(T=T&&(h.subtreeFlags&10256)!==0,h=h.child;h!==null;){var N=c,J=h,at=x,yt=b,Ut=J.flags;switch(J.tag){case 0:case 11:case 15:Rs(N,J,at,yt,T),Bh(8,J);break;case 23:break;case 22:var ne=J.stateNode;J.memoizedState!==null?ne._visibility&4?Rs(N,J,at,yt,T):Bl(N,J):(ne._visibility|=4,Rs(N,J,at,yt,T)),T&&Ut&2048&&Qp(J.alternate,J);break;case 24:Rs(N,J,at,yt,T),T&&Ut&2048&&AA(J.alternate,J);break;default:Rs(N,J,at,yt,T)}h=h.sibling}}function Bl(c,h){if(h.subtreeFlags&10256)for(h=h.child;h!==null;){var x=c,b=h,T=b.flags;switch(b.tag){case 22:Bl(x,b),T&2048&&Qp(b.alternate,b);break;case 24:Bl(x,b),T&2048&&AA(b.alternate,b);break;default:Bl(x,b)}h=h.sibling}}function os(c){if(c.subtreeFlags&Nc)for(c=c.child;c!==null;)xc(c),c=c.sibling}function xc(c){switch(c.tag){case 26:os(c),c.flags&Nc&&(c.memoizedState!==null?mg(js,c.memoizedState,c.memoizedProps):Di(c.type,c.memoizedProps));break;case 5:os(c),c.flags&Nc&&Di(c.type,c.memoizedProps);break;case 3:case 4:if(Ua){var h=js;js=LA(c.stateNode.containerInfo),os(c),js=h}else os(c);break;case 22:c.memoizedState===null&&(h=c.alternate,h!==null&&h.memoizedState!==null?(h=Nc,Nc=16777216,os(c),Nc=h):os(c));break;default:os(c)}}function pA(c){var h=c.alternate;if(h!==null&&(c=h.child,c!==null)){h.child=null;do h=c.sibling,c.sibling=null,c=h;while(c!==null)}}function Ml(c){var h=c.deletions;if((c.flags&16)!==0){if(h!==null)for(var x=0;x<h.length;x++){var b=h[x];zi=b,wl(b,c)}pA(c)}if(c.subtreeFlags&10256)for(c=c.child;c!==null;)wh(c),c=c.sibling}function wh(c){switch(c.tag){case 0:case 11:case 15:Ml(c),c.flags&2048&&Cl(9,c,c.return);break;case 3:Ml(c);break;case 12:Ml(c);break;case 22:var h=c.stateNode;c.memoizedState!==null&&h._visibility&4&&(c.return===null||c.return.tag!==13)?(h._visibility&=-5,vu(c)):Ml(c);break;default:Ml(c)}}function vu(c){var h=c.deletions;if((c.flags&16)!==0){if(h!==null)for(var x=0;x<h.length;x++){var b=h[x];zi=b,wl(b,c)}pA(c)}for(c=c.child;c!==null;){switch(h=c,h.tag){case 0:case 11:case 15:Cl(8,h,h.return),vu(h);break;case 22:x=h.stateNode,x._visibility&4&&(x._visibility&=-5,vu(h));break;default:vu(h)}c=c.sibling}}function wl(c,h){for(;zi!==null;){var x=zi;switch(x.tag){case 0:case 11:case 15:Cl(8,x,h);break;case 23:case 22:if(x.memoizedState!==null&&x.memoizedState.cachePool!==null){var b=x.memoizedState.cachePool.pool;b!=null&&b.refCount++}break;case 24:uu(x.memoizedState.cache)}if(b=x.child,b!==null)b.return=x,zi=b;else t:for(x=c;zi!==null;){b=zi;var T=b.sibling,N=b.return;if(mu(b),b===x){zi=null;break t}if(T!==null){T.return=N,zi=T;break t}zi=N}}}function gA(c){var h=Xp(c);if(h!=null){if(typeof h.memoizedProps["data-testname"]!="string")throw Error(i(364));return h}if(c=Mc(c),c===null)throw Error(i(362));return c.stateNode.current}function Eu(c,h){var x=c.tag;switch(h.$$typeof){case sf:if(c.type===h.value)return!0;break;case XA:t:{for(h=h.value,c=[c,0],x=0;x<c.length;){var b=c[x++],T=b.tag,N=c[x++],J=h[N];if(T!==5&&T!==26&&T!==27||!lo(b)){for(;J!=null&&Eu(b,J);)N++,J=h[N];if(N===h.length){h=!0;break t}else for(b=b.child;b!==null;)c.push(b,N),b=b.sibling}}h=!1}return h;case JA:if((x===5||x===26||x===27)&&e_(c.stateNode,h.value))return!0;break;case Zn:if((x===5||x===6||x===26||x===27)&&(c=Ph(c),c!==null&&0<=c.indexOf(h.value)))return!0;break;case Dn:if((x===5||x===26||x===27)&&(c=c.memoizedProps["data-testname"],typeof c=="string"&&c.toLowerCase()===h.value.toLowerCase()))return!0;break;default:throw Error(i(365))}return!1}function Tl(c){switch(c.$$typeof){case sf:return"<"+(l(c.value)||"Unknown")+">";case XA:return":has("+(Tl(c)||"")+")";case JA:return'[role="'+c.value+'"]';case Zn:return'"'+c.value+'"';case Dn:return'[data-testname="'+c.value+'"]';default:throw Error(i(365))}}function U0(c,h){var x=[];c=[c,0];for(var b=0;b<c.length;){var T=c[b++],N=T.tag,J=c[b++],at=h[J];if(N!==5&&N!==26&&N!==27||!lo(T)){for(;at!=null&&Eu(T,at);)J++,at=h[J];if(J===h.length)x.push(T);else for(T=T.child;T!==null;)c.push(T,J),T=T.sibling}}return x}function Xs(c,h){if(!oo)throw Error(i(363));c=gA(c),c=U0(c,h),h=[],c=Array.from(c);for(var x=0;x<c.length;){var b=c[x++],T=b.tag;if(T===5||T===26||T===27)lo(b)||h.push(b.stateNode);else for(b=b.child;b!==null;)c.push(b),b=b.sibling}return h}function Js(){if((ze&2)!==0&&yn!==0)return yn&-yn;if(ke.T!==null){var c=ua;return c!==0?c:Ht()}return ar()}function to(){Aa===0&&(Aa=(yn&536870912)===0||zn?P():536870912);var c=ka.current;return c!==null&&(c.flags|=32),Aa}function Ns(c,h,x){(c===Cn&&si===2||c.cancelPendingCommit!==null)&&(Tr(c,0),wr(c,yn,Aa,!1)),k(c,x),((ze&2)===0||c!==Cn)&&(c===Cn&&((ze&2)===0&&(zr|=x),Rn===4&&wr(c,yn,Aa,!1)),Zt(c))}function Th(c,h,x){if((ze&6)!==0)throw Error(i(327));var b=!x&&(h&60)===0&&(h&c.expiredLanes)===0||D(c,h),T=b?io(c,h):eo(c,h,!0),N=b;do{if(T===0){Ha&&!b&&wr(c,h,0,!1);break}else if(T===6)wr(c,h,0,!Wn);else{if(x=c.current.alternate,N&&!L0(x)){T=eo(c,h,!1),N=!1;continue}if(T===2){if(N=h,c.errorRecoveryDisabledLanes&N)var J=0;else J=c.pendingLanes&-536870913,J=J!==0?J:J&536870912?536870912:0;if(J!==0){h=J;t:{var at=c;T=Ou;var yt=Zs&&at.current.memoizedState.isDehydrated;if(yt&&(Tr(at,J).flags|=256),J=eo(at,J,!1),J!==2){if(Zo&&!yt){at.errorRecoveryDisabledLanes|=N,zr|=N,T=4;break t}N=Ya,Ya=T,N!==null&&No(N)}T=J}if(N=!1,T!==2)continue}}if(T===1){Tr(c,0),wr(c,h,0,!0);break}t:{switch(b=c,T){case 0:case 1:throw Error(i(345));case 4:if((h&4194176)===h){wr(b,h,Aa,!Wn);break t}break;case 2:Ya=null;break;case 3:case 5:break;default:throw Error(i(329))}if(b.finishedWork=x,b.finishedLanes=h,(h&62914560)===h&&(N=Ao+300-Cs(),10<N)){if(wr(b,h,Aa,!Wn),R(b,0)!==0)break t;b.timeoutHandle=qp(mA.bind(null,b,x,Ya,Or,Fu,h,Aa,zr,Wo,Wn,2,-0,0),N);break t}mA(b,x,Ya,Or,Fu,h,Aa,zr,Wo,Wn,0,-0,0)}}break}while(!0);Zt(c)}function No(c){Ya===null?Ya=c:Ya.push.apply(Ya,c)}function mA(c,h,x,b,T,N,J,at,yt,Ut,ne,de,xe){var tn=h.subtreeFlags;if((tn&8192||(tn&16785408)===16785408)&&(Na(),xc(h),h=IA(),h!==null)){c.cancelPendingCommit=h(hi.bind(null,c,x,b,T,J,at,yt,1,de,xe)),wr(c,N,J,!Ut);return}hi(c,x,b,T,J,at,yt,ne,de,xe)}function L0(c){for(var h=c;;){var x=h.tag;if((x===0||x===11||x===15)&&h.flags&16384&&(x=h.updateQueue,x!==null&&(x=x.stores,x!==null)))for(var b=0;b<x.length;b++){var T=x[b],N=T.getSnapshot;T=T.value;try{if(!La(N(),T))return!1}catch{return!1}}if(x=h.child,h.subtreeFlags&16384&&x!==null)x.return=h,h=x;else{if(h===c)break;for(;h.sibling===null;){if(h.return===null||h.return===c)return!0;h=h.return}h.sibling.return=h.return,h=h.sibling}}return!0}function wr(c,h,x,b){h&=~Ps,h&=~zr,c.suspendedLanes|=h,c.pingedLanes&=~h,b&&(c.warmLanes|=h),b=c.expirationTimes;for(var T=h;0<T;){var N=31-la(T),J=1<<N;b[N]=-1,T&=~J}x!==0&&W(c,x,h)}function Dp(){return(ze&6)===0?($t(0),!1):!0}function aa(){if(sn!==null){if(si===0)var c=sn.return;else c=sn,Li=Yl=null,Ir(c),uo=null,lr=0,c=sn;for(;c!==null;)Bp(c.alternate,c),c=c.return;sn=null}}function Tr(c,h){c.finishedWork=null,c.finishedLanes=0;var x=c.timeoutHandle;x!==Bc&&(c.timeoutHandle=Bc,Fh(x)),x=c.cancelPendingCommit,x!==null&&(c.cancelPendingCommit=null,x()),aa(),Cn=c,sn=x=Us(c.current,null),yn=h,si=0,Vi=null,Wn=!1,Ha=D(c,h),Zo=!1,Wo=Aa=Ps=zr=Va=Rn=0,Ya=Ou=null,Fu=!1,(h&8)!==0&&(h|=h&32);var b=c.entangledLanes;if(b!==0)for(c=c.entanglements,b&=h;0<b;){var T=31-la(b),N=1<<T;h|=c[T],b&=~N}return Lr=h,zt(),x}function vc(c,h){un=null,ke.H=On,h===ni?(h=Ae(),si=3):h===Eg?(h=Ae(),si=4):si=h===py?8:h!==null&&typeof h=="object"&&typeof h.then=="function"?6:1,Vi=h,sn===null&&(Rn=1,Ds(c,ot(h,c.current)))}function Qh(){var c=ka.current;return c===null?!0:(yn&4194176)===yn?cr===null:(yn&62914560)===yn||(yn&536870912)!==0?c===cr:!1}function _u(){var c=ke.H;return ke.H=On,c===null?On:c}function Da(){var c=ke.A;return ke.A=qA,c}function ra(){Rn=4,Wn||(yn&4194176)!==yn&&ka.current!==null||(Ha=!0),(Va&134217727)===0&&(zr&134217727)===0||Cn===null||wr(Cn,yn,Aa,!1)}function eo(c,h,x){var b=ze;ze|=2;var T=_u(),N=Da();(Cn!==c||yn!==h)&&(Or=null,Tr(c,h)),h=!1;var J=Rn;t:do try{if(si!==0&&sn!==null){var at=sn,yt=Vi;switch(si){case 8:aa(),J=6;break t;case 3:case 2:case 6:ka.current===null&&(h=!0);var Ut=si;if(si=0,Vi=null,Ql(c,at,yt,Ut),x&&Ha){J=0;break t}break;default:Ut=si,si=0,Vi=null,Ql(c,at,yt,Ut)}}no(),J=Rn;break}catch(ne){vc(c,ne)}while(!0);return h&&c.shellSuspendCounter++,Li=Yl=null,ze=b,ke.H=T,ke.A=N,sn===null&&(Cn=null,yn=0,zt()),J}function no(){for(;sn!==null;)Rp(sn)}function io(c,h){var x=ze;ze|=2;var b=_u(),T=Da();Cn!==c||yn!==h?(Or=null,Bi=Cs()+500,Tr(c,h)):Ha=D(c,h);t:do try{if(si!==0&&sn!==null){h=sn;var N=Vi;e:switch(si){case 1:si=0,Vi=null,Ql(c,h,N,1);break;case 2:if(ie(N)){si=0,Vi=null,yA(h);break}h=function(){si===2&&Cn===c&&(si=7),Zt(c)},N.then(h,h);break t;case 3:si=7;break t;case 4:si=5;break t;case 7:ie(N)?(si=0,Vi=null,yA(h)):(si=0,Vi=null,Ql(c,h,N,7));break;case 5:var J=null;switch(sn.tag){case 26:J=sn.memoizedState;case 5:case 27:var at=sn,yt=at.type,Ut=at.pendingProps;if(J?gg(J):ko(yt,Ut)){si=0,Vi=null;var ne=at.sibling;if(ne!==null)sn=ne;else{var de=at.return;de!==null?(sn=de,Dh(de)):sn=null}break e}}si=0,Vi=null,Ql(c,h,N,5);break;case 6:si=0,Vi=null,Ql(c,h,N,6);break;case 8:aa(),Rn=6;break t;default:throw Error(i(462))}}Uo();break}catch(xe){vc(c,xe)}while(!0);return Li=Yl=null,ke.H=b,ke.A=T,ze=x,sn!==null?0:(Cn=null,yn=0,zt(),Rn)}function Uo(){for(;sn!==null&&!uy();)Rp(sn)}function Rp(c){var h=M0(c.alternate,c,Lr);c.memoizedProps=c.pendingProps,h===null?Dh(c):sn=h}function yA(c){var h=c,x=h.alternate;switch(h.tag){case 15:case 0:h=C0(x,h,h.pendingProps,h.type,void 0,yn);break;case 11:h=C0(x,h,h.pendingProps,h.type.render,h.ref,yn);break;case 5:Ir(h);default:Bp(x,h),h=sn=Oo(h,Lr),h=M0(x,h,Lr)}c.memoizedProps=c.pendingProps,h===null?Dh(c):sn=h}function Ql(c,h,x,b){Li=Yl=null,Ir(h),uo=null,lr=0;var T=h.return;try{if(_h(c,T,h,x,yn)){Rn=1,Ds(c,ot(x,c.current)),sn=null;return}}catch(N){if(T!==null)throw sn=T,N;Rn=1,Ds(c,ot(x,c.current)),sn=null;return}h.flags&32768?(zn||b===1?c=!0:Ha||(yn&536870912)!==0?c=!1:(Wn=c=!0,(b===2||b===3||b===6)&&(b=ka.current,b!==null&&b.tag===13&&(b.flags|=16384))),ls(h,c)):Dh(h)}function Dh(c){var h=c;do{if((h.flags&32768)!==0){ls(h,Wn);return}c=h.return;var x=T0(h.alternate,h,Lr);if(x!==null){sn=x;return}if(h=h.sibling,h!==null){sn=h;return}sn=h=c}while(h!==null);Rn===0&&(Rn=5)}function ls(c,h){do{var x=Q0(c.alternate,c);if(x!==null){x.flags&=32767,sn=x;return}if(x=c.return,x!==null&&(x.flags|=32768,x.subtreeFlags=0,x.deletions=null),!h&&(c=c.sibling,c!==null)){sn=c;return}sn=c=x}while(c!==null);Rn=6,sn=null}function hi(c,h,x,b,T,N,J,at,yt,Ut){var ne=ke.T,de=ts();try{Ls(2),ke.T=null,wn(c,h,x,b,de,T,N,J,at,yt,Ut)}finally{ke.T=ne,Ls(de)}}function wn(c,h,x,b,T,N,J,at){do cs();while(jo!==null);if((ze&6)!==0)throw Error(i(327));var yt=c.finishedWork;if(b=c.finishedLanes,yt===null)return null;if(c.finishedWork=null,c.finishedLanes=0,yt===c.current)throw Error(i(177));c.callbackNode=null,c.callbackPriority=0,c.cancelPendingCommit=null;var Ut=yt.lanes|yt.childLanes;if(Ut|=Ru,Y(c,b,Ut,N,J,at),c===Cn&&(sn=Cn=null,yn=0),(yt.subtreeFlags&10256)===0&&(yt.flags&10256)===0||hr||(hr=!0,ZA=Ut,Lc=x,Rh(OA,function(){return cs(),null})),x=(yt.flags&15990)!==0,(yt.subtreeFlags&15990)!==0||x?(x=ke.T,ke.T=null,N=ts(),Ls(2),J=ze,ze|=4,gu(c,yt),Sl(yt,c),Vp(c.containerInfo),c.current=yt,hA(c,yt.alternate,yt),hy(),ze=J,Ls(N),ke.T=x):c.current=yt,hr?(hr=!1,jo=c,Uc=b):Lo(c,Ut),Ut=c.pendingLanes,Ut===0&&(qa=null),H(yt.stateNode),Zt(c),h!==null)for(T=c.onRecoverableError,yt=0;yt<h.length;yt++)Ut=h[yt],T(Ut.value,{componentStack:Ut.stack});return(Uc&3)!==0&&cs(),Ut=c.pendingLanes,(b&4194218)!==0&&(Ut&42)!==0?c===Ks?zc++:(zc=0,Ks=c):zc=0,$t(0),null}function Lo(c,h){(c.pooledCacheLanes&=h)===0&&(h=c.pooledCache,h!=null&&(c.pooledCache=null,uu(h)))}function cs(){if(jo!==null){var c=jo,h=ZA;ZA=0;var x=nt(Uc),b=32>x?32:x;x=ke.T;var T=ts();try{if(Ls(b),ke.T=null,jo===null)var N=!1;else{b=Lc,Lc=null;var J=jo,at=Uc;if(jo=null,Uc=0,(ze&6)!==0)throw Error(i(331));var yt=ze;if(ze|=4,wh(J.current),dA(J,J.current,at,b),ze=yt,$t(0,!1),ca&&typeof ca.onPostCommitFiberRoot=="function")try{ca.onPostCommitFiberRoot(Qu,J)}catch{}N=!0}return N}finally{Ls(T),ke.T=x,Lo(c,h)}}return!1}function xA(c,h,x){h=ot(x,h),h=wa(c.stateNode,h,2),c=Jt(c,h,2),c!==null&&(k(c,2),Zt(c))}function Bn(c,h,x){if(c.tag===3)xA(c,c,x);else for(;h!==null;){if(h.tag===3){xA(h,c,x);break}else if(h.tag===1){var b=h.stateNode;if(typeof h.type.getDerivedStateFromError=="function"||typeof b.componentDidCatch=="function"&&(qa===null||!qa.has(b))){c=ot(x,c),x=To(2),b=Jt(h,x,2),b!==null&&(xl(x,b,h,c),k(b,2),Zt(b));break}}h=h.return}}function vA(c,h,x){var b=c.pingCache;if(b===null){b=c.pingCache=new Mn;var T=new Set;b.set(h,T)}else T=b.get(h),T===void 0&&(T=new Set,b.set(h,T));T.has(x)||(Zo=!0,T.add(x),c=z0.bind(null,c,h,x),h.then(c,c))}function z0(c,h,x){var b=c.pingCache;b!==null&&b.delete(h),c.pingedLanes|=c.suspendedLanes&x,c.warmLanes&=~x,Cn===c&&(yn&x)===x&&(Rn===4||Rn===3&&(yn&62914560)===yn&&300>Cs()-Ao?(ze&2)===0&&Tr(c,0):Ps|=x,Wo===yn&&(Wo=0)),Zt(c)}function Ec(c,h){h===0&&(h=z()),c=Vt(c,h),c!==null&&(k(c,h),Zt(c))}function _c(c){var h=c.memoizedState,x=0;h!==null&&(x=h.retryLane),Ec(c,x)}function Np(c,h){var x=0;switch(c.tag){case 13:var b=c.stateNode,T=c.memoizedState;T!==null&&(x=T.retryLane);break;case 19:b=c.stateNode;break;case 22:b=c.stateNode._retryCache;break;default:throw Error(i(314))}b!==null&&b.delete(h),Ec(c,x)}function Rh(c,h){return Tu(c,h)}function Up(c,h,x,b){this.tag=c,this.key=x,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=h,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=b,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function zo(c){return c=c.prototype,!(!c||!c.isReactComponent)}function Us(c,h){var x=c.alternate;return x===null?(x=e(c.tag,h,c.key,c.mode),x.elementType=c.elementType,x.type=c.type,x.stateNode=c.stateNode,x.alternate=c,c.alternate=x):(x.pendingProps=h,x.type=c.type,x.flags=0,x.subtreeFlags=0,x.deletions=null),x.flags=c.flags&31457280,x.childLanes=c.childLanes,x.lanes=c.lanes,x.child=c.child,x.memoizedProps=c.memoizedProps,x.memoizedState=c.memoizedState,x.updateQueue=c.updateQueue,h=c.dependencies,x.dependencies=h===null?null:{lanes:h.lanes,firstContext:h.firstContext},x.sibling=c.sibling,x.index=c.index,x.ref=c.ref,x.refCleanup=c.refCleanup,x}function Oo(c,h){c.flags&=31457282;var x=c.alternate;return x===null?(c.childLanes=0,c.lanes=h,c.child=null,c.subtreeFlags=0,c.memoizedProps=null,c.memoizedState=null,c.updateQueue=null,c.dependencies=null,c.stateNode=null):(c.childLanes=x.childLanes,c.lanes=x.lanes,c.child=x.child,c.subtreeFlags=0,c.deletions=null,c.memoizedProps=x.memoizedProps,c.memoizedState=x.memoizedState,c.updateQueue=x.updateQueue,c.type=x.type,h=x.dependencies,c.dependencies=h===null?null:{lanes:h.lanes,firstContext:h.firstContext}),c}function sr(c,h,x,b,T,N){var J=0;if(b=c,typeof c=="function")zo(c)&&(J=1);else if(typeof c=="string")J=Ua&&_s?cg(c,x,hs.current)?26:Mu(c)?27:5:Ua?cg(c,x,hs.current)?26:5:_s&&Mu(c)?27:5;else t:switch(c){case bu:return Fo(x.children,T,N,h);case Pp:J=8,T|=24;break;case Gp:return c=e(12,x,h,T|2),c.elementType=Gp,c.lanes=N,c;case _A:return c=e(13,x,h,T),c.elementType=_A,c.lanes=N,c;case Nl:return c=e(19,x,h,T),c.elementType=Nl,c.lanes=N,c;case Lh:return EA(x,T,N,h);default:if(typeof c=="object"&&c!==null)switch(c.$$typeof){case P0:case so:J=10;break t;case Rl:J=9;break t;case Su:J=11;break t;case Uh:J=14;break t;case Dr:J=16,b=null;break t}J=29,x=Error(i(130,c===null?"null":typeof c,"")),b=null}return h=e(J,x,h,T),h.elementType=c,h.type=b,h.lanes=N,h}function Fo(c,h,x,b){return c=e(7,c,b,h),c.lanes=x,c}function EA(c,h,x,b){c=e(22,c,b,h),c.elementType=Lh,c.lanes=x;var T={_visibility:1,_pendingVisibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null,_current:null,detach:function(){var N=T._current;if(N===null)throw Error(i(456));if((T._pendingVisibility&2)===0){var J=Vt(N,2);J!==null&&(T._pendingVisibility|=2,Ns(J,N,2))}},attach:function(){var N=T._current;if(N===null)throw Error(i(456));if((T._pendingVisibility&2)!==0){var J=Vt(N,2);J!==null&&(T._pendingVisibility&=-3,Ns(J,N,2))}}};return c.stateNode=T,c}function Dl(c,h,x){return c=e(6,c,null,h),c.lanes=x,c}function Cu(c,h,x){return h=e(4,c.children!==null?c.children:[],c.key,h),h.lanes=x,h.stateNode={containerInfo:c.containerInfo,pendingChildren:null,implementation:c.implementation},h}function Cc(c,h,x,b,T,N,J,at){this.tag=1,this.containerInfo=c,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=Bc,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=L(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.finishedLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=L(0),this.hiddenUpdates=L(null),this.identifierPrefix=b,this.onUncaughtError=T,this.onCaughtError=N,this.onRecoverableError=J,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=at,this.incompleteTransitions=new Map}function us(c,h,x,b,T,N,J,at,yt,Ut,ne,de){return c=new Cc(c,h,x,J,at,yt,Ut,de),h=1,N===!0&&(h|=24),N=e(3,null,null,h),c.current=N,N.stateNode=c,h=rA(),h.refCount++,c.pooledCache=h,h.refCount++,N.memoizedState={element:b,isDehydrated:x,cache:h},we(N),c}function Nh(c){return c?(c=wc,c):wc}function Lp(c){var h=c._reactInternals;if(h===void 0)throw typeof c.render=="function"?Error(i(188)):(c=Object.keys(c).join(","),Error(i(268,c)));return c=v(h),c=c!==null?C(c):null,c===null?null:Iu(c.stateNode)}function O0(c,h,x,b,T,N){T=Nh(T),b.context===null?b.context=T:b.pendingContext=T,b=Gt(h),b.payload={element:x},N=N===void 0?null:N,N!==null&&(b.callback=N),x=Jt(c,b,h),x!==null&&(Ns(x,c,h),Be(x,c,h))}function F0(c,h){if(c=c.memoizedState,c!==null&&c.dehydrated!==null){var x=c.retryLane;c.retryLane=x!==0&&x<h?x:h}}function zp(c,h){F0(c,h),(c=c.alternate)&&F0(c,h)}var Le={},Op=ap(),vs=h3(),bc=Object.assign,Fp=Symbol.for("react.element"),Po=Symbol.for("react.transitional.element"),Qr=Symbol.for("react.portal"),bu=Symbol.for("react.fragment"),Pp=Symbol.for("react.strict_mode"),Gp=Symbol.for("react.profiler"),P0=Symbol.for("react.provider"),Rl=Symbol.for("react.consumer"),so=Symbol.for("react.context"),Su=Symbol.for("react.forward_ref"),_A=Symbol.for("react.suspense"),Nl=Symbol.for("react.suspense_list"),Uh=Symbol.for("react.memo"),Dr=Symbol.for("react.lazy"),Lh=Symbol.for("react.offscreen"),G0=Symbol.for("react.memo_cache_sentinel"),kp=Symbol.iterator,Sc=Symbol.for("react.client.reference"),ke=Op.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,CA,Hp,Ul=!1,Ll=Array.isArray,bA=t.rendererVersion,zh=t.rendererPackageName,Oh=t.extraDevToolsConfig,Iu=t.getPublicInstance,Ic=t.getRootHostContext,k0=t.getChildHostContext,zl=t.prepareForCommit,Vp=t.resetAfterCommit,Yp=t.createInstance,ao=t.appendInitialChild,Go=t.finalizeInitialChildren,Ol=t.shouldSetTextContent,SA=t.createTextInstance,qp=t.scheduleTimeout,Fh=t.cancelTimeout,Bc=t.noTimeout,ro=t.isPrimaryRenderer;t.warnsIfNotActing;var Es=t.supportsMutation,Ra=t.supportsPersistence,Zs=t.supportsHydration,Xp=t.getInstanceFromNode;t.beforeActiveInstanceBlur,t.afterActiveInstanceBlur;var Jp=t.preparePortalMount;t.prepareScopeUpdate,t.getInstanceFromScope;var Ls=t.setCurrentUpdatePriority,ts=t.getCurrentUpdatePriority,ar=t.resolveUpdatePriority;t.resolveEventType,t.resolveEventTimeStamp;var Fl=t.shouldAttemptEagerTransition,Zp=t.detachDeletedInstance;t.requestPostPaintCallback;var H0=t.maySuspendCommit,ko=t.preloadInstance,Na=t.startSuspendingCommit,Di=t.suspendInstance,IA=t.waitForCommitToBeReady,oa=t.NotPendingTransition,Ye=t.HostTransitionContext,ii=t.resetFormInstance;t.bindToConsole;var Ji=t.supportsMicrotasks,BA=t.scheduleMicrotask,oo=t.supportsTestSelectors,Mc=t.findFiberRoot,MA=t.getBoundingRect,Ph=t.getTextContent,lo=t.isHiddenSubtree,e_=t.matchAccessibilityRole,Ri=t.setFocusIfFocusable,Wp=t.setupIntersectionObserver,jp=t.appendChild,V0=t.appendChildToContainer,Y0=t.commitTextUpdate,n_=t.commitMount,Kp=t.commitUpdate,$p=t.insertBefore,tg=t.insertInContainerBefore,Ws=t.removeChild,Pi=t.removeChildFromContainer,Gh=t.resetTextContent,kh=t.hideInstance,wA=t.hideTextInstance,eg=t.unhideInstance,Ho=t.unhideTextInstance,TA=t.clearContainer,ng=t.cloneInstance,QA=t.createContainerChildSet,ig=t.appendChildToContainerChildSet,q0=t.finalizeContainerChildren,sg=t.replaceContainerChildren,ag=t.cloneHiddenInstance,rg=t.cloneHiddenTextInstance,DA=t.isSuspenseInstancePending,Hh=t.isSuspenseInstanceFallback,X0=t.getSuspenseInstanceFallbackErrorDetails,i_=t.registerSuspenseInstanceRetry,J0=t.canHydrateFormStateMarker,Z0=t.isFormStateMarkerMatching,og=t.getNextHydratableSibling,RA=t.getFirstHydratableChild,W0=t.getFirstHydratableChildWithinContainer,j0=t.getFirstHydratableChildWithinSuspenseInstance,K0=t.canHydrateInstance,$0=t.canHydrateTextInstance,ty=t.canHydrateSuspenseInstance,s_=t.hydrateInstance,ey=t.hydrateTextInstance,Bu=t.hydrateSuspenseInstance,ny=t.getNextHydratableInstanceAfterSuspenseInstance,NA=t.commitHydratedContainer,UA=t.commitHydratedSuspenseInstance,iy=t.clearSuspenseBoundary,lg=t.clearSuspenseBoundaryFromContainer,sy=t.shouldDeleteUnhydratedTailInstances;t.diffHydratedPropsForDevWarnings,t.diffHydratedTextForDevWarnings,t.describeHydratableInstanceForDevWarnings;var ay=t.validateHydratableInstance,ry=t.validateHydratableTextInstance,Ua=t.supportsResources,cg=t.isHostHoistableType,LA=t.getHoistableRoot,zA=t.getResource,ug=t.acquireResource,hg=t.releaseResource,fg=t.hydrateHoistable,Ag=t.mountHoistable,dg=t.unmountHoistable,a_=t.createHoistableInstance,pg=t.prepareToCommitHoistables,oy=t.mayResourceSuspendCommit,gg=t.preloadResource,mg=t.suspendResource,_s=t.supportsSingletons,yg=t.resolveSingletonInstance,r_=t.clearSingleton,o_=t.acquireSingletonInstance,ly=t.releaseSingletonInstance,Mu=t.isHostSingletonType,Vh=[],Vo=-1,wc={},la=Math.clz32?Math.clz32:w,Yh=Math.log,cy=Math.LN2,wu=128,qh=4194304,Tu=vs.unstable_scheduleCallback,Xh=vs.unstable_cancelCallback,uy=vs.unstable_shouldYield,hy=vs.unstable_requestPaint,Cs=vs.unstable_now,xg=vs.unstable_ImmediatePriority,fy=vs.unstable_UserBlockingPriority,OA=vs.unstable_NormalPriority,FA=vs.unstable_IdlePriority,Ay=vs.log,vg=vs.unstable_setDisableYieldValue,Qu=null,ca=null,La=typeof Object.is=="function"?Object.is:it,PA=new WeakMap,yi=[],Ni=0,Jh=null,Zh=0,za=[],Oa=0,Rr=null,co=1,rr="",hs=S(null),Wh=S(null),Nr=S(null),Du=S(null),zs=null,bs=null,zn=!1,Fa=null,or=!1,jh=Error(i(519)),Pa=[],Pl=0,Ru=0,Nu=null,Tc=null,Kh=!1,$h=!1,Ur=!1,Gl=0,tf=null,GA=0,ua=0,kl=null,Yo=!1,Uu=!1,ef=Object.prototype.hasOwnProperty,ni=Error(i(460)),Eg=Error(i(474)),kA={then:function(){}},Qc=null,uo=null,lr=0,Hl=$i(!0),_g=$i(!1),ho=S(null),Ga=S(0),ka=S(null),cr=null,Zi=S(0),fo=0,un=null,Yn=null,Gi=null,ur=!1,xi=!1,qo=!1,nf=0,Ui=0,Lu=null,dy=0,HA=function(){return{lastEffect:null,events:null,stores:null,memoCache:null}},On={readContext:xs,use:Ct,useCallback:an,useContext:an,useEffect:an,useImperativeHandle:an,useLayoutEffect:an,useInsertionEffect:an,useMemo:an,useReducer:an,useRef:an,useState:an,useDebugValue:an,useDeferredValue:an,useTransition:an,useSyncExternalStore:an,useId:an};On.useCacheRefresh=an,On.useMemoCache=an,On.useHostTransitionStatus=an,On.useFormState=an,On.useActionState=an,On.useOptimistic=an;var Wi={readContext:xs,use:Ct,useCallback:function(c,h){return pi().memoizedState=[c,h===void 0?null:h],c},useContext:xs,useEffect:ml,useImperativeHandle:function(c,h,x){x=x!=null?x.concat([c]):null,ms(4194308,4,uc.bind(null,h,c),x)},useLayoutEffect:function(c,h){return ms(4194308,4,c,h)},useInsertionEffect:function(c,h){ms(4,2,c,h)},useMemo:function(c,h){var x=pi();h=h===void 0?null:h;var b=c();if(qo){tt(!0);try{c()}finally{tt(!1)}}return x.memoizedState=[b,h],b},useReducer:function(c,h,x){var b=pi();if(x!==void 0){var T=x(h);if(qo){tt(!0);try{x(h)}finally{tt(!1)}}}else T=h;return b.memoizedState=b.baseState=T,c={pending:null,lanes:0,dispatch:null,lastRenderedReducer:c,lastRenderedState:T},b.queue=c,c=c.dispatch=Mr.bind(null,un,c),[b.memoizedState,c]},useRef:function(c){var h=pi();return c={current:c},h.memoizedState=c},useState:function(c){c=Ke(c);var h=c.queue,x=dc.bind(null,un,h);return h.dispatch=x,[c.memoizedState,x]},useDebugValue:hc,useDeferredValue:function(c,h){var x=pi();return Wr(x,c,h)},useTransition:function(){var c=Ke(!1);return c=cu.bind(null,un,c.queue,!0,!1),pi().memoizedState=c,[!1,c]},useSyncExternalStore:function(c,h,x){var b=un,T=pi();if(zn){if(x===void 0)throw Error(i(407));x=x()}else{if(x=h(),Cn===null)throw Error(i(349));(yn&60)!==0||Te(b,h,x)}T.memoizedState=x;var N={value:x,getSnapshot:h};return T.queue=N,ml(Qe.bind(null,b,N,c),[c]),b.flags|=2048,bi(9,_e.bind(null,b,N,x,h),{destroy:void 0},null),x},useId:function(){var c=pi(),h=Cn.identifierPrefix;if(zn){var x=rr,b=co;x=(b&~(1<<32-la(b)-1)).toString(32)+x,h=":"+h+"R"+x,x=nf++,0<x&&(h+="H"+x.toString(32)),h+=":"}else x=dy++,h=":"+h+"r"+x.toString(32)+":";return c.memoizedState=h},useCacheRefresh:function(){return pi().memoizedState=yl.bind(null,un)}};Wi.useMemoCache=vt,Wi.useHostTransitionStatus=wo,Wi.useFormState=Ba,Wi.useActionState=Ba,Wi.useOptimistic=function(c){var h=pi();h.memoizedState=h.baseState=c;var x={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return h.queue=x,h=ue.bind(null,un,!0,x),x.dispatch=h,[c,h]};var Os={readContext:xs,use:Ct,useCallback:lu,useContext:xs,useEffect:Zr,useImperativeHandle:nr,useInsertionEffect:vh,useLayoutEffect:iA,useMemo:Br,useReducer:Kt,useRef:Ma,useState:function(){return Kt(ht)},useDebugValue:hc,useDeferredValue:function(c,h){var x=q();return fc(x,Yn.memoizedState,c,h)},useTransition:function(){var c=Kt(ht)[0],h=q().memoizedState;return[typeof c=="boolean"?c:ut(c),h]},useSyncExternalStore:ye,useId:ir};Os.useCacheRefresh=Ac,Os.useMemoCache=vt,Os.useHostTransitionStatus=wo,Os.useFormState=Xn,Os.useActionState=Xn,Os.useOptimistic=function(c,h){var x=q();return cn(x,Yn,c,h)};var Vl={readContext:xs,use:Ct,useCallback:lu,useContext:xs,useEffect:Zr,useImperativeHandle:nr,useInsertionEffect:vh,useLayoutEffect:iA,useMemo:Br,useReducer:me,useRef:Ma,useState:function(){return me(ht)},useDebugValue:hc,useDeferredValue:function(c,h){var x=q();return Yn===null?Wr(x,c,h):fc(x,Yn.memoizedState,c,h)},useTransition:function(){var c=me(ht)[0],h=q().memoizedState;return[typeof c=="boolean"?c:ut(c),h]},useSyncExternalStore:ye,useId:ir};Vl.useCacheRefresh=Ac,Vl.useMemoCache=vt,Vl.useHostTransitionStatus=wo,Vl.useFormState=Qi,Vl.useActionState=Qi,Vl.useOptimistic=function(c,h){var x=q();return Yn!==null?cn(x,Yn,c,h):(x.baseState=c,[c,x.queue.dispatch])};var VA={isMounted:function(c){return(c=c._reactInternals)?g(c)===c:!1},enqueueSetState:function(c,h,x){c=c._reactInternals;var b=Js(),T=Gt(b);T.payload=h,x!=null&&(T.callback=x),h=Jt(c,T,b),h!==null&&(Ns(h,c,b),Be(h,c,b))},enqueueReplaceState:function(c,h,x){c=c._reactInternals;var b=Js(),T=Gt(b);T.tag=1,T.payload=h,x!=null&&(T.callback=x),h=Jt(c,T,b),h!==null&&(Ns(h,c,b),Be(h,c,b))},enqueueForceUpdate:function(c,h){c=c._reactInternals;var x=Js(),b=Gt(x);b.tag=2,h!=null&&(b.callback=h),h=Jt(c,b,x),h!==null&&(Ns(h,c,x),Be(h,c,x))}},Cg=typeof reportError=="function"?reportError:function(c){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var h=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof c=="object"&&c!==null&&typeof c.message=="string"?String(c.message):String(c),error:c});if(!window.dispatchEvent(h))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",c);return}console.error(c)},py=Error(i(461)),ki=!1,Fs={dehydrated:null,treeContext:null,retryLane:0},ha=S(null),Yl=null,Li=null,gy=typeof AbortController<"u"?AbortController:function(){var c=[],h=this.signal={aborted:!1,addEventListener:function(x,b){c.push(b)}};this.abort=function(){h.aborted=!0,c.forEach(function(x){return x()})}},Xo=vs.unstable_scheduleCallback,Dc=vs.unstable_NormalPriority,Jn={$$typeof:so,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0},YA=ke.S;ke.S=function(c,h){typeof h=="object"&&h!==null&&typeof h.then=="function"&&Bt(c,h),YA!==null&&YA(c,h)};var Jo=S(null),es=!1,Ii=!1,ql=!1,zu=typeof WeakSet=="function"?WeakSet:Set,zi=null,Rc=!1,Hi=null,fa=!1,js=null,Nc=8192,qA={getCacheForType:function(c){var h=xs(Jn),x=h.data.get(c);return x===void 0&&(x=c(),h.data.set(c,x)),x}},sf=0,XA=1,JA=2,Dn=3,Zn=4;if(typeof Symbol=="function"&&Symbol.for){var hn=Symbol.for;sf=hn("selector.component"),XA=hn("selector.has_pseudo_class"),JA=hn("selector.role"),Dn=hn("selector.test_id"),Zn=hn("selector.text")}var Mn=typeof WeakMap=="function"?WeakMap:Map,ze=0,Cn=null,sn=null,yn=0,si=0,Vi=null,Wn=!1,Ha=!1,Zo=!1,Lr=0,Rn=0,Va=0,zr=0,Ps=0,Aa=0,Wo=0,Ou=null,Ya=null,Fu=!1,Ao=0,Bi=1/0,Or=null,qa=null,hr=!1,jo=null,Uc=0,ZA=0,Lc=null,zc=0,Ks=null;return Le.attemptContinuousHydration=function(c){if(c.tag===13){var h=Vt(c,67108864);h!==null&&Ns(h,c,67108864),zp(c,67108864)}},Le.attemptHydrationAtCurrentPriority=function(c){if(c.tag===13){var h=Js(),x=Vt(c,h);x!==null&&Ns(x,c,h),zp(c,h)}},Le.attemptSynchronousHydration=function(c){switch(c.tag){case 3:if(c=c.stateNode,c.current.memoizedState.isDehydrated){var h=Q(c.pendingLanes);if(h!==0){for(c.pendingLanes|=2,c.entangledLanes|=2;h;){var x=1<<31-la(h);c.entanglements[1]|=x,h&=~x}Zt(c),(ze&6)===0&&(Bi=Cs()+500,$t(0))}}break;case 13:h=Vt(c,2),h!==null&&Ns(h,c,2),Dp(),zp(c,2)}},Le.batchedUpdates=function(c,h){return c(h)},Le.createComponentSelector=function(c){return{$$typeof:sf,value:c}},Le.createContainer=function(c,h,x,b,T,N,J,at,yt,Ut){return us(c,h,!1,null,x,b,N,J,at,yt,Ut,null)},Le.createHasPseudoClassSelector=function(c){return{$$typeof:XA,value:c}},Le.createHydrationContainer=function(c,h,x,b,T,N,J,at,yt,Ut,ne,de,xe){return c=us(x,b,!0,c,T,N,at,yt,Ut,ne,de,xe),c.context=Nh(null),x=c.current,b=Js(),T=Gt(b),T.callback=h??null,Jt(x,T,b),c.current.lanes=b,k(c,b),Zt(c),c},Le.createPortal=function(c,h,x){var b=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:Qr,key:b==null?null:""+b,children:c,containerInfo:h,implementation:x}},Le.createRoleSelector=function(c){return{$$typeof:JA,value:c}},Le.createTestNameSelector=function(c){return{$$typeof:Dn,value:c}},Le.createTextSelector=function(c){return{$$typeof:Zn,value:c}},Le.defaultOnCaughtError=function(c){console.error(c)},Le.defaultOnRecoverableError=function(c){Cg(c)},Le.defaultOnUncaughtError=function(c){Cg(c)},Le.deferredUpdates=function(c){var h=ke.T,x=ts();try{return Ls(32),ke.T=null,c()}finally{Ls(x),ke.T=h}},Le.discreteUpdates=function(c,h,x,b,T){var N=ke.T,J=ts();try{return Ls(2),ke.T=null,c(h,x,b,T)}finally{Ls(J),ke.T=N,ze===0&&(Bi=Cs()+500)}},Le.findAllNodes=Xs,Le.findBoundingRects=function(c,h){if(!oo)throw Error(i(363));h=Xs(c,h),c=[];for(var x=0;x<h.length;x++)c.push(MA(h[x]));for(h=c.length-1;0<h;h--){x=c[h];for(var b=x.x,T=b+x.width,N=x.y,J=N+x.height,at=h-1;0<=at;at--)if(h!==at){var yt=c[at],Ut=yt.x,ne=Ut+yt.width,de=yt.y,xe=de+yt.height;if(b>=Ut&&N>=de&&T<=ne&&J<=xe){c.splice(h,1);break}else if(b!==Ut||x.width!==yt.width||xe<N||de>J){if(!(N!==de||x.height!==yt.height||ne<b||Ut>T)){Ut>b&&(yt.width+=Ut-b,yt.x=b),ne<T&&(yt.width=T-Ut),c.splice(h,1);break}}else{de>N&&(yt.height+=de-N,yt.y=N),xe<J&&(yt.height=J-de),c.splice(h,1);break}}}return c},Le.findHostInstance=Lp,Le.findHostInstanceWithNoPortals=function(c){return c=v(c),c=c!==null?I(c):null,c===null?null:Iu(c.stateNode)},Le.findHostInstanceWithWarning=function(c){return Lp(c)},Le.flushPassiveEffects=cs,Le.flushSyncFromReconciler=function(c){var h=ze;ze|=1;var x=ke.T,b=ts();try{if(Ls(2),ke.T=null,c)return c()}finally{Ls(b),ke.T=x,ze=h,(ze&6)===0&&$t(0)}},Le.flushSyncWork=Dp,Le.focusWithin=function(c,h){if(!oo)throw Error(i(363));for(c=gA(c),h=U0(c,h),h=Array.from(h),c=0;c<h.length;){var x=h[c++],b=x.tag;if(!lo(x)){if((b===5||b===26||b===27)&&Ri(x.stateNode))return!0;for(x=x.child;x!==null;)h.push(x),x=x.sibling}}return!1},Le.getFindAllNodesFailureDescription=function(c,h){if(!oo)throw Error(i(363));var x=0,b=[];c=[gA(c),0];for(var T=0;T<c.length;){var N=c[T++],J=N.tag,at=c[T++],yt=h[at];if((J!==5&&J!==26&&J!==27||!lo(N))&&(Eu(N,yt)&&(b.push(Tl(yt)),at++,at>x&&(x=at)),at<h.length))for(N=N.child;N!==null;)c.push(N,at),N=N.sibling}if(x<h.length){for(c=[];x<h.length;x++)c.push(Tl(h[x]));return`findAllNodes was able to match part of the selector:
  `+(b.join(" > ")+`

No matching component was found for:
  `)+c.join(" > ")}return null},Le.getPublicRootInstance=function(c){if(c=c.current,!c.child)return null;switch(c.child.tag){case 27:case 5:return Iu(c.child.stateNode);default:return c.child.stateNode}},Le.injectIntoDevTools=function(){var c={bundleType:0,version:bA,rendererPackageName:zh,currentDispatcherRef:ke,findFiberByHostInstance:Xp,reconcilerVersion:"19.0.0"};if(Oh!==null&&(c.rendererConfig=Oh),typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u")c=!1;else{var h=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(h.isDisabled||!h.supportsFiber)c=!0;else{try{Qu=h.inject(c),ca=h}catch{}c=!!h.checkDCE}}return c},Le.isAlreadyRendering=function(){return!1},Le.observeVisibleRects=function(c,h,x,b){if(!oo)throw Error(i(363));c=Xs(c,h);var T=Wp(c,x,b).disconnect;return{disconnect:function(){T()}}},Le.shouldError=function(){return null},Le.shouldSuspend=function(){return!1},Le.startHostTransition=function(c,h,x,b){if(c.tag!==5)throw Error(i(476));var T=Eh(c).queue;cu(c,T,h,oa,x===null?n:function(){var N=Eh(c).next.queue;return jr(c,N,{},Js()),x(b)})},Le.updateContainer=function(c,h,x,b){var T=h.current,N=Js();return O0(T,N,c,h,x,b),N},Le.updateContainerSync=function(c,h,x,b){return h.tag===0&&cs(),O0(h.current,2,c,h,x,b),2},Le},s.exports.default=s.exports,Object.defineProperty(s.exports,"__esModule",{value:!0})})(LC)),LC.exports}var sB;function dF(){return sB||(sB=1,UC.exports=AF()),UC.exports}var pF=dF();const gF=uS(pF);var aB=h3();function tI(s,t,e){if(!s)return;if(e(s)===!0)return s;let n=t?s.return:s.child;for(;n;){const i=tI(n,t,e);if(i)return i;n=t?null:n.sibling}}function f3(s){try{return Object.defineProperties(s,{_currentRenderer:{get(){return null},set(){}},_currentRenderer2:{get(){return null},set(){}}})}catch{return s}}const eI=f3(et.createContext(null));class A3 extends et.Component{render(){return et.createElement(eI.Provider,{value:this._reactInternals},this.props.children)}}function d3(){const s=et.useContext(eI);if(s===null)throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");const t=et.useId();return et.useMemo(()=>{for(const e of[s,s?.alternate]){if(!e)continue;const n=tI(e,!1,i=>{let r=i.memoizedState;for(;r;){if(r.memoizedState===t)return!0;r=r.next}});if(n)return n}},[s,t])}const mF=Symbol.for("react.context"),yF=s=>s!==null&&typeof s=="object"&&"$$typeof"in s&&s.$$typeof===mF;function xF(){const s=d3(),[t]=et.useState(()=>new Map);t.clear();let e=s;for(;e;){const n=e.type;yF(n)&&n!==eI&&!t.has(n)&&t.set(n,et.use(f3(n))),e=e.return}return t}function vF(){const s=xF();return et.useMemo(()=>Array.from(s.keys()).reduce((t,e)=>n=>et.createElement(t,null,et.createElement(e.Provider,{...n,value:s.get(e)})),t=>et.createElement(A3,{...t})),[s])}function p3(s){let t=s.root;for(;t.getState().previousRoot;)t=t.getState().previousRoot;return t}const g3=s=>s&&s.isOrthographicCamera,EF=s=>s&&s.hasOwnProperty("current"),_F=s=>s!=null&&(typeof s=="string"||typeof s=="number"||s.isColor),d0=((s,t)=>typeof window<"u"&&(((s=window.document)==null?void 0:s.createElement)||((t=window.navigator)==null?void 0:t.product)==="ReactNative"))()?et.useLayoutEffect:et.useEffect;function m3(s){const t=et.useRef(s);return d0(()=>{t.current=s},[s]),t}function CF(){const s=d3(),t=vF();return et.useMemo(()=>({children:e})=>{const i=!!tI(s,!0,r=>r.type===et.StrictMode)?et.StrictMode:et.Fragment;return pn.jsx(i,{children:pn.jsx(t,{children:e})})},[s,t])}function bF({set:s}){return d0(()=>(s(new Promise(()=>null)),()=>s(!1)),[s]),null}const SF=(s=>(s=class extends et.Component{constructor(...e){super(...e),this.state={error:!1}}componentDidCatch(e){this.props.set(e)}render(){return this.state.error?null:this.props.children}},s.getDerivedStateFromError=()=>({error:!0}),s))();function y3(s){var t;const e=typeof window<"u"?(t=window.devicePixelRatio)!=null?t:2:1;return Array.isArray(s)?Math.min(Math.max(s[0],e),s[1]):s}function Cd(s){var t;return(t=s.__r3f)==null?void 0:t.root.getState()}const Oi={obj:s=>s===Object(s)&&!Oi.arr(s)&&typeof s!="function",fun:s=>typeof s=="function",str:s=>typeof s=="string",num:s=>typeof s=="number",boo:s=>typeof s=="boolean",und:s=>s===void 0,nul:s=>s===null,arr:s=>Array.isArray(s),equ(s,t,{arrays:e="shallow",objects:n="reference",strict:i=!0}={}){if(typeof s!=typeof t||!!s!=!!t)return!1;if(Oi.str(s)||Oi.num(s)||Oi.boo(s))return s===t;const r=Oi.obj(s);if(r&&n==="reference")return s===t;const l=Oi.arr(s);if(l&&e==="reference")return s===t;if((l||r)&&s===t)return!0;let u;for(u in s)if(!(u in t))return!1;if(r&&e==="shallow"&&n==="shallow"){for(u in i?t:s)if(!Oi.equ(s[u],t[u],{strict:i,objects:"reference"}))return!1}else for(u in i?t:s)if(s[u]!==t[u])return!1;if(Oi.und(u)){if(l&&s.length===0&&t.length===0||r&&Object.keys(s).length===0&&Object.keys(t).length===0)return!0;if(s!==t)return!1}return!0}};function IF(s){const t={nodes:{},materials:{},meshes:{}};return s&&s.traverse(e=>{e.name&&(t.nodes[e.name]=e),e.material&&!t.materials[e.material.name]&&(t.materials[e.material.name]=e.material),e.isMesh&&!t.meshes[e.name]&&(t.meshes[e.name]=e)}),t}function BF(s){s.type!=="Scene"&&(s.dispose==null||s.dispose());for(const t in s){const e=s[t];e?.type!=="Scene"&&(e==null||e.dispose==null||e.dispose())}}const x3=["children","key","ref"];function MF(s){const t={};for(const e in s)x3.includes(e)||(t[e]=s[e]);return t}function $v(s,t,e,n){const i=s;let r=i?.__r3f;return r||(r={root:t,type:e,parent:null,children:[],props:MF(n),object:i,eventCount:0,handlers:{},isHidden:!1},i&&(i.__r3f=r)),r}function Km(s,t){if(!t.includes("-"))return{root:s,key:t,target:s[t]};if(t in s)return{root:s,key:t,target:s[t]};let e=s;const n=t.split("-");for(const i of n){if(typeof e!="object"||e===null){if(e!==void 0){const r=n.slice(n.indexOf(i)).join("-");return{root:e,key:r,target:void 0}}return{root:s,key:t,target:void 0}}t=i,s=e,e=e[t]}return{root:s,key:t,target:e}}const rB=/-\d+$/;function tE(s,t){if(Oi.str(t.props.attach)){if(rB.test(t.props.attach)){const i=t.props.attach.replace(rB,""),{root:r,key:l}=Km(s.object,i);Array.isArray(r[l])||(r[l]=[])}const{root:e,key:n}=Km(s.object,t.props.attach);t.previousAttach=e[n],e[n]=t.object}else Oi.fun(t.props.attach)&&(t.previousAttach=t.props.attach(s.object,t.object))}function eE(s,t){if(Oi.str(t.props.attach)){const{root:e,key:n}=Km(s.object,t.props.attach),i=t.previousAttach;i===void 0?delete e[n]:e[n]=i}else t.previousAttach==null||t.previousAttach(s.object,t.object);delete t.previousAttach}const Ob=[...x3,"args","dispose","attach","object","onUpdate","dispose"],oB=new Map;function wF(s){let t=oB.get(s.constructor);try{t||(t=new s.constructor,oB.set(s.constructor,t))}catch{}return t}function TF(s,t){const e={};for(const n in t)if(!Ob.includes(n)&&!Oi.equ(t[n],s.props[n])){e[n]=t[n];for(const i in t)i.startsWith(`${n}-`)&&(e[i]=t[i])}for(const n in s.props){if(Ob.includes(n)||t.hasOwnProperty(n))continue;const{root:i,key:r}=Km(s.object,n);if(i.constructor&&i.constructor.length===0){const l=wF(i);Oi.und(l)||(e[r]=l[r])}else e[r]=0}return e}const QF=["map","emissiveMap","sheenColorMap","specularColorMap","envMap"],DF=/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;function oh(s,t){var e;const n=s.__r3f,i=n&&p3(n).getState(),r=n?.eventCount;for(const u in t){let A=t[u];if(Ob.includes(u))continue;if(n&&DF.test(u)){typeof A=="function"?n.handlers[u]=A:delete n.handlers[u],n.eventCount=Object.keys(n.handlers).length;continue}if(A===void 0)continue;let{root:d,key:m,target:g}=Km(s,u);if(g===void 0&&(typeof d!="object"||d===null))throw Error(`R3F: Cannot set "${u}". Ensure it is an object before setting "${m}".`);if(g instanceof ep&&A instanceof ep)g.mask=A.mask;else if(g instanceof le&&_F(A))g.set(A);else if(g!==null&&typeof g=="object"&&typeof g.set=="function"&&typeof g.copy=="function"&&A!=null&&A.constructor&&g.constructor===A.constructor)g.copy(A);else if(g!==null&&typeof g=="object"&&typeof g.set=="function"&&Array.isArray(A))typeof g.fromArray=="function"?g.fromArray(A):g.set(...A);else if(g!==null&&typeof g=="object"&&typeof g.set=="function"&&typeof A=="number")typeof g.setScalar=="function"?g.setScalar(A):g.set(A);else{var l;d[m]=A,i&&!i.linear&&QF.includes(m)&&(l=d[m])!=null&&l.isTexture&&d[m].format===Ki&&d[m].type===ea&&(d[m].colorSpace=ks)}}if(n!=null&&n.parent&&i!=null&&i.internal&&(e=n.object)!=null&&e.isObject3D&&r!==n.eventCount){const u=n.object,A=i.internal.interaction.indexOf(u);A>-1&&i.internal.interaction.splice(A,1),n.eventCount&&u.raycast!==null&&i.internal.interaction.push(u)}return n&&n.props.attach===void 0&&(n.object.isBufferGeometry?n.props.attach="geometry":n.object.isMaterial&&(n.props.attach="material")),n&&hp(n),s}function hp(s){var t;if(!s.parent)return;s.props.onUpdate==null||s.props.onUpdate(s.object);const e=(t=s.root)==null||t.getState==null?void 0:t.getState();e&&e.internal.frames===0&&e.invalidate()}function RF(s,t){s.manual||(g3(s)?(s.left=t.width/-2,s.right=t.width/2,s.top=t.height/2,s.bottom=t.height/-2):s.aspect=t.width/t.height,s.updateProjectionMatrix())}const Wa=s=>s?.isObject3D;function Sx(s){return(s.eventObject||s.object).uuid+"/"+s.index+s.instanceId}function v3(s,t,e,n){const i=e.get(t);i&&(e.delete(t),e.size===0&&(s.delete(n),i.target.releasePointerCapture(n)))}function NF(s,t){const{internal:e}=s.getState();e.interaction=e.interaction.filter(n=>n!==t),e.initialHits=e.initialHits.filter(n=>n!==t),e.hovered.forEach((n,i)=>{(n.eventObject===t||n.object===t)&&e.hovered.delete(i)}),e.capturedMap.forEach((n,i)=>{v3(e.capturedMap,t,n,i)})}function UF(s){function t(A){const{internal:d}=s.getState(),m=A.offsetX-d.initialClick[0],g=A.offsetY-d.initialClick[1];return Math.round(Math.sqrt(m*m+g*g))}function e(A){return A.filter(d=>["Move","Over","Enter","Out","Leave"].some(m=>{var g;return(g=d.__r3f)==null?void 0:g.handlers["onPointer"+m]}))}function n(A,d){const m=s.getState(),g=new Set,y=[],v=d?d(m.internal.interaction):m.internal.interaction;for(let E=0;E<v.length;E++){const B=Cd(v[E]);B&&(B.raycaster.camera=void 0)}m.previousRoot||m.events.compute==null||m.events.compute(A,m);function C(E){const B=Cd(E);if(!B||!B.events.enabled||B.raycaster.camera===null)return[];if(B.raycaster.camera===void 0){var w;B.events.compute==null||B.events.compute(A,B,(w=B.previousRoot)==null?void 0:w.getState()),B.raycaster.camera===void 0&&(B.raycaster.camera=null)}return B.raycaster.camera?B.raycaster.intersectObject(E,!0):[]}let I=v.flatMap(C).sort((E,B)=>{const w=Cd(E.object),Q=Cd(B.object);return!w||!Q?E.distance-B.distance:Q.events.priority-w.events.priority||E.distance-B.distance}).filter(E=>{const B=Sx(E);return g.has(B)?!1:(g.add(B),!0)});m.events.filter&&(I=m.events.filter(I,m));for(const E of I){let B=E.object;for(;B;){var S;(S=B.__r3f)!=null&&S.eventCount&&y.push({...E,eventObject:B}),B=B.parent}}if("pointerId"in A&&m.internal.capturedMap.has(A.pointerId))for(let E of m.internal.capturedMap.get(A.pointerId).values())g.has(Sx(E.intersection))||y.push(E.intersection);return y}function i(A,d,m,g){if(A.length){const y={stopped:!1};for(const v of A){let C=Cd(v.object);if(C||v.object.traverseAncestors(I=>{const S=Cd(I);if(S)return C=S,!1}),C){const{raycaster:I,pointer:S,camera:E,internal:B}=C,w=new F(S.x,S.y,0).unproject(E),Q=z=>{var L,k;return(L=(k=B.capturedMap.get(z))==null?void 0:k.has(v.eventObject))!=null?L:!1},R=z=>{const L={intersection:v,target:d.target};B.capturedMap.has(z)?B.capturedMap.get(z).set(v.eventObject,L):B.capturedMap.set(z,new Map([[v.eventObject,L]])),d.target.setPointerCapture(z)},D=z=>{const L=B.capturedMap.get(z);L&&v3(B.capturedMap,v.eventObject,L,z)};let U={};for(let z in d){let L=d[z];typeof L!="function"&&(U[z]=L)}let P={...v,...U,pointer:S,intersections:A,stopped:y.stopped,delta:m,unprojectedPoint:w,ray:I.ray,camera:E,stopPropagation(){const z="pointerId"in d&&B.capturedMap.get(d.pointerId);if((!z||z.has(v.eventObject))&&(P.stopped=y.stopped=!0,B.hovered.size&&Array.from(B.hovered.values()).find(L=>L.eventObject===v.eventObject))){const L=A.slice(0,A.indexOf(v));r([...L,v])}},target:{hasPointerCapture:Q,setPointerCapture:R,releasePointerCapture:D},currentTarget:{hasPointerCapture:Q,setPointerCapture:R,releasePointerCapture:D},nativeEvent:d};if(g(P),y.stopped===!0)break}}}return A}function r(A){const{internal:d}=s.getState();for(const m of d.hovered.values())if(!A.length||!A.find(g=>g.object===m.object&&g.index===m.index&&g.instanceId===m.instanceId)){const y=m.eventObject.__r3f;if(d.hovered.delete(Sx(m)),y!=null&&y.eventCount){const v=y.handlers,C={...m,intersections:A};v.onPointerOut==null||v.onPointerOut(C),v.onPointerLeave==null||v.onPointerLeave(C)}}}function l(A,d){for(let m=0;m<d.length;m++){const g=d[m].__r3f;g==null||g.handlers.onPointerMissed==null||g.handlers.onPointerMissed(A)}}function u(A){switch(A){case"onPointerLeave":case"onPointerCancel":return()=>r([]);case"onLostPointerCapture":return d=>{const{internal:m}=s.getState();"pointerId"in d&&m.capturedMap.has(d.pointerId)&&requestAnimationFrame(()=>{m.capturedMap.has(d.pointerId)&&(m.capturedMap.delete(d.pointerId),r([]))})}}return function(m){const{onPointerMissed:g,internal:y}=s.getState();y.lastEvent.current=m;const v=A==="onPointerMove",C=A==="onClick"||A==="onContextMenu"||A==="onDoubleClick",S=n(m,v?e:void 0),E=C?t(m):0;A==="onPointerDown"&&(y.initialClick=[m.offsetX,m.offsetY],y.initialHits=S.map(w=>w.eventObject)),C&&!S.length&&E<=2&&(l(m,y.interaction),g&&g(m)),v&&r(S);function B(w){const Q=w.eventObject,R=Q.__r3f;if(!(R!=null&&R.eventCount))return;const D=R.handlers;if(v){if(D.onPointerOver||D.onPointerEnter||D.onPointerOut||D.onPointerLeave){const U=Sx(w),P=y.hovered.get(U);P?P.stopped&&w.stopPropagation():(y.hovered.set(U,w),D.onPointerOver==null||D.onPointerOver(w),D.onPointerEnter==null||D.onPointerEnter(w))}D.onPointerMove==null||D.onPointerMove(w)}else{const U=D[A];U?(!C||y.initialHits.includes(Q))&&(l(m,y.interaction.filter(P=>!y.initialHits.includes(P))),U(w)):C&&y.initialHits.includes(Q)&&l(m,y.interaction.filter(P=>!y.initialHits.includes(P)))}}i(S,m,E,B)}}return{handlePointer:u}}const lB=s=>!!(s!=null&&s.render),E3=et.createContext(null),LF=(s,t)=>{const e=oF((u,A)=>{const d=new F,m=new F,g=new F;function y(E=A().camera,B=m,w=A().size){const{width:Q,height:R,top:D,left:U}=w,P=Q/R;B.isVector3?g.copy(B):g.set(...B);const z=E.getWorldPosition(d).distanceTo(g);if(g3(E))return{width:Q/E.zoom,height:R/E.zoom,top:D,left:U,factor:1,distance:z,aspect:P};{const L=E.fov*Math.PI/180,k=2*Math.tan(L/2)*z,Y=k*(Q/R);return{width:Y,height:k,top:D,left:U,factor:Q/Y,distance:z,aspect:P}}}let v;const C=E=>u(B=>({performance:{...B.performance,current:E}})),I=new Dt;return{set:u,get:A,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},scene:null,xr:null,invalidate:(E=1)=>s(A(),E),advance:(E,B)=>t(E,B,A()),legacy:!1,linear:!1,flat:!1,controls:null,clock:new h0,pointer:I,mouse:I,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:()=>{const E=A();v&&clearTimeout(v),E.performance.current!==E.performance.min&&C(E.performance.min),v=setTimeout(()=>C(A().performance.max),E.performance.debounce)}},size:{width:0,height:0,top:0,left:0},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport:y},setEvents:E=>u(B=>({...B,events:{...B.events,...E}})),setSize:(E,B,w=0,Q=0)=>{const R=A().camera,D={width:E,height:B,top:w,left:Q};u(U=>({size:D,viewport:{...U.viewport,...y(R,m,D)}}))},setDpr:E=>u(B=>{const w=y3(E);return{viewport:{...B.viewport,dpr:w,initialDpr:B.viewport.initialDpr||w}}}),setFrameloop:(E="always")=>{const B=A().clock;B.stop(),B.elapsedTime=0,E!=="never"&&(B.start(),B.elapsedTime=0),u(()=>({frameloop:E}))},previousRoot:void 0,internal:{interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,lastEvent:et.createRef(),active:!1,frames:0,priority:0,subscribe:(E,B,w)=>{const Q=A().internal;return Q.priority=Q.priority+(B>0?1:0),Q.subscribers.push({ref:E,priority:B,store:w}),Q.subscribers=Q.subscribers.sort((R,D)=>R.priority-D.priority),()=>{const R=A().internal;R!=null&&R.subscribers&&(R.priority=R.priority-(B>0?1:0),R.subscribers=R.subscribers.filter(D=>D.ref!==E))}}}}}),n=e.getState();let i=n.size,r=n.viewport.dpr,l=n.camera;return e.subscribe(()=>{const{camera:u,size:A,viewport:d,gl:m,set:g}=e.getState();if(A.width!==i.width||A.height!==i.height||d.dpr!==r){i=A,r=d.dpr,RF(u,A),d.dpr>0&&m.setPixelRatio(d.dpr);const y=typeof HTMLCanvasElement<"u"&&m.domElement instanceof HTMLCanvasElement;m.setSize(A.width,A.height,y)}u!==l&&(l=u,g(y=>({viewport:{...y.viewport,...y.viewport.getCurrentViewport(u)}})))}),e.subscribe(u=>s(u)),e};function _3(){const s=et.useContext(E3);if(!s)throw new Error("R3F: Hooks can only be used within the Canvas component!");return s}function ss(s=e=>e,t){return _3()(s,t)}function FE(s,t=0){const e=_3(),n=e.getState().internal.subscribe,i=m3(s);return d0(()=>n(i,t,e),[t,n,e]),null}const cB=new WeakMap,zF=s=>{var t;return typeof s=="function"&&(s==null||(t=s.prototype)==null?void 0:t.constructor)===s};function C3(s,t){return function(e,...n){let i;return zF(e)?(i=cB.get(e),i||(i=new e,cB.set(e,i))):i=e,s&&s(i),Promise.all(n.map(r=>new Promise((l,u)=>i.load(r,A=>{Wa(A?.scene)&&Object.assign(A,IF(A.scene)),l(A)},t,A=>u(new Error(`Could not load ${r}: ${A?.message}`))))))}}function p0(s,t,e,n){const i=Array.isArray(t)?t:[t],r=cF(C3(e,n),[s,...i],{equal:Oi.equ});return Array.isArray(t)?r:r[0]}p0.preload=function(s,t,e){const n=Array.isArray(t)?t:[t];return uF(C3(e),[s,...n])};p0.clear=function(s,t){const e=Array.isArray(t)?t:[t];return hF([s,...e])};var OF={version:"9.4.2"};function FF(s){const t=gF(s);return t.injectIntoDevTools(),t}const b3=0,sp={},PF=/^three(?=[A-Z])/,PE=s=>`${s[0].toUpperCase()}${s.slice(1)}`;let GF=0;const kF=s=>typeof s=="function";function GE(s){if(kF(s)){const t=`${GF++}`;return sp[t]=s,t}else Object.assign(sp,s)}function S3(s,t){const e=PE(s),n=sp[e];if(s!=="primitive"&&!n)throw new Error(`R3F: ${e} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);if(s==="primitive"&&!t.object)throw new Error("R3F: Primitives without 'object' are invalid!");if(t.args!==void 0&&!Array.isArray(t.args))throw new Error("R3F: The args prop must be an array!")}function HF(s,t,e){var n;return s=PE(s)in sp?s:s.replace(PF,""),S3(s,t),s==="primitive"&&(n=t.object)!=null&&n.__r3f&&delete t.object.__r3f,$v(t.object,e,s,t)}function VF(s){if(!s.isHidden){var t;s.props.attach&&(t=s.parent)!=null&&t.object?eE(s.parent,s):Wa(s.object)&&(s.object.visible=!1),s.isHidden=!0,hp(s)}}function I3(s){if(s.isHidden){var t;s.props.attach&&(t=s.parent)!=null&&t.object?tE(s.parent,s):Wa(s.object)&&s.props.visible!==!1&&(s.object.visible=!0),s.isHidden=!1,hp(s)}}function nI(s,t,e){const n=t.root.getState();if(!(!s.parent&&s.object!==n.scene)){if(!t.object){var i,r;const l=sp[PE(t.type)];t.object=(i=t.props.object)!=null?i:new l(...(r=t.props.args)!=null?r:[]),t.object.__r3f=t}if(oh(t.object,t.props),t.props.attach)tE(s,t);else if(Wa(t.object)&&Wa(s.object)){const l=s.object.children.indexOf(e?.object);if(e&&l!==-1){const u=s.object.children.indexOf(t.object);if(u!==-1){s.object.children.splice(u,1);const A=u<l?l-1:l;s.object.children.splice(A,0,t.object)}else t.object.parent=s.object,s.object.children.splice(l,0,t.object),t.object.dispatchEvent({type:"added"}),s.object.dispatchEvent({type:"childadded",child:t.object})}else s.object.add(t.object)}for(const l of t.children)nI(t,l);hp(t)}}function FC(s,t){t&&(t.parent=s,s.children.push(t),nI(s,t))}function uB(s,t,e){if(!t||!e)return;t.parent=s;const n=s.children.indexOf(e);n!==-1?s.children.splice(n,0,t):s.children.push(t),nI(s,t,e)}function B3(s){if(typeof s.dispose=="function"){const t=()=>{try{s.dispose()}catch{}};typeof IS_REACT_ACT_ENVIRONMENT<"u"?t():aB.unstable_scheduleCallback(aB.unstable_IdlePriority,t)}}function Fb(s,t,e){if(!t)return;t.parent=null;const n=s.children.indexOf(t);n!==-1&&s.children.splice(n,1),t.props.attach?eE(s,t):Wa(t.object)&&Wa(s.object)&&(s.object.remove(t.object),NF(p3(t),t.object));const i=t.props.dispose!==null&&e!==!1;for(let r=t.children.length-1;r>=0;r--){const l=t.children[r];Fb(t,l,i)}t.children.length=0,delete t.object.__r3f,i&&t.type!=="primitive"&&t.object.type!=="Scene"&&B3(t.object),e===void 0&&hp(t)}function YF(s,t){for(const e of[s,s.alternate])if(e!==null)if(typeof e.ref=="function"){e.refCleanup==null||e.refCleanup();const n=e.ref(t);typeof n=="function"&&(e.refCleanup=n)}else e.ref&&(e.ref.current=t)}const av=[];function qF(){for(const[e]of av){const n=e.parent;if(n){e.props.attach?eE(n,e):Wa(e.object)&&Wa(n.object)&&n.object.remove(e.object);for(const i of e.children)i.props.attach?eE(e,i):Wa(i.object)&&Wa(e.object)&&e.object.remove(i.object)}e.isHidden&&I3(e),e.object.__r3f&&delete e.object.__r3f,e.type!=="primitive"&&B3(e.object)}for(const[e,n,i]of av){e.props=n;const r=e.parent;if(r){var s,t;const l=sp[PE(e.type)];e.object=(s=e.props.object)!=null?s:new l(...(t=e.props.args)!=null?t:[]),e.object.__r3f=e,YF(i,e.object),oh(e.object,e.props),e.props.attach?tE(r,e):Wa(e.object)&&Wa(r.object)&&r.object.add(e.object);for(const u of e.children)u.props.attach?tE(e,u):Wa(u.object)&&Wa(e.object)&&e.object.add(u.object);hp(e)}}av.length=0}const PC=()=>{},hB={};let Ix=b3;const XF=0,JF=4,Pb=FF({isPrimaryRenderer:!1,warnsIfNotActing:!1,supportsMutation:!0,supportsPersistence:!1,supportsHydration:!1,createInstance:HF,removeChild:Fb,appendChild:FC,appendInitialChild:FC,insertBefore:uB,appendChildToContainer(s,t){const e=s.getState().scene.__r3f;!t||!e||FC(e,t)},removeChildFromContainer(s,t){const e=s.getState().scene.__r3f;!t||!e||Fb(e,t)},insertInContainerBefore(s,t,e){const n=s.getState().scene.__r3f;!t||!e||!n||uB(n,t,e)},getRootHostContext:()=>hB,getChildHostContext:()=>hB,commitUpdate(s,t,e,n,i){var r,l,u;S3(t,n);let A=!1;if((s.type==="primitive"&&e.object!==n.object||((r=n.args)==null?void 0:r.length)!==((l=e.args)==null?void 0:l.length)||(u=n.args)!=null&&u.some((m,g)=>{var y;return m!==((y=e.args)==null?void 0:y[g])}))&&(A=!0),A)av.push([s,{...n},i]);else{const m=TF(s,n);Object.keys(m).length&&(Object.assign(s.props,m),oh(s.object,m))}(i.sibling===null||(i.flags&JF)===XF)&&qF()},finalizeInitialChildren:()=>!1,commitMount(){},getPublicInstance:s=>s?.object,prepareForCommit:()=>null,preparePortalMount:s=>$v(s.getState().scene,s,"",{}),resetAfterCommit:()=>{},shouldSetTextContent:()=>!1,clearContainer:()=>!1,hideInstance:VF,unhideInstance:I3,createTextInstance:PC,hideTextInstance:PC,unhideTextInstance:PC,scheduleTimeout:typeof setTimeout=="function"?setTimeout:void 0,cancelTimeout:typeof clearTimeout=="function"?clearTimeout:void 0,noTimeout:-1,getInstanceFromNode:()=>null,beforeActiveInstanceBlur(){},afterActiveInstanceBlur(){},detachDeletedInstance(){},prepareScopeUpdate(){},getInstanceFromScope:()=>null,shouldAttemptEagerTransition:()=>!1,trackSchedulerEvent:()=>{},resolveEventType:()=>null,resolveEventTimeStamp:()=>-1.1,requestPostPaintCallback(){},maySuspendCommit:()=>!1,preloadInstance:()=>!0,startSuspendingCommit(){},suspendInstance(){},waitForCommitToBeReady:()=>null,NotPendingTransition:null,HostTransitionContext:et.createContext(null),setCurrentUpdatePriority(s){Ix=s},getCurrentUpdatePriority(){return Ix},resolveUpdatePriority(){var s;if(Ix!==b3)return Ix;switch(typeof window<"u"&&((s=window.event)==null?void 0:s.type)){case"click":case"contextmenu":case"dblclick":case"pointercancel":case"pointerdown":case"pointerup":return ev.DiscreteEventPriority;case"pointermove":case"pointerout":case"pointerover":case"pointerenter":case"pointerleave":case"wheel":return ev.ContinuousEventPriority;default:return ev.DefaultEventPriority}},resetFormInstance(){},rendererPackageName:"@react-three/fiber",rendererVersion:OF.version}),Zf=new Map,bd={objects:"shallow",strict:!1};function ZF(s,t){if(!t&&typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement&&s.parentElement){const{width:e,height:n,top:i,left:r}=s.parentElement.getBoundingClientRect();return{width:e,height:n,top:i,left:r}}else if(!t&&typeof OffscreenCanvas<"u"&&s instanceof OffscreenCanvas)return{width:s.width,height:s.height,top:0,left:0};return{width:0,height:0,top:0,left:0,...t}}function WF(s){const t=Zf.get(s),e=t?.fiber,n=t?.store;t&&console.warn("R3F.createRoot should only be called once!");const i=typeof reportError=="function"?reportError:console.error,r=n||LF(Hb,AB),l=e||Pb.createContainer(r,ev.ConcurrentRoot,null,!1,null,"",i,i,i,null);t||Zf.set(s,{fiber:l,store:r});let u,A,d=!1,m=null;return{async configure(g={}){let y;m=new Promise(V=>y=V);let{gl:v,size:C,scene:I,events:S,onCreated:E,shadows:B=!1,linear:w=!1,flat:Q=!1,legacy:R=!1,orthographic:D=!1,frameloop:U="always",dpr:P=[1,2],performance:z,raycaster:L,camera:k,onPointerMissed:Y}=g,W=r.getState(),K=W.gl;if(!W.gl){const V={canvas:s,powerPreference:"high-performance",antialias:!0,alpha:!0},st=typeof v=="function"?await v(V):v;lB(st)?K=st:K=new o3({...V,...v}),W.set({gl:K})}let nt=W.raycaster;nt||W.set({raycaster:nt=new f0});const{params:H,...tt}=L||{};if(Oi.equ(tt,nt,bd)||oh(nt,{...tt}),Oi.equ(H,nt.params,bd)||oh(nt,{params:{...nt.params,...H}}),!W.camera||W.camera===A&&!Oi.equ(A,k,bd)){A=k;const V=k?.isCamera,st=V?k:D?new cp(0,0,0,0,.1,1e3):new As(75,0,.1,1e3);V||(st.position.z=5,k&&(oh(st,k),st.manual||("aspect"in k||"left"in k||"right"in k||"bottom"in k||"top"in k)&&(st.manual=!0,st.updateProjectionMatrix())),!W.camera&&!(k!=null&&k.rotation)&&st.lookAt(0,0,0)),W.set({camera:st}),nt.camera=st}if(!W.scene){let V;I!=null&&I.isScene?(V=I,$v(V,r,"",{})):(V=new TS,$v(V,r,"",{}),I&&oh(V,I)),W.set({scene:V})}S&&!W.events.handlers&&W.set({events:S(r)});const it=ZF(s,C);if(Oi.equ(it,W.size,bd)||W.setSize(it.width,it.height,it.top,it.left),P&&W.viewport.dpr!==y3(P)&&W.setDpr(P),W.frameloop!==U&&W.setFrameloop(U),W.onPointerMissed||W.set({onPointerMissed:Y}),z&&!Oi.equ(z,W.performance,bd)&&W.set(V=>({performance:{...V.performance,...z}})),!W.xr){var ot;const V=(j,Rt)=>{const dt=r.getState();dt.frameloop!=="never"&&AB(j,!0,dt,Rt)},st=()=>{const j=r.getState();j.gl.xr.enabled=j.gl.xr.isPresenting,j.gl.xr.setAnimationLoop(j.gl.xr.isPresenting?V:null),j.gl.xr.isPresenting||Hb(j)},xt={connect(){const j=r.getState().gl;j.xr.addEventListener("sessionstart",st),j.xr.addEventListener("sessionend",st)},disconnect(){const j=r.getState().gl;j.xr.removeEventListener("sessionstart",st),j.xr.removeEventListener("sessionend",st)}};typeof((ot=K.xr)==null?void 0:ot.addEventListener)=="function"&&xt.connect(),W.set({xr:xt})}if(K.shadowMap){const V=K.shadowMap.enabled,st=K.shadowMap.type;if(K.shadowMap.enabled=!!B,Oi.boo(B))K.shadowMap.type=gm;else if(Oi.str(B)){var At;const xt={basic:pM,percentage:oE,soft:gm,variance:rl};K.shadowMap.type=(At=xt[B])!=null?At:gm}else Oi.obj(B)&&Object.assign(K.shadowMap,B);(V!==K.shadowMap.enabled||st!==K.shadowMap.type)&&(K.shadowMap.needsUpdate=!0)}return Gn.enabled=!R,d||(K.outputColorSpace=w?Ah:ks,K.toneMapping=Q?ic:hS),W.legacy!==R&&W.set(()=>({legacy:R})),W.linear!==w&&W.set(()=>({linear:w})),W.flat!==Q&&W.set(()=>({flat:Q})),v&&!Oi.fun(v)&&!lB(v)&&!Oi.equ(v,K,bd)&&oh(K,v),u=E,d=!0,y(),this},render(g){return!d&&!m&&this.configure(),m.then(()=>{Pb.updateContainer(pn.jsx(jF,{store:r,children:g,onCreated:u,rootElement:s}),l,null,()=>{})}),r},unmount(){M3(s)}}}function jF({store:s,children:t,onCreated:e,rootElement:n}){return d0(()=>{const i=s.getState();i.set(r=>({internal:{...r.internal,active:!0}})),e&&e(i),s.getState().events.connected||i.events.connect==null||i.events.connect(n)},[]),pn.jsx(E3.Provider,{value:s,children:t})}function M3(s,t){const e=Zf.get(s),n=e?.fiber;if(n){const i=e?.store.getState();i&&(i.internal.active=!1),Pb.updateContainer(null,n,null,()=>{i&&setTimeout(()=>{try{var r,l,u,A;i.events.disconnect==null||i.events.disconnect(),(r=i.gl)==null||(l=r.renderLists)==null||l.dispose==null||l.dispose(),(u=i.gl)==null||u.forceContextLoss==null||u.forceContextLoss(),(A=i.gl)!=null&&A.xr&&i.xr.disconnect(),BF(i.scene),Zf.delete(s)}catch{}},500)})}}const KF=new Set,$F=new Set,t5=new Set;function GC(s,t){if(s.size)for(const{callback:e}of s.values())e(t)}function Sm(s,t){switch(s){case"before":return GC(KF,t);case"after":return GC($F,t);case"tail":return GC(t5,t)}}let kC,HC;function Gb(s,t,e){let n=t.clock.getDelta();t.frameloop==="never"&&typeof s=="number"&&(n=s-t.clock.elapsedTime,t.clock.oldTime=t.clock.elapsedTime,t.clock.elapsedTime=s),kC=t.internal.subscribers;for(let i=0;i<kC.length;i++)HC=kC[i],HC.ref.current(HC.store.getState(),n,e);return!t.internal.priority&&t.gl.render&&t.gl.render(t.scene,t.camera),t.internal.frames=Math.max(0,t.internal.frames-1),t.frameloop==="always"?1:t.internal.frames}let nE=!1,kb=!1,VC,fB,Sd;function w3(s){fB=requestAnimationFrame(w3),nE=!0,VC=0,Sm("before",s),kb=!0;for(const e of Zf.values()){var t;Sd=e.store.getState(),Sd.internal.active&&(Sd.frameloop==="always"||Sd.internal.frames>0)&&!((t=Sd.gl.xr)!=null&&t.isPresenting)&&(VC+=Gb(s,Sd))}if(kb=!1,Sm("after",s),VC===0)return Sm("tail",s),nE=!1,cancelAnimationFrame(fB)}function Hb(s,t=1){var e;if(!s)return Zf.forEach(n=>Hb(n.store.getState(),t));(e=s.gl.xr)!=null&&e.isPresenting||!s.internal.active||s.frameloop==="never"||(t>1?s.internal.frames=Math.min(60,s.internal.frames+t):kb?s.internal.frames=2:s.internal.frames=1,nE||(nE=!0,requestAnimationFrame(w3)))}function AB(s,t=!0,e,n){if(t&&Sm("before",s),e)Gb(s,e,n);else for(const i of Zf.values())Gb(s,i.store.getState());t&&Sm("after",s)}const YC={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]};function e5(s){const{handlePointer:t}=UF(s);return{priority:1,enabled:!0,compute(e,n,i){n.pointer.set(e.offsetX/n.size.width*2-1,-(e.offsetY/n.size.height)*2+1),n.raycaster.setFromCamera(n.pointer,n.camera)},connected:void 0,handlers:Object.keys(YC).reduce((e,n)=>({...e,[n]:t(n)}),{}),update:()=>{var e;const{events:n,internal:i}=s.getState();(e=i.lastEvent)!=null&&e.current&&n.handlers&&n.handlers.onPointerMove(i.lastEvent.current)},connect:e=>{const{set:n,events:i}=s.getState();if(i.disconnect==null||i.disconnect(),n(r=>({events:{...r.events,connected:e}})),i.handlers)for(const r in i.handlers){const l=i.handlers[r],[u,A]=YC[r];e.addEventListener(u,l,{passive:A})}},disconnect:()=>{const{set:e,events:n}=s.getState();if(n.connected){if(n.handlers)for(const i in n.handlers){const r=n.handlers[i],[l]=YC[i];n.connected.removeEventListener(l,r)}e(i=>({events:{...i.events,connected:void 0}}))}}}}function dB(s,t){let e;return(...n)=>{window.clearTimeout(e),e=window.setTimeout(()=>s(...n),t)}}function n5({debounce:s,scroll:t,polyfill:e,offsetSize:n}={debounce:0,scroll:!1,offsetSize:!1}){const i=e||(typeof window>"u"?class{}:window.ResizeObserver);if(!i)throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");const[r,l]=et.useState({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),u=et.useRef({element:null,scrollContainers:null,resizeObserver:null,lastBounds:r,orientationHandler:null}),A=s?typeof s=="number"?s:s.scroll:null,d=s?typeof s=="number"?s:s.resize:null,m=et.useRef(!1);et.useEffect(()=>(m.current=!0,()=>{m.current=!1}));const[g,y,v]=et.useMemo(()=>{const E=()=>{if(!u.current.element)return;const{left:B,top:w,width:Q,height:R,bottom:D,right:U,x:P,y:z}=u.current.element.getBoundingClientRect(),L={left:B,top:w,width:Q,height:R,bottom:D,right:U,x:P,y:z};u.current.element instanceof HTMLElement&&n&&(L.height=u.current.element.offsetHeight,L.width=u.current.element.offsetWidth),Object.freeze(L),m.current&&!r5(u.current.lastBounds,L)&&l(u.current.lastBounds=L)};return[E,d?dB(E,d):E,A?dB(E,A):E]},[l,n,A,d]);function C(){u.current.scrollContainers&&(u.current.scrollContainers.forEach(E=>E.removeEventListener("scroll",v,!0)),u.current.scrollContainers=null),u.current.resizeObserver&&(u.current.resizeObserver.disconnect(),u.current.resizeObserver=null),u.current.orientationHandler&&("orientation"in screen&&"removeEventListener"in screen.orientation?screen.orientation.removeEventListener("change",u.current.orientationHandler):"onorientationchange"in window&&window.removeEventListener("orientationchange",u.current.orientationHandler))}function I(){u.current.element&&(u.current.resizeObserver=new i(v),u.current.resizeObserver.observe(u.current.element),t&&u.current.scrollContainers&&u.current.scrollContainers.forEach(E=>E.addEventListener("scroll",v,{capture:!0,passive:!0})),u.current.orientationHandler=()=>{v()},"orientation"in screen&&"addEventListener"in screen.orientation?screen.orientation.addEventListener("change",u.current.orientationHandler):"onorientationchange"in window&&window.addEventListener("orientationchange",u.current.orientationHandler))}const S=E=>{!E||E===u.current.element||(C(),u.current.element=E,u.current.scrollContainers=T3(E),I())};return s5(v,!!t),i5(y),et.useEffect(()=>{C(),I()},[t,v,y]),et.useEffect(()=>C,[]),[S,r,g]}function i5(s){et.useEffect(()=>{const t=s;return window.addEventListener("resize",t),()=>{window.removeEventListener("resize",t)}},[s])}function s5(s,t){et.useEffect(()=>{if(t){const e=s;return window.addEventListener("scroll",e,{capture:!0,passive:!0}),()=>{window.removeEventListener("scroll",e,!0)}}},[s,t])}function T3(s){const t=[];if(!s||s===document.body)return t;const{overflow:e,overflowX:n,overflowY:i}=window.getComputedStyle(s);return[e,n,i].some(r=>r==="auto"||r==="scroll")&&t.push(s),[...t,...T3(s.parentElement)]}const a5=["x","y","top","bottom","left","right","width","height"],r5=(s,t)=>a5.every(e=>s[e]===t[e]);function o5({ref:s,children:t,fallback:e,resize:n,style:i,gl:r,events:l=e5,eventSource:u,eventPrefix:A,shadows:d,linear:m,flat:g,legacy:y,orthographic:v,frameloop:C,dpr:I,performance:S,raycaster:E,camera:B,scene:w,onPointerMissed:Q,onCreated:R,...D}){et.useMemo(()=>GE(jO),[]);const U=CF(),[P,z]=n5({scroll:!0,debounce:{scroll:50,resize:0},...n}),L=et.useRef(null),k=et.useRef(null);et.useImperativeHandle(s,()=>L.current);const Y=m3(Q),[W,K]=et.useState(!1),[nt,H]=et.useState(!1);if(W)throw W;if(nt)throw nt;const tt=et.useRef(null);d0(()=>{const ot=L.current;if(z.width>0&&z.height>0&&ot){tt.current||(tt.current=WF(ot));async function At(){await tt.current.configure({gl:r,scene:w,events:l,shadows:d,linear:m,flat:g,legacy:y,orthographic:v,frameloop:C,dpr:I,performance:S,raycaster:E,camera:B,size:z,onPointerMissed:(...V)=>Y.current==null?void 0:Y.current(...V),onCreated:V=>{V.events.connect==null||V.events.connect(u?EF(u)?u.current:u:k.current),A&&V.setEvents({compute:(st,xt)=>{const j=st[A+"X"],Rt=st[A+"Y"];xt.pointer.set(j/xt.size.width*2-1,-(Rt/xt.size.height)*2+1),xt.raycaster.setFromCamera(xt.pointer,xt.camera)}}),R?.(V)}}),tt.current.render(pn.jsx(U,{children:pn.jsx(SF,{set:H,children:pn.jsx(et.Suspense,{fallback:pn.jsx(bF,{set:K}),children:t??null})})}))}At()}}),et.useEffect(()=>{const ot=L.current;if(ot)return()=>M3(ot)},[]);const it=u?"none":"auto";return pn.jsx("div",{ref:k,style:{position:"relative",width:"100%",height:"100%",overflow:"hidden",pointerEvents:it,...i},...D,children:pn.jsx("div",{ref:P,style:{width:"100%",height:"100%"},children:pn.jsx("canvas",{ref:L,style:{display:"block"},children:e})})})}function l5(s){return pn.jsx(A3,{children:pn.jsx(o5,{...s})})}function nu(){return nu=Object.assign?Object.assign.bind():function(s){for(var t=1;t<arguments.length;t++){var e=arguments[t];for(var n in e)({}).hasOwnProperty.call(e,n)&&(s[n]=e[n])}return s},nu.apply(null,arguments)}const c5=s=>s;function u5(s,t=c5){const e=Xe.useSyncExternalStore(s.subscribe,Xe.useCallback(()=>t(s.getState()),[s,t]),Xe.useCallback(()=>t(s.getInitialState()),[s,t]));return Xe.useDebugValue(e),e}const pB=s=>{const t=l3(s),e=n=>u5(t,n);return Object.assign(e,t),e},fp=(s=>s?pB(s):pB);let Zg=0;const h5=fp(s=>(Hd.onStart=(t,e,n)=>{s({active:!0,item:t,loaded:e,total:n,progress:(e-Zg)/(n-Zg)*100})},Hd.onLoad=()=>{s({active:!1})},Hd.onError=t=>s(e=>({errors:[...e.errors,t]})),Hd.onProgress=(t,e,n)=>{e===n&&(Zg=n),s({active:!0,item:t,loaded:e,total:n,progress:(e-Zg)/(n-Zg)*100||100})},{errors:[],active:!1,progress:0,item:"",loaded:0,total:0})),f5=s=>`Loading ${s.toFixed(2)}%`;function A5({containerStyles:s,innerStyles:t,barStyles:e,dataStyles:n,dataInterpolation:i=f5,initialState:r=l=>l}){const{active:l,progress:u}=h5(),A=et.useRef(0),d=et.useRef(0),m=et.useRef(null),[g,y]=et.useState(r(l));et.useEffect(()=>{let C;return l!==g&&(C=setTimeout(()=>y(l),300)),()=>clearTimeout(C)},[g,l]);const v=et.useCallback(()=>{m.current&&(A.current+=(u-A.current)/2,(A.current>.95*u||u===100)&&(A.current=u),m.current.innerText=i(A.current),A.current<u&&(d.current=requestAnimationFrame(v)))},[i,u]);return et.useEffect(()=>(v(),()=>cancelAnimationFrame(d.current)),[v]),g?et.createElement("div",{style:{...Bx.container,opacity:l?1:0,...s}},et.createElement("div",null,et.createElement("div",{style:{...Bx.inner,...t}},et.createElement("div",{style:{...Bx.bar,transform:`scaleX(${u/100})`,...e}}),et.createElement("span",{ref:m,style:{...Bx.data,...n}})))):null}const Bx={container:{position:"absolute",top:0,left:0,width:"100%",height:"100%",background:"#171717",display:"flex",alignItems:"center",justifyContent:"center",transition:"opacity 300ms ease",zIndex:1e3},inner:{width:100,height:3,background:"#272727",textAlign:"center"},bar:{height:3,width:"100%",background:"white",transition:"transform 200ms",transformOrigin:"left center"},data:{display:"inline-block",position:"relative",fontVariantNumeric:"tabular-nums",marginTop:"0.8em",color:"#f0f0f0",fontSize:"0.6em",fontFamily:'-apple-system, BlinkMacSystemFont, "Inter", "Segoe UI", "Helvetica Neue", Helvetica, Arial, Roboto, Ubuntu, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',whiteSpace:"nowrap"}},d5=s=>(t,e,n)=>{const i=n.subscribe;return n.subscribe=((l,u,A)=>{let d=l;if(u){const m=A?.equalityFn||Object.is;let g=l(n.getState());d=y=>{const v=l(y);if(!m(g,v)){const C=g;u(g=v,C)}},A?.fireImmediately&&u(g,g)}return i(d)}),s(t,e,n)},Q3=d5,p5=et.createContext(null);function gB(s){const[t,e,n]=et.useContext(p5);return[t,e]}var g5=Object.defineProperty,m5=(s,t,e)=>t in s?g5(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,Qt=(s,t,e)=>(m5(s,typeof t!="symbol"?t+"":t,e),e);let y5=class extends gn{constructor(t,e){super(),Qt(this,"isTransformControls",!0),Qt(this,"visible",!1),Qt(this,"domElement"),Qt(this,"raycaster",new f0),Qt(this,"gizmo"),Qt(this,"plane"),Qt(this,"tempVector",new F),Qt(this,"tempVector2",new F),Qt(this,"tempQuaternion",new Ge),Qt(this,"unit",{X:new F(1,0,0),Y:new F(0,1,0),Z:new F(0,0,1)}),Qt(this,"pointStart",new F),Qt(this,"pointEnd",new F),Qt(this,"offset",new F),Qt(this,"rotationAxis",new F),Qt(this,"startNorm",new F),Qt(this,"endNorm",new F),Qt(this,"rotationAngle",0),Qt(this,"cameraPosition",new F),Qt(this,"cameraQuaternion",new Ge),Qt(this,"cameraScale",new F),Qt(this,"parentPosition",new F),Qt(this,"parentQuaternion",new Ge),Qt(this,"parentQuaternionInv",new Ge),Qt(this,"parentScale",new F),Qt(this,"worldPositionStart",new F),Qt(this,"worldQuaternionStart",new Ge),Qt(this,"worldScaleStart",new F),Qt(this,"worldPosition",new F),Qt(this,"worldQuaternion",new Ge),Qt(this,"worldQuaternionInv",new Ge),Qt(this,"worldScale",new F),Qt(this,"eye",new F),Qt(this,"positionStart",new F),Qt(this,"quaternionStart",new Ge),Qt(this,"scaleStart",new F),Qt(this,"camera"),Qt(this,"object"),Qt(this,"enabled",!0),Qt(this,"axis",null),Qt(this,"mode","translate"),Qt(this,"translationSnap",null),Qt(this,"rotationSnap",null),Qt(this,"scaleSnap",null),Qt(this,"space","world"),Qt(this,"size",1),Qt(this,"dragging",!1),Qt(this,"showX",!0),Qt(this,"showY",!0),Qt(this,"showZ",!0),Qt(this,"changeEvent",{type:"change"}),Qt(this,"mouseDownEvent",{type:"mouseDown",mode:this.mode}),Qt(this,"mouseUpEvent",{type:"mouseUp",mode:this.mode}),Qt(this,"objectChangeEvent",{type:"objectChange"}),Qt(this,"intersectObjectWithRay",(i,r,l)=>{const u=r.intersectObject(i,!0);for(let A=0;A<u.length;A++)if(u[A].object.visible||l)return u[A];return!1}),Qt(this,"attach",i=>(this.object=i,this.visible=!0,this)),Qt(this,"detach",()=>(this.object=void 0,this.visible=!1,this.axis=null,this)),Qt(this,"reset",()=>this.enabled?(this.dragging&&this.object!==void 0&&(this.object.position.copy(this.positionStart),this.object.quaternion.copy(this.quaternionStart),this.object.scale.copy(this.scaleStart),this.dispatchEvent(this.changeEvent),this.dispatchEvent(this.objectChangeEvent),this.pointStart.copy(this.pointEnd)),this):this),Qt(this,"updateMatrixWorld",()=>{this.object!==void 0&&(this.object.updateMatrixWorld(),this.object.parent===null?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this.parentPosition,this.parentQuaternion,this.parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this.worldScale),this.parentQuaternionInv.copy(this.parentQuaternion).invert(),this.worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this.cameraScale),this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld()}),Qt(this,"pointerHover",i=>{if(this.object===void 0||this.dragging===!0)return;this.raycaster.setFromCamera(i,this.camera);const r=this.intersectObjectWithRay(this.gizmo.picker[this.mode],this.raycaster);r?this.axis=r.object.name:this.axis=null}),Qt(this,"pointerDown",i=>{if(!(this.object===void 0||this.dragging===!0||i.button!==0)&&this.axis!==null){this.raycaster.setFromCamera(i,this.camera);const r=this.intersectObjectWithRay(this.plane,this.raycaster,!0);if(r){let l=this.space;if(this.mode==="scale"?l="local":(this.axis==="E"||this.axis==="XYZE"||this.axis==="XYZ")&&(l="world"),l==="local"&&this.mode==="rotate"){const u=this.rotationSnap;this.axis==="X"&&u&&(this.object.rotation.x=Math.round(this.object.rotation.x/u)*u),this.axis==="Y"&&u&&(this.object.rotation.y=Math.round(this.object.rotation.y/u)*u),this.axis==="Z"&&u&&(this.object.rotation.z=Math.round(this.object.rotation.z/u)*u)}this.object.updateMatrixWorld(),this.object.parent&&this.object.parent.updateMatrixWorld(),this.positionStart.copy(this.object.position),this.quaternionStart.copy(this.object.quaternion),this.scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this.worldScaleStart),this.pointStart.copy(r.point).sub(this.worldPositionStart)}this.dragging=!0,this.mouseDownEvent.mode=this.mode,this.dispatchEvent(this.mouseDownEvent)}}),Qt(this,"pointerMove",i=>{const r=this.axis,l=this.mode,u=this.object;let A=this.space;if(l==="scale"?A="local":(r==="E"||r==="XYZE"||r==="XYZ")&&(A="world"),u===void 0||r===null||this.dragging===!1||i.button!==-1)return;this.raycaster.setFromCamera(i,this.camera);const d=this.intersectObjectWithRay(this.plane,this.raycaster,!0);if(d){if(this.pointEnd.copy(d.point).sub(this.worldPositionStart),l==="translate")this.offset.copy(this.pointEnd).sub(this.pointStart),A==="local"&&r!=="XYZ"&&this.offset.applyQuaternion(this.worldQuaternionInv),r.indexOf("X")===-1&&(this.offset.x=0),r.indexOf("Y")===-1&&(this.offset.y=0),r.indexOf("Z")===-1&&(this.offset.z=0),A==="local"&&r!=="XYZ"?this.offset.applyQuaternion(this.quaternionStart).divide(this.parentScale):this.offset.applyQuaternion(this.parentQuaternionInv).divide(this.parentScale),u.position.copy(this.offset).add(this.positionStart),this.translationSnap&&(A==="local"&&(u.position.applyQuaternion(this.tempQuaternion.copy(this.quaternionStart).invert()),r.search("X")!==-1&&(u.position.x=Math.round(u.position.x/this.translationSnap)*this.translationSnap),r.search("Y")!==-1&&(u.position.y=Math.round(u.position.y/this.translationSnap)*this.translationSnap),r.search("Z")!==-1&&(u.position.z=Math.round(u.position.z/this.translationSnap)*this.translationSnap),u.position.applyQuaternion(this.quaternionStart)),A==="world"&&(u.parent&&u.position.add(this.tempVector.setFromMatrixPosition(u.parent.matrixWorld)),r.search("X")!==-1&&(u.position.x=Math.round(u.position.x/this.translationSnap)*this.translationSnap),r.search("Y")!==-1&&(u.position.y=Math.round(u.position.y/this.translationSnap)*this.translationSnap),r.search("Z")!==-1&&(u.position.z=Math.round(u.position.z/this.translationSnap)*this.translationSnap),u.parent&&u.position.sub(this.tempVector.setFromMatrixPosition(u.parent.matrixWorld))));else if(l==="scale"){if(r.search("XYZ")!==-1){let m=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(m*=-1),this.tempVector2.set(m,m,m)}else this.tempVector.copy(this.pointStart),this.tempVector2.copy(this.pointEnd),this.tempVector.applyQuaternion(this.worldQuaternionInv),this.tempVector2.applyQuaternion(this.worldQuaternionInv),this.tempVector2.divide(this.tempVector),r.search("X")===-1&&(this.tempVector2.x=1),r.search("Y")===-1&&(this.tempVector2.y=1),r.search("Z")===-1&&(this.tempVector2.z=1);u.scale.copy(this.scaleStart).multiply(this.tempVector2),this.scaleSnap&&this.object&&(r.search("X")!==-1&&(this.object.scale.x=Math.round(u.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),r.search("Y")!==-1&&(u.scale.y=Math.round(u.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),r.search("Z")!==-1&&(u.scale.z=Math.round(u.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if(l==="rotate"){this.offset.copy(this.pointEnd).sub(this.pointStart);const m=20/this.worldPosition.distanceTo(this.tempVector.setFromMatrixPosition(this.camera.matrixWorld));r==="E"?(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this.startNorm.copy(this.pointStart).normalize(),this.endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this.endNorm.cross(this.startNorm).dot(this.eye)<0?1:-1):r==="XYZE"?(this.rotationAxis.copy(this.offset).cross(this.eye).normalize(),this.rotationAngle=this.offset.dot(this.tempVector.copy(this.rotationAxis).cross(this.eye))*m):(r==="X"||r==="Y"||r==="Z")&&(this.rotationAxis.copy(this.unit[r]),this.tempVector.copy(this.unit[r]),A==="local"&&this.tempVector.applyQuaternion(this.worldQuaternion),this.rotationAngle=this.offset.dot(this.tempVector.cross(this.eye).normalize())*m),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),A==="local"&&r!=="E"&&r!=="XYZE"?(u.quaternion.copy(this.quaternionStart),u.quaternion.multiply(this.tempQuaternion.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this.parentQuaternionInv),u.quaternion.copy(this.tempQuaternion.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),u.quaternion.multiply(this.quaternionStart).normalize())}this.dispatchEvent(this.changeEvent),this.dispatchEvent(this.objectChangeEvent)}}),Qt(this,"pointerUp",i=>{i.button===0&&(this.dragging&&this.axis!==null&&(this.mouseUpEvent.mode=this.mode,this.dispatchEvent(this.mouseUpEvent)),this.dragging=!1,this.axis=null)}),Qt(this,"getPointer",i=>{var r;if(this.domElement&&((r=this.domElement.ownerDocument)!=null&&r.pointerLockElement))return{x:0,y:0,button:i.button};{const l=i.changedTouches?i.changedTouches[0]:i,u=this.domElement.getBoundingClientRect();return{x:(l.clientX-u.left)/u.width*2-1,y:-(l.clientY-u.top)/u.height*2+1,button:i.button}}}),Qt(this,"onPointerHover",i=>{if(this.enabled)switch(i.pointerType){case"mouse":case"pen":this.pointerHover(this.getPointer(i));break}}),Qt(this,"onPointerDown",i=>{!this.enabled||!this.domElement||(this.domElement.style.touchAction="none",this.domElement.ownerDocument.addEventListener("pointermove",this.onPointerMove),this.pointerHover(this.getPointer(i)),this.pointerDown(this.getPointer(i)))}),Qt(this,"onPointerMove",i=>{this.enabled&&this.pointerMove(this.getPointer(i))}),Qt(this,"onPointerUp",i=>{!this.enabled||!this.domElement||(this.domElement.style.touchAction="",this.domElement.ownerDocument.removeEventListener("pointermove",this.onPointerMove),this.pointerUp(this.getPointer(i)))}),Qt(this,"getMode",()=>this.mode),Qt(this,"setMode",i=>{this.mode=i}),Qt(this,"setTranslationSnap",i=>{this.translationSnap=i}),Qt(this,"setRotationSnap",i=>{this.rotationSnap=i}),Qt(this,"setScaleSnap",i=>{this.scaleSnap=i}),Qt(this,"setSize",i=>{this.size=i}),Qt(this,"setSpace",i=>{this.space=i}),Qt(this,"update",()=>{console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.")}),Qt(this,"connect",i=>{i===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.domElement=i,this.domElement.addEventListener("pointerdown",this.onPointerDown),this.domElement.addEventListener("pointermove",this.onPointerHover),this.domElement.ownerDocument.addEventListener("pointerup",this.onPointerUp)}),Qt(this,"dispose",()=>{var i,r,l,u,A,d;(i=this.domElement)==null||i.removeEventListener("pointerdown",this.onPointerDown),(r=this.domElement)==null||r.removeEventListener("pointermove",this.onPointerHover),(u=(l=this.domElement)==null?void 0:l.ownerDocument)==null||u.removeEventListener("pointermove",this.onPointerMove),(d=(A=this.domElement)==null?void 0:A.ownerDocument)==null||d.removeEventListener("pointerup",this.onPointerUp),this.traverse(m=>{const g=m;g.geometry&&g.geometry.dispose(),g.material&&g.material.dispose()})}),this.domElement=e,this.camera=t,this.gizmo=new x5,this.add(this.gizmo),this.plane=new v5,this.add(this.plane);const n=(i,r)=>{let l=r;Object.defineProperty(this,i,{get:function(){return l!==void 0?l:r},set:function(u){l!==u&&(l=u,this.plane[i]=u,this.gizmo[i]=u,this.dispatchEvent({type:i+"-changed",value:u}),this.dispatchEvent(this.changeEvent))}}),this[i]=r,this.plane[i]=r,this.gizmo[i]=r};n("camera",this.camera),n("object",this.object),n("enabled",this.enabled),n("axis",this.axis),n("mode",this.mode),n("translationSnap",this.translationSnap),n("rotationSnap",this.rotationSnap),n("scaleSnap",this.scaleSnap),n("space",this.space),n("size",this.size),n("dragging",this.dragging),n("showX",this.showX),n("showY",this.showY),n("showZ",this.showZ),n("worldPosition",this.worldPosition),n("worldPositionStart",this.worldPositionStart),n("worldQuaternion",this.worldQuaternion),n("worldQuaternionStart",this.worldQuaternionStart),n("cameraPosition",this.cameraPosition),n("cameraQuaternion",this.cameraQuaternion),n("pointStart",this.pointStart),n("pointEnd",this.pointEnd),n("rotationAxis",this.rotationAxis),n("rotationAngle",this.rotationAngle),n("eye",this.eye),e!==void 0&&this.connect(e)}};class x5 extends gn{constructor(){super(),Qt(this,"isTransformControlsGizmo",!0),Qt(this,"type","TransformControlsGizmo"),Qt(this,"tempVector",new F(0,0,0)),Qt(this,"tempEuler",new _r),Qt(this,"alignVector",new F(0,1,0)),Qt(this,"zeroVector",new F(0,0,0)),Qt(this,"lookAtMatrix",new he),Qt(this,"tempQuaternion",new Ge),Qt(this,"tempQuaternion2",new Ge),Qt(this,"identityQuaternion",new Ge),Qt(this,"unitX",new F(1,0,0)),Qt(this,"unitY",new F(0,1,0)),Qt(this,"unitZ",new F(0,0,1)),Qt(this,"gizmo"),Qt(this,"picker"),Qt(this,"helper"),Qt(this,"rotationAxis",new F),Qt(this,"cameraPosition",new F),Qt(this,"worldPositionStart",new F),Qt(this,"worldQuaternionStart",new Ge),Qt(this,"worldPosition",new F),Qt(this,"worldQuaternion",new Ge),Qt(this,"eye",new F),Qt(this,"camera",null),Qt(this,"enabled",!0),Qt(this,"axis",null),Qt(this,"mode","translate"),Qt(this,"space","world"),Qt(this,"size",1),Qt(this,"dragging",!1),Qt(this,"showX",!0),Qt(this,"showY",!0),Qt(this,"showZ",!0),Qt(this,"updateMatrixWorld",()=>{let At=this.space;this.mode==="scale"&&(At="local");const V=At==="local"?this.worldQuaternion:this.identityQuaternion;this.gizmo.translate.visible=this.mode==="translate",this.gizmo.rotate.visible=this.mode==="rotate",this.gizmo.scale.visible=this.mode==="scale",this.helper.translate.visible=this.mode==="translate",this.helper.rotate.visible=this.mode==="rotate",this.helper.scale.visible=this.mode==="scale";let st=[];st=st.concat(this.picker[this.mode].children),st=st.concat(this.gizmo[this.mode].children),st=st.concat(this.helper[this.mode].children);for(let xt=0;xt<st.length;xt++){const j=st[xt];j.visible=!0,j.rotation.set(0,0,0),j.position.copy(this.worldPosition);let Rt;if(this.camera.isOrthographicCamera?Rt=(this.camera.top-this.camera.bottom)/this.camera.zoom:Rt=this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),j.scale.set(1,1,1).multiplyScalar(Rt*this.size/7),j.tag==="helper"){j.visible=!1,j.name==="AXIS"?(j.position.copy(this.worldPositionStart),j.visible=!!this.axis,this.axis==="X"&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,0,0)),j.quaternion.copy(V).multiply(this.tempQuaternion),Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(V).dot(this.eye))>.9&&(j.visible=!1)),this.axis==="Y"&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,0,Math.PI/2)),j.quaternion.copy(V).multiply(this.tempQuaternion),Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(V).dot(this.eye))>.9&&(j.visible=!1)),this.axis==="Z"&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,Math.PI/2,0)),j.quaternion.copy(V).multiply(this.tempQuaternion),Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(V).dot(this.eye))>.9&&(j.visible=!1)),this.axis==="XYZE"&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,Math.PI/2,0)),this.alignVector.copy(this.rotationAxis),j.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.zeroVector,this.alignVector,this.unitY)),j.quaternion.multiply(this.tempQuaternion),j.visible=this.dragging),this.axis==="E"&&(j.visible=!1)):j.name==="START"?(j.position.copy(this.worldPositionStart),j.visible=this.dragging):j.name==="END"?(j.position.copy(this.worldPosition),j.visible=this.dragging):j.name==="DELTA"?(j.position.copy(this.worldPositionStart),j.quaternion.copy(this.worldQuaternionStart),this.tempVector.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),this.tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()),j.scale.copy(this.tempVector),j.visible=this.dragging):(j.quaternion.copy(V),this.dragging?j.position.copy(this.worldPositionStart):j.position.copy(this.worldPosition),this.axis&&(j.visible=this.axis.search(j.name)!==-1));continue}j.quaternion.copy(V),this.mode==="translate"||this.mode==="scale"?((j.name==="X"||j.name==="XYZX")&&Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(V).dot(this.eye))>.99&&(j.scale.set(1e-10,1e-10,1e-10),j.visible=!1),(j.name==="Y"||j.name==="XYZY")&&Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(V).dot(this.eye))>.99&&(j.scale.set(1e-10,1e-10,1e-10),j.visible=!1),(j.name==="Z"||j.name==="XYZZ")&&Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(V).dot(this.eye))>.99&&(j.scale.set(1e-10,1e-10,1e-10),j.visible=!1),j.name==="XY"&&Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(V).dot(this.eye))<.2&&(j.scale.set(1e-10,1e-10,1e-10),j.visible=!1),j.name==="YZ"&&Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(V).dot(this.eye))<.2&&(j.scale.set(1e-10,1e-10,1e-10),j.visible=!1),j.name==="XZ"&&Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(V).dot(this.eye))<.2&&(j.scale.set(1e-10,1e-10,1e-10),j.visible=!1),j.name.search("X")!==-1&&(this.alignVector.copy(this.unitX).applyQuaternion(V).dot(this.eye)<0?j.tag==="fwd"?j.visible=!1:j.scale.x*=-1:j.tag==="bwd"&&(j.visible=!1)),j.name.search("Y")!==-1&&(this.alignVector.copy(this.unitY).applyQuaternion(V).dot(this.eye)<0?j.tag==="fwd"?j.visible=!1:j.scale.y*=-1:j.tag==="bwd"&&(j.visible=!1)),j.name.search("Z")!==-1&&(this.alignVector.copy(this.unitZ).applyQuaternion(V).dot(this.eye)<0?j.tag==="fwd"?j.visible=!1:j.scale.z*=-1:j.tag==="bwd"&&(j.visible=!1))):this.mode==="rotate"&&(this.tempQuaternion2.copy(V),this.alignVector.copy(this.eye).applyQuaternion(this.tempQuaternion.copy(V).invert()),j.name.search("E")!==-1&&j.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.eye,this.zeroVector,this.unitY)),j.name==="X"&&(this.tempQuaternion.setFromAxisAngle(this.unitX,Math.atan2(-this.alignVector.y,this.alignVector.z)),this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2,this.tempQuaternion),j.quaternion.copy(this.tempQuaternion)),j.name==="Y"&&(this.tempQuaternion.setFromAxisAngle(this.unitY,Math.atan2(this.alignVector.x,this.alignVector.z)),this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2,this.tempQuaternion),j.quaternion.copy(this.tempQuaternion)),j.name==="Z"&&(this.tempQuaternion.setFromAxisAngle(this.unitZ,Math.atan2(this.alignVector.y,this.alignVector.x)),this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2,this.tempQuaternion),j.quaternion.copy(this.tempQuaternion))),j.visible=j.visible&&(j.name.indexOf("X")===-1||this.showX),j.visible=j.visible&&(j.name.indexOf("Y")===-1||this.showY),j.visible=j.visible&&(j.name.indexOf("Z")===-1||this.showZ),j.visible=j.visible&&(j.name.indexOf("E")===-1||this.showX&&this.showY&&this.showZ),j.material.tempOpacity=j.material.tempOpacity||j.material.opacity,j.material.tempColor=j.material.tempColor||j.material.color.clone(),j.material.color.copy(j.material.tempColor),j.material.opacity=j.material.tempOpacity,this.enabled?this.axis&&(j.name===this.axis?(j.material.opacity=1,j.material.color.lerp(new le(1,1,1),.5)):this.axis.split("").some(function(dt){return j.name===dt})?(j.material.opacity=1,j.material.color.lerp(new le(1,1,1),.5)):(j.material.opacity*=.25,j.material.color.lerp(new le(1,1,1),.5))):(j.material.opacity*=.5,j.material.color.lerp(new le(1,1,1),.5))}super.updateMatrixWorld()});const t=new pl({depthTest:!1,depthWrite:!1,transparent:!0,side:gr,fog:!1,toneMapped:!1}),e=new na({depthTest:!1,depthWrite:!1,transparent:!0,linewidth:1,fog:!1,toneMapped:!1}),n=t.clone();n.opacity=.15;const i=t.clone();i.opacity=.33;const r=t.clone();r.color.set(16711680);const l=t.clone();l.color.set(65280);const u=t.clone();u.color.set(255);const A=t.clone();A.opacity=.25;const d=A.clone();d.color.set(16776960);const m=A.clone();m.color.set(65535);const g=A.clone();g.color.set(16711935),t.clone().color.set(16776960);const v=e.clone();v.color.set(16711680);const C=e.clone();C.color.set(65280);const I=e.clone();I.color.set(255);const S=e.clone();S.color.set(65535);const E=e.clone();E.color.set(16711935);const B=e.clone();B.color.set(16776960);const w=e.clone();w.color.set(7895160);const Q=B.clone();Q.opacity=.25;const R=new Ea(0,.05,.2,12,1,!1),D=new pr(.125,.125,.125),U=new Fe;U.setAttribute("position",new Ce([0,0,0,1,0,0],3));const P=(At,V)=>{const st=new Fe,xt=[];for(let j=0;j<=64*V;++j)xt.push(0,Math.cos(j/32*Math.PI)*At,Math.sin(j/32*Math.PI)*At);return st.setAttribute("position",new Ce(xt,3)),st},z=()=>{const At=new Fe;return At.setAttribute("position",new Ce([0,0,0,1,1,1],3)),At},L={X:[[new oe(R,r),[1,0,0],[0,0,-Math.PI/2],null,"fwd"],[new oe(R,r),[1,0,0],[0,0,Math.PI/2],null,"bwd"],[new Sn(U,v)]],Y:[[new oe(R,l),[0,1,0],null,null,"fwd"],[new oe(R,l),[0,1,0],[Math.PI,0,0],null,"bwd"],[new Sn(U,C),null,[0,0,Math.PI/2]]],Z:[[new oe(R,u),[0,0,1],[Math.PI/2,0,0],null,"fwd"],[new oe(R,u),[0,0,1],[-Math.PI/2,0,0],null,"bwd"],[new Sn(U,I),null,[0,-Math.PI/2,0]]],XYZ:[[new oe(new xo(.1,0),A.clone()),[0,0,0],[0,0,0]]],XY:[[new oe(new kr(.295,.295),d.clone()),[.15,.15,0]],[new Sn(U,B),[.18,.3,0],null,[.125,1,1]],[new Sn(U,B),[.3,.18,0],[0,0,Math.PI/2],[.125,1,1]]],YZ:[[new oe(new kr(.295,.295),m.clone()),[0,.15,.15],[0,Math.PI/2,0]],[new Sn(U,S),[0,.18,.3],[0,0,Math.PI/2],[.125,1,1]],[new Sn(U,S),[0,.3,.18],[0,-Math.PI/2,0],[.125,1,1]]],XZ:[[new oe(new kr(.295,.295),g.clone()),[.15,0,.15],[-Math.PI/2,0,0]],[new Sn(U,E),[.18,0,.3],null,[.125,1,1]],[new Sn(U,E),[.3,0,.18],[0,-Math.PI/2,0],[.125,1,1]]]},k={X:[[new oe(new Ea(.2,0,1,4,1,!1),n),[.6,0,0],[0,0,-Math.PI/2]]],Y:[[new oe(new Ea(.2,0,1,4,1,!1),n),[0,.6,0]]],Z:[[new oe(new Ea(.2,0,1,4,1,!1),n),[0,0,.6],[Math.PI/2,0,0]]],XYZ:[[new oe(new xo(.2,0),n)]],XY:[[new oe(new kr(.4,.4),n),[.2,.2,0]]],YZ:[[new oe(new kr(.4,.4),n),[0,.2,.2],[0,Math.PI/2,0]]],XZ:[[new oe(new kr(.4,.4),n),[.2,0,.2],[-Math.PI/2,0,0]]]},Y={START:[[new oe(new xo(.01,2),i),null,null,null,"helper"]],END:[[new oe(new xo(.01,2),i),null,null,null,"helper"]],DELTA:[[new Sn(z(),i),null,null,null,"helper"]],X:[[new Sn(U,i.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new Sn(U,i.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new Sn(U,i.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},W={X:[[new Sn(P(1,.5),v)],[new oe(new xo(.04,0),r),[0,0,.99],null,[1,3,1]]],Y:[[new Sn(P(1,.5),C),null,[0,0,-Math.PI/2]],[new oe(new xo(.04,0),l),[0,0,.99],null,[3,1,1]]],Z:[[new Sn(P(1,.5),I),null,[0,Math.PI/2,0]],[new oe(new xo(.04,0),u),[.99,0,0],null,[1,3,1]]],E:[[new Sn(P(1.25,1),Q),null,[0,Math.PI/2,0]],[new oe(new Ea(.03,0,.15,4,1,!1),Q),[1.17,0,0],[0,0,-Math.PI/2],[1,1,.001]],[new oe(new Ea(.03,0,.15,4,1,!1),Q),[-1.17,0,0],[0,0,Math.PI/2],[1,1,.001]],[new oe(new Ea(.03,0,.15,4,1,!1),Q),[0,-1.17,0],[Math.PI,0,0],[1,1,.001]],[new oe(new Ea(.03,0,.15,4,1,!1),Q),[0,1.17,0],[0,0,0],[1,1,.001]]],XYZE:[[new Sn(P(1,1),w),null,[0,Math.PI/2,0]]]},K={AXIS:[[new Sn(U,i.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},nt={X:[[new oe(new ch(1,.1,4,24),n),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new oe(new ch(1,.1,4,24),n),[0,0,0],[Math.PI/2,0,0]]],Z:[[new oe(new ch(1,.1,4,24),n),[0,0,0],[0,0,-Math.PI/2]]],E:[[new oe(new ch(1.25,.1,2,24),n)]],XYZE:[[new oe(new lp(.7,10,8),n)]]},H={X:[[new oe(D,r),[.8,0,0],[0,0,-Math.PI/2]],[new Sn(U,v),null,null,[.8,1,1]]],Y:[[new oe(D,l),[0,.8,0]],[new Sn(U,C),null,[0,0,Math.PI/2],[.8,1,1]]],Z:[[new oe(D,u),[0,0,.8],[Math.PI/2,0,0]],[new Sn(U,I),null,[0,-Math.PI/2,0],[.8,1,1]]],XY:[[new oe(D,d),[.85,.85,0],null,[2,2,.2]],[new Sn(U,B),[.855,.98,0],null,[.125,1,1]],[new Sn(U,B),[.98,.855,0],[0,0,Math.PI/2],[.125,1,1]]],YZ:[[new oe(D,m),[0,.85,.85],null,[.2,2,2]],[new Sn(U,S),[0,.855,.98],[0,0,Math.PI/2],[.125,1,1]],[new Sn(U,S),[0,.98,.855],[0,-Math.PI/2,0],[.125,1,1]]],XZ:[[new oe(D,g),[.85,0,.85],null,[2,.2,2]],[new Sn(U,E),[.855,0,.98],null,[.125,1,1]],[new Sn(U,E),[.98,0,.855],[0,-Math.PI/2,0],[.125,1,1]]],XYZX:[[new oe(new pr(.125,.125,.125),A.clone()),[1.1,0,0]]],XYZY:[[new oe(new pr(.125,.125,.125),A.clone()),[0,1.1,0]]],XYZZ:[[new oe(new pr(.125,.125,.125),A.clone()),[0,0,1.1]]]},tt={X:[[new oe(new Ea(.2,0,.8,4,1,!1),n),[.5,0,0],[0,0,-Math.PI/2]]],Y:[[new oe(new Ea(.2,0,.8,4,1,!1),n),[0,.5,0]]],Z:[[new oe(new Ea(.2,0,.8,4,1,!1),n),[0,0,.5],[Math.PI/2,0,0]]],XY:[[new oe(D,n),[.85,.85,0],null,[3,3,.2]]],YZ:[[new oe(D,n),[0,.85,.85],null,[.2,3,3]]],XZ:[[new oe(D,n),[.85,0,.85],null,[3,.2,3]]],XYZX:[[new oe(new pr(.2,.2,.2),n),[1.1,0,0]]],XYZY:[[new oe(new pr(.2,.2,.2),n),[0,1.1,0]]],XYZZ:[[new oe(new pr(.2,.2,.2),n),[0,0,1.1]]]},it={X:[[new Sn(U,i.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new Sn(U,i.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new Sn(U,i.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},ot=At=>{const V=new gn;for(let st in At)for(let xt=At[st].length;xt--;){const j=At[st][xt][0].clone(),Rt=At[st][xt][1],dt=At[st][xt][2],pt=At[st][xt][3],qt=At[st][xt][4];j.name=st,j.tag=qt,Rt&&j.position.set(Rt[0],Rt[1],Rt[2]),dt&&j.rotation.set(dt[0],dt[1],dt[2]),pt&&j.scale.set(pt[0],pt[1],pt[2]),j.updateMatrix();const Wt=j.geometry.clone();Wt.applyMatrix4(j.matrix),j.geometry=Wt,j.renderOrder=1/0,j.position.set(0,0,0),j.rotation.set(0,0,0),j.scale.set(1,1,1),V.add(j)}return V};this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=ot(L)),this.add(this.gizmo.rotate=ot(W)),this.add(this.gizmo.scale=ot(H)),this.add(this.picker.translate=ot(k)),this.add(this.picker.rotate=ot(nt)),this.add(this.picker.scale=ot(tt)),this.add(this.helper.translate=ot(Y)),this.add(this.helper.rotate=ot(K)),this.add(this.helper.scale=ot(it)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}}class v5 extends oe{constructor(){super(new kr(1e5,1e5,2,2),new pl({visible:!1,wireframe:!0,side:gr,transparent:!0,opacity:.1,toneMapped:!1})),Qt(this,"isTransformControlsPlane",!0),Qt(this,"type","TransformControlsPlane"),Qt(this,"unitX",new F(1,0,0)),Qt(this,"unitY",new F(0,1,0)),Qt(this,"unitZ",new F(0,0,1)),Qt(this,"tempVector",new F),Qt(this,"dirVector",new F),Qt(this,"alignVector",new F),Qt(this,"tempMatrix",new he),Qt(this,"identityQuaternion",new Ge),Qt(this,"cameraQuaternion",new Ge),Qt(this,"worldPosition",new F),Qt(this,"worldQuaternion",new Ge),Qt(this,"eye",new F),Qt(this,"axis",null),Qt(this,"mode","translate"),Qt(this,"space","world"),Qt(this,"updateMatrixWorld",()=>{let t=this.space;switch(this.position.copy(this.worldPosition),this.mode==="scale"&&(t="local"),this.unitX.set(1,0,0).applyQuaternion(t==="local"?this.worldQuaternion:this.identityQuaternion),this.unitY.set(0,1,0).applyQuaternion(t==="local"?this.worldQuaternion:this.identityQuaternion),this.unitZ.set(0,0,1).applyQuaternion(t==="local"?this.worldQuaternion:this.identityQuaternion),this.alignVector.copy(this.unitY),this.mode){case"translate":case"scale":switch(this.axis){case"X":this.alignVector.copy(this.eye).cross(this.unitX),this.dirVector.copy(this.unitX).cross(this.alignVector);break;case"Y":this.alignVector.copy(this.eye).cross(this.unitY),this.dirVector.copy(this.unitY).cross(this.alignVector);break;case"Z":this.alignVector.copy(this.eye).cross(this.unitZ),this.dirVector.copy(this.unitZ).cross(this.alignVector);break;case"XY":this.dirVector.copy(this.unitZ);break;case"YZ":this.dirVector.copy(this.unitX);break;case"XZ":this.alignVector.copy(this.unitZ),this.dirVector.copy(this.unitY);break;case"XYZ":case"E":this.dirVector.set(0,0,0);break}break;default:this.dirVector.set(0,0,0)}this.dirVector.length()===0?this.quaternion.copy(this.cameraQuaternion):(this.tempMatrix.lookAt(this.tempVector.set(0,0,0),this.dirVector,this.alignVector),this.quaternion.setFromRotationMatrix(this.tempMatrix)),super.updateMatrixWorld()})}}function E5(s,t,e,n){var i;return i=class extends $a{constructor(r){super({vertexShader:t,fragmentShader:e,...r});for(const l in s)this.uniforms[l]=new LE(s[l]),Object.defineProperty(this,l,{get(){return this.uniforms[l].value},set(u){this.uniforms[l].value=u}});this.uniforms=BS.clone(this.uniforms)}},i.key=_S.generateUUID(),i}const qC=s=>s===Object(s)&&!Array.isArray(s)&&typeof s!="function";function iI(s,t){const e=ss(r=>r.gl),n=p0(NE,qC(s)?Object.values(s):s);return et.useLayoutEffect(()=>{t?.(n)},[t]),et.useEffect(()=>{if("initTexture"in e){let r=[];Array.isArray(n)?r=n:n instanceof wi?r=[n]:qC(n)&&(r=Object.values(n)),r.forEach(l=>{l instanceof wi&&e.initTexture(l)})}},[e,n]),et.useMemo(()=>{if(qC(s)){const r={};let l=0;for(const u in s)r[u]=n[l++];return r}else return n},[s,n])}iI.preload=s=>p0.preload(NE,s);iI.clear=s=>p0.clear(NE,s);const _5=()=>parseInt(Kf.replace(/\D+/g,"")),C5=_5(),mB=E5({color:new le("white"),scale:new Dt(1,1),imageBounds:new Dt(1,1),resolution:1024,map:null,zoom:1,radius:0,grayscale:0,opacity:1},`
  varying vec2 vUv;
  varying vec2 vPos;
  void main() {
    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);
    vUv = uv;
    vPos = position.xy;
  }
`,`
  // mostly from https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44
  varying vec2 vUv;
  varying vec2 vPos;
  uniform vec2 scale;
  uniform vec2 imageBounds;
  uniform float resolution;
  uniform vec3 color;
  uniform sampler2D map;
  uniform float radius;
  uniform float zoom;
  uniform float grayscale;
  uniform float opacity;
  const vec3 luma = vec3(.299, 0.587, 0.114);
  vec4 toGrayscale(vec4 color, float intensity) {
    return vec4(mix(color.rgb, vec3(dot(color.rgb, luma)), intensity), color.a);
  }
  vec2 aspect(vec2 size) {
    return size / min(size.x, size.y);
  }
  
  const float PI = 3.14159265;
    
  // from https://iquilezles.org/articles/distfunctions
  float udRoundBox( vec2 p, vec2 b, float r ) {
    return length(max(abs(p)-b+r,0.0))-r;
  }

  void main() {
    vec2 s = aspect(scale);
    vec2 i = aspect(imageBounds);
    float rs = s.x / s.y;
    float ri = i.x / i.y;
    vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);
    vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;
    vec2 uv = vUv * s / new + offset;
    vec2 zUv = (uv - vec2(0.5, 0.5)) / zoom + vec2(0.5, 0.5);

    vec2 res = vec2(scale * resolution);
    vec2 halfRes = 0.5 * res;
    float b = udRoundBox(vUv.xy * res - halfRes, halfRes, resolution * radius);    
	  vec3 a = mix(vec3(1.0,0.0,0.0), vec3(0.0,0.0,0.0), smoothstep(0.0, 1.0, b));
    gl_FragColor = toGrayscale(texture2D(map, zUv) * vec4(color, opacity * a), grayscale);
    
    #include <tonemapping_fragment>
    #include <${C5>=154?"colorspace_fragment":"encodings_fragment"}>
  }
`),D3=et.forwardRef(({children:s,color:t,segments:e=1,scale:n=1,zoom:i=1,grayscale:r=0,opacity:l=1,radius:u=0,texture:A,toneMapped:d,transparent:m,side:g,...y},v)=>{GE({ImageMaterial:mB});const C=et.useRef(null),I=ss(w=>w.size),S=Array.isArray(n)?[n[0],n[1]]:[n,n],E=[A.image.width,A.image.height],B=Math.max(I.width,I.height);return et.useImperativeHandle(v,()=>C.current,[]),et.useLayoutEffect(()=>{C.current.geometry.parameters&&C.current.material.scale.set(S[0]*C.current.geometry.parameters.width,S[1]*C.current.geometry.parameters.height)},[S[0],S[1]]),et.createElement("mesh",nu({ref:C,scale:Array.isArray(n)?[...n,1]:n},y),et.createElement("planeGeometry",{args:[1,1,e,e]}),et.createElement("imageMaterial",{color:t,map:A,zoom:i,grayscale:r,opacity:l,scale:S,imageBounds:E,resolution:B,radius:u,toneMapped:d,transparent:m,side:g,key:mB.key}),s)}),b5=et.forwardRef(({url:s,...t},e)=>{const n=iI(s);return et.createElement(D3,nu({},t,{texture:n,ref:e}))}),S5=et.forwardRef(({url:s,...t},e)=>et.createElement(D3,nu({},t,{ref:e}))),I5=et.forwardRef((s,t)=>{if(s.url)return et.createElement(b5,nu({},s,{ref:t}));if(s.texture)return et.createElement(S5,nu({},s,{ref:t}));throw new Error("<Image /> requires a url or texture")}),B5=et.forwardRef(({children:s,domElement:t,onChange:e,onMouseDown:n,onMouseUp:i,onObjectChange:r,object:l,makeDefault:u,camera:A,enabled:d,axis:m,mode:g,translationSnap:y,rotationSnap:v,scaleSnap:C,space:I,size:S,showX:E,showY:B,showZ:w,...Q},R)=>{const D=ss(V=>V.controls),U=ss(V=>V.gl),P=ss(V=>V.events),z=ss(V=>V.camera),L=ss(V=>V.invalidate),k=ss(V=>V.get),Y=ss(V=>V.set),W=A||z,K=t||P.connected||U.domElement,nt=et.useMemo(()=>new y5(W,K),[W,K]),H=et.useRef(null);et.useLayoutEffect(()=>(l?nt.attach(l instanceof gn?l:l.current):H.current instanceof gn&&nt.attach(H.current),()=>{nt.detach()}),[l,s,nt]),et.useEffect(()=>{if(D){const V=st=>D.enabled=!st.value;return nt.addEventListener("dragging-changed",V),()=>nt.removeEventListener("dragging-changed",V)}},[nt,D]);const tt=et.useRef(void 0),it=et.useRef(void 0),ot=et.useRef(void 0),At=et.useRef(void 0);return et.useLayoutEffect(()=>{tt.current=e},[e]),et.useLayoutEffect(()=>{it.current=n},[n]),et.useLayoutEffect(()=>{ot.current=i},[i]),et.useLayoutEffect(()=>{At.current=r},[r]),et.useEffect(()=>{const V=Rt=>{L(),tt.current==null||tt.current(Rt)},st=Rt=>it.current==null?void 0:it.current(Rt),xt=Rt=>ot.current==null?void 0:ot.current(Rt),j=Rt=>At.current==null?void 0:At.current(Rt);return nt.addEventListener("change",V),nt.addEventListener("mouseDown",st),nt.addEventListener("mouseUp",xt),nt.addEventListener("objectChange",j),()=>{nt.removeEventListener("change",V),nt.removeEventListener("mouseDown",st),nt.removeEventListener("mouseUp",xt),nt.removeEventListener("objectChange",j)}},[L,nt]),et.useEffect(()=>{if(u){const V=k().controls;return Y({controls:nt}),()=>Y({controls:V})}},[u,nt]),et.createElement(et.Fragment,null,et.createElement("primitive",{ref:R,object:nt,enabled:d,axis:m,mode:g,translationSnap:y,rotationSnap:v,scaleSnap:C,space:I,size:S,showX:E,showY:B,showZ:w}),et.createElement("group",nu({ref:H},Q),s))});const Yi={LEFT:1,RIGHT:2,MIDDLE:4},It=Object.freeze({NONE:0,ROTATE:1,TRUCK:2,SCREEN_PAN:4,OFFSET:8,DOLLY:16,ZOOM:32,TOUCH_ROTATE:64,TOUCH_TRUCK:128,TOUCH_SCREEN_PAN:256,TOUCH_OFFSET:512,TOUCH_DOLLY:1024,TOUCH_ZOOM:2048,TOUCH_DOLLY_TRUCK:4096,TOUCH_DOLLY_SCREEN_PAN:8192,TOUCH_DOLLY_OFFSET:16384,TOUCH_DOLLY_ROTATE:32768,TOUCH_ZOOM_TRUCK:65536,TOUCH_ZOOM_OFFSET:131072,TOUCH_ZOOM_SCREEN_PAN:262144,TOUCH_ZOOM_ROTATE:524288}),Id={NONE:0,IN:1,OUT:-1};function vf(s){return s.isPerspectiveCamera}function ih(s){return s.isOrthographicCamera}const th=Math.PI*2,yB=Math.PI/2,R3=1e-5,Wg=Math.PI/180;function sl(s,t,e){return Math.max(t,Math.min(e,s))}function Si(s,t=R3){return Math.abs(s)<t}function ai(s,t,e=R3){return Si(s-t,e)}function xB(s,t){return Math.round(s/t)*t}function jg(s){return isFinite(s)?s:s<0?-Number.MAX_VALUE:Number.MAX_VALUE}function Kg(s){return Math.abs(s)<Number.MAX_VALUE?s:s*(1/0)}function Mx(s,t,e,n,i=1/0,r){n=Math.max(1e-4,n);const l=2/n,u=l*r,A=1/(1+u+.48*u*u+.235*u*u*u);let d=s-t;const m=t,g=i*n;d=sl(d,-g,g),t=s-d;const y=(e.value+l*d)*r;e.value=(e.value-l*y)*A;let v=t+(d+y)*A;return m-s>0==v>m&&(v=m,e.value=(v-m)/r),v}function vB(s,t,e,n,i=1/0,r,l){n=Math.max(1e-4,n);const u=2/n,A=u*r,d=1/(1+A+.48*A*A+.235*A*A*A);let m=t.x,g=t.y,y=t.z,v=s.x-m,C=s.y-g,I=s.z-y;const S=m,E=g,B=y,w=i*n,Q=w*w,R=v*v+C*C+I*I;if(R>Q){const nt=Math.sqrt(R);v=v/nt*w,C=C/nt*w,I=I/nt*w}m=s.x-v,g=s.y-C,y=s.z-I;const D=(e.x+u*v)*r,U=(e.y+u*C)*r,P=(e.z+u*I)*r;e.x=(e.x-u*D)*d,e.y=(e.y-u*U)*d,e.z=(e.z-u*P)*d,l.x=m+(v+D)*d,l.y=g+(C+U)*d,l.z=y+(I+P)*d;const z=S-s.x,L=E-s.y,k=B-s.z,Y=l.x-S,W=l.y-E,K=l.z-B;return z*Y+L*W+k*K>0&&(l.x=S,l.y=E,l.z=B,e.x=(l.x-S)/r,e.y=(l.y-E)/r,e.z=(l.z-B)/r),l}function XC(s,t){t.set(0,0),s.forEach(e=>{t.x+=e.clientX,t.y+=e.clientY}),t.x/=s.length,t.y/=s.length}function JC(s,t){return ih(s)?(console.warn(`${t} is not supported in OrthographicCamera`),!0):!1}class M5{_listeners={};addEventListener(t,e){const n=this._listeners;n[t]===void 0&&(n[t]=[]),n[t].indexOf(e)===-1&&n[t].push(e)}hasEventListener(t,e){const n=this._listeners;return n[t]!==void 0&&n[t].indexOf(e)!==-1}removeEventListener(t,e){const i=this._listeners[t];if(i!==void 0){const r=i.indexOf(e);r!==-1&&i.splice(r,1)}}removeAllEventListeners(t){if(!t){this._listeners={};return}Array.isArray(this._listeners[t])&&(this._listeners[t].length=0)}dispatchEvent(t){const n=this._listeners[t.type];if(n!==void 0){t.target=this;const i=n.slice(0);for(let r=0,l=i.length;r<l;r++)i[r].call(this,t)}}}const w5="3.1.2",wx=1/8,T5=/Mac/.test(globalThis?.navigator?.platform);let en,EB,Tx,ZC,Ar,vn,$n,Bd,$g,Wl,jl,Ef,_B,CB,Gr,Md,wd,bB,WC,SB,jC,KC,Qx,Q5=class Vb extends M5{static install(t){en=t.THREE,EB=Object.freeze(new en.Vector3(0,0,0)),Tx=Object.freeze(new en.Vector3(0,1,0)),ZC=Object.freeze(new en.Vector3(0,0,1)),Ar=new en.Vector2,vn=new en.Vector3,$n=new en.Vector3,Bd=new en.Vector3,$g=new en.Vector3,Wl=new en.Vector3,jl=new en.Vector3,Ef=new en.Vector3,_B=new en.Vector3,CB=new en.Vector3,Gr=new en.Spherical,Md=new en.Spherical,wd=new en.Box3,bB=new en.Box3,WC=new en.Sphere,SB=new en.Quaternion,jC=new en.Quaternion,KC=new en.Matrix4,Qx=new en.Raycaster}static get ACTION(){return It}minPolarAngle=0;maxPolarAngle=Math.PI;minAzimuthAngle=-1/0;maxAzimuthAngle=1/0;minDistance=Number.EPSILON;maxDistance=1/0;infinityDolly=!1;minZoom=.01;maxZoom=1/0;smoothTime=.25;draggingSmoothTime=.125;maxSpeed=1/0;azimuthRotateSpeed=1;polarRotateSpeed=1;dollySpeed=1;dollyDragInverted=!1;truckSpeed=2;dollyToCursor=!1;dragToOffset=!1;boundaryFriction=0;restThreshold=.01;colliderMeshes=[];mouseButtons;touches;cancel=()=>{};lockPointer;unlockPointer;_enabled=!0;_camera;_yAxisUpSpace;_yAxisUpSpaceInverse;_state=It.NONE;_domElement;_viewport=null;_target;_targetEnd;_focalOffset;_focalOffsetEnd;_spherical;_sphericalEnd;_lastDistance;_zoom;_zoomEnd;_lastZoom;_cameraUp0;_target0;_position0;_zoom0;_focalOffset0;_dollyControlCoord;_changedDolly=0;_changedZoom=0;_nearPlaneCorners;_hasRested=!0;_boundary;_boundaryEnclosesCamera=!1;_needsUpdate=!0;_updatedLastTime=!1;_elementRect=new DOMRect;_isDragging=!1;_dragNeedsUpdate=!0;_activePointers=[];_lockedPointer=null;_interactiveArea=new DOMRect(0,0,1,1);_isUserControllingRotate=!1;_isUserControllingDolly=!1;_isUserControllingTruck=!1;_isUserControllingOffset=!1;_isUserControllingZoom=!1;_lastDollyDirection=Id.NONE;_thetaVelocity={value:0};_phiVelocity={value:0};_radiusVelocity={value:0};_targetVelocity=new en.Vector3;_focalOffsetVelocity=new en.Vector3;_zoomVelocity={value:0};set verticalDragToForward(t){console.warn("camera-controls: `verticalDragToForward` was removed. Use `mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.")}constructor(t,e){super(),typeof en>"u"&&console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."),this._camera=t,this._yAxisUpSpace=new en.Quaternion().setFromUnitVectors(this._camera.up,Tx),this._yAxisUpSpaceInverse=this._yAxisUpSpace.clone().invert(),this._state=It.NONE,this._target=new en.Vector3,this._targetEnd=this._target.clone(),this._focalOffset=new en.Vector3,this._focalOffsetEnd=this._focalOffset.clone(),this._spherical=new en.Spherical().setFromVector3(vn.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)),this._sphericalEnd=this._spherical.clone(),this._lastDistance=this._spherical.radius,this._zoom=this._camera.zoom,this._zoomEnd=this._zoom,this._lastZoom=this._zoom,this._nearPlaneCorners=[new en.Vector3,new en.Vector3,new en.Vector3,new en.Vector3],this._updateNearPlaneCorners(),this._boundary=new en.Box3(new en.Vector3(-1/0,-1/0,-1/0),new en.Vector3(1/0,1/0,1/0)),this._cameraUp0=this._camera.up.clone(),this._target0=this._target.clone(),this._position0=this._camera.position.clone(),this._zoom0=this._zoom,this._focalOffset0=this._focalOffset.clone(),this._dollyControlCoord=new en.Vector2,this.mouseButtons={left:It.ROTATE,middle:It.DOLLY,right:It.TRUCK,wheel:vf(this._camera)?It.DOLLY:ih(this._camera)?It.ZOOM:It.NONE},this.touches={one:It.TOUCH_ROTATE,two:vf(this._camera)?It.TOUCH_DOLLY_TRUCK:ih(this._camera)?It.TOUCH_ZOOM_TRUCK:It.NONE,three:It.TOUCH_TRUCK};const n=new en.Vector2,i=new en.Vector2,r=new en.Vector2,l=E=>{if(!this._enabled||!this._domElement)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const Q=this._domElement.getBoundingClientRect(),R=E.clientX/Q.width,D=E.clientY/Q.height;if(R<this._interactiveArea.left||R>this._interactiveArea.right||D<this._interactiveArea.top||D>this._interactiveArea.bottom)return}const B=E.pointerType!=="mouse"?null:(E.buttons&Yi.LEFT)===Yi.LEFT?Yi.LEFT:(E.buttons&Yi.MIDDLE)===Yi.MIDDLE?Yi.MIDDLE:(E.buttons&Yi.RIGHT)===Yi.RIGHT?Yi.RIGHT:null;if(B!==null){const Q=this._findPointerByMouseButton(B);Q&&this._disposePointer(Q)}if((E.buttons&Yi.LEFT)===Yi.LEFT&&this._lockedPointer)return;const w={pointerId:E.pointerId,clientX:E.clientX,clientY:E.clientY,deltaX:0,deltaY:0,mouseButton:B};this._activePointers.push(w),this._domElement.ownerDocument.removeEventListener("pointermove",u,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",A),this._domElement.ownerDocument.addEventListener("pointermove",u,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",A),this._isDragging=!0,y(E)},u=E=>{E.cancelable&&E.preventDefault();const B=E.pointerId,w=this._lockedPointer||this._findPointerById(B);if(w){if(w.clientX=E.clientX,w.clientY=E.clientY,w.deltaX=E.movementX,w.deltaY=E.movementY,this._state=0,E.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else(!this._isDragging&&this._lockedPointer||this._isDragging&&(E.buttons&Yi.LEFT)===Yi.LEFT)&&(this._state=this._state|this.mouseButtons.left),this._isDragging&&(E.buttons&Yi.MIDDLE)===Yi.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),this._isDragging&&(E.buttons&Yi.RIGHT)===Yi.RIGHT&&(this._state=this._state|this.mouseButtons.right);v()}},A=E=>{const B=this._findPointerById(E.pointerId);if(!(B&&B===this._lockedPointer)){if(B&&this._disposePointer(B),E.pointerType==="touch")switch(this._activePointers.length){case 0:this._state=It.NONE;break;case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else this._state=It.NONE;C()}};let d=-1;const m=E=>{if(!this._domElement||!this._enabled||this.mouseButtons.wheel===It.NONE)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const U=this._domElement.getBoundingClientRect(),P=E.clientX/U.width,z=E.clientY/U.height;if(P<this._interactiveArea.left||P>this._interactiveArea.right||z<this._interactiveArea.top||z>this._interactiveArea.bottom)return}if(E.preventDefault(),this.dollyToCursor||this.mouseButtons.wheel===It.ROTATE||this.mouseButtons.wheel===It.TRUCK){const U=performance.now();d-U<1e3&&this._getClientRect(this._elementRect),d=U}const B=T5?-1:-3,w=E.deltaMode===1&&!E.ctrlKey?E.deltaY/B:E.deltaY/(B*10),Q=this.dollyToCursor?(E.clientX-this._elementRect.x)/this._elementRect.width*2-1:0,R=this.dollyToCursor?(E.clientY-this._elementRect.y)/this._elementRect.height*-2+1:0;switch(E.ctrlKey?It.ZOOM:this.mouseButtons.wheel){case It.ROTATE:{this._rotateInternal(E.deltaX,E.deltaY),this._isUserControllingRotate=!0;break}case It.TRUCK:{this._truckInternal(E.deltaX,E.deltaY,!1,!1),this._isUserControllingTruck=!0;break}case It.SCREEN_PAN:{this._truckInternal(E.deltaX,E.deltaY,!1,!0),this._isUserControllingTruck=!0;break}case It.OFFSET:{this._truckInternal(E.deltaX,E.deltaY,!0,!1),this._isUserControllingOffset=!0;break}case It.DOLLY:{this._dollyInternal(-w,Q,R),this._isUserControllingDolly=!0;break}case It.ZOOM:{this._zoomInternal(-w,Q,R),this._isUserControllingZoom=!0;break}}this.dispatchEvent({type:"control"})},g=E=>{if(!(!this._domElement||!this._enabled)){if(this.mouseButtons.right===Vb.ACTION.NONE){const B=E instanceof PointerEvent?E.pointerId:0,w=this._findPointerById(B);w&&this._disposePointer(w),this._domElement.ownerDocument.removeEventListener("pointermove",u,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",A);return}E.preventDefault()}},y=E=>{if(!this._enabled)return;if(XC(this._activePointers,Ar),this._getClientRect(this._elementRect),n.copy(Ar),i.copy(Ar),this._activePointers.length>=2){const w=Ar.x-this._activePointers[1].clientX,Q=Ar.y-this._activePointers[1].clientY,R=Math.sqrt(w*w+Q*Q);r.set(0,R);const D=(this._activePointers[0].clientX+this._activePointers[1].clientX)*.5,U=(this._activePointers[0].clientY+this._activePointers[1].clientY)*.5;i.set(D,U)}if(this._state=0,!E)this._lockedPointer&&(this._state=this._state|this.mouseButtons.left);else if("pointerType"in E&&E.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else!this._lockedPointer&&(E.buttons&Yi.LEFT)===Yi.LEFT&&(this._state=this._state|this.mouseButtons.left),(E.buttons&Yi.MIDDLE)===Yi.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),(E.buttons&Yi.RIGHT)===Yi.RIGHT&&(this._state=this._state|this.mouseButtons.right);((this._state&It.ROTATE)===It.ROTATE||(this._state&It.TOUCH_ROTATE)===It.TOUCH_ROTATE||(this._state&It.TOUCH_DOLLY_ROTATE)===It.TOUCH_DOLLY_ROTATE||(this._state&It.TOUCH_ZOOM_ROTATE)===It.TOUCH_ZOOM_ROTATE)&&(this._sphericalEnd.theta=this._spherical.theta,this._sphericalEnd.phi=this._spherical.phi,this._thetaVelocity.value=0,this._phiVelocity.value=0),((this._state&It.TRUCK)===It.TRUCK||(this._state&It.SCREEN_PAN)===It.SCREEN_PAN||(this._state&It.TOUCH_TRUCK)===It.TOUCH_TRUCK||(this._state&It.TOUCH_SCREEN_PAN)===It.TOUCH_SCREEN_PAN||(this._state&It.TOUCH_DOLLY_TRUCK)===It.TOUCH_DOLLY_TRUCK||(this._state&It.TOUCH_DOLLY_SCREEN_PAN)===It.TOUCH_DOLLY_SCREEN_PAN||(this._state&It.TOUCH_ZOOM_TRUCK)===It.TOUCH_ZOOM_TRUCK||(this._state&It.TOUCH_ZOOM_SCREEN_PAN)===It.TOUCH_DOLLY_SCREEN_PAN)&&(this._targetEnd.copy(this._target),this._targetVelocity.set(0,0,0)),((this._state&It.DOLLY)===It.DOLLY||(this._state&It.TOUCH_DOLLY)===It.TOUCH_DOLLY||(this._state&It.TOUCH_DOLLY_TRUCK)===It.TOUCH_DOLLY_TRUCK||(this._state&It.TOUCH_DOLLY_SCREEN_PAN)===It.TOUCH_DOLLY_SCREEN_PAN||(this._state&It.TOUCH_DOLLY_OFFSET)===It.TOUCH_DOLLY_OFFSET||(this._state&It.TOUCH_DOLLY_ROTATE)===It.TOUCH_DOLLY_ROTATE)&&(this._sphericalEnd.radius=this._spherical.radius,this._radiusVelocity.value=0),((this._state&It.ZOOM)===It.ZOOM||(this._state&It.TOUCH_ZOOM)===It.TOUCH_ZOOM||(this._state&It.TOUCH_ZOOM_TRUCK)===It.TOUCH_ZOOM_TRUCK||(this._state&It.TOUCH_ZOOM_SCREEN_PAN)===It.TOUCH_ZOOM_SCREEN_PAN||(this._state&It.TOUCH_ZOOM_OFFSET)===It.TOUCH_ZOOM_OFFSET||(this._state&It.TOUCH_ZOOM_ROTATE)===It.TOUCH_ZOOM_ROTATE)&&(this._zoomEnd=this._zoom,this._zoomVelocity.value=0),((this._state&It.OFFSET)===It.OFFSET||(this._state&It.TOUCH_OFFSET)===It.TOUCH_OFFSET||(this._state&It.TOUCH_DOLLY_OFFSET)===It.TOUCH_DOLLY_OFFSET||(this._state&It.TOUCH_ZOOM_OFFSET)===It.TOUCH_ZOOM_OFFSET)&&(this._focalOffsetEnd.copy(this._focalOffset),this._focalOffsetVelocity.set(0,0,0)),this.dispatchEvent({type:"controlstart"})},v=()=>{if(!this._enabled||!this._dragNeedsUpdate)return;this._dragNeedsUpdate=!1,XC(this._activePointers,Ar);const B=this._domElement&&this._domElement.ownerDocument.pointerLockElement===this._domElement?this._lockedPointer||this._activePointers[0]:null,w=B?-B.deltaX:i.x-Ar.x,Q=B?-B.deltaY:i.y-Ar.y;if(i.copy(Ar),((this._state&It.ROTATE)===It.ROTATE||(this._state&It.TOUCH_ROTATE)===It.TOUCH_ROTATE||(this._state&It.TOUCH_DOLLY_ROTATE)===It.TOUCH_DOLLY_ROTATE||(this._state&It.TOUCH_ZOOM_ROTATE)===It.TOUCH_ZOOM_ROTATE)&&(this._rotateInternal(w,Q),this._isUserControllingRotate=!0),(this._state&It.DOLLY)===It.DOLLY||(this._state&It.ZOOM)===It.ZOOM){const R=this.dollyToCursor?(n.x-this._elementRect.x)/this._elementRect.width*2-1:0,D=this.dollyToCursor?(n.y-this._elementRect.y)/this._elementRect.height*-2+1:0,U=this.dollyDragInverted?-1:1;(this._state&It.DOLLY)===It.DOLLY?(this._dollyInternal(U*Q*wx,R,D),this._isUserControllingDolly=!0):(this._zoomInternal(U*Q*wx,R,D),this._isUserControllingZoom=!0)}if((this._state&It.TOUCH_DOLLY)===It.TOUCH_DOLLY||(this._state&It.TOUCH_ZOOM)===It.TOUCH_ZOOM||(this._state&It.TOUCH_DOLLY_TRUCK)===It.TOUCH_DOLLY_TRUCK||(this._state&It.TOUCH_ZOOM_TRUCK)===It.TOUCH_ZOOM_TRUCK||(this._state&It.TOUCH_DOLLY_SCREEN_PAN)===It.TOUCH_DOLLY_SCREEN_PAN||(this._state&It.TOUCH_ZOOM_SCREEN_PAN)===It.TOUCH_ZOOM_SCREEN_PAN||(this._state&It.TOUCH_DOLLY_OFFSET)===It.TOUCH_DOLLY_OFFSET||(this._state&It.TOUCH_ZOOM_OFFSET)===It.TOUCH_ZOOM_OFFSET||(this._state&It.TOUCH_DOLLY_ROTATE)===It.TOUCH_DOLLY_ROTATE||(this._state&It.TOUCH_ZOOM_ROTATE)===It.TOUCH_ZOOM_ROTATE){const R=Ar.x-this._activePointers[1].clientX,D=Ar.y-this._activePointers[1].clientY,U=Math.sqrt(R*R+D*D),P=r.y-U;r.set(0,U);const z=this.dollyToCursor?(i.x-this._elementRect.x)/this._elementRect.width*2-1:0,L=this.dollyToCursor?(i.y-this._elementRect.y)/this._elementRect.height*-2+1:0;(this._state&It.TOUCH_DOLLY)===It.TOUCH_DOLLY||(this._state&It.TOUCH_DOLLY_ROTATE)===It.TOUCH_DOLLY_ROTATE||(this._state&It.TOUCH_DOLLY_TRUCK)===It.TOUCH_DOLLY_TRUCK||(this._state&It.TOUCH_DOLLY_SCREEN_PAN)===It.TOUCH_DOLLY_SCREEN_PAN||(this._state&It.TOUCH_DOLLY_OFFSET)===It.TOUCH_DOLLY_OFFSET?(this._dollyInternal(P*wx,z,L),this._isUserControllingDolly=!0):(this._zoomInternal(P*wx,z,L),this._isUserControllingZoom=!0)}((this._state&It.TRUCK)===It.TRUCK||(this._state&It.TOUCH_TRUCK)===It.TOUCH_TRUCK||(this._state&It.TOUCH_DOLLY_TRUCK)===It.TOUCH_DOLLY_TRUCK||(this._state&It.TOUCH_ZOOM_TRUCK)===It.TOUCH_ZOOM_TRUCK)&&(this._truckInternal(w,Q,!1,!1),this._isUserControllingTruck=!0),((this._state&It.SCREEN_PAN)===It.SCREEN_PAN||(this._state&It.TOUCH_SCREEN_PAN)===It.TOUCH_SCREEN_PAN||(this._state&It.TOUCH_DOLLY_SCREEN_PAN)===It.TOUCH_DOLLY_SCREEN_PAN||(this._state&It.TOUCH_ZOOM_SCREEN_PAN)===It.TOUCH_ZOOM_SCREEN_PAN)&&(this._truckInternal(w,Q,!1,!0),this._isUserControllingTruck=!0),((this._state&It.OFFSET)===It.OFFSET||(this._state&It.TOUCH_OFFSET)===It.TOUCH_OFFSET||(this._state&It.TOUCH_DOLLY_OFFSET)===It.TOUCH_DOLLY_OFFSET||(this._state&It.TOUCH_ZOOM_OFFSET)===It.TOUCH_ZOOM_OFFSET)&&(this._truckInternal(w,Q,!0,!1),this._isUserControllingOffset=!0),this.dispatchEvent({type:"control"})},C=()=>{XC(this._activePointers,Ar),i.copy(Ar),this._dragNeedsUpdate=!1,(this._activePointers.length===0||this._activePointers.length===1&&this._activePointers[0]===this._lockedPointer)&&(this._isDragging=!1),this._activePointers.length===0&&this._domElement&&(this._domElement.ownerDocument.removeEventListener("pointermove",u,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",A),this.dispatchEvent({type:"controlend"}))};this.lockPointer=()=>{!this._enabled||!this._domElement||(this.cancel(),this._lockedPointer={pointerId:-1,clientX:0,clientY:0,deltaX:0,deltaY:0,mouseButton:null},this._activePointers.push(this._lockedPointer),this._domElement.ownerDocument.removeEventListener("pointermove",u,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",A),this._domElement.requestPointerLock(),this._domElement.ownerDocument.addEventListener("pointerlockchange",I),this._domElement.ownerDocument.addEventListener("pointerlockerror",S),this._domElement.ownerDocument.addEventListener("pointermove",u,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",A),y())},this.unlockPointer=()=>{this._lockedPointer!==null&&(this._disposePointer(this._lockedPointer),this._lockedPointer=null),this._domElement?.ownerDocument.exitPointerLock(),this._domElement?.ownerDocument.removeEventListener("pointerlockchange",I),this._domElement?.ownerDocument.removeEventListener("pointerlockerror",S),this.cancel()};const I=()=>{this._domElement&&this._domElement.ownerDocument.pointerLockElement===this._domElement||this.unlockPointer()},S=()=>{this.unlockPointer()};this._addAllEventListeners=E=>{this._domElement=E,this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none",this._domElement.addEventListener("pointerdown",l),this._domElement.addEventListener("pointercancel",A),this._domElement.addEventListener("wheel",m,{passive:!1}),this._domElement.addEventListener("contextmenu",g)},this._removeAllEventListeners=()=>{this._domElement&&(this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect="",this._domElement.removeEventListener("pointerdown",l),this._domElement.removeEventListener("pointercancel",A),this._domElement.removeEventListener("wheel",m,{passive:!1}),this._domElement.removeEventListener("contextmenu",g),this._domElement.ownerDocument.removeEventListener("pointermove",u,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",A),this._domElement.ownerDocument.removeEventListener("pointerlockchange",I),this._domElement.ownerDocument.removeEventListener("pointerlockerror",S))},this.cancel=()=>{this._state!==It.NONE&&(this._state=It.NONE,this._activePointers.length=0,C())},e&&this.connect(e),this.update(0)}get camera(){return this._camera}set camera(t){this._camera=t,this.updateCameraUp(),this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0}get enabled(){return this._enabled}set enabled(t){this._enabled=t,this._domElement&&(t?(this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none"):(this.cancel(),this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect=""))}get active(){return!this._hasRested}get currentAction(){return this._state}get distance(){return this._spherical.radius}set distance(t){this._spherical.radius===t&&this._sphericalEnd.radius===t||(this._spherical.radius=t,this._sphericalEnd.radius=t,this._needsUpdate=!0)}get azimuthAngle(){return this._spherical.theta}set azimuthAngle(t){this._spherical.theta===t&&this._sphericalEnd.theta===t||(this._spherical.theta=t,this._sphericalEnd.theta=t,this._needsUpdate=!0)}get polarAngle(){return this._spherical.phi}set polarAngle(t){this._spherical.phi===t&&this._sphericalEnd.phi===t||(this._spherical.phi=t,this._sphericalEnd.phi=t,this._needsUpdate=!0)}get boundaryEnclosesCamera(){return this._boundaryEnclosesCamera}set boundaryEnclosesCamera(t){this._boundaryEnclosesCamera=t,this._needsUpdate=!0}set interactiveArea(t){this._interactiveArea.width=sl(t.width,0,1),this._interactiveArea.height=sl(t.height,0,1),this._interactiveArea.x=sl(t.x,0,1-this._interactiveArea.width),this._interactiveArea.y=sl(t.y,0,1-this._interactiveArea.height)}addEventListener(t,e){super.addEventListener(t,e)}removeEventListener(t,e){super.removeEventListener(t,e)}rotate(t,e,n=!1){return this.rotateTo(this._sphericalEnd.theta+t,this._sphericalEnd.phi+e,n)}rotateAzimuthTo(t,e=!1){return this.rotateTo(t,this._sphericalEnd.phi,e)}rotatePolarTo(t,e=!1){return this.rotateTo(this._sphericalEnd.theta,t,e)}rotateTo(t,e,n=!1){this._isUserControllingRotate=!1;const i=sl(t,this.minAzimuthAngle,this.maxAzimuthAngle),r=sl(e,this.minPolarAngle,this.maxPolarAngle);this._sphericalEnd.theta=i,this._sphericalEnd.phi=r,this._sphericalEnd.makeSafe(),this._needsUpdate=!0,n||(this._spherical.theta=this._sphericalEnd.theta,this._spherical.phi=this._sphericalEnd.phi);const l=!n||ai(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&ai(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold);return this._createOnRestPromise(l)}dolly(t,e=!1){return this.dollyTo(this._sphericalEnd.radius-t,e)}dollyTo(t,e=!1){return this._isUserControllingDolly=!1,this._lastDollyDirection=Id.NONE,this._changedDolly=0,this._dollyToNoClamp(sl(t,this.minDistance,this.maxDistance),e)}_dollyToNoClamp(t,e=!1){const n=this._sphericalEnd.radius;if(this.colliderMeshes.length>=1){const l=this._collisionTest(),u=ai(l,this._spherical.radius);if(!(n>t)&&u)return Promise.resolve();this._sphericalEnd.radius=Math.min(t,l)}else this._sphericalEnd.radius=t;this._needsUpdate=!0,e||(this._spherical.radius=this._sphericalEnd.radius);const r=!e||ai(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(r)}dollyInFixed(t,e=!1){this._targetEnd.add(this._getCameraDirection($g).multiplyScalar(t)),e||this._target.copy(this._targetEnd);const n=!e||ai(this._target.x,this._targetEnd.x,this.restThreshold)&&ai(this._target.y,this._targetEnd.y,this.restThreshold)&&ai(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(n)}zoom(t,e=!1){return this.zoomTo(this._zoomEnd+t,e)}zoomTo(t,e=!1){this._isUserControllingZoom=!1,this._zoomEnd=sl(t,this.minZoom,this.maxZoom),this._needsUpdate=!0,e||(this._zoom=this._zoomEnd);const n=!e||ai(this._zoom,this._zoomEnd,this.restThreshold);return this._changedZoom=0,this._createOnRestPromise(n)}pan(t,e,n=!1){return console.warn("`pan` has been renamed to `truck`"),this.truck(t,e,n)}truck(t,e,n=!1){this._camera.updateMatrix(),Wl.setFromMatrixColumn(this._camera.matrix,0),jl.setFromMatrixColumn(this._camera.matrix,1),Wl.multiplyScalar(t),jl.multiplyScalar(-e);const i=vn.copy(Wl).add(jl),r=$n.copy(this._targetEnd).add(i);return this.moveTo(r.x,r.y,r.z,n)}forward(t,e=!1){vn.setFromMatrixColumn(this._camera.matrix,0),vn.crossVectors(this._camera.up,vn),vn.multiplyScalar(t);const n=$n.copy(this._targetEnd).add(vn);return this.moveTo(n.x,n.y,n.z,e)}elevate(t,e=!1){return vn.copy(this._camera.up).multiplyScalar(t),this.moveTo(this._targetEnd.x+vn.x,this._targetEnd.y+vn.y,this._targetEnd.z+vn.z,e)}moveTo(t,e,n,i=!1){this._isUserControllingTruck=!1;const r=vn.set(t,e,n).sub(this._targetEnd);this._encloseToBoundary(this._targetEnd,r,this.boundaryFriction),this._needsUpdate=!0,i||this._target.copy(this._targetEnd);const l=!i||ai(this._target.x,this._targetEnd.x,this.restThreshold)&&ai(this._target.y,this._targetEnd.y,this.restThreshold)&&ai(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(l)}lookInDirectionOf(t,e,n,i=!1){const u=vn.set(t,e,n).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);return this.setPosition(u.x,u.y,u.z,i)}fitToBox(t,e,{cover:n=!1,paddingLeft:i=0,paddingRight:r=0,paddingBottom:l=0,paddingTop:u=0}={}){const A=[],d=t.isBox3?wd.copy(t):wd.setFromObject(t);d.isEmpty()&&(console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"),Promise.resolve());const m=xB(this._sphericalEnd.theta,yB),g=xB(this._sphericalEnd.phi,yB);A.push(this.rotateTo(m,g,e));const y=vn.setFromSpherical(this._sphericalEnd).normalize(),v=SB.setFromUnitVectors(y,ZC),C=ai(Math.abs(y.y),1);C&&v.multiply(jC.setFromAxisAngle(Tx,m)),v.multiply(this._yAxisUpSpaceInverse);const I=bB.makeEmpty();$n.copy(d.min).applyQuaternion(v),I.expandByPoint($n),$n.copy(d.min).setX(d.max.x).applyQuaternion(v),I.expandByPoint($n),$n.copy(d.min).setY(d.max.y).applyQuaternion(v),I.expandByPoint($n),$n.copy(d.max).setZ(d.min.z).applyQuaternion(v),I.expandByPoint($n),$n.copy(d.min).setZ(d.max.z).applyQuaternion(v),I.expandByPoint($n),$n.copy(d.max).setY(d.min.y).applyQuaternion(v),I.expandByPoint($n),$n.copy(d.max).setX(d.min.x).applyQuaternion(v),I.expandByPoint($n),$n.copy(d.max).applyQuaternion(v),I.expandByPoint($n),I.min.x-=i,I.min.y-=l,I.max.x+=r,I.max.y+=u,v.setFromUnitVectors(ZC,y),C&&v.premultiply(jC.invert()),v.premultiply(this._yAxisUpSpace);const S=I.getSize(vn),E=I.getCenter($n).applyQuaternion(v);if(vf(this._camera)){const B=this.getDistanceToFitBox(S.x,S.y,S.z,n);A.push(this.moveTo(E.x,E.y,E.z,e)),A.push(this.dollyTo(B,e)),A.push(this.setFocalOffset(0,0,0,e))}else if(ih(this._camera)){const B=this._camera,w=B.right-B.left,Q=B.top-B.bottom,R=n?Math.max(w/S.x,Q/S.y):Math.min(w/S.x,Q/S.y);A.push(this.moveTo(E.x,E.y,E.z,e)),A.push(this.zoomTo(R,e)),A.push(this.setFocalOffset(0,0,0,e))}return Promise.all(A)}fitToSphere(t,e){const n=[],r="isObject3D"in t?Vb.createBoundingSphere(t,WC):WC.copy(t);if(n.push(this.moveTo(r.center.x,r.center.y,r.center.z,e)),vf(this._camera)){const l=this.getDistanceToFitSphere(r.radius);n.push(this.dollyTo(l,e))}else if(ih(this._camera)){const l=this._camera.right-this._camera.left,u=this._camera.top-this._camera.bottom,A=2*r.radius,d=Math.min(l/A,u/A);n.push(this.zoomTo(d,e))}return n.push(this.setFocalOffset(0,0,0,e)),Promise.all(n)}setLookAt(t,e,n,i,r,l,u=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=Id.NONE,this._changedDolly=0;const A=$n.set(i,r,l),d=vn.set(t,e,n);this._targetEnd.copy(A),this._sphericalEnd.setFromVector3(d.sub(A).applyQuaternion(this._yAxisUpSpace)),this._needsUpdate=!0,u||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const m=!u||ai(this._target.x,this._targetEnd.x,this.restThreshold)&&ai(this._target.y,this._targetEnd.y,this.restThreshold)&&ai(this._target.z,this._targetEnd.z,this.restThreshold)&&ai(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&ai(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&ai(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(m)}lerp(t,e,n,i=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=Id.NONE,this._changedDolly=0;const r=vn.set(...t.target);if("spherical"in t)Gr.set(...t.spherical);else{const g=$n.set(...t.position);Gr.setFromVector3(g.sub(r).applyQuaternion(this._yAxisUpSpace))}const l=Bd.set(...e.target);if("spherical"in e)Md.set(...e.spherical);else{const g=$n.set(...e.position);Md.setFromVector3(g.sub(l).applyQuaternion(this._yAxisUpSpace))}this._targetEnd.copy(r.lerp(l,n));const u=Md.theta-Gr.theta,A=Md.phi-Gr.phi,d=Md.radius-Gr.radius;this._sphericalEnd.set(Gr.radius+d*n,Gr.phi+A*n,Gr.theta+u*n),this._needsUpdate=!0,i||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const m=!i||ai(this._target.x,this._targetEnd.x,this.restThreshold)&&ai(this._target.y,this._targetEnd.y,this.restThreshold)&&ai(this._target.z,this._targetEnd.z,this.restThreshold)&&ai(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&ai(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&ai(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(m)}lerpLookAt(t,e,n,i,r,l,u,A,d,m,g,y,v,C=!1){return this.lerp({position:[t,e,n],target:[i,r,l]},{position:[u,A,d],target:[m,g,y]},v,C)}setPosition(t,e,n,i=!1){return this.setLookAt(t,e,n,this._targetEnd.x,this._targetEnd.y,this._targetEnd.z,i)}setTarget(t,e,n,i=!1){const r=this.getPosition(vn),l=this.setLookAt(r.x,r.y,r.z,t,e,n,i);return this._sphericalEnd.phi=sl(this._sphericalEnd.phi,this.minPolarAngle,this.maxPolarAngle),l}setFocalOffset(t,e,n,i=!1){this._isUserControllingOffset=!1,this._focalOffsetEnd.set(t,e,n),this._needsUpdate=!0,i||this._focalOffset.copy(this._focalOffsetEnd);const r=!i||ai(this._focalOffset.x,this._focalOffsetEnd.x,this.restThreshold)&&ai(this._focalOffset.y,this._focalOffsetEnd.y,this.restThreshold)&&ai(this._focalOffset.z,this._focalOffsetEnd.z,this.restThreshold);return this._createOnRestPromise(r)}setOrbitPoint(t,e,n){this._camera.updateMatrixWorld(),Wl.setFromMatrixColumn(this._camera.matrixWorldInverse,0),jl.setFromMatrixColumn(this._camera.matrixWorldInverse,1),Ef.setFromMatrixColumn(this._camera.matrixWorldInverse,2);const i=vn.set(t,e,n),r=i.distanceTo(this._camera.position),l=i.sub(this._camera.position);Wl.multiplyScalar(l.x),jl.multiplyScalar(l.y),Ef.multiplyScalar(l.z),vn.copy(Wl).add(jl).add(Ef),vn.z=vn.z+r,this.dollyTo(r,!1),this.setFocalOffset(-vn.x,vn.y,-vn.z,!1),this.moveTo(t,e,n,!1)}setBoundary(t){if(!t){this._boundary.min.set(-1/0,-1/0,-1/0),this._boundary.max.set(1/0,1/0,1/0),this._needsUpdate=!0;return}this._boundary.copy(t),this._boundary.clampPoint(this._targetEnd,this._targetEnd),this._needsUpdate=!0}setViewport(t,e,n,i){if(t===null){this._viewport=null;return}this._viewport=this._viewport||new en.Vector4,typeof t=="number"?this._viewport.set(t,e,n,i):this._viewport.copy(t)}getDistanceToFitBox(t,e,n,i=!1){if(JC(this._camera,"getDistanceToFitBox"))return this._spherical.radius;const r=t/e,l=this._camera.getEffectiveFOV()*Wg,u=this._camera.aspect;return((i?r>u:r<u)?e:t/u)*.5/Math.tan(l*.5)+n*.5}getDistanceToFitSphere(t){if(JC(this._camera,"getDistanceToFitSphere"))return this._spherical.radius;const e=this._camera.getEffectiveFOV()*Wg,n=Math.atan(Math.tan(e*.5)*this._camera.aspect)*2,i=1<this._camera.aspect?e:n;return t/Math.sin(i*.5)}getTarget(t,e=!0){return(t&&t.isVector3?t:new en.Vector3).copy(e?this._targetEnd:this._target)}getPosition(t,e=!0){return(t&&t.isVector3?t:new en.Vector3).setFromSpherical(e?this._sphericalEnd:this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(e?this._targetEnd:this._target)}getSpherical(t,e=!0){return(t||new en.Spherical).copy(e?this._sphericalEnd:this._spherical)}getFocalOffset(t,e=!0){return(t&&t.isVector3?t:new en.Vector3).copy(e?this._focalOffsetEnd:this._focalOffset)}normalizeRotations(){return this._sphericalEnd.theta=(this._sphericalEnd.theta%th+th)%th,this._sphericalEnd.theta>Math.PI&&(this._sphericalEnd.theta-=th),this._spherical.theta+=th*Math.round((this._sphericalEnd.theta-this._spherical.theta)/th),this}stop(){this._focalOffset.copy(this._focalOffsetEnd),this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd),this._zoom=this._zoomEnd}reset(t=!1){if(!ai(this._camera.up.x,this._cameraUp0.x)||!ai(this._camera.up.y,this._cameraUp0.y)||!ai(this._camera.up.z,this._cameraUp0.z)){this._camera.up.copy(this._cameraUp0);const n=this.getPosition(vn);this.updateCameraUp(),this.setPosition(n.x,n.y,n.z)}const e=[this.setLookAt(this._position0.x,this._position0.y,this._position0.z,this._target0.x,this._target0.y,this._target0.z,t),this.setFocalOffset(this._focalOffset0.x,this._focalOffset0.y,this._focalOffset0.z,t),this.zoomTo(this._zoom0,t)];return Promise.all(e)}saveState(){this._cameraUp0.copy(this._camera.up),this.getTarget(this._target0),this.getPosition(this._position0),this._zoom0=this._zoom,this._focalOffset0.copy(this._focalOffset)}updateCameraUp(){this._yAxisUpSpace.setFromUnitVectors(this._camera.up,Tx),this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert()}applyCameraUp(){const t=vn.subVectors(this._target,this._camera.position).normalize(),e=$n.crossVectors(t,this._camera.up);this._camera.up.crossVectors(e,t).normalize(),this._camera.updateMatrixWorld();const n=this.getPosition(vn);this.updateCameraUp(),this.setPosition(n.x,n.y,n.z)}update(t){const e=this._sphericalEnd.theta-this._spherical.theta,n=this._sphericalEnd.phi-this._spherical.phi,i=this._sphericalEnd.radius-this._spherical.radius,r=_B.subVectors(this._targetEnd,this._target),l=CB.subVectors(this._focalOffsetEnd,this._focalOffset),u=this._zoomEnd-this._zoom;if(Si(e))this._thetaVelocity.value=0,this._spherical.theta=this._sphericalEnd.theta;else{const g=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.theta=Mx(this._spherical.theta,this._sphericalEnd.theta,this._thetaVelocity,g,1/0,t),this._needsUpdate=!0}if(Si(n))this._phiVelocity.value=0,this._spherical.phi=this._sphericalEnd.phi;else{const g=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.phi=Mx(this._spherical.phi,this._sphericalEnd.phi,this._phiVelocity,g,1/0,t),this._needsUpdate=!0}if(Si(i))this._radiusVelocity.value=0,this._spherical.radius=this._sphericalEnd.radius;else{const g=this._isUserControllingDolly?this.draggingSmoothTime:this.smoothTime;this._spherical.radius=Mx(this._spherical.radius,this._sphericalEnd.radius,this._radiusVelocity,g,this.maxSpeed,t),this._needsUpdate=!0}if(Si(r.x)&&Si(r.y)&&Si(r.z))this._targetVelocity.set(0,0,0),this._target.copy(this._targetEnd);else{const g=this._isUserControllingTruck?this.draggingSmoothTime:this.smoothTime;vB(this._target,this._targetEnd,this._targetVelocity,g,this.maxSpeed,t,this._target),this._needsUpdate=!0}if(Si(l.x)&&Si(l.y)&&Si(l.z))this._focalOffsetVelocity.set(0,0,0),this._focalOffset.copy(this._focalOffsetEnd);else{const g=this._isUserControllingOffset?this.draggingSmoothTime:this.smoothTime;vB(this._focalOffset,this._focalOffsetEnd,this._focalOffsetVelocity,g,this.maxSpeed,t,this._focalOffset),this._needsUpdate=!0}if(Si(u))this._zoomVelocity.value=0,this._zoom=this._zoomEnd;else{const g=this._isUserControllingZoom?this.draggingSmoothTime:this.smoothTime;this._zoom=Mx(this._zoom,this._zoomEnd,this._zoomVelocity,g,1/0,t)}if(this.dollyToCursor){if(vf(this._camera)&&this._changedDolly!==0){const g=this._spherical.radius-this._lastDistance,y=this._camera,v=this._getCameraDirection($g),C=vn.copy(v).cross(y.up).normalize();C.lengthSq()===0&&(C.x=1);const I=$n.crossVectors(C,v),S=this._sphericalEnd.radius*Math.tan(y.getEffectiveFOV()*Wg*.5),B=(this._sphericalEnd.radius-g-this._sphericalEnd.radius)/this._sphericalEnd.radius,w=Bd.copy(this._targetEnd).add(C.multiplyScalar(this._dollyControlCoord.x*S*y.aspect)).add(I.multiplyScalar(this._dollyControlCoord.y*S)),Q=vn.copy(this._targetEnd).lerp(w,B),R=this._lastDollyDirection===Id.IN&&this._spherical.radius<=this.minDistance,D=this._lastDollyDirection===Id.OUT&&this.maxDistance<=this._spherical.radius;if(this.infinityDolly&&(R||D)){this._sphericalEnd.radius-=g,this._spherical.radius-=g;const P=$n.copy(v).multiplyScalar(-g);Q.add(P)}this._boundary.clampPoint(Q,Q);const U=$n.subVectors(Q,this._targetEnd);this._targetEnd.copy(Q),this._target.add(U),this._changedDolly-=g,Si(this._changedDolly)&&(this._changedDolly=0)}else if(ih(this._camera)&&this._changedZoom!==0){const g=this._zoom-this._lastZoom,y=this._camera,v=vn.set(this._dollyControlCoord.x,this._dollyControlCoord.y,(y.near+y.far)/(y.near-y.far)).unproject(y),C=$n.set(0,0,-1).applyQuaternion(y.quaternion),I=Bd.copy(v).add(C.multiplyScalar(-v.dot(y.up))),E=-(this._zoom-g-this._zoom)/this._zoom,B=this._getCameraDirection($g),w=this._targetEnd.dot(B),Q=vn.copy(this._targetEnd).lerp(I,E),R=Q.dot(B),D=B.multiplyScalar(R-w);Q.sub(D),this._boundary.clampPoint(Q,Q);const U=$n.subVectors(Q,this._targetEnd);this._targetEnd.copy(Q),this._target.add(U),this._changedZoom-=g,Si(this._changedZoom)&&(this._changedZoom=0)}}this._camera.zoom!==this._zoom&&(this._camera.zoom=this._zoom,this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0),this._dragNeedsUpdate=!0;const A=this._collisionTest();this._spherical.radius=Math.min(this._spherical.radius,A),this._spherical.makeSafe(),this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target),this._camera.lookAt(this._target),(!Si(this._focalOffset.x)||!Si(this._focalOffset.y)||!Si(this._focalOffset.z))&&(this._camera.matrix.compose(this._camera.position,this._camera.quaternion,this._camera.scale),Wl.setFromMatrixColumn(this._camera.matrix,0),jl.setFromMatrixColumn(this._camera.matrix,1),Ef.setFromMatrixColumn(this._camera.matrix,2),Wl.multiplyScalar(this._focalOffset.x),jl.multiplyScalar(-this._focalOffset.y),Ef.multiplyScalar(this._focalOffset.z),vn.copy(Wl).add(jl).add(Ef),this._camera.position.add(vn),this._camera.updateMatrixWorld()),this._boundaryEnclosesCamera&&this._encloseToBoundary(this._camera.position.copy(this._target),vn.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse),1);const m=this._needsUpdate;return m&&!this._updatedLastTime?(this._hasRested=!1,this.dispatchEvent({type:"wake"}),this.dispatchEvent({type:"update"})):m?(this.dispatchEvent({type:"update"}),Si(e,this.restThreshold)&&Si(n,this.restThreshold)&&Si(i,this.restThreshold)&&Si(r.x,this.restThreshold)&&Si(r.y,this.restThreshold)&&Si(r.z,this.restThreshold)&&Si(l.x,this.restThreshold)&&Si(l.y,this.restThreshold)&&Si(l.z,this.restThreshold)&&Si(u,this.restThreshold)&&!this._hasRested&&(this._hasRested=!0,this.dispatchEvent({type:"rest"}))):!m&&this._updatedLastTime&&this.dispatchEvent({type:"sleep"}),this._lastDistance=this._spherical.radius,this._lastZoom=this._zoom,this._updatedLastTime=m,this._needsUpdate=!1,m}toJSON(){return JSON.stringify({enabled:this._enabled,minDistance:this.minDistance,maxDistance:jg(this.maxDistance),minZoom:this.minZoom,maxZoom:jg(this.maxZoom),minPolarAngle:this.minPolarAngle,maxPolarAngle:jg(this.maxPolarAngle),minAzimuthAngle:jg(this.minAzimuthAngle),maxAzimuthAngle:jg(this.maxAzimuthAngle),smoothTime:this.smoothTime,draggingSmoothTime:this.draggingSmoothTime,dollySpeed:this.dollySpeed,truckSpeed:this.truckSpeed,dollyToCursor:this.dollyToCursor,target:this._targetEnd.toArray(),position:vn.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),zoom:this._zoomEnd,focalOffset:this._focalOffsetEnd.toArray(),target0:this._target0.toArray(),position0:this._position0.toArray(),zoom0:this._zoom0,focalOffset0:this._focalOffset0.toArray()})}fromJSON(t,e=!1){const n=JSON.parse(t);this.enabled=n.enabled,this.minDistance=n.minDistance,this.maxDistance=Kg(n.maxDistance),this.minZoom=n.minZoom,this.maxZoom=Kg(n.maxZoom),this.minPolarAngle=n.minPolarAngle,this.maxPolarAngle=Kg(n.maxPolarAngle),this.minAzimuthAngle=Kg(n.minAzimuthAngle),this.maxAzimuthAngle=Kg(n.maxAzimuthAngle),this.smoothTime=n.smoothTime,this.draggingSmoothTime=n.draggingSmoothTime,this.dollySpeed=n.dollySpeed,this.truckSpeed=n.truckSpeed,this.dollyToCursor=n.dollyToCursor,this._target0.fromArray(n.target0),this._position0.fromArray(n.position0),this._zoom0=n.zoom0,this._focalOffset0.fromArray(n.focalOffset0),this.moveTo(n.target[0],n.target[1],n.target[2],e),Gr.setFromVector3(vn.fromArray(n.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)),this.rotateTo(Gr.theta,Gr.phi,e),this.dollyTo(Gr.radius,e),this.zoomTo(n.zoom,e),this.setFocalOffset(n.focalOffset[0],n.focalOffset[1],n.focalOffset[2],e),this._needsUpdate=!0}connect(t){if(this._domElement){console.warn("camera-controls is already connected.");return}t.setAttribute("data-camera-controls-version",w5),this._addAllEventListeners(t),this._getClientRect(this._elementRect)}disconnect(){this.cancel(),this._removeAllEventListeners(),this._domElement&&(this._domElement.removeAttribute("data-camera-controls-version"),this._domElement=void 0)}dispose(){this.removeAllEventListeners(),this.disconnect()}_getTargetDirection(t){return t.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse)}_getCameraDirection(t){return this._getTargetDirection(t).negate()}_findPointerById(t){return this._activePointers.find(e=>e.pointerId===t)}_findPointerByMouseButton(t){return this._activePointers.find(e=>e.mouseButton===t)}_disposePointer(t){this._activePointers.splice(this._activePointers.indexOf(t),1)}_encloseToBoundary(t,e,n){const i=e.lengthSq();if(i===0)return t;const r=$n.copy(e).add(t),u=this._boundary.clampPoint(r,Bd).sub(r),A=u.lengthSq();if(A===0)return t.add(e);if(A===i)return t;if(n===0)return t.add(e).add(u);{const d=1+n*A/e.dot(u);return t.add($n.copy(e).multiplyScalar(d)).add(u.multiplyScalar(1-n))}}_updateNearPlaneCorners(){if(vf(this._camera)){const t=this._camera,e=t.near,n=t.getEffectiveFOV()*Wg,i=Math.tan(n*.5)*e,r=i*t.aspect;this._nearPlaneCorners[0].set(-r,-i,0),this._nearPlaneCorners[1].set(r,-i,0),this._nearPlaneCorners[2].set(r,i,0),this._nearPlaneCorners[3].set(-r,i,0)}else if(ih(this._camera)){const t=this._camera,e=1/t.zoom,n=t.left*e,i=t.right*e,r=t.top*e,l=t.bottom*e;this._nearPlaneCorners[0].set(n,r,0),this._nearPlaneCorners[1].set(i,r,0),this._nearPlaneCorners[2].set(i,l,0),this._nearPlaneCorners[3].set(n,l,0)}}_truckInternal=(t,e,n,i)=>{let r,l;if(vf(this._camera)){const u=vn.copy(this._camera.position).sub(this._target),A=this._camera.getEffectiveFOV()*Wg,d=u.length()*Math.tan(A*.5);r=this.truckSpeed*t*d/this._elementRect.height,l=this.truckSpeed*e*d/this._elementRect.height}else if(ih(this._camera)){const u=this._camera;r=this.truckSpeed*t*(u.right-u.left)/u.zoom/this._elementRect.width,l=this.truckSpeed*e*(u.top-u.bottom)/u.zoom/this._elementRect.height}else return;i?(n?this.setFocalOffset(this._focalOffsetEnd.x+r,this._focalOffsetEnd.y,this._focalOffsetEnd.z,!0):this.truck(r,0,!0),this.forward(-l,!0)):n?this.setFocalOffset(this._focalOffsetEnd.x+r,this._focalOffsetEnd.y+l,this._focalOffsetEnd.z,!0):this.truck(r,l,!0)};_rotateInternal=(t,e)=>{const n=th*this.azimuthRotateSpeed*t/this._elementRect.height,i=th*this.polarRotateSpeed*e/this._elementRect.height;this.rotate(n,i,!0)};_dollyInternal=(t,e,n)=>{const i=Math.pow(.95,-t*this.dollySpeed),r=this._sphericalEnd.radius,l=this._sphericalEnd.radius*i,u=sl(l,this.minDistance,this.maxDistance),A=u-l;this.infinityDolly&&this.dollyToCursor?this._dollyToNoClamp(l,!0):this.infinityDolly&&!this.dollyToCursor?(this.dollyInFixed(A,!0),this._dollyToNoClamp(u,!0)):this._dollyToNoClamp(u,!0),this.dollyToCursor&&(this._changedDolly+=(this.infinityDolly?l:u)-r,this._dollyControlCoord.set(e,n)),this._lastDollyDirection=Math.sign(-t)};_zoomInternal=(t,e,n)=>{const i=Math.pow(.95,t*this.dollySpeed),r=this._zoom,l=this._zoom*i;this.zoomTo(l,!0),this.dollyToCursor&&(this._changedZoom+=l-r,this._dollyControlCoord.set(e,n))};_collisionTest(){let t=1/0;if(!(this.colliderMeshes.length>=1)||JC(this._camera,"_collisionTest"))return t;const n=this._getTargetDirection($g);KC.lookAt(EB,n,this._camera.up);for(let i=0;i<4;i++){const r=$n.copy(this._nearPlaneCorners[i]);r.applyMatrix4(KC);const l=Bd.addVectors(this._target,r);Qx.set(l,n),Qx.far=this._spherical.radius+1;const u=Qx.intersectObjects(this.colliderMeshes);u.length!==0&&u[0].distance<t&&(t=u[0].distance)}return t}_getClientRect(t){if(!this._domElement)return;const e=this._domElement.getBoundingClientRect();return t.x=e.left,t.y=e.top,this._viewport?(t.x+=this._viewport.x,t.y+=e.height-this._viewport.w-this._viewport.y,t.width=this._viewport.z,t.height=this._viewport.w):(t.width=e.width,t.height=e.height),t}_createOnRestPromise(t){return t?Promise.resolve():(this._hasRested=!1,this.dispatchEvent({type:"transitionstart"}),new Promise(e=>{const n=()=>{this.removeEventListener("rest",n),e()};this.addEventListener("rest",n)}))}_addAllEventListeners(t){}_removeAllEventListeners(){}get dampingFactor(){return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."),0}set dampingFactor(t){console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.")}get draggingDampingFactor(){return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."),0}set draggingDampingFactor(t){console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.")}static createBoundingSphere(t,e=new en.Sphere){const n=e,i=n.center;wd.makeEmpty(),t.traverseVisible(l=>{l.isMesh&&wd.expandByObject(l)}),wd.getCenter(i);let r=0;return t.traverseVisible(l=>{if(!l.isMesh)return;const u=l;if(!u.geometry)return;const A=u.geometry.clone();A.applyMatrix4(u.matrixWorld);const m=A.attributes.position;for(let g=0,y=m.count;g<y;g++)vn.fromBufferAttribute(m,g),r=Math.max(r,i.distanceToSquared(vn))}),n.radius=Math.sqrt(r),n}};const D5=et.forwardRef((s,t)=>{const{impl:e,camera:n,domElement:i,makeDefault:r,onControlStart:l,onControl:u,onControlEnd:A,onTransitionStart:d,onUpdate:m,onWake:g,onRest:y,onSleep:v,onStart:C,onEnd:I,onChange:S,regress:E,...B}=s,w=e??Q5;et.useMemo(()=>{const nt={Box3:kn,MathUtils:{clamp:_S.clamp},Matrix4:he,Quaternion:Ge,Raycaster:f0,Sphere:Bs,Spherical:$w,Vector2:Dt,Vector3:F,Vector4:We};w.install({THREE:nt}),GE({CameraControlsImpl:w})},[w]);const Q=ss(nt=>nt.camera),R=ss(nt=>nt.gl),D=ss(nt=>nt.invalidate),U=ss(nt=>nt.events),P=ss(nt=>nt.setEvents),z=ss(nt=>nt.set),L=ss(nt=>nt.get),k=ss(nt=>nt.performance),Y=n||Q,W=i||U.connected||R.domElement,K=et.useMemo(()=>new w(Y),[w,Y]);return FE((nt,H)=>{K.update(H)},-1),et.useEffect(()=>(K.connect(W),()=>{K.disconnect()}),[W,K]),et.useEffect(()=>{function nt(){D(),E&&k.regress()}const H=j=>{nt(),l?.(j),C?.(j)},tt=j=>{nt(),u?.(j),S?.(j)},it=j=>{A?.(j),I?.(j)},ot=j=>{nt(),d?.(j),S?.(j)},At=j=>{nt(),m?.(j),S?.(j)},V=j=>{nt(),g?.(j),S?.(j)},st=j=>{y?.(j)},xt=j=>{v?.(j)};return K.addEventListener("controlstart",H),K.addEventListener("control",tt),K.addEventListener("controlend",it),K.addEventListener("transitionstart",ot),K.addEventListener("update",At),K.addEventListener("wake",V),K.addEventListener("rest",st),K.addEventListener("sleep",xt),()=>{K.removeEventListener("controlstart",H),K.removeEventListener("control",tt),K.removeEventListener("controlend",it),K.removeEventListener("transitionstart",ot),K.removeEventListener("update",At),K.removeEventListener("wake",V),K.removeEventListener("rest",st),K.removeEventListener("sleep",xt)}},[K,D,P,E,k,l,u,A,d,m,g,y,v,S,C,I]),et.useEffect(()=>{if(r){const nt=L().controls;return z({controls:K}),()=>z({controls:nt})}},[r,K]),et.createElement("primitive",nu({ref:t,object:K},B))});function N3(s,t,...e){const n=et.useRef(null),i=ss(r=>r.scene);return et.useLayoutEffect(()=>{let r;if(s&&s!=null&&s.current&&t&&(n.current=r=new t(s.current,...e)),r)return r.traverse(l=>l.raycast=()=>null),i.add(r),()=>{n.current=void 0,i.remove(r),r.dispose==null||r.dispose()}},[i,t,s,...e]),FE(()=>{var r;(r=n.current)==null||r.update==null?void 0:r.update()}),n}const R5=new cp(-1,1,1,-1,0,1);class N5 extends Fe{constructor(){super(),this.setAttribute("position",new Ce([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new Ce([0,2,0,0,2,0],2))}}const U5=new N5;class U3{constructor(t){this._mesh=new oe(U5,t)}dispose(){this._mesh.geometry.dispose()}render(t){t.render(this._mesh,R5)}get material(){return this._mesh.material}set material(t){this._mesh.material=t}}var Hs=Uint8Array,Im=Uint16Array,L5=Int32Array,L3=new Hs([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),z3=new Hs([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),z5=new Hs([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),O3=function(s,t){for(var e=new Im(31),n=0;n<31;++n)e[n]=t+=1<<s[n-1];for(var i=new L5(e[30]),n=1;n<30;++n)for(var r=e[n];r<e[n+1];++r)i[r]=r-e[n]<<5|n;return{b:e,r:i}},F3=O3(L3,2),P3=F3.b,O5=F3.r;P3[28]=258,O5[258]=28;var F5=O3(z3,0),P5=F5.b,G3=new Im(32768);for(var Mi=0;Mi<32768;++Mi){var eh=(Mi&43690)>>1|(Mi&21845)<<1;eh=(eh&52428)>>2|(eh&13107)<<2,eh=(eh&61680)>>4|(eh&3855)<<4,G3[Mi]=((eh&65280)>>8|(eh&255)<<8)>>1}var Bm=function(s,t,e){for(var n=s.length,i=0,r=new Im(t);i<n;++i)s[i]&&++r[s[i]-1];var l=new Im(t);for(i=1;i<t;++i)l[i]=l[i-1]+r[i-1]<<1;var u;{u=new Im(1<<t);var A=15-t;for(i=0;i<n;++i)if(s[i])for(var d=i<<4|s[i],m=t-s[i],g=l[s[i]-1]++<<m,y=g|(1<<m)-1;g<=y;++g)u[G3[g]>>A]=d}return u},g0=new Hs(288);for(var Mi=0;Mi<144;++Mi)g0[Mi]=8;for(var Mi=144;Mi<256;++Mi)g0[Mi]=9;for(var Mi=256;Mi<280;++Mi)g0[Mi]=7;for(var Mi=280;Mi<288;++Mi)g0[Mi]=8;var k3=new Hs(32);for(var Mi=0;Mi<32;++Mi)k3[Mi]=5;var G5=Bm(g0,9),k5=Bm(k3,5),$C=function(s){for(var t=s[0],e=1;e<s.length;++e)s[e]>t&&(t=s[e]);return t},nl=function(s,t,e){var n=t/8|0;return(s[n]|s[n+1]<<8)>>(t&7)&e},tb=function(s,t){var e=t/8|0;return(s[e]|s[e+1]<<8|s[e+2]<<16)>>(t&7)},H3=function(s){return(s+7)/8|0},Xd=function(s,t,e){return(t==null||t<0)&&(t=0),(e==null||e>s.length)&&(e=s.length),new Hs(s.subarray(t,e))},H5=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],ja=function(s,t,e){var n=new Error(t||H5[s]);if(n.code=s,Error.captureStackTrace&&Error.captureStackTrace(n,ja),!e)throw n;return n},V3=function(s,t,e,n){var i=s.length,r=n?n.length:0;if(!i||t.f&&!t.l)return e||new Hs(0);var l=!e,u=l||t.i!=2,A=t.i;l&&(e=new Hs(i*3));var d=function(Ie){var He=e.length;if(Ie>He){var be=new Hs(Math.max(He*2,Ie));be.set(e),e=be}},m=t.f||0,g=t.p||0,y=t.b||0,v=t.l,C=t.d,I=t.m,S=t.n,E=i*8;do{if(!v){m=nl(s,g,1);var B=nl(s,g+1,3);if(g+=3,B)if(B==1)v=G5,C=k5,I=9,S=5;else if(B==2){var D=nl(s,g,31)+257,U=nl(s,g+10,15)+4,P=D+nl(s,g+5,31)+1;g+=14;for(var z=new Hs(P),L=new Hs(19),k=0;k<U;++k)L[z5[k]]=nl(s,g+k*3,7);g+=U*3;for(var Y=$C(L),W=(1<<Y)-1,K=Bm(L,Y),k=0;k<P;){var nt=K[nl(s,g,W)];g+=nt&15;var w=nt>>4;if(w<16)z[k++]=w;else{var H=0,tt=0;for(w==16?(tt=3+nl(s,g,3),g+=2,H=z[k-1]):w==17?(tt=3+nl(s,g,7),g+=3):w==18&&(tt=11+nl(s,g,127),g+=7);tt--;)z[k++]=H}}var it=z.subarray(0,D),ot=z.subarray(D);I=$C(it),S=$C(ot),v=Bm(it,I),C=Bm(ot,S)}else ja(1);else{var w=H3(g)+4,Q=s[w-4]|s[w-3]<<8,R=w+Q;if(R>i){A&&ja(0);break}u&&d(y+Q),e.set(s.subarray(w,R),y),t.b=y+=Q,t.p=g=R*8,t.f=m;continue}if(g>E){A&&ja(0);break}}u&&d(y+131072);for(var At=(1<<I)-1,V=(1<<S)-1,st=g;;st=g){var H=v[tb(s,g)&At],xt=H>>4;if(g+=H&15,g>E){A&&ja(0);break}if(H||ja(2),xt<256)e[y++]=xt;else if(xt==256){st=g,v=null;break}else{var j=xt-254;if(xt>264){var k=xt-257,Rt=L3[k];j=nl(s,g,(1<<Rt)-1)+P3[k],g+=Rt}var dt=C[tb(s,g)&V],pt=dt>>4;dt||ja(3),g+=dt&15;var ot=P5[pt];if(pt>3){var Rt=z3[pt];ot+=tb(s,g)&(1<<Rt)-1,g+=Rt}if(g>E){A&&ja(0);break}u&&d(y+131072);var qt=y+j;if(y<ot){var Wt=r-ot,ce=Math.min(ot,qt);for(Wt+y<0&&ja(3);y<ce;++y)e[y]=n[Wt+y]}for(;y<qt;++y)e[y]=e[y-ot]}}t.l=v,t.p=st,t.b=y,t.f=m,v&&(m=1,t.m=I,t.d=C,t.n=S)}while(!m);return y!=e.length&&l?Xd(e,0,y):e.subarray(0,y)},V5=new Hs(0),$l=function(s,t){return s[t]|s[t+1]<<8},ll=function(s,t){return(s[t]|s[t+1]<<8|s[t+2]<<16|s[t+3]<<24)>>>0},eb=function(s,t){return ll(s,t)+ll(s,t+4)*4294967296},Y5=function(s){(s[0]!=31||s[1]!=139||s[2]!=8)&&ja(6,"invalid gzip data");var t=s[3],e=10;t&4&&(e+=(s[10]|s[11]<<8)+2);for(var n=(t>>3&1)+(t>>4&1);n>0;n-=!s[e++]);return e+(t&2)},nb=(function(){function s(t,e){typeof t=="function"&&(e=t,t={}),this.ondata=e;var n=t&&t.dictionary&&t.dictionary.subarray(-32768);this.s={i:0,b:n?n.length:0},this.o=new Hs(32768),this.p=new Hs(0),n&&this.o.set(n)}return s.prototype.e=function(t){if(this.ondata||ja(5),this.d&&ja(4),!this.p.length)this.p=t;else if(t.length){var e=new Hs(this.p.length+t.length);e.set(this.p),e.set(t,this.p.length),this.p=e}},s.prototype.c=function(t){this.s.i=+(this.d=t||!1);var e=this.s.b,n=V3(this.p,this.s,this.o);this.ondata(Xd(n,e,this.s.b),this.d),this.o=Xd(n,this.s.b-32768),this.s.b=this.o.length,this.p=Xd(this.p,this.s.p/8|0),this.s.p&=7},s.prototype.push=function(t,e){this.e(t),this.c(e)},s})();function q5(s,t){return V3(s,{i:2},t&&t.out,t&&t.dictionary)}var X5=(function(){function s(t,e){this.v=1,this.r=0,nb.call(this,t,e)}return s.prototype.push=function(t,e){if(nb.prototype.e.call(this,t),this.r+=t.length,this.v){var n=this.p.subarray(this.v-1),i=n.length>3?Y5(n):4;if(i>n.length){if(!e)return}else this.v>1&&this.onmember&&this.onmember(this.r-n.length);this.p=n.subarray(i),this.v=0}nb.prototype.c.call(this,e),this.s.f&&!this.s.l&&!e&&(this.v=H3(this.s.p)+9,this.s={i:0},this.o=new Hs(0),this.push(new Hs(0),e))},s})(),Yb=typeof TextDecoder<"u"&&new TextDecoder,J5=0;try{Yb.decode(V5,{stream:!0}),J5=1}catch{}var Z5=function(s){for(var t="",e=0;;){var n=s[e++],i=(n>127)+(n>223)+(n>239);if(e+i>s.length)return{s:t,r:Xd(s,e-1)};i?i==3?(n=((n&15)<<18|(s[e++]&63)<<12|(s[e++]&63)<<6|s[e++]&63)-65536,t+=String.fromCharCode(55296|n>>10,56320|n&1023)):i&1?t+=String.fromCharCode((n&31)<<6|s[e++]&63):t+=String.fromCharCode((n&15)<<12|(s[e++]&63)<<6|s[e++]&63):t+=String.fromCharCode(n)}};function W5(s,t){if(t){for(var e="",n=0;n<s.length;n+=16384)e+=String.fromCharCode.apply(null,s.subarray(n,n+16384));return e}else{if(Yb)return Yb.decode(s);var i=Z5(s),r=i.s,e=i.r;return e.length&&ja(8),r}}var j5=function(s,t){return t+30+$l(s,t+26)+$l(s,t+28)},K5=function(s,t,e){var n=$l(s,t+28),i=W5(s.subarray(t+46,t+46+n),!($l(s,t+8)&2048)),r=t+46+n,l=ll(s,t+20),u=e&&l==4294967295?$5(s,r):[l,ll(s,t+24),ll(s,t+42)],A=u[0],d=u[1],m=u[2];return[$l(s,t+10),A,d,i,r+$l(s,t+30)+$l(s,t+32),m]},$5=function(s,t){for(;$l(s,t)!=1;t+=4+$l(s,t+2));return[eb(s,t+12),eb(s,t+4),eb(s,t+20)]};function tP(s,t){for(var e={},n=s.length-22;ll(s,n)!=101010256;--n)(!n||s.length-n>65558)&&ja(13);var i=$l(s,n+8);if(!i)return{};var r=ll(s,n+16),l=r==4294967295||i==65535;if(l){var u=ll(s,n-12);l=ll(s,u)==101075792,l&&(i=ll(s,u+32),r=ll(s,u+48))}for(var A=t&&t.filter,d=0;d<i;++d){var m=K5(s,r,l),g=m[0],y=m[1],v=m[2],C=m[3],I=m[4],S=m[5],E=j5(s,S);r=I,(!A||A({name:C,size:y,originalSize:v,compression:g}))&&(g?g==8?e[C]=q5(s.subarray(E,E+y),{out:new Hs(v)}):ja(14,"unknown compression type "+g):e[C]=Xd(s,E,E+y))}return e}let tu;const Y3=typeof TextDecoder<"u"?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}};typeof TextDecoder<"u"&&Y3.decode();let hm=null;function eP(){return(hm===null||hm.byteLength===0)&&(hm=new Uint8Array(tu.memory.buffer)),hm}function nP(s,t){return s=s>>>0,Y3.decode(eP().subarray(s,s+t))}function iP(s,t,e,n,i,r,l,u,A,d,m,g,y){return tu.raycast_splats(s,t,e,n,i,r,l,u,A,d,m,g,y)}async function sP(s,t){if(typeof Response=="function"&&s instanceof Response){if(typeof WebAssembly.instantiateStreaming=="function")try{return await WebAssembly.instantiateStreaming(s,t)}catch(n){if(s.headers.get("Content-Type")!="application/wasm")console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",n);else throw n}const e=await s.arrayBuffer();return await WebAssembly.instantiate(e,t)}else{const e=await WebAssembly.instantiate(s,t);return e instanceof WebAssembly.Instance?{instance:e,module:s}:e}}function aP(){const s={};return s.wbg={},s.wbg.__wbg_buffer_609cc3eee51ed158=function(t){return t.buffer},s.wbg.__wbg_length_3b4f022188ae8db6=function(t){return t.length},s.wbg.__wbg_length_6ca527665d89694d=function(t){return t.length},s.wbg.__wbg_length_8cfd2c6409af88ad=function(t){return t.length},s.wbg.__wbg_new_9fee97a409b32b68=function(t){return new Uint16Array(t)},s.wbg.__wbg_new_e3b321dcfef89fc7=function(t){return new Uint32Array(t)},s.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354=function(t,e,n){return new Float32Array(t,e>>>0,n>>>0)},s.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212=function(t,e,n){return new Uint32Array(t,e>>>0,n>>>0)},s.wbg.__wbg_newwithlength_5a5efe313cfd59f1=function(t){return new Float32Array(t>>>0)},s.wbg.__wbg_set_10bad9bee0e9c58b=function(t,e,n){t.set(e,n>>>0)},s.wbg.__wbg_set_d23661d19148b229=function(t,e,n){t.set(e,n>>>0)},s.wbg.__wbg_set_f4f1f0daa30696fc=function(t,e,n){t.set(e,n>>>0)},s.wbg.__wbg_subarray_3aaeec89bb2544f0=function(t,e,n){return t.subarray(e>>>0,n>>>0)},s.wbg.__wbg_subarray_769e1e0f81bb259b=function(t,e,n){return t.subarray(e>>>0,n>>>0)},s.wbg.__wbindgen_init_externref_table=function(){const t=tu.__wbindgen_export_0,e=t.grow(4);t.set(0,void 0),t.set(e+0,void 0),t.set(e+1,null),t.set(e+2,!0),t.set(e+3,!1)},s.wbg.__wbindgen_memory=function(){return tu.memory},s.wbg.__wbindgen_throw=function(t,e){throw new Error(nP(t,e))},s}function rP(s,t){return tu=s.exports,q3.__wbindgen_wasm_module=t,hm=null,tu.__wbindgen_start(),tu}async function q3(s){if(tu!==void 0)return tu;typeof s<"u"&&(Object.getPrototypeOf(s)===Object.prototype?{module_or_path:s}=s:console.warn("using deprecated parameters for the initialization function; pass a single object instead")),typeof s>"u"&&(s=new URL("data:application/wasm;base64,AGFzbQEAAAABzAEeYAJ/fwF/YAJ/fwBgA39/fwF/YAF/AX9gA39/fwBgAX8AYAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAFvAW9gA29vfwBgAW8Bf2AAAX9gBH9/f38AYAAAYAR/f39/AX9gA39vbwF/YAF/AW9gAAFvYAF9AX1gBn9/f39/fwBgDX19fX19fX19f29/fX0Bb2AGf39/f39/AX9gBX9/fH9/AGAEf3x/fwBgBX9/fX9/AGAEf31/fwBgBX9/fn9/AGAEf35/fwBgAn19AX0C8gQRA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZxpfX3diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwAKA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAALA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAcDd2JnGl9fd2JnX25ld19lM2IzMjFkY2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAoDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAsDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoX2U2YjdlNjlhY2Q0YzczNTQABwN3YmcaX193Ymdfc2V0XzEwYmFkOWJlZTBlOWM1OGIACgN3YmcdX193YmdfbGVuZ3RoXzNiNGYwMjIxODhhZThkYjYACwN3YmcfX193Ymdfc3ViYXJyYXlfNzY5ZTFlMGY4MWJiMjU5YgAHA3diZx9fX3diZ19zdWJhcnJheV8zYWFlZWM4OWJiMjU0NGYwAAcDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfNWE1ZWZlMzEzY2ZkNTlmMQARA3diZxBfX3diaW5kZ2VuX3Rocm93AAEDd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABIDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGUADgNhYAMAAQIIBQQCEwEMAAEBAgAAAQwBBAYFBQQAAQYFFAENBAAGBQQEAQQOAgECAQAIBAAVARYG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ACIDKAIEQXhxRgRAIAMhAgwBCyABQRkgAkEBdmtBACACQR9HG3QhBQNAIAMgBUEddkEEcWpBEGoiBCgCACICRQ0CIAVBAXQhBSACIQMgAigCBEF4cSABRw0ACwsgAigCCCIBIAA2AgwgAiAANgIIIABBADYCGCAAIAI2AgwgACABNgIIDwsgBCAANgIAIAAgAzYCGCAAIAA2AgwgACAANgIIC/MCAQR/IwBBMGsiACQAAkACQEGQksAAKAIARQRAQaiSwAAoAgAhAUGoksAAQQA2AgAgAUUNASAAQRhqIAERBQAgAEEQaiICIABBJGopAgA3AwAgACAAKQIcNwMIIAAoAhghAUGQksAAKAIAIgMNAgJAIANFDQBBlJLAACgCACICRQ0AQZiSwAAoAgAgAkECdBBlC0GUksAAIAE2AgBBkJLAAEEBNgIAQZiSwAAgACkDCDcCAEGgksAAIABBEGopAwA3AgALIABBMGokAEGUksAADwsgAEEANgIoIABBATYCHCAAQaCHwAA2AhggAEIENwIgIABBGGpBiIjAABBDAAsgAEEoaiACKQMANwIAIAAgACkDCDcCICAAIAE2AhwgAEEBNgIYAkAgAEEYaiIBKAIARQ0AIAEoAgQiAkUNACABKAIIIAJBAnQQZQsgAEEANgIoIABBATYCHCAAQaiIwAA2AhggAEIENwIgIAFBsIjAABBDAAuoAgIDfwF+IwBBQGoiAiQAIAEoAgBBgICAgHhGBEAgASgCDCEDIAJBJGoiBEEANgIAIAJCgICAgBA3AhwgAkEwaiADKAIAIgNBCGopAgA3AwAgAkE4aiADQRBqKQIANwMAIAIgAykCADcDKCACQRxqQcCIwAAgAkEoahAYGiACQRhqIAQoAgAiAzYCACACIAIpAhwiBTcDECABQQhqIAM2AgAgASAFNwIACyABKQIAIQUgAUKAgICAEDcCACACQQhqIgMgAUEIaiIBKAIANgIAIAFBADYCAEGxk8AALQAAGiACIAU3AwBBDEEEEF0iAUUEQEEEQQwQbQALIAEgAikDADcCACABQQhqIAMoAgA2AgAgAEHgisAANgIEIAAgATYCACACQUBrJAAL0gECBH8BfiMAQSBrIgMkACABIAEgAmoiAksEQEEAQQAQUgALQQggACgCACIEQQF0IgEgAiABIAJLGyICIAJBCEkb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QQRqrUKAgICA4ACENwMoIAEgAa1CgICAgOAAhDcDICABIAFBIGo2AhAgAUEIakHIj8AAEEMAC2kCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQfyNwAA2AgggA0ICNwIUIANCgICAgOAAIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhBDAAtpAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0H4kcAANgIIIANCAjcCFCADQoCAgIDgACIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQQwALZgAjAEEwayIAJABBsJPAAC0AAARAIABBAjYCDCAAQbCKwAA2AgggAEIBNwIUIAAgATYCLCAAIABBLGqtQoCAgIDgAIQ3AyAgACAAQSBqNgIQIABBCGpB0IrAABBDAAsgAEEwaiQAC5QBAgN/AW8jAEEgayIDJAAgAyAAKAIAEHAiBDYCACADIAI2AgQgAiAERwRAIANBADYCCCADIANBBGogA0EIahBAAAsQWyIEEFMiBSUBEAUhBhAbIgIgBiYBIAVBhAFPBEAgBRAtCyACIAAoAgAgAUECdhBkIAJBhAFPBEAgAhAtCyAEQYQBTwRAIAQQLQsgA0EgaiQAC08BAX8jAEEwayIAJAAgAEEBNgIMIABBwI3AADYCCCAAQgE3AhQgACAAQS9qrUKAgICAoAWENwMgIAAgAEEgajYCECAAQQhqQcSBwAAQQwALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhAlIAAoAgghAwsgACgCBCADaiABIAIQHxogACACIANqNgIIQQALTQECf0Gxk8AALQAAGiABKAIEIQIgASgCACEDQQhBBBBdIgFFBEBBBEEIEG0ACyABIAI2AgQgASADNgIAIABB8IrAADYCBCAAIAE2AgALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhApIAAoAgghAwsgACgCBCADaiABIAIQHxogACACIANqNgIIQQALQQEBfyMAQSBrIgIkACACQQA2AhAgAkEBNgIEIAJCBDcCCCACQS42AhwgAiAANgIYIAIgAkEYajYCACACIAEQQwALswIBA38gACgCACECIAEoAhwiAEEQcUUE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ZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkTGF6eSBpbnN0YW5jZSBoYXMgcHJldmlvdXNseSBiZWVuIHBvaXNvbmVkdgMQACoAAAAvVXNlcnMvZG1hcmNvcy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL29uY2VfY2VsbC0xLjIxLjMvc3JjL2xpYi5ycwCoAxAAXwAAAAgDAAAZAAAAcmVlbnRyYW50IGluaXQAABgEEAAOAAAAqAMQAF8AAAB6AgAADQAAABYAAAAMAAAABAAAABcAAAAYAAAAGQAAAC9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjYvc3JjL2RsbWFsbG9jLnJzYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPj0gc2l6ZSArIG1pbl9vdmVyaGVhZABYBBAAKQAAAKgEAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPD0gc2l6ZSArIG1heF9vdmVyaGVhZAAAWAQQACkAAACuBAAADQAAAEFjY2Vzc0Vycm9ybWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAAAAAsFEAAVAAAAIAUQAA0AAABzdGQvc3JjL2FsbG9jLnJzQAUQABAAAABjAQAACQAAABYAAAAMAAAABAAAABoAAAAAAAAACAAAAAQAAAAbAAAAAAAAAAgAAAAEAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAQAAAABAAAACEAAAAiAAAAIwAAACQAAABFcnJvcgAAACUAAAAMAAAABAAAACYAAAAnAAAAKAAAAGNhcGFjaXR5IG92ZXJmbG93AAAA2AUQABEAAABhbGxvYy9zcmMvcmF3X3ZlYy5yc/QFEAAUAAAAGAAAAAUAQaCMwAAL8AUBAAAAKQAAAGEgZm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAfgYQABAAAAB+AgAADgAAAEJvcnJvd011dEVycm9yYWxyZWFkeSBib3Jyb3dlZDogrgYQABIAAABpbmRleCBvdXQgb2YgYm91bmRzOiB0aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIAAAyAYQACAAAADoBhAAEgAAAD09IT1tYXRjaGVzYXNzZXJ0aW9uIGBsZWZ0ICByaWdodGAgZmFpbGVkCiAgbGVmdDogCiByaWdodDogABcHEAAQAAAAJwcQABcAAAA+BxAACQAAACByaWdodGAgZmFpbGVkOiAKICBsZWZ0OiAAAAAXBxAAEAAAAGAHEAAQAAAAcAcQAAkAAAA+BxAACQAAADogAAABAAAAAAAAAJwHEAACAAAAfSB9Y29yZS9zcmMvZm10L251bS5ycwAAswcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTlyYW5nZSBzdGFydCBpbmRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggAACiCBAAEgAAALQIEAAiAAAAcmFuZ2UgZW5kIGluZGV4IOgIEAAQAAAAtAgQACIAAAAAAAA/AAAAvwBBqJLAAAsBFABwCXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS44My4wICg5MGIzNWE2MjMgMjAyNC0xMS0yNikGd2FscnVzBjAuMjMuMwx3YXNtLWJpbmRnZW4HMC4yLjEwMABJD3RhcmdldF9mZWF0dXJlcwQrD211dGFibGUtZ2xvYmFscysIc2lnbi1leHQrD3JlZmVyZW5jZS10eXBlcysKbXVsdGl2YWx1ZQ==",import.meta.url));const t=aP();(typeof s=="string"||typeof Request=="function"&&s instanceof Request||typeof URL=="function"&&s instanceof URL)&&(s=fetch(s));const{instance:e,module:n}=await sP(await s,t);return rP(e,n)}const iu=-12,su=9,oP=-30,ib=Math.exp(oP),lP=11,cP=11,vi=1<<lP,zf=1<<cP,uP=1;function hP(s){return s==="bool"||s==="bvec2"||s==="bvec3"||s==="bvec4"}function Of(s){return s==="int"||s==="ivec2"||s==="ivec3"||s==="ivec4"}function Ff(s){return s==="uint"||s==="uvec2"||s==="uvec3"||s==="uvec4"}function fP(s){return s==="float"||s==="vec2"||s==="vec3"||s==="vec4"}function AP(s){return s==="mat2"||s==="mat2x2"||s==="mat2x3"||s==="mat2x4"||s==="mat3"||s==="mat3x2"||s==="mat3x3"||s==="mat3x4"||s==="mat4"||s==="mat4x2"||s==="mat4x3"||s==="mat4x4"}function $m(s){return fP(s)||AP(s)}function Td(s){return s==="mat2"||s==="mat2x2"}function Qd(s){return s==="mat3"||s==="mat3x3"}function Dd(s){return s==="mat4"||s==="mat4x4"}function dP(s){switch(s){case"vec2":return"float";case"vec3":return"float";case"vec4":return"float";case"ivec2":return"int";case"ivec3":return"int";case"ivec4":return"int";case"uvec2":return"uint";case"uvec3":return"uint";case"uvec4":return"uint";default:throw new Error(`Invalid vector type: ${s}`)}}function pP(s){switch(s){case"vec2":case"ivec2":case"uvec2":return 2;case"vec3":case"ivec3":case"uvec3":return 3;case"vec4":case"ivec4":case"uvec4":return 4;default:throw new Error(`Invalid vector type: ${s}`)}}function Ss(s){return Math.trunc(s).toString()}function Is(s){return`${Math.max(0,Math.trunc(s)).toString()}u`}function ti(s){return s===Number.POSITIVE_INFINITY?"INFINITY":s===Number.NEGATIVE_INFINITY?"-INFINITY":Number.isInteger(s)?s.toFixed(1):s.toString()}function Kc(s){return s instanceof Pf?s.type:s.dynoOut().type}class Pf{constructor(t){this.__isDynoValue=!0,this.type=t}}class Er extends Pf{constructor(t,e){super(t.outTypes[e]),this.dyno=t,this.key=e}}class rv extends Pf{constructor(t,e){super(t),this.literal=e}getLiteral(){return this.literal}}class gP extends rv{constructor(t,e){super(t,""),this.value=e}getLiteral(){const{type:t,value:e}=this;switch(t){case"bool":return e?"true":"false";case"uint":return Is(e);case"int":return Ss(e);case"float":return ti(e);case"bvec2":{const n=e;return`bvec2(${n[0]}, ${n[1]})`}case"uvec2":{if(e instanceof Dt)return`uvec2(${Is(e.x)}, ${Is(e.y)})`;const n=e;return`uvec2(${Is(n[0])}, ${Is(n[1])})`}case"ivec2":{if(e instanceof Dt)return`ivec2(${Ss(e.x)}, ${Ss(e.y)})`;const n=e;return`ivec2(${Ss(n[0])}, ${Ss(n[1])})`}case"vec2":{if(e instanceof Dt)return`vec2(${ti(e.x)}, ${ti(e.y)})`;const n=e;return`vec2(${ti(n[0])}, ${ti(n[1])})`}case"bvec3":{const n=e;return`bvec3(${n[0]}, ${n[1]}, ${n[2]})`}case"uvec3":{if(e instanceof F)return`uvec3(${Is(e.x)}, ${Is(e.y)}, ${Is(e.z)})`;const n=e;return`uvec3(${Is(n[0])}, ${Is(n[1])}, ${Is(n[2])})`}case"ivec3":{if(e instanceof F)return`ivec3(${Ss(e.x)}, ${Ss(e.y)}, ${Ss(e.z)})`;const n=e;return`ivec3(${Ss(n[0])}, ${Ss(n[1])}, ${Ss(n[2])})`}case"vec3":{if(e instanceof F)return`vec3(${ti(e.x)}, ${ti(e.y)}, ${ti(e.z)})`;const n=e;return`vec3(${ti(n[0])}, ${ti(n[1])}, ${ti(n[2])})`}case"bvec4":{const n=e;return`bvec4(${n[0]}, ${n[1]}, ${n[2]}, ${n[3]})`}case"uvec4":{if(e instanceof We)return`uvec4(${Is(e.x)}, ${Is(e.y)}, ${Is(e.z)}, ${Is(e.w)})`;const n=e;return`uvec4(${Is(n[0])}, ${Is(n[1])}, ${Is(n[2])}, ${Is(n[3])})`}case"ivec4":{if(e instanceof We)return`ivec4(${Ss(e.x)}, ${Ss(e.y)}, ${Ss(e.z)}, ${Ss(e.w)})`;const n=e;return`ivec4(${Ss(n[0])}, ${Ss(n[1])}, ${Ss(n[2])}, ${Ss(n[3])})`}case"vec4":{if(e instanceof We)return`vec4(${ti(e.x)}, ${ti(e.y)}, ${ti(e.z)}, ${ti(e.w)})`;if(e instanceof Ge)return`vec4(${ti(e.x)}, ${ti(e.y)}, ${ti(e.z)}, ${ti(e.w)})`;const n=e;return`vec4(${ti(n[0])}, ${ti(n[1])}, ${ti(n[2])}, ${ti(n[3])})`}case"mat2":case"mat2x2":{const n=e,i=n instanceof A0?n.elements:e,r=new Array(4).fill(0).map((l,u)=>ti(i[u]));return`${t}(${r.join(", ")})`}case"mat2x3":{const n=e,i=new Array(6).fill(0).map((r,l)=>ti(n[l]));return`${t}(${i.join(", ")})`}case"mat2x4":{const n=e,i=new Array(8).fill(0).map((r,l)=>ti(n[l]));return`${t}(${i.join(", ")})`}case"mat3":case"mat3x3":{const n=e,i=n instanceof Ze?n.elements:e,r=new Array(9).fill(0).map((l,u)=>ti(i[u]));return`${t}(${r.join(", ")})`}case"mat3x2":{const n=e,i=new Array(6).fill(0).map((r,l)=>ti(n[l]));return`${t}(${i.join(", ")})`}case"mat3x4":{const n=e,i=new Array(12).fill(0).map((r,l)=>ti(n[l]));return`${t}(${i.join(", ")})`}case"mat4":case"mat4x4":{const n=e,i=n instanceof he?n.elements:e,r=new Array(16).fill(0).map((l,u)=>ti(i[u]));return`${t}(${r.join(", ")})`}case"mat4x2":{const n=e,i=new Array(8).fill(0).map((r,l)=>ti(n[l]));return`${t}(${i.join(", ")})`}case"mat4x3":{const n=e,i=new Array(12).fill(0).map((r,l)=>ti(n[l]));return`${t}(${i.join(", ")})`}default:throw new Error(`Type not implemented: ${String(t)}`)}}}function Mm(s,t){return new gP(s,t)}function Dx(s){const t=String(s);if(hP(s))return`${t}(false)`;if($m(s))return`${t}(0.0)`;if(Of(s))return`${t}(0)`;if(Ff(s))return`${t}(0u)`;throw new Error(`Type not implemented: ${t}`)}const IB="    ";class mP{constructor({indent:t}={}){this.globals=new Set,this.statements=[],this.uniforms={},this.declares=new Set,this.updaters=[],this.sequence=0,this.indent=IB,this.indent=t??IB}nextSequence(){return this.sequence++}}class Vs{constructor({inTypes:t,outTypes:e,inputs:n,update:i,globals:r,statements:l,generate:u}){this.inTypes=t??{},this.outTypes=e??{},this.inputs=n??{},this.update=i,this.globals=r,this.statements=l,this.generate=u??(({inputs:A,outputs:d,compile:m})=>{var g,y;return{globals:(g=this.globals)==null?void 0:g.call(this,{inputs:A,outputs:d,compile:m}),statements:(y=this.statements)==null?void 0:y.call(this,{inputs:A,outputs:d,compile:m})}})}get outputs(){const t={};for(const e in this.outTypes)t[e]=new Er(this,e);return t}apply(t){return Object.assign(this.inputs,t),this.outputs}compile({inputs:t,outputs:e,compile:n}){const i=[`// ${this.constructor.name}(${Object.values(t).join(", ")}) => (${Object.values(e).join(", ")})`],r=[];for(const d in e){const m=e[d];m&&!n.declares.has(m)&&(n.declares.add(m),r.push(d))}const{globals:l,statements:u,uniforms:A}=this.generate({inputs:t,outputs:e,compile:n});for(const d of l??[])n.globals.add(d);for(const d in A)n.uniforms[d]=A[d];this.update&&n.updaters.push(this.update);for(const d of r){const m=e[d];m&&(n.uniforms[m]||i.push(`${X3(m,this.outTypes[d])};`))}return u?.length&&(i.push("{"),i.push(...u.map(d=>n.indent+d)),i.push("}")),i}}class yP extends Vs{constructor({inTypes:t,outTypes:e,inputs:n,update:i,globals:r,construct:l}){super({inTypes:t,outTypes:e,inputs:n,update:i,globals:r,generate:u=>this.generateBlock(u)}),this.construct=l}generateBlock({inputs:t,outputs:e,compile:n}){var i,r;const l={},u={};for(const S in t)t[S]!=null&&(l[S]=new rv(this.inTypes[S],t[S]));for(const S in e)e[S]!=null&&(u[S]=new Pf(this.outTypes[S]));const A={roots:[]},d=this.construct(l,u,A);for(const S of((i=this.globals)==null?void 0:i.call(this,{inputs:t,outputs:e,compile:n}))??[])n.globals.add(S);const m=[],g=new Map;function y(S,E,B){let w=g.get(S);if(!w){w={sequence:n.nextSequence(),outNames:new Map,newOuts:new Set},g.set(S,w);for(const Q in S.inputs){let R=S.inputs[Q];for(;R;){if(R instanceof Pf){R instanceof Er&&y(R.dyno,R.key);break}R=R.dynoOut()}}m.push(S)}E&&(B||w.newOuts.add(E),w.outNames.set(E,B??`${E}_${w.sequence}`))}for(const S of A.roots)y(S);for(const S in u){let E=d?.[S]??u[S];for(;E;){if(E instanceof Pf){E instanceof Er&&y(E.dyno,E.key,e[S]);break}E=E.dynoOut()}u[S]=E}const v=[];for(const S of m){const E={},B={};for(const R in S.inputs){let D=S.inputs[R];for(;D;){if(D instanceof Pf){if(D instanceof rv)E[R]=D.getLiteral();else if(D instanceof Er){const U=(r=g.get(D.dyno))==null?void 0:r.outNames.get(D.key);if(!U)throw new Error(`Source not found for ${D.dyno.constructor.name}.${D.key}`);E[R]=U}break}D=D.dynoOut()}}const w=g.get(S)??{outNames:new Map};for(const[R,D]of w.outNames.entries())B[R]=D;const Q=S.compile({inputs:E,outputs:B,compile:n});v.push(Q)}const C=[];for(const S in e)u[S]instanceof rv&&C.push(`${e[S]} = ${u[S].getLiteral()};`);return C.length>0&&v.push(C),{statements:v.flatMap((S,E)=>E===0?S:["",...S])}}}function au(s,t,e,{update:n,globals:i}={}){return new yP({inTypes:s,outTypes:t,construct:e,update:n,globals:i})}function kE({inTypes:s,outTypes:t,inputs:e,update:n,globals:i,statements:r,generate:l}){return new Vs({inTypes:s,outTypes:t,inputs:e,update:n,globals:i,statements:r,generate:l})}function X3(s,t,e){const n=typeof t=="string"?t:t.type;if(!n)throw new Error(`Invalid DynoType: ${String(t)}`);return`${n} ${s}${e!=null?`[${e}]`:""}`}function lc(s){var t;let e=!1;const n=s.split(`
`).map(l=>{const u=l.trimEnd();return e?u:u.length>0?(e=!0,u):null}).filter(l=>l!=null);for(;n.length>0&&n[n.length-1].length===0;)n.pop();if(n.length===0)return[];const i=(t=n[0].match(/^\s*/))==null?void 0:t[0];if(!i)return n;const r=new RegExp(`^${i}`);return n.map(l=>l.replace(r,""))}function Cr(s){return lc(s).join(`
`)}class HE extends Vs{constructor({a:t,outKey:e,outTypeFunc:n}){const i={a:Kc(t)},r=n(Kc(t)),l={[e]:r};super({inTypes:i,outTypes:l,inputs:{a:t}}),this.outKey=e}dynoOut(){return new Er(this,this.outKey)}}class VE extends Vs{constructor({a:t,b:e,outKey:n,outTypeFunc:i}){const r={a:Kc(t),b:Kc(e)},l=i(Kc(t),Kc(e)),u={[n]:l};super({inTypes:r,outTypes:u,inputs:{a:t,b:e}}),this.outKey=n}dynoOut(){return new Er(this,this.outKey)}}const Ts={type:"Gsplat"},YE={type:"PackedSplats"},wm=(s,t)=>new vP({packedSplats:s,index:t}),xP=(s,t,e,n)=>new EP({packedSplats:s,index:t,base:e,count:n}),ov=s=>new _P({gsplat:s}),sb=({gsplat:s,flags:t,index:e,center:n,scales:i,quaternion:r,rgba:l,rgb:u,opacity:A,x:d,y:m,z:g,r:y,g:v,b:C})=>new CP({gsplat:s,flags:t,index:e,center:n,scales:i,quaternion:r,rgba:l,rgb:u,opacity:A,x:d,y:m,z:g,r:y,g:v,b:C}),J3=(s,{scale:t,rotate:e,translate:n,recolor:i})=>new bP({gsplat:s,scale:t,rotate:e,translate:n,recolor:i}),cc=Cr(`
  struct Gsplat {
    vec3 center;
    uint flags;
    vec3 scales;
    int index;
    vec4 quaternion;
    vec4 rgba;
  };
  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;

  bool isGsplatActive(uint flags) {
    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;
  }
`),sI=Cr(`
  struct PackedSplats {
    usampler2DArray texture;
    int numSplats;
    vec4 rgbMinMaxLnScaleMinMax;
  };
`),Z3=Cr(`
  bool readPackedSplat(usampler2DArray texture, int numSplats, vec4 rgbMinMaxLnScaleMinMax, int index, out Gsplat gsplat) {
    if ((index >= 0) && (index < numSplats)) {
      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);
      unpackSplatEncoding(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba, rgbMinMaxLnScaleMinMax);
      return true;
    } else {
      return false;
    }
  }
`);class vP extends Vs{constructor({packedSplats:t,index:e}){super({inTypes:{packedSplats:YE,index:"int"},outTypes:{gsplat:Ts},inputs:{packedSplats:t,index:e},globals:()=>[cc,sI,Z3],statements:({inputs:n,outputs:i})=>{const{gsplat:r}=i;if(!r)return[];const{packedSplats:l,index:u}=n;let A;return l&&u?A=lc(`
            if (readPackedSplat(${l}.texture, ${l}.numSplats, ${l}.rgbMinMaxLnScaleMinMax, ${u}, ${r})) {
              bool zeroSize = all(equal(${r}.scales, vec3(0.0, 0.0, 0.0)));
              ${r}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
            } else {
              ${r}.flags = 0u;
            }
          `):A=[`${r}.flags = 0u;`],A.push(`${r}.index = ${u??"0"};`),A}})}dynoOut(){return new Er(this,"gsplat")}}class EP extends Vs{constructor({packedSplats:t,index:e,base:n,count:i}){super({inTypes:{packedSplats:YE,index:"int",base:"int",count:"int"},outTypes:{gsplat:Ts},inputs:{packedSplats:t,index:e,base:n,count:i},globals:()=>[cc,sI,Z3],statements:({inputs:r,outputs:l})=>{const{gsplat:u}=l;if(!u)return[];const{packedSplats:A,index:d,base:m,count:g}=r;let y;return A&&d&&m&&g?y=lc(`
            ${u}.flags = 0u;
            if ((${d} >= ${m}) && (${d} < (${m} + ${g}))) {
              if (readPackedSplat(${A}.texture, ${A}.numSplats, ${A}.rgbMinMaxLnScaleMinMax, ${d}, ${u})) {
                bool zeroSize = all(equal(${u}.scales, vec3(0.0, 0.0, 0.0)));
                ${u}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
              }
            }
          `):y=[`${u}.flags = 0u;`],y.push(`${u}.index = ${d??"0"};`),y}})}dynoOut(){return new Er(this,"gsplat")}}class _P extends Vs{constructor({gsplat:t}){super({inTypes:{gsplat:Ts},outTypes:{flags:"uint",active:"bool",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},inputs:{gsplat:t},globals:()=>[cc],statements:({inputs:e,outputs:n})=>{const{gsplat:i}=e,{flags:r,active:l,index:u,center:A,scales:d,quaternion:m,rgba:g,rgb:y,opacity:v,x:C,y:I,z:S,r:E,g:B,b:w}=n;return[r?`${r} = ${i?`${i}.flags`:"0u"};`:null,l?`${l} = isGsplatActive(${i?`${i}.flags`:"0u"});`:null,u?`${u} = ${i?`${i}.index`:"0"};`:null,A?`${A} = ${i?`${i}.center`:"vec3(0.0, 0.0, 0.0)"};`:null,d?`${d} = ${i?`${i}.scales`:"vec3(0.0, 0.0, 0.0)"};`:null,m?`${m} = ${i?`${i}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)"};`:null,g?`${g} = ${i?`${i}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)"};`:null,y?`${y} = ${i?`${i}.rgba.rgb`:"vec3(0.0, 0.0, 0.0)"};`:null,v?`${v} = ${i?`${i}.rgba.a`:"0.0"};`:null,C?`${C} = ${i?`${i}.center.x`:"0.0"};`:null,I?`${I} = ${i?`${i}.center.y`:"0.0"};`:null,S?`${S} = ${i?`${i}.center.z`:"0.0"};`:null,E?`${E} = ${i?`${i}.rgba.r`:"0.0"};`:null,B?`${B} = ${i?`${i}.rgba.g`:"0.0"};`:null,w?`${w} = ${i?`${i}.rgba.b`:"0.0"};`:null].filter(Boolean)}})}}class CP extends Vs{constructor({gsplat:t,flags:e,index:n,center:i,scales:r,quaternion:l,rgba:u,rgb:A,opacity:d,x:m,y:g,z:y,r:v,g:C,b:I}){super({inTypes:{gsplat:Ts,flags:"uint",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},outTypes:{gsplat:Ts},inputs:{gsplat:t,flags:e,index:n,center:i,scales:r,quaternion:l,rgba:u,rgb:A,opacity:d,x:m,y:g,z:y,r:v,g:C,b:I},globals:()=>[cc],statements:({inputs:S,outputs:E})=>{const{gsplat:B}=E;if(!B)return[];const{gsplat:w,flags:Q,index:R,center:D,scales:U,quaternion:P,rgba:z,rgb:L,opacity:k,x:Y,y:W,z:K,r:nt,g:H,b:tt}=S;return[`${B}.flags = ${Q??(w?`${w}.flags`:"0u")};`,`${B}.index = ${R??(w?`${w}.index`:"0")};`,`${B}.center = ${D??(w?`${w}.center`:"vec3(0.0, 0.0, 0.0)")};`,`${B}.scales = ${U??(w?`${w}.scales`:"vec3(0.0, 0.0, 0.0)")};`,`${B}.quaternion = ${P??(w?`${w}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)")};`,`${B}.rgba = ${z??(w?`${w}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)")};`,L?`${B}.rgba.rgb = ${L};`:null,k?`${B}.rgba.a = ${k};`:null,Y?`${B}.center.x = ${Y};`:null,W?`${B}.center.y = ${W};`:null,K?`${B}.center.z = ${K};`:null,nt?`${B}.rgba.r = ${nt};`:null,H?`${B}.rgba.g = ${H};`:null,tt?`${B}.rgba.b = ${tt};`:null].filter(Boolean)}})}dynoOut(){return new Er(this,"gsplat")}}Cr(`
  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {
    float minScale = min(scales.x, min(scales.y, scales.z));
    vec3 normal;
    if (scales.z == minScale) {
      normal = vec3(0.0, 0.0, 1.0);
    } else if (scales.y == minScale) {
      normal = vec3(0.0, 1.0, 0.0);
    } else {
      normal = vec3(1.0, 0.0, 0.0);
    }
    return quatVec(quaternion, normal);
  }
`);class bP extends Vs{constructor({gsplat:t,scale:e,rotate:n,translate:i,recolor:r}){super({inTypes:{gsplat:Ts,scale:"float",rotate:"vec4",translate:"vec3",recolor:"vec4"},outTypes:{gsplat:Ts},inputs:{gsplat:t,scale:e,rotate:n,translate:i,recolor:r},globals:()=>[cc],statements:({inputs:l,outputs:u,compile:A})=>{const{gsplat:d}=u;if(!d||!l.gsplat)return[];const{scale:m,rotate:g,translate:y,recolor:v}=l,C=A.indent;return[`${d} = ${l.gsplat};`,`if (isGsplatActive(${d}.flags)) {`,m?`${C}${d}.center *= ${m};`:null,g?`${C}${d}.center = quatVec(${g}, ${d}.center);`:null,y?`${C}${d}.center += ${y};`:null,m?`${C}${d}.scales *= ${m};`:null,g?`${C}${d}.quaternion = quatQuat(${g}, ${d}.quaternion);`:null,v?`${C}${d}.rgba *= ${v};`:null,"}"].filter(Boolean)}})}dynoOut(){return new Er(this,"gsplat")}}const SP=(s,t)=>new IP({gsplat:s,rgbMinMaxLnScaleMinMax:t});class IP extends Vs{constructor({gsplat:t,rgbMinMaxLnScaleMinMax:e}){super({inTypes:{gsplat:Ts,rgbMinMaxLnScaleMinMax:"vec4"},inputs:{gsplat:t,rgbMinMaxLnScaleMinMax:e},globals:()=>[cc],statements:({inputs:n,outputs:i})=>{const{output:r}=i;if(!r)return[];const{gsplat:l,rgbMinMaxLnScaleMinMax:u}=n;return l?lc(`
            if (isGsplatActive(${l}.flags)) {
              ${r} = packSplatEncoding(${l}.center, ${l}.scales, ${l}.quaternion, ${l}.rgba, ${u});
            } else {
              ${r} = uvec4(0u, 0u, 0u, 0u);
            }
          `):[`${r} = uvec4(0u, 0u, 0u, 0u);`]}})}dynoOut(){return new Er(this,"output")}}class BP extends Vs{constructor({rgba8:t}){super({inTypes:{rgba8:"vec4"},inputs:{rgba8:t},statements:({inputs:e,outputs:n})=>[`target = ${e.rgba8??"vec4(0.0, 0.0, 0.0, 0.0)"};`]})}dynoOut(){return new Er(this,"rgba8")}}class Al extends Vs{constructor({key:t,type:e,count:n,value:i,update:r,globals:l}){t=t??"value",super({outTypes:{[t]:e},update:()=>{if(r){const u=r(this.value);u!==void 0&&(this.value=u)}this.uniform.value=this.value},generate:({inputs:u,outputs:A})=>{const d=l?.({inputs:u,outputs:A})??[],m={},g=A[t];return g&&(d.push(`uniform ${X3(g,e,n)};`),m[g]=this.uniform),{globals:d,uniforms:m}}}),this.type=e,this.count=n,this.value=i,this.uniform={value:i},this.outKey=t}dynoOut(){return new Er(this,this.outKey)}}class BB extends Al{constructor({key:t,value:e,update:n}){super({key:t,type:"bool",value:e,update:n})}}class qb extends Al{constructor({key:t,value:e,update:n}){super({key:t,type:"int",value:e,update:n})}}class t0 extends Al{constructor({key:t,value:e,update:n}){super({key:t,type:"float",value:e,update:n})}}class ab extends Al{constructor({key:t,value:e,update:n}){super({key:t,type:"vec2",value:e,update:n})}}class iE extends Al{constructor({key:t,value:e,update:n}){super({key:t,type:"vec3",value:e,update:n})}}class qE extends Al{constructor({key:t,value:e,update:n}){super({key:t,type:"vec4",value:e,update:n})}}class rb extends Al{constructor({key:t,value:e,update:n}){super({key:t,type:"usampler2DArray",value:e,update:n})}}const aI=new Float32Array(1),W3=new Uint32Array(aI.buffer),rI="Float16Array"in globalThis,sE=rI?new globalThis.Float16Array(1):null,j3=new Uint16Array(sE?.buffer),ob=rI?MP:wP,lb=rI?TP:QP;function MP(s){return sE[0]=s,j3[0]}function wP(s){aI[0]=s;const t=W3[0],e=t>>31&1,n=t>>23&255,i=t&8388607,r=e<<15;if(n===255)return i!==0?r|32767:r|31744;const l=n-127+15;if(l>=31)return r|31744;if(l<=0){if(l<-10)return r;const A=(i|8388608)>>1-l+13;return r|A}const u=i>>13;return r|l<<10|u}function TP(s){return j3[0]=s,sE[0]}function QP(s){const t=s>>15&1,e=s>>10&31,n=s&1023;let i;if(e===0)if(n===0)i=t<<31;else{let r=n,l=-14;for(;(r&1024)===0;)r<<=1,l--;r&=1023;const u=l+127,A=r<<13;i=t<<31|u<<23|A}else if(e===31)n===0?i=t<<31|2139095040:i=t<<31|2143289344;else{const r=e-15+127,l=n<<13;i=t<<31|r<<23|l}return W3[0]=i,aI[0]}function Rx(s){return Math.max(0,Math.min(255,Math.round(s*255)))}function DP(s){const t=[],e=new Set;function n(i){i&&typeof i=="object"&&!e.has(i)&&(e.add(i),i instanceof ArrayBuffer?t.push(i):ArrayBuffer.isView(i)?t.push(i.buffer):Array.isArray(i)?i.forEach(n):Object.values(i).forEach(n))}return n(s),t}class RP{constructor({allocate:t,dispose:e,valid:n}){this.items=[],this.allocate=t,this.dispose=e,this.valid=n}alloc(t){for(;;){const e=this.items.pop();if(!e)break;if(this.valid(e,t))return e;this.dispose&&this.dispose(e)}return this.allocate(t)}free(t){this.items.push(t)}disposeAll(){let t;for(t=this.items.pop();t;)this.dispose&&this.dispose(t),t=this.items.pop()}}function MB(s,t,e,n,i,r,l,u,A,d,m,g,y,v,C,I,S){const E=S?.rgbMin??0,w=(S?.rgbMax??1)-E,Q=Rx((v-E)/w),R=Rx((C-E)/w),D=Rx((I-E)/w),U=Rx(y),P=qP(NP.set(A,d,m,g)),z=P&255,L=P>>>8&255,k=P>>>16&255,Y=S?.lnScaleMin??iu,K=254/((S?.lnScaleMax??su)-Y),nt=r<ib?0:Math.min(255,Math.max(1,Math.round((Math.log(r)-Y)*K)+1)),H=l<ib?0:Math.min(255,Math.max(1,Math.round((Math.log(l)-Y)*K)+1)),tt=u<ib?0:Math.min(255,Math.max(1,Math.round((Math.log(u)-Y)*K)+1)),it=ob(e),ot=ob(n),At=ob(i),V=t*4;s[V]=Q|R<<8|D<<16|U<<24,s[V+1]=it|ot<<16,s[V+2]=At|z<<16|L<<24,s[V+3]=nt|H<<8|tt<<16|k<<24}const NP=new Ge,UP=new F,LP=new F,zP=new Ge,OP=new le,FP={center:UP,scales:LP,quaternion:zP,color:OP,opacity:0};function wB(s,t,e){const n=FP,i=t*4,r=s[i],l=s[i+1],u=s[i+2],A=s[i+3],d=e?.rgbMin??0,g=(e?.rgbMax??1)-d;n.color.set(d+(r&255)/255*g,d+(r>>>8&255)/255*g,d+(r>>>16&255)/255*g),n.opacity=(r>>>24&255)/255,n.center.set(lb(l&65535),lb(l>>>16&65535),lb(u&65535));const y=e?.lnScaleMin??iu,C=((e?.lnScaleMax??su)-y)/254,I=A&255;n.scales.x=I===0?0:Math.exp(y+(I-1)*C);const S=A>>>8&255;n.scales.y=S===0?0:Math.exp(y+(S-1)*C);const E=A>>>16&255;n.scales.z=E===0?0:Math.exp(y+(E-1)*C);const B=u>>>16&65535|A>>>8&16711680;return XP(B,n.quaternion),n}function vo(s){const t=vi,e=Math.max(uP,Math.min(zf,Math.ceil(s/t))),n=Math.ceil(s/(t*e)),i=t*e*n;return{width:t,height:e,depth:n,maxSplats:i}}function PP(s){const t=new h0(s.autoStart);return t.startTime=s.startTime,t.oldTime=s.oldTime,t.elapsedTime=s.elapsedTime,t.running=s.running,t}const GP=Cr(`
  precision highp float;

  in vec3 position;

  void main() {
    gl_Position = vec4(position.xy, 0.0, 1.0);
  }
`);function kP(s){const t=new F;for(const e of s)t.add(e);return t.divideScalar(s.length)}function HP(s){if(s.length===0)return new Ge;const t=s[0].clone();for(let e=1;e<s.length;e++)s[e].dot(s[0])<0?(t.x-=s[e].x,t.y-=s[e].y,t.z-=s[e].z,t.w-=s[e].w):(t.x+=s[e].x,t.y+=s[e].y,t.z+=s[e].z,t.w+=s[e].w);return t.normalize()}function VP(s,t){const[e,n]=[new F,new Ge],[i,r]=[new F,new Ge];s.decompose(e,n,new F),t.decompose(i,r,new F);const l=e.distanceTo(i),u=Math.abs(n.dot(r));return{distance:l,coorient:u}}function Xb({matrix1:s,matrix2:t,maxDistance:e,minCoorient:n}){const{distance:i,coorient:r}=VP(s,t);return i<=e&&(n==null||r>=n)}const YP=new Ge,Jb=new F;function qP(s){const t=YP.copy(s).normalize();t.w<0&&t.set(-t.x,-t.y,-t.z,-t.w);const e=2*Math.acos(t.w),n=Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z),i=n<1e-6?Jb.set(1,0,0):Jb.set(t.x,t.y,t.z).divideScalar(n),r=Math.abs(i.x)+Math.abs(i.y)+Math.abs(i.z);let l=i.x/r,u=i.y/r;if(i.z<0){const v=l;l=(1-Math.abs(u))*(l>=0?1:-1),u=(1-Math.abs(v))*(u>=0?1:-1)}const A=l*.5+.5,d=u*.5+.5,m=Math.round(A*255),g=Math.round(d*255);return Math.round(e*(255/Math.PI))<<16|g<<8|m}function XP(s,t){const e=s&255,n=s>>>8&255,i=s>>>16&255,r=e/255,l=n/255;let u=(r-.5)*2,A=(l-.5)*2;const d=1-(Math.abs(u)+Math.abs(A)),m=Math.max(-d,0);u+=u>=0?-m:m,A+=A>=0?-m:m;const g=Jb.set(u,A,d).normalize(),v=i/255*Math.PI*.5,C=Math.sin(v),I=Math.cos(v);return t.set(g.x*C,g.y*C,g.z*C,I),t}function JP(s,t){const e=[];let n=0,i=null;const r=new X5((A,d)=>{if(e.push(A),n+=A.length,d||n>=t){const m=new Uint8Array(n);let g=0;for(const y of e)m.set(y,g),g+=y.length;i=m.slice(0,t)}}),l=1024;let u=0;for(;i==null&&u<s.length;){const A=s.slice(u,u+l);r.push(A,!1),u+=l}if(i==null&&(r.push(new Uint8Array,!0),i==null))throw new Error("Failed to decompress partial gzip");return i}class K3{constructor({graph:t,inputs:e,outputs:n,template:i}){this.graph=t,this.template=i,this.inputs=e??{},this.outputs=n??{};const r=new mP({indent:this.template.indent});for(const u in this.outputs)this.outputs[u]&&r.declares.add(this.outputs[u]);const l=t.compile({inputs:this.inputs,outputs:this.outputs,compile:r});this.shader=i.generate({globals:r.globals,statements:l}),this.uniforms=r.uniforms,this.updaters=r.updaters}prepareMaterial(){return ZP(this)}update(){for(const t of this.updaters)t()}}class $3{constructor(t){const e=t.match(/^([ \t]*)\{\{\s*GLOBALS\s*\}\}/m),n=t.match(/^([ \t]*)\{\{\s*STATEMENTS\s*\}\}/m);if(!e||!n)throw new Error("Template must contain {{ GLOBALS }} and {{ STATEMENTS }}");this.before=t.substring(0,e.index),this.between=t.substring(e.index+e[0].length,n.index),this.after=t.substring(n.index+n[0].length),this.indent=n[1]}generate({globals:t,statements:e}){return this.before+Array.from(t).join(`

`)+this.between+e.map(n=>this.indent+n).join(`
`)+this.after}}const TB=new Map;function ZP(s){let t=TB.get(s);return t||(t=new l0({glslVersion:Gm,vertexShader:GP,fragmentShader:s.shader,uniforms:s.uniforms}),TB.set(s,t),t)}function tT(s,t,e="add"){const n=()=>{throw new Error(`Invalid ${e} types: ${s}, ${t}`)};if(s===t)return s;if(s==="int"){if(Of(t))return t;n()}if(t==="int"){if(Of(s))return s;n()}if(s==="uint"){if(Ff(t))return t;n()}if(t==="uint"){if(Ff(s))return s;n()}if(s==="float"){if($m(t))return t;n()}if(t==="float"){if($m(s))return s;n()}throw new Error(`Invalid ${e} types: ${s}, ${t}`)}function WP(s,t){return tT(s,t,"sub")}function jP(s,t){const e=()=>{throw new Error(`Invalid mul types: ${s}, ${t}`)},n=i=>i;if(s==="int"){if(Of(t))return n(t);e()}if(t==="int"){if(Of(s))return n(s);e()}if(s==="uint"){if(Ff(t))return n(t);e()}if(t==="uint"){if(Ff(s))return n(s);e()}if(s==="float"){if($m(t))return n(t);e()}if(t==="float"){if($m(s))return n(s);e()}if(Of(s)||Ff(s)||Of(t)||Ff(t)){if(s===t)return n(s);e()}if(s==="vec2"){if(t==="vec2"||Td(t))return n("vec2");if(t==="mat3x2")return n("vec3");if(t==="mat4x2")return n("vec4");e()}if(s==="vec3"){if(t==="mat2x3")return n("vec2");if(t==="vec3"||Qd(t))return n("vec3");if(t==="mat4x3")return n("vec4");e()}if(s==="vec4"){if(t==="mat2x4")return n("vec2");if(t==="mat3x4")return n("vec3");if(t==="vec4"||Dd(t))return n("vec4");e()}if(t==="vec2"){if(Td(s))return n("vec2");if(s==="mat2x3")return n("vec3");if(s==="mat2x4")return n("vec4");e()}if(t==="vec3"){if(s==="mat3x2")return n("vec2");if(Qd(s))return n("vec3");if(s==="mat3x4")return n("vec4");e()}if(t==="vec4"){if(s==="mat4x2")return n("vec2");if(s==="mat4x3")return n("vec3");if(Dd(s))return n("vec4");e()}if(Td(s)){if(Td(t))return n("mat2");if(t==="mat3x2")return n("mat3x2");if(t==="mat4x2")return n("mat4x2");e()}if(s==="mat2x3"){if(Td(t))return n("mat2x3");if(t==="mat3x2")return n("mat3");if(t==="mat4x2")return n("mat4x3");e()}if(s==="mat2x4"){if(Td(t))return n("mat2x4");if(t==="mat3x2")return n("mat3x4");if(t==="mat4x2")return n("mat4");e()}if(s==="mat3x2"){if(t==="mat2x3")return n("mat2");if(Qd(t))return n("mat3x2");if(t==="mat4x3")return n("mat4x2");e()}if(Qd(s)){if(t==="mat2x3")return n("mat2x3");if(Qd(t))return n("mat3");if(t==="mat4x3")return n("mat4x3");e()}if(s==="mat3x4"){if(t==="mat2x3")return n("mat2x4");if(Qd(t))return n("mat3x4");if(t==="mat4x3")return n("mat4");e()}if(s==="mat4x2"){if(t==="mat2x4")return n("mat2");if(t==="mat3x4")return n("mat3x2");if(Dd(t))return n("mat4x2");e()}if(s==="mat4x3"){if(t==="mat2x4")return n("mat2x3");if(t==="mat3x4")return n("mat3");if(Dd(t))return n("mat4x3");e()}if(Dd(s)){if(t==="mat2x4")return n("mat2x4");if(t==="mat3x4")return n("mat3x4");if(Dd(t))return n("mat4");e()}throw new Error(`Invalid mul types: ${s}, ${t}`)}const Qf=(s,t)=>new KP({a:s,b:t}),QB=(s,t)=>new $P({a:s,b:t}),fm=(s,t)=>new t8({a:s,b:t});class KP extends VE{constructor({a:t,b:e}){super({a:t,b:e,outKey:"sum",outTypeFunc:tT}),this.statements=({inputs:n,outputs:i})=>[`${i.sum} = ${n.a} + ${n.b};`]}}class $P extends VE{constructor({a:t,b:e}){super({a:t,b:e,outKey:"difference",outTypeFunc:WP}),this.statements=({inputs:n,outputs:i})=>[`${i.difference} = ${n.a} - ${n.b};`]}}class t8 extends VE{constructor({a:t,b:e}){super({a:t,b:e,outKey:"product",outTypeFunc:jP}),this.statements=({inputs:n,outputs:i})=>[`${i.product} = ${n.a} * ${n.b};`]}}const e8=s=>new i8({value:s}),n8=s=>new s8({value:s}),DB=s=>new a8({value:s});class i8 extends HE{constructor({value:t}){super({a:t,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:e,outputs:n})=>[`${n.uint} = floatBitsToUint(${e.a});`]}}class s8 extends HE{constructor({value:t}){super({a:t,outKey:"uint",outTypeFunc:()=>"uint"}),this.statements=({inputs:e,outputs:n})=>[`${n.uint} = packHalf2x16(${e.a});`]}}class a8 extends HE{constructor({value:t}){super({a:t,outKey:"rgba8",outTypeFunc:()=>"vec4"}),this.statements=({inputs:e,outputs:n})=>[`uvec4 uRgba = uvec4(${e.a} & 0xffu, (${e.a} >> 8u) & 0xffu, (${e.a} >> 16u) & 0xffu, (${e.a} >> 24u) & 0xffu);`,`${n.rgba8} = vec4(uRgba) / 255.0;`]}}const r8=s=>new u8({a:s}),o8=s=>new d8({vector:s}),l8=({vector:s,vectorType:t,x:e,y:n,z:i,w:r,r:l,g:u,b:A,a:d})=>new p8({vector:s,vectorType:t,x:e,y:n,z:i,w:r,r:l,g:u,b:A,a:d}),c8=(s,t)=>new f8({a:s,b:t});class u8 extends HE{constructor({a:t}){super({a:t,outTypeFunc:e=>e,outKey:"normalize"}),this.statements=({inputs:e,outputs:n})=>[`${n.normalize} = normalize(${e.a});`]}}function h8(s){if(s==="float")return"vec2";if(s==="vec2")return"vec3";if(s==="vec3")return"vec4";throw new Error("Invalid type")}class f8 extends VE{constructor({a:t,b:e}){const n=Kc(t),i=h8(n);super({a:t,b:e,outKey:"extend",outTypeFunc:()=>i}),this.statements=({inputs:r,outputs:l})=>[`${l.extend} = ${i}(${r.a}, ${r.b});`]}}function A8(s){const t=e=>e;switch(s){case"vec2":return t({x:"float",y:"float",r:"float",g:"float"});case"vec3":return t({x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"});case"vec4":return t({x:"float",y:"float",z:"float",w:"float",r:"float",g:"float",b:"float",a:"float"});case"ivec2":return t({x:"int",y:"int",r:"int",g:"int"});case"ivec3":return t({x:"int",y:"int",z:"int",r:"int",g:"int",b:"int"});case"ivec4":return t({x:"int",y:"int",z:"int",w:"int",r:"int",g:"int",b:"int",a:"int"});case"uvec2":return t({x:"uint",y:"uint",r:"uint",g:"uint"});case"uvec3":return t({x:"uint",y:"uint",z:"uint",r:"uint",g:"uint",b:"uint"});case"uvec4":return t({x:"uint",y:"uint",z:"uint",w:"uint",r:"uint",g:"uint",b:"uint",a:"uint"});default:throw new Error(`Invalid vector type: ${s}`)}}class d8 extends Vs{constructor({vector:t}){const n={vector:Kc(t)},i=A8(n.vector);super({inTypes:n,outTypes:i,inputs:{vector:t}}),this.statements=({inputs:r,outputs:l})=>{const{x:u,y:A,z:d,w:m,r:g,g:y,b:v,a:C}=l,{vector:I}=r;return[u?`${u} = ${I}.x;`:null,A?`${A} = ${I}.y;`:null,d?`${d} = ${I}.z;`:null,m?`${m} = ${I}.w;`:null,g?`${g} = ${I}.r;`:null,y?`${y} = ${I}.g;`:null,v?`${v} = ${I}.b;`:null,C?`${C} = ${I}.a;`:null].filter(Boolean)}}}class p8 extends Vs{constructor({vector:t,vectorType:e,x:n,y:i,z:r,w:l,r:u,g:A,b:d,a:m}){if(!t&&!e)throw new Error("Either vector or vectorType must be provided");const g=e??Kc(t),y=dP(g),v=pP(g),C={vector:g,x:y,y,r:y,g:y},I={vector:t,x:n,y:i,r:u,g:A};v>=3&&(Object.assign(C,{z:y,b:y}),Object.assign(I,{z:r,b:d})),v>=4&&(Object.assign(C,{w:y,a:y}),Object.assign(I,{w:l,a:m})),super({inTypes:C,outTypes:{vector:g},inputs:I}),this.statements=({inputs:S,outputs:E})=>{const{vector:B}=E,{vector:w,x:Q,y:R,z:D,w:U,r:P,g:z,b:L,a:k}=S,Y=[`${B}.x = ${Q??P??(w?`${w}.x`:Dx(y))};`,`${B}.y = ${R??z??(w?`${w}.y`:Dx(y))};`];return v>=3&&Y.push(`${B}.z = ${D??L??(w?`${w}.z`:Dx(y))};`),v>=4&&Y.push(`${B}.w = ${U??k??(w?`${w}.w`:Dx(y))};`),Y}}dynoOut(){return new Er(this,"vector")}}const g8=(s,{scale:t,scales:e,rotate:n,translate:i})=>new y8({position:s,scale:t,scales:e,rotate:n,translate:i}).outputs.position,m8=(s,{scale:t,scales:e,rotate:n})=>new x8({dir:s,scale:t,scales:e,rotate:n}).outputs.dir;class y8 extends Vs{constructor({position:t,scale:e,scales:n,rotate:i,translate:r}){super({inTypes:{position:"vec3",scale:"float",scales:"vec3",rotate:"vec4",translate:"vec3"},outTypes:{position:"vec3"},inputs:{position:t,scale:e,scales:n,rotate:i,translate:r},statements:({inputs:l,outputs:u})=>{const{position:A}=u;if(!A)return[];const{scale:d,scales:m,rotate:g,translate:y}=l;return[`${A} = ${l.position??"vec3(0.0, 0.0, 0.0)"};`,d?`${A} *= ${d};`:null,m?`${A} *= ${m};`:null,g?`${A} = quatVec(${g}, ${A});`:null,y?`${A} += ${y};`:null].filter(Boolean)}})}}class x8 extends Vs{constructor({dir:t,scale:e,scales:n,rotate:i}){super({inTypes:{dir:"vec3",scale:"float",scales:"vec3",rotate:"vec4"},outTypes:{dir:"vec3"},inputs:{dir:t,scale:e,scales:n,rotate:i},statements:({inputs:r,outputs:l})=>{const{dir:u}=l;if(!u)return[];const{scale:A,scales:d,rotate:m}=r;return[`${u} = ${r.dir??"vec3(0.0, 0.0, 0.0)"};`,A?`${u} *= ${A};`:null,d?`${u} *= ${d};`:null,m?`${u} = quatVec(${m}, ${u});`:null].filter(Boolean)}})}}var v8=`precision highp float;
precision highp int;
precision highp sampler2D;
precision highp usampler2D;
precision highp isampler2D;
precision highp sampler2DArray;
precision highp usampler2DArray;
precision highp isampler2DArray;
precision highp sampler3D;
precision highp usampler3D;
precision highp isampler3D;

#include <splatDefines>

uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;

out vec4 target;

{{ GLOBALS }}

void computeReadback(int index) {
    {{ STATEMENTS }}
}

void main() {
    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);
    int index = targetIndex - targetBase;

    if ((index >= 0) && (index < targetCount)) {
        computeReadback(index);
    } else {
        target = vec4(0.0, 0.0, 0.0, 0.0);
    }
}`;const XE=class sh{constructor({renderer:t}={}){this.renderer=t,this.capacity=0,this.count=0}dispose(){this.target&&(this.target.dispose(),this.target=void 0)}ensureBuffer(t,e){const i=Math.ceil(Math.max(1,t)/vi)*vi*4;if(e.byteLength>=i)return e;const r=new ArrayBuffer(i);if(e instanceof ArrayBuffer)return r;const l=e.constructor;return new l(r)}ensureCapacity(t){const{width:e,height:n,depth:i,maxSplats:r}=vo(t);(!this.target||r>this.capacity)&&(this.dispose(),this.capacity=r,this.target=new bS(e,n,i,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:rs,minFilter:rs}),this.target.texture.format=Ki,this.target.texture.type=ea,this.target.texture.internalFormat="RGBA8",this.target.scissorTest=!0)}prepareProgramMaterial(t){let e=sh.readbackProgram.get(t);if(!e){const i=au({index:"int"},{rgba8:"vec4"},({index:r})=>(t.inputs.index=r,{rgba8:new BP({rgba8:t.outputs.rgba8})}));sh.programTemplate||(sh.programTemplate=new $3(v8)),e=new K3({graph:i,inputs:{index:"index"},outputs:{rgba8:"target"},template:sh.programTemplate}),Object.assign(e.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),sh.readbackProgram.set(t,e)}const n=e.prepareMaterial();return sh.fullScreenQuad.material=n,{program:e,material:n}}saveRenderState(t){return{xrEnabled:t.xr.enabled,autoClear:t.autoClear}}resetRenderState(t,e){t.setRenderTarget(null),t.xr.enabled=e.xrEnabled,t.autoClear=e.autoClear}process({count:t,material:e}){const n=this.renderer;if(!n)throw new Error("No renderer");if(!this.target)throw new Error("No target");const i=vi*zf;e.uniforms.targetBase.value=0,e.uniforms.targetCount.value=t;let r=0;for(;r<t;){const l=Math.floor(r/i),u=l*i,A=Math.min(zf,Math.ceil((t-u)/vi));e.uniforms.targetLayer.value=l,this.target.scissor.set(0,0,vi,A),n.setRenderTarget(this.target,l),n.xr.enabled=!1,n.autoClear=!1,sh.fullScreenQuad.render(n),r+=vi*A}this.count=t}async read({readback:t}){const e=this.renderer;if(!e)throw new Error("No renderer");if(!this.target)throw new Error("No target");const n=Math.ceil(this.count/vi)*vi;if(t.byteLength<n*4)throw new Error(`Readback buffer too small: ${t.byteLength} < ${n*4}`);const i=new Uint8Array(t instanceof ArrayBuffer?t:t.buffer),r=vi*zf;let l=0;const u=[];for(;l<this.count;){const A=Math.floor(l/r),d=A*r,m=Math.min(zf,Math.ceil((this.count-d)/vi));e.setRenderTarget(this.target,A);const g=vi*m*4,y=i.subarray(d*4,d*4+g),v=e?.readRenderTargetPixelsAsync(this.target,0,0,vi,m,y);u.push(v),l+=vi*m}return Promise.all(u).then(()=>t)}render({reader:t,count:e,renderer:n}){if(this.renderer=n||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(e);const{program:i,material:r}=this.prepareProgramMaterial(t);i.update();const l=this.saveRenderState(this.renderer);this.process({count:e,material:r}),this.resetRenderState(this.renderer,l)}async readback({readback:t}){if(!this.renderer)throw new Error("No renderer");const e=this.saveRenderState(this.renderer),n=this.read({readback:t});return this.resetRenderState(this.renderer,e),n}async renderReadback({reader:t,count:e,renderer:n,readback:i}){if(this.renderer=n||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(e);const{program:r,material:l}=this.prepareProgramMaterial(t);r.update();const u=this.saveRenderState(this.renderer);this.process({count:e,material:l});const A=this.read({readback:i});return this.resetRenderState(this.renderer,u),A}getTexture(){var t;return(t=this.target)==null?void 0:t.texture}};XE.programTemplate=null;XE.readbackProgram=new Map;XE.fullScreenQuad=new U3(new l0({visible:!1}));let eT=XE;const oI=class Ja{constructor(t={}){this.capacity=0,this.count=0,this.array=null,this.readback=null,this.source=null,this.needsUpdate=!0,this.dyno=new Al({key:"rgbaArray",type:nT,globals:()=>[iT],value:{texture:Ja.getEmpty(),count:0},update:e=>{var n;return e.texture=((n=this.readback)==null?void 0:n.getTexture())??this.source??Ja.getEmpty(),e.count=this.count,e}}),t.array?(this.array=t.array,this.capacity=Math.floor(this.array.length/4),this.capacity=Math.floor(this.capacity/vi)*vi,this.count=Math.min(this.capacity,t.count??Number.POSITIVE_INFINITY)):(this.capacity=t.capacity??0,this.count=0)}dispose(){this.readback&&(this.readback.dispose(),this.readback=null),this.source&&(this.source.dispose(),this.source=null)}ensureCapacity(t){var e;if(!this.array||t>(((e=this.array)==null?void 0:e.length)??0)/4){this.capacity=vo(t).maxSplats;const n=new Uint8Array(this.capacity*4);this.array&&n.set(this.array),this.array=n}return this.array}getTexture(){var t;let e=(t=this.readback)==null?void 0:t.getTexture();return(this.source||this.array)&&(e=this.maybeUpdateSource()),e??Ja.getEmpty()}maybeUpdateSource(){if(!this.array)throw new Error("No array");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:t,height:e,depth:n}=this.source.image;this.capacity!==t*e*n&&(this.source.dispose(),this.source=null)}if(this.source)this.array.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.array.buffer));else{const{width:t,height:e,depth:n}=vo(this.capacity);this.source=new hl(this.array,t,e,n),this.source.format=Ki,this.source.type=ea,this.source.internalFormat="RGBA8",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}render({reader:t,count:e,renderer:n}){this.readback||(this.readback=new eT({renderer:n})),this.readback.render({reader:t,count:e,renderer:n}),this.capacity=this.readback.capacity,this.count=this.readback.count}fromPackedSplats({packedSplats:t,base:e,count:n,renderer:i}){const{dynoSplats:r,dynoBase:l,dynoCount:u,reader:A}=Ja.makeDynos();return r.packedSplats=t,l.value=e,u.value=n,this.render({reader:A,count:n,renderer:i}),this}async read(){if(!this.readback)throw new Error("No readback");return(!this.array||this.array.length<this.count*4)&&(this.array=new Uint8Array(this.capacity*4)),(await this.readback.readback({readback:this.array})).subarray(0,this.count*4)}static getEmpty(){if(!Ja.emptySource){const t=new Uint8Array(4);Ja.emptySource=new hl(t,1,1,1),Ja.emptySource.format=Ki,Ja.emptySource.type=ea,Ja.emptySource.internalFormat="RGBA8",Ja.emptySource.needsUpdate=!0}return Ja.emptySource}static makeDynos(){if(!Ja.dynos){const t=new uI,e=new qb({value:0}),n=new qb({value:0}),i=au({index:"int"},{rgba8:"vec4"},({index:r})=>{if(!r)throw new Error("index is undefined");r=Qf(r,e);const l=xP(t,r,e,n);return{rgba8:ov(l).outputs.rgba}});Ja.dynos={dynoSplats:t,dynoBase:e,dynoCount:n,reader:i}}return Ja.dynos}};oI.emptySource=null;oI.dynos=null;let E8=oI;const nT={type:"RgbaArray"},iT=Cr(`
  struct RgbaArray {
    sampler2DArray texture;
    int count;
  };
`);function _8(s,t){return new Vs({inTypes:{rgba:nT,index:"int"},outTypes:{rgba:"vec4"},inputs:{rgba:s,index:t},globals:()=>[iT],statements:({inputs:n,outputs:i})=>lc(`
        if ((index >= 0) && (index < ${n.rgba}.count)) {
          ${i.rgba} = texelFetch(${n.rgba}.texture, splatTexCoord(index), 0);
        } else {
          ${i.rgba} = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `)}).outputs.rgba}function C8(s){switch(s){case"all":return 0;case"plane":return 1;case"sphere":return 2;case"box":return 3;case"ellipsoid":return 4;case"cylinder":return 5;case"capsule":return 6;case"infinite_cone":return 7;default:throw new Error(`Unknown SDF type: ${s}`)}}function b8(s){switch(s){case"multiply":return 0;case"set_rgb":return 1;case"add_rgba":return 2;default:throw new Error(`Unknown blend mode: ${s}`)}}class S8 extends gn{constructor(t={}){super();const{type:e,invert:n,opacity:i,color:r,displace:l,radius:u}=t;this.type=e??"sphere",this.invert=n??!1,this.opacity=i??1,this.color=r??new le(1,1,1),this.displace=l??new F(0,0,0),this.radius=u??0}}const sT=class aT extends gn{constructor(t={}){const{name:e,rgbaBlendMode:n="multiply",sdfSmooth:i=0,softEdge:r=0,invert:l=!1,sdfs:u=null}=t;super(),this.rgbaBlendMode=n,this.sdfSmooth=i,this.softEdge=r,this.invert=l,this.sdfs=u,this.ordering=aT.nextOrdering++,this.name=e??`Edit ${this.ordering}`}addSdf(t){this.sdfs==null&&(this.sdfs=[]),this.sdfs.includes(t)||this.sdfs.push(t)}removeSdf(t){this.sdfs!=null&&(this.sdfs=this.sdfs.filter(e=>e!==t))}};sT.nextOrdering=1;let rT=sT;class I8{constructor({maxSdfs:t,maxEdits:e}){this.maxSdfs=Math.max(16,t??0),this.numSdfs=0,this.sdfData=new Uint32Array(this.maxSdfs*8*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs),this.dynoSdfArray=new Al({key:"sdfArray",type:oT,globals:()=>[lT],value:{numSdfs:0,sdfTexture:this.sdfTexture},update:n=>(n.numSdfs=this.numSdfs,n.sdfTexture=this.sdfTexture,n)}),this.maxEdits=Math.max(16,e??0),this.numEdits=0,this.editData=new Uint32Array(this.maxEdits*4),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoNumEdits=new qb({value:0}),this.dynoEdits=this.newEdits(this.editData,this.maxEdits)}newSdfTexture(t,e){const n=new So(t,8,e,sc,Ca);return n.internalFormat="RGBA32UI",n.needsUpdate=!0,n}newEdits(t,e){return new Al({key:"edits",type:"uvec4",count:e,globals:()=>[cT],value:t})}ensureCapacity({maxSdfs:t,maxEdits:e}){let n=!1;return t>this.sdfTexture.image.height&&(this.sdfTexture.dispose(),this.maxSdfs=Math.max(this.maxSdfs*2,t),this.sdfData=new Uint32Array(this.maxSdfs*8*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs)),e>(this.dynoEdits.count??0)&&(this.maxEdits=Math.max(this.maxEdits*2,e),this.editData=new Uint32Array(this.maxEdits*4),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoEdits=this.newEdits(this.editData,this.maxEdits),n=!0),n}updateEditData(t,e){const n=this.editData[t]!==e;return this.editData[t]=e,n}updateEditFloatData(t,e){Rd[0]=e;const n=this.editFloatData[t]!==Rd[0];return n&&(this.editFloatData[t]=Rd[0]),n}encodeEdit(t,{sdfFirst:e,sdfCount:n,invert:i,rgbaBlendMode:r,softEdge:l,sdfSmooth:u}){const A=t*4;let d=!1;return d=this.updateEditData(A+0,r|(i?256:0))||d,d=this.updateEditData(A+1,e|n<<16)||d,d=this.updateEditFloatData(A+2,l)||d,d=this.updateEditFloatData(A+3,u)||d,d}updateSdfData(t,e){const n=this.sdfData[t]!==e;return this.sdfData[t]=e,n}updateSdfFloatData(t,e){Rd[0]=e;const n=this.sdfFloatData[t]!==Rd[0];return n&&(this.sdfFloatData[t]=Rd[0]),n}encodeSdf(t,{sdfType:e,invert:n,center:i,quaternion:r,scale:l,sizes:u},A){const d=t*32,m=e|(n?256:0);let g=!1;g=this.updateSdfFloatData(d+0,i?.x??0)||g,g=this.updateSdfFloatData(d+1,i?.y??0)||g,g=this.updateSdfFloatData(d+2,i?.z??0)||g,g=this.updateSdfData(d+3,m)||g,g=this.updateSdfFloatData(d+4,r?.x??0)||g,g=this.updateSdfFloatData(d+5,r?.y??0)||g,g=this.updateSdfFloatData(d+6,r?.z??0)||g,g=this.updateSdfFloatData(d+7,r?.w??0)||g,g=this.updateSdfFloatData(d+8,l?.x??0)||g,g=this.updateSdfFloatData(d+9,l?.y??0)||g,g=this.updateSdfFloatData(d+10,l?.z??0)||g,g=this.updateSdfData(d+11,0)||g,g=this.updateSdfFloatData(d+12,u?.x??0)||g,g=this.updateSdfFloatData(d+13,u?.y??0)||g,g=this.updateSdfFloatData(d+14,u?.z??0)||g,g=this.updateSdfFloatData(d+15,u?.w??0)||g;const y=Math.min(4,A.length);for(let v=0;v<y;++v){const C=d+16+v*4;g=this.updateSdfFloatData(C+0,A[v].x)||g,g=this.updateSdfFloatData(C+1,A[v].y)||g,g=this.updateSdfFloatData(C+2,A[v].z)||g,g=this.updateSdfFloatData(C+3,A[v].w)||g}return g}update(t){const e=t.reduce((g,{sdfs:y})=>g+y.length,0),n=this.ensureCapacity({maxEdits:t.length,maxSdfs:e}),i=[new We,new We],r=new F,l=new Ge,u=new F,A=new We;let d=0,m=n;t.length!==this.dynoNumEdits.value&&(this.dynoNumEdits.value=t.length,this.numEdits=t.length,m=!0);for(const[g,{edit:y,sdfs:v}]of t.entries()){m=this.encodeEdit(g,{sdfFirst:d,sdfCount:v.length,invert:y.invert,rgbaBlendMode:b8(y.rgbaBlendMode),softEdge:y.softEdge,sdfSmooth:y.sdfSmooth})||m;let C=!1;for(const I of v)A.set(I.scale.x,I.scale.y,I.scale.z,I.radius),I.scale.setScalar(1),I.updateMatrixWorld(),I.matrixWorld.clone().invert().decompose(r,l,u),I.scale.set(A.x,A.y,A.z),I.updateMatrixWorld(),i[0].set(I.color.r,I.color.g,I.color.b,I.opacity),i[1].set(I.displace.x,I.displace.y,I.displace.z,1),C=this.encodeSdf(d,{sdfType:C8(I.type),invert:I.invert,center:r,quaternion:l,scale:u,sizes:A},i)||C,d+=1;this.numSdfs=d,C&&(this.sdfTexture.needsUpdate=!0),m||(m=C)}return{updated:m,dynoUpdated:n}}modify(t){return B8(t,this.dynoSdfArray,this.dynoNumEdits,this.dynoEdits)}}const oT={type:"SdfArray"},lT=Cr(`
  struct SdfArray {
    int numSdfs;
    usampler2D sdfTexture;
  };

  void unpackSdfArray(
    usampler2D sdfTexture, int sdfIndex, out uint flags,
    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,
    int numValues, out vec4 values[4]
  ) {
    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);
    flags = temp.w;
    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);
    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);
    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);
    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    for (int i = 0; i < numValues; ++i) {
      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);
      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));
    }
  }

  const uint SDF_FLAG_TYPE = 0xFFu;
  const uint SDF_FLAG_INVERT = 1u << 8u;

  const uint SDF_TYPE_ALL = 0u;
  const uint SDF_TYPE_PLANE = 1u;
  const uint SDF_TYPE_SPHERE = 2u;
  const uint SDF_TYPE_BOX = 3u;
  const uint SDF_TYPE_ELLIPSOID = 4u;
  const uint SDF_TYPE_CYLINDER = 5u;
  const uint SDF_TYPE_CAPSULE = 6u;
  const uint SDF_TYPE_INFINITE_CONE = 7u;

  float evaluateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 outValues[4]
  ) {
    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;
    float maxExp = -1.0 / 0.0;
    for (int i = 0; i < numValues; ++i) {
        outValues[i] = vec4(0.0);
    }

    uint flags;
    vec3 center, scale;
    vec4 quaternion, sizes;
    vec4 values[4];

    int sdfLast = min(sdfFirst + sdfCount, numSdfs);
    for (int index = sdfFirst; index < sdfLast; ++index) {
      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);
      uint sdfType = flags & SDF_FLAG_TYPE;
      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;

      float distance;
      switch (sdfType) {
        case SDF_TYPE_ALL:
          distance = -1.0 / 0.0;
          break;
        case SDF_TYPE_PLANE: {
          distance = sdfPos.z;
          break;
        }
        case SDF_TYPE_SPHERE: {
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_BOX: {
          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;
          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;
          break;
        }
        case SDF_TYPE_ELLIPSOID: {
          vec3 sizes = sizes.xyz;
          float k0 = length(sdfPos / sizes);
          float k1 = length(sdfPos / dot(sizes, sizes));
          distance = k0 * (k0 - 1.0) / k1;
          break;
        }
        case SDF_TYPE_CYLINDER: {
          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;
          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
          break;
        }
        case SDF_TYPE_CAPSULE: {
          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_INFINITE_CONE: {
          float angle = 0.25 * PI * sizes.w;
          vec2 c = vec2(sin(angle), cos(angle));
          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);
          float d = length(q - c * max(dot(q, c), 0.0));
          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);
          break;
        }
      }

      if ((flags & SDF_FLAG_INVERT) != 0u) {
        distance = -distance;
      }

      if (smoothK == 0.0) {
        if (distance < distanceAccum) {
          distanceAccum = distance;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] = values[i];
          }
        }
      } else {
        float scaledDistance = -distance / smoothK;
        if (scaledDistance > maxExp) {
          float scale = exp(maxExp - scaledDistance);
          distanceAccum *= scale;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] *= scale;
          }
          maxExp = scaledDistance;
        }

        float weight = exp(scaledDistance - maxExp);
        distanceAccum += weight;
        for (int i = 0; i < numValues; ++i) {
          outValues[i] += weight * values[i];
        }
      }
    }

    if (smoothK == 0.0) {
      return distanceAccum;
    } else {
      // Very distant SDFs may result in 0 accumulation
      if (distanceAccum == 0.0) {
        return 1.0 / 0.0;
      }
      for (int i = 0; i < numValues; ++i) {
        outValues[i] /= distanceAccum;
      }
      return (-log(distanceAccum) - maxExp) * smoothK;
    }
  }

  float modulateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 values[4],
    float softEdge, bool invert
  ) {
    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);
    if (invert) {
      distance = -distance;
    }

    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)
      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);
  }
`),cT=Cr(`
  const uint EDIT_FLAG_BLEND = 0xFFu;
  const uint EDIT_BLEND_MULTIPLY = 0u;
  const uint EDIT_BLEND_SET_RGB = 1u;
  const uint EDIT_BLEND_ADD_RGBA = 2u;
  const uint EDIT_FLAG_INVERT = 0x100u;

  void decodeEdit(
    uvec4 packedEdit, out int sdfFirst, out int sdfCount,
    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth
  ) {
    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;
    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;

    sdfFirst = int(packedEdit.y & 0xFFFFu);
    sdfCount = int(packedEdit.y >> 16u);

    softEdge = uintBitsToFloat(packedEdit.z);
    sdfSmooth = uintBitsToFloat(packedEdit.w);
  }

  void applyRgbaDisplaceEdit(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,
    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba
  ) {
    vec4 values[4];
    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);
    // On Android, moving values[0] is necessary to work around a compiler bug.
    vec4 sdfRgba = values[0];
    vec4 sdfDisplaceScale = values[1];

    vec4 target;
    switch (rgbaBlendMode) {
      case EDIT_BLEND_MULTIPLY:
        target = rgba * sdfRgba;
        break;
      case EDIT_BLEND_SET_RGB:
        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);
        break;
      case EDIT_BLEND_ADD_RGBA:
        target = rgba + sdfRgba;
        break;
      default:
        // Debug output if blend mode not set
        target = vec4(fract(pos), 1.0);
    }
    rgba = mix(rgba, target, modulate);
    pos += sdfDisplaceScale.xyz * modulate;
  }

  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {
    int sdfFirst, sdfCount;
    bool invert;
    uint rgbaBlendMode;
    float softEdge, sdfSmooth;
    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);
    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);
  }
`);function B8(s,t,e,n){return new Vs({inTypes:{gsplat:Ts,sdfArray:oT,numEdits:"int",rgbaDisplaceEdits:"uvec4"},outTypes:{gsplat:Ts},globals:()=>[lT,cT],inputs:{gsplat:s,sdfArray:t,numEdits:e,rgbaDisplaceEdits:n},statements:({inputs:r,outputs:l})=>{const{sdfArray:u,numEdits:A,rgbaDisplaceEdits:d}=r,{gsplat:m}=l;return lc(`
        ${m} = ${r.gsplat};
        if (isGsplatActive(${m}.flags)) {
          for (int editIndex = 0; editIndex < ${A}; ++editIndex) {
            applyPackedRgbaDisplaceEdit(
              ${d}[editIndex], ${u}.sdfTexture, ${u}.numSdfs,
              ${m}.center, ${m}.rgba
            );
          }
        }
      `)}}).outputs.gsplat}const Rd=new Float32Array(1);class M8{constructor(t){this.modifier=t,this.cache=new Map}apply(t){let e=this.cache.get(t);return e||(e=au({index:"int"},{gsplat:Ts},({index:n})=>{const{gsplat:i}=t.apply({index:n});return this.modifier.apply({gsplat:i})}),this.cache.set(t,e)),e}}class Nx{constructor(){this.scale=new t0({value:Number.NEGATIVE_INFINITY}),this.rotate=new qE({value:new Ge(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)}),this.translate=new iE({value:new F(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)})}apply(t){return g8(t,{scale:this.scale,rotate:this.rotate,translate:this.translate})}applyDir(t){return m8(t,{rotate:this.rotate})}applyGsplat(t){return J3(t,{scale:this.scale,rotate:this.rotate,translate:this.translate})}updateFromMatrix(t){const e=new F,n=new Ge,i=new F;t.decompose(i,n,e);const r=(e.x+e.y+e.z)/3;let l=!1;return r!==this.scale.value&&(this.scale.value=r,l=!0),i.equals(this.translate.value)||(this.translate.value.copy(i),l=!0),n.equals(this.rotate.value)||(this.rotate.value.copy(n),l=!0),l}update(t){return t.updateMatrixWorld(),this.updateFromMatrix(t.matrixWorld)}}class Zb extends gn{constructor({numSplats:t,generator:e,construct:n,update:i}){if(super(),this.numSplats=t??0,this.generator=e,this.frameUpdate=i,this.version=0,n){const r=n(this);Object.assign(this,r)}}updateVersion(){this.version+=1}set needsUpdate(t){t&&this.updateVersion()}}const e0=class Wb extends Zb{constructor(t={}){const e=new Nx,n=new Nx,i=new Nx,r=new Nx,l=new qE({value:new We(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY)}),u=new t0({value:0}),A=new t0({value:0}),d={transform:e,viewToWorld:n,worldToView:i,viewToObject:r,recolor:l,time:u,deltaTime:A};if(super({update:({time:m,deltaTime:g,viewToWorld:y,globalEdits:v})=>this.update({time:m,deltaTime:g,viewToWorld:y,globalEdits:v})}),this.isInitialized=!1,this.recolor=new le(1,1,1),this.opacity=1,this.enableViewToObject=!1,this.enableViewToWorld=!1,this.enableWorldToView=!1,this.skinning=null,this.edits=null,this.rgbaDisplaceEdits=null,this.splatRgba=null,this.maxSh=3,this.packedSplats=t.packedSplats??new Wf,this.packedSplats.splatEncoding=t.splatEncoding??{...JE},this.numSplats=this.packedSplats.numSplats,this.editable=t.editable??!0,this.onFrame=t.onFrame,this.context=d,this.objectModifier=t.objectModifier,this.worldModifier=t.worldModifier,this.updateGenerator(),t.url||t.fileBytes||t.constructSplats||t.packedSplats&&!t.packedSplats.isInitialized)this.initialized=this.asyncInitialize(t).then(async()=>{if(this.updateGenerator(),this.isInitialized=!0,t.onLoad){const m=t.onLoad(this);m instanceof Promise&&await m}return this});else if(this.isInitialized=!0,this.initialized=Promise.resolve(this),t.onLoad){const m=t.onLoad(this);m instanceof Promise&&(this.initialized=m.then(()=>this))}this.add(z8())}async asyncInitialize(t){const{url:e,fileBytes:n,fileType:i,fileName:r,maxSplats:l,constructSplats:u,splatEncoding:A}=t;if(e||n||u){const d={url:e,fileBytes:n,fileType:i,fileName:r,maxSplats:l,construct:u,splatEncoding:A};this.packedSplats.reinitialize(d)}this.packedSplats&&(await this.packedSplats.initialized,this.numSplats=this.packedSplats.numSplats,this.updateGenerator())}static async staticInitialize(){await q3(),Wb.isStaticInitialized=!0}pushSplat(t,e,n,i,r){this.packedSplats.pushSplat(t,e,n,i,r)}forEachSplat(t){this.packedSplats.forEachSplat(t)}dispose(){this.packedSplats.dispose()}getBoundingBox(t=!0){if(!this.initialized)throw new Error("Cannot get bounding box before SplatMesh is initialized");const e=new F(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY),n=new F(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY),i=new F,r=[-1,1];return this.packedSplats.forEachSplat((u,A,d,m,g,y)=>{if(t)e.min(A),n.max(A);else for(const v of r)for(const C of r)for(const I of r)i.set(v*d.x,C*d.y,I*d.z),i.applyQuaternion(m),i.add(A),e.min(i),n.max(i)}),new kn(e,n)}constructGenerator(t){const{transform:e,viewToObject:n,recolor:i}=t,r=au({index:"int"},{gsplat:Ts},({index:l})=>{if(!l)throw new Error("index is undefined");let u=wm(this.packedSplats.dyno,l);if(this.maxSh>=1){const{sh1Texture:d,sh2Texture:m,sh3Texture:g}=this.ensureShTextures();if(d){let y=function(w,Q){const{x:R,y:D}=o8(Q).outputs,U=fm(Qf(R,D),Mm("float",.5)),P=fm(QB(D,R),Mm("float",.5));return Qf(U,fm(w,P))};const v=n.translate,{center:C}=ov(u).outputs,I=r8(QB(C,v)),S=D8(u,d,I);let E=y(S,this.packedSplats.dynoSh1MinMax);if(this.maxSh>=2&&m){const w=R8(u,m,I);E=Qf(E,y(w,this.packedSplats.dynoSh2MinMax))}if(this.maxSh>=3&&g){const w=N8(u,g,I);E=Qf(E,y(w,this.packedSplats.dynoSh3MinMax))}let{rgba:B}=ov(u).outputs;B=Qf(B,c8(E,Mm("float",0))),u=sb({gsplat:u,rgba:B})}}if(this.splatRgba){const d=_8(this.splatRgba.dyno,l);u=sb({gsplat:u,rgba:d})}this.skinning&&(u=this.skinning.modify(u)),this.objectModifier&&(u=this.objectModifier.apply({gsplat:u}).gsplat),u=e.applyGsplat(u);const A=fm(i,ov(u).outputs.rgba);return u=sb({gsplat:u,rgba:A}),this.rgbaDisplaceEdits&&(u=this.rgbaDisplaceEdits.modify(u)),this.worldModifier&&(u=this.worldModifier.apply({gsplat:u}).gsplat),{gsplat:u}});this.generator=r}updateGenerator(){this.constructGenerator(this.context)}update({time:t,viewToWorld:e,deltaTime:n,globalEdits:i}){var r;this.numSplats=this.packedSplats.numSplats,this.context.time.value=t,this.context.deltaTime.value=n,Wb.dynoTime.value=t;const{transform:l,viewToObject:u,recolor:A}=this.context;let d=l.update(this);this.context.viewToWorld.updateFromMatrix(e)&&this.enableViewToWorld&&(d=!0);const m=e.clone().invert();this.context.worldToView.updateFromMatrix(m)&&this.enableWorldToView&&(d=!0);const v=new he().compose(l.translate.value,l.rotate.value,new F().setScalar(l.scale.value)).invert().multiply(e);u.updateFromMatrix(v)&&(this.enableViewToObject||this.packedSplats.extra.sh1)&&(d=!0);const C=new We(this.recolor.r,this.recolor.g,this.recolor.b,this.opacity);C.equals(A.value)||(A.value.copy(C),d=!0);const I=this.editable?(this.edits??[]).concat(i):[];this.editable&&!this.edits&&this.traverseVisible(E=>{E instanceof rT&&I.push(E)}),I.sort((E,B)=>E.ordering-B.ordering);const S=I.map(E=>{if(E.sdfs!=null)return{edit:E,sdfs:E.sdfs};const B=[];return E.traverseVisible(w=>{w instanceof S8&&B.push(w)}),{edit:E,sdfs:B}});if(S.length>0&&!this.rgbaDisplaceEdits){const E=S.length,B=S.reduce((w,Q)=>w+Q.sdfs.length,0);this.rgbaDisplaceEdits=new I8({maxEdits:E,maxSdfs:B}),this.updateGenerator()}if(this.rgbaDisplaceEdits){const E=this.rgbaDisplaceEdits.update(S);d||(d=E.updated),E.dynoUpdated&&this.updateGenerator()}d&&this.updateVersion(),(r=this.onFrame)==null||r.call(this,{mesh:this,time:t,deltaTime:n})}raycast(t,e){var n,i;if(!this.packedSplats.packedArray||!this.packedSplats.numSplats)return;const{near:r,far:l,ray:u}=t,A=this.matrixWorld.clone().invert(),d=new Ze().setFromMatrix4(A),m=u.origin.clone().applyMatrix4(A),g=u.direction.clone().applyMatrix3(d),y=new F;A.decompose(new F,new Ge,y),(y.x*y.y*y.z)**(1/3);const C=iP(m.x,m.y,m.z,g.x,g.y,g.z,r,l,this.packedSplats.numSplats,this.packedSplats.packedArray,!0,((n=this.packedSplats.splatEncoding)==null?void 0:n.lnScaleMin)??iu,((i=this.packedSplats.splatEncoding)==null?void 0:i.lnScaleMax)??su);for(const I of C){const S=u.direction.clone().multiplyScalar(I).add(u.origin);e.push({distance:I,point:S,object:this})}}ensureShTextures(){if(!this.packedSplats.extra.sh1)return{};let t=this.packedSplats.extra.sh1Texture;if(!t){let i=this.packedSplats.extra.sh1;const{width:r,height:l,depth:u,maxSplats:A}=vo(i.length/2);if(i.length<A*2){const m=new Uint32Array(A*2);m.set(i),this.packedSplats.extra.sh1=m,i=m}const d=new hl(i,r,l,u);d.format=s0,d.type=Ca,d.internalFormat="RG32UI",d.needsUpdate=!0,t=new rb({value:d,key:"sh1"}),this.packedSplats.extra.sh1Texture=t}if(!this.packedSplats.extra.sh2)return{sh1Texture:t};let e=this.packedSplats.extra.sh2Texture;if(!e){let i=this.packedSplats.extra.sh2;const{width:r,height:l,depth:u,maxSplats:A}=vo(i.length/4);if(i.length<A*4){const m=new Uint32Array(A*4);m.set(i),this.packedSplats.extra.sh2=m,i=m}const d=new hl(i,r,l,u);d.format=sc,d.type=Ca,d.internalFormat="RGBA32UI",d.needsUpdate=!0,e=new rb({value:d,key:"sh2"}),this.packedSplats.extra.sh2Texture=e}if(!this.packedSplats.extra.sh3)return{sh1Texture:t,sh2Texture:e};let n=this.packedSplats.extra.sh3Texture;if(!n){let i=this.packedSplats.extra.sh3;const{width:r,height:l,depth:u,maxSplats:A}=vo(i.length/4);if(i.length<A*4){const m=new Uint32Array(A*4);m.set(i),this.packedSplats.extra.sh3=m,i=m}const d=new hl(i,r,l,u);d.format=sc,d.type=Ca,d.internalFormat="RGBA32UI",d.needsUpdate=!0,n=new rb({value:d,key:"sh3"}),this.packedSplats.extra.sh3Texture=n}return{sh1Texture:t,sh2Texture:e,sh3Texture:n}}};e0.staticInitialized=e0.staticInitialize();e0.isStaticInitialized=!1;e0.dynoTime=new t0({value:0});let lI=e0;const w8=Cr(`
  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {
    // Extract sint7 values packed into 2 x uint32
    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;
    vec3 sh1_0 = vec3(ivec3(
      int(packed.x << 25u) >> 25,
      int(packed.x << 18u) >> 25,
      int(packed.x << 11u) >> 25
    )) / 63.0;
    vec3 sh1_1 = vec3(ivec3(
      int(packed.x << 4u) >> 25,
      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,
      int(packed.y << 22u) >> 25
    )) / 63.0;
    vec3 sh1_2 = vec3(ivec3(
      int(packed.y << 15u) >> 25,
      int(packed.y << 8u) >> 25,
      int(packed.y << 1u) >> 25
    )) / 63.0;

    return sh1_0 * (-0.4886025 * viewDir.y)
      + sh1_1 * (0.4886025 * viewDir.z)
      + sh1_2 * (-0.4886025 * viewDir.x);
  }
`),T8=Cr(`
  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {
    // Extract sint8 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);
    vec3 sh2_0 = vec3(ivec3(
      int(packed.x << 24u) >> 24,
      int(packed.x << 16u) >> 24,
      int(packed.x << 8u) >> 24
    )) / 127.0;
    vec3 sh2_1 = vec3(ivec3(
      int(packed.x) >> 24,
      int(packed.y << 24u) >> 24,
      int(packed.y << 16u) >> 24
    )) / 127.0;
    vec3 sh2_2 = vec3(ivec3(
      int(packed.y << 8u) >> 24,
      int(packed.y) >> 24,
      int(packed.z << 24u) >> 24
    )) / 127.0;
    vec3 sh2_3 = vec3(ivec3(
      int(packed.z << 16u) >> 24,
      int(packed.z << 8u) >> 24,
      int(packed.z) >> 24
    )) / 127.0;
    vec3 sh2_4 = vec3(ivec3(
      int(packed.w << 24u) >> 24,
      int(packed.w << 16u) >> 24,
      int(packed.w << 8u) >> 24
    )) / 127.0;

    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)
      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)
      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))
      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)
      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));
  }
`),Q8=Cr(`
  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {
    // Extract sint6 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);
    vec3 sh3_0 = vec3(ivec3(
      int(packed.x << 26u) >> 26,
      int(packed.x << 20u) >> 26,
      int(packed.x << 14u) >> 26
    )) / 31.0;
    vec3 sh3_1 = vec3(ivec3(
      int(packed.x << 8u) >> 26,
      int(packed.x << 2u) >> 26,
      int((packed.x >> 4u) | (packed.y << 28u)) >> 26
    )) / 31.0;
    vec3 sh3_2 = vec3(ivec3(
      int(packed.y << 22u) >> 26,
      int(packed.y << 16u) >> 26,
      int(packed.y << 10u) >> 26
    )) / 31.0;
    vec3 sh3_3 = vec3(ivec3(
      int(packed.y << 4u) >> 26,
      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,
      int(packed.z << 24u) >> 26
    )) / 31.0;
    vec3 sh3_4 = vec3(ivec3(
      int(packed.z << 18u) >> 26,
      int(packed.z << 12u) >> 26,
      int(packed.z << 6u) >> 26
    )) / 31.0;
    vec3 sh3_5 = vec3(ivec3(
      int(packed.z) >> 26,
      int(packed.w << 26u) >> 26,
      int(packed.w << 20u) >> 26
    )) / 31.0;
    vec3 sh3_6 = vec3(ivec3(
      int(packed.w << 14u) >> 26,
      int(packed.w << 8u) >> 26,
      int(packed.w << 2u) >> 26
    )) / 31.0;

    float xx = viewDir.x * viewDir.x;
    float yy = viewDir.y * viewDir.y;
    float zz = viewDir.z * viewDir.z;
    float xy = viewDir.x * viewDir.y;
    float yz = viewDir.y * viewDir.z;
    float zx = viewDir.z * viewDir.x;

    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))
      + sh3_1 * (2.8906114 * xy * viewDir.z) +
      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))
      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))
      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))
      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))
      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));
  }
`);function D8(s,t,e){return kE({inTypes:{gsplat:Ts,sh1:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:s,sh1:t,viewDir:e},globals:()=>[cc,w8],statements:({inputs:n,outputs:i})=>lc(`
        if (isGsplatActive(${n.gsplat}.flags)) {
          ${i.rgb} = evaluateSH1(${n.gsplat}, ${n.sh1}, ${n.viewDir});
        } else {
          ${i.rgb} = vec3(0.0);
        }
      `)}).outputs.rgb}function R8(s,t,e){return kE({inTypes:{gsplat:Ts,sh2:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:s,sh2:t,viewDir:e},globals:()=>[cc,T8],statements:({inputs:n,outputs:i})=>lc(`
        if (isGsplatActive(${n.gsplat}.flags)) {
          ${i.rgb} = evaluateSH2(${n.gsplat}, ${n.sh2}, ${n.viewDir});
        } else {
          ${i.rgb} = vec3(0.0);
        }
      `)}).outputs.rgb}function N8(s,t,e){return kE({inTypes:{gsplat:Ts,sh3:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:s,sh3:t,viewDir:e},globals:()=>[cc,Q8],statements:({inputs:n,outputs:i})=>lc(`
        if (isGsplatActive(${n.gsplat}.flags)) {
          ${i.rgb} = evaluateSH3(${n.gsplat}, ${n.sh3}, ${n.viewDir});
        } else {
          ${i.rgb} = vec3(0.0);
        }
      `)}).outputs.rgb}const U8=new Fe,L8=new $a;function z8(){const s=new oe(U8,L8);return s.frustumCulled=!1,s.onBeforeRender=function(t,e){if(!e.isScene){this.removeFromParent();return}let n=!1;e.traverse(i=>{i instanceof $b&&(n=!0)}),n||e.add(new $b({renderer:t})),this.removeFromParent()},s}const RB=["char","uchar","short","ushort","int","uint","float","double"],uT=class lv{constructor({fileBytes:t}){this.header="",this.littleEndian=!0,this.elements={},this.comments=[],this.data=null,this.numSplats=0,this.fileBytes=t instanceof ArrayBuffer?new Uint8Array(t):t}async parseHeader(){const e=new ReadableStream({start:l=>{l.enqueue(this.fileBytes.slice(0,65536)),l.close()}}).pipeThrough(new TextDecoderStream).getReader();this.header="";const n=`end_header
`;for(;;){const{value:l,done:u}=await e.read();if(u)throw new Error("Failed to read header");this.header+=l;const A=this.header.indexOf(n);if(A>=0){this.header=this.header.slice(0,A+n.length);break}}const i=new TextEncoder().encode(this.header).length;this.data=new DataView(this.fileBytes.buffer,i),this.elements={};let r=null;this.comments=[],this.header.trim().split(`
`).forEach((l,u)=>{const A=l.trim();if(u===0){if(A!=="ply")throw new Error("Invalid PLY header");return}if(A.length===0)return;const d=A.split(" ");switch(d[0]){case"format":if(d[1]==="binary_little_endian")this.littleEndian=!0;else if(d[1]==="binary_big_endian")this.littleEndian=!1;else throw new Error(`Unsupported PLY format: ${d[1]}`);if(d[2]!=="1.0")throw new Error(`Unsupported PLY version: ${d[2]}`);break;case"end_header":break;case"comment":this.comments.push(A.slice(8));break;case"element":{const m=d[1];r={name:m,count:Number.parseInt(d[2]),properties:{}},this.elements[m]=r;break}case"property":if(r==null)throw new Error("Property must be inside an element");d[1]==="list"?r.properties[d[4]]={isList:!0,type:d[3],countType:d[2]}:r.properties[d[2]]={isList:!1,type:d[1]};break}}),this.elements.vertex&&(this.numSplats=this.elements.vertex.count)}parseData(t){let e=0;const n=this.data;if(n==null)throw new Error("No data to parse");for(const i in this.elements){const r=this.elements[i],{count:l,properties:u}=r,A=G8(u),d=k8(u,this.littleEndian),m=t(r)??(()=>{});for(let g=0;g<l;g++)e=d(n,e,A),m(g,A)}}parseSplats(t,e){if(this.elements.vertex==null)throw new Error("No vertex element found");let n=!1;const i=[];let r=0,l=[],u=[],A=[],d,m,g;function y(){const E=P8[r];l=new Array(3).fill(null).flatMap((B,w)=>[0,1,2].map((Q,R)=>w+R*E/3)),u=new Array(5).fill(null).flatMap((B,w)=>[0,1,2].map((Q,R)=>3+w+R*E/3)),A=new Array(7).fill(null).flatMap((B,w)=>[0,1,2].map((Q,R)=>8+w+R*E/3)),d=r>=1?new Float32Array(9):void 0,m=r>=2?new Float32Array(15):void 0,g=r>=3?new Float32Array(21):void 0}function v(E,B){if(!d)throw new Error("Missing sh1");const w=B.f_rest;for(let Q=0;Q<l.length;Q++)d[Q]=w[l[Q]]*8/255-4;if(m)for(let Q=0;Q<u.length;Q++)m[Q]=w[u[Q]]*8/255-4;if(g)for(let Q=0;Q<A.length;Q++)g[Q]=w[A[Q]]*8/255-4;e?.(E,d,m,g)}function C(E){const{min_x:B,min_y:w,min_z:Q,max_x:R,max_y:D,max_z:U,min_scale_x:P,min_scale_y:z,min_scale_z:L,max_scale_x:k,max_scale_y:Y,max_scale_z:W}=E.properties;if(!B||!w||!Q||!R||!D||!U||!P||!z||!L||!k||!Y||!W)throw new Error("Missing PLY chunk properties");return n=!0,(K,nt)=>{const{min_x:H,min_y:tt,min_z:it,max_x:ot,max_y:At,max_z:V,min_scale_x:st,min_scale_y:xt,min_scale_z:j,max_scale_x:Rt,max_scale_y:dt,max_scale_z:pt,min_r:qt,min_g:Wt,min_b:ce,max_r:Ie,max_g:He,max_b:be}=nt;i.push({min_x:H,min_y:tt,min_z:it,max_x:ot,max_y:At,max_z:V,min_scale_x:st,min_scale_y:xt,min_scale_z:j,max_scale_x:Rt,max_scale_y:dt,max_scale_z:pt,min_r:qt,min_g:Wt,min_b:ce,max_r:Ie,max_g:He,max_b:be})}}function I(E){if(e&&E.name==="sh")return r=jb(E.properties),y(),v;if(E.name!=="vertex")return null;const{packed_position:B,packed_rotation:w,packed_scale:Q,packed_color:R}=E.properties;if(!B||!w||!Q||!R)throw new Error("Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color");const D=Math.sqrt(2);return(U,P)=>{const z=i[U>>>8];if(z==null)throw new Error("Missing PLY chunk");const{min_x:L,min_y:k,min_z:Y,max_x:W,max_y:K,max_z:nt,min_scale_x:H,min_scale_y:tt,min_scale_z:it,max_scale_x:ot,max_scale_y:At,max_scale_z:V,min_r:st,min_g:xt,min_b:j,max_r:Rt,max_g:dt,max_b:pt}=z,{packed_position:qt,packed_rotation:Wt,packed_scale:ce,packed_color:Ie}=P,He=(qt>>>21&2047)/2047*(W-L)+L,be=(qt>>>11&1023)/1023*(K-k)+k,zt=(qt&2047)/2047*(nt-Y)+Y,Z=((Wt>>>20&1023)/1023-.5)*D,Ot=((Wt>>>10&1023)/1023-.5)*D,Vt=((Wt&1023)/1023-.5)*D,Pt=Math.sqrt(Math.max(0,1-Z*Z-Ot*Ot-Vt*Vt)),kt=Wt>>>30,Zt=kt===0?Z:kt===1?Pt:Ot,$t=kt<=1?Ot:kt===2?Pt:Vt,fe=kt<=2?Vt:Pt,$=kt===0?Pt:Z,G=Math.exp((ce>>>21&2047)/2047*(ot-H)+H),ft=Math.exp((ce>>>11&1023)/1023*(At-tt)+tt),Tt=Math.exp((ce&2047)/2047*(V-it)+it),Ht=(Ie>>>24&255)/255*((Rt??1)-(st??0))+(st??0),Bt=(Ie>>>16&255)/255*((dt??1)-(xt??0))+(xt??0),Se=(Ie>>>8&255)/255*((pt??1)-(j??0))+(j??0),ae=(Ie&255)/255;t(U,He,be,zt,G,ft,Tt,Zt,$t,fe,$,ae,Ht,Bt,Se)}}const S=E=>{if(E.name==="chunk")return C(E);if(n)return I(E);if(E.name!=="vertex")return null;const{x:B,y:w,z:Q,scale_0:R,scale_1:D,scale_2:U,rot_0:P,rot_1:z,rot_2:L,rot_3:k,opacity:Y,f_dc_0:W,f_dc_1:K,f_dc_2:nt,red:H,green:tt,blue:it,alpha:ot}=E.properties;if(!B||!w||!Q)throw new Error("Missing PLY properties: x, y, z");const At=R&&D&&U,V=P&&z&&L&&k,st=ot!=null?Lx[ot.type]:1,xt=H!=null?Lx[H.type]:1,j=tt!=null?Lx[tt.type]:1,Rt=it!=null?Lx[it.type]:1;return r=jb(E.properties),y(),(dt,pt)=>{const qt=At?Math.exp(pt.scale_0):lv.defaultPointScale,Wt=At?Math.exp(pt.scale_1):lv.defaultPointScale,ce=At?Math.exp(pt.scale_2):lv.defaultPointScale,Ie=V?pt.rot_1:0,He=V?pt.rot_2:0,be=V?pt.rot_3:0,zt=V?pt.rot_0:1,Z=Y!=null?1/(1+Math.exp(-pt.opacity)):ot!=null?pt.alpha/st:1,Ot=W!=null?pt.f_dc_0*Ux+.5:H!=null?pt.red/xt:1,Vt=K!=null?pt.f_dc_1*Ux+.5:tt!=null?pt.green/j:1,Pt=nt!=null?pt.f_dc_2*Ux+.5:it!=null?pt.blue/Rt:1;if(t(dt,pt.x,pt.y,pt.z,qt,Wt,ce,Ie,He,be,zt,Z,Ot,Vt,Pt),e&&d){const kt=pt.f_rest;if(d)for(let Zt=0;Zt<l.length;Zt++)d[Zt]=kt[l[Zt]];if(m)for(let Zt=0;Zt<u.length;Zt++)m[Zt]=kt[u[Zt]];if(g)for(let Zt=0;Zt<A.length;Zt++)g[Zt]=kt[A[Zt]];e(dt,d,m,g)}}};this.parseData(S)}injectRgba(t){let e=0;const n=this.data;if(n==null)throw new Error("No parsed data");if(t.length!==this.numSplats*4)throw new Error("Invalid RGBA array length");for(const i in this.elements){const r=this.elements[i],{count:l,properties:u}=r,A=[];let d=0;const m=i==="vertex";if(m){for(const g of["opacity","f_dc_0","f_dc_1","f_dc_2"])if(!u[g]||u[g].type!=="float")throw new Error(`Can't injectRgba due to property: ${g}`)}for(const[g,y]of Object.entries(u))if(y.isList)A.push(()=>{const v=Vd[y.countType](n,e,this.littleEndian);e+=ul[y.countType],e+=v*ul[y.type]});else{if(m)if(g==="f_dc_0"||g==="f_dc_1"||g==="f_dc_2"){const v=Number.parseInt(g.slice(5));A.push(()=>{const C=(t[d+v]/255-.5)/Ux;NB[y.type](n,e,this.littleEndian,C)})}else g==="opacity"&&A.push(()=>{const v=Math.max(-100,Math.min(100,-Math.log(1/(t[d+3]/255)-1)));NB[y.type](n,e,this.littleEndian,v)});A.push(()=>{e+=ul[y.type]})}for(let g=0;g<l;g++){for(const y of A)y();m&&(d+=4)}}}};uT.defaultPointScale=.001;let O8=uT;const Ux=.28209479177387814,Vd={char:(s,t,e)=>s.getInt8(t),uchar:(s,t,e)=>s.getUint8(t),short:(s,t,e)=>s.getInt16(t,e),ushort:(s,t,e)=>s.getUint16(t,e),int:(s,t,e)=>s.getInt32(t,e),uint:(s,t,e)=>s.getUint32(t,e),float:(s,t,e)=>s.getFloat32(t,e),double:(s,t,e)=>s.getFloat64(t,e)},NB={char:(s,t,e,n)=>{s.setInt8(t,n)},uchar:(s,t,e,n)=>{s.setUint8(t,n)},short:(s,t,e,n)=>{s.setInt16(t,n,e)},ushort:(s,t,e,n)=>{s.setUint16(t,n,e)},int:(s,t,e,n)=>{s.setInt32(t,n,e)},uint:(s,t,e,n)=>{s.setUint32(t,n,e)},float:(s,t,e,n)=>{s.setFloat32(t,n,e)},double:(s,t,e,n)=>{s.setFloat64(t,n,e)}},ul={char:1,uchar:1,short:2,ushort:2,int:4,uint:4,float:4,double:8},Lx={char:127,uchar:255,short:32767,ushort:65535,int:2147483647,uint:4294967295,float:1,double:1},F8={0:0,9:1,24:2,45:3},P8={0:0,1:9,2:24,3:45},cI=/^f_rest_([0-9]{1,2})$/;function G8(s){const t={};for(const[e,n]of Object.entries(s))cI.test(e)?t.f_rest=new Array(jb(s)):t[e]=n.isList?[]:0;return t}function k8(s,t){return Y8(s)?q8(s,t):X8(s,t)}const H8=(()=>{try{new Function("return 42;")}catch{return!1}return!0})(),V8=/^[a-zA-Z0-9_]+$/;function Y8(s){if(!H8)return!1;for(const[t,e]of Object.entries(s))if(!V8.test(t)||e.isList&&!RB.includes(e.countType)||!RB.includes(e.type))return!1;return!0}function q8(s,t){const e=["let list;"];for(const[i,r]of Object.entries(s)){const l=i.match(cI);if(l){const u=+l[1];e.push(`
        item.f_rest[${u}] = PARSE_FIELD['${r.type}'](data, offset, ${t});
        offset += ${ul[r.type]};
      `)}else r.isList?e.push(`
        list = item['${i}'];
        list.length = PARSE_FIELD['${r.countType}'](data, offset, ${t});
        offset += ${ul[r.countType]};
        for (let i = 0; i < list.length; i++) {
          list[i] = PARSE_FIELD['${r.type}'](data, offset, ${t});
          offset += ${ul[r.type]};
        }
      `):e.push(`
        item['${i}'] = PARSE_FIELD['${r.type}'](data, offset, ${t});
        offset += ${ul[r.type]};
      `)}e.push("return offset;");const n=new Function("data","offset","item","PARSE_FIELD",e.join(`
`));return(i,r,l)=>n(i,r,l,Vd)}function X8(s,t){const e=[];for(const[n,i]of Object.entries(s)){const r=n.match(cI);if(r){const l=+r[1];e.push((u,A,d)=>(d.f_rest[l]=Vd[i.type](u,A,t),A+ul[i.type]))}else i.isList?e.push((l,u,A)=>{const d=A[n];d.length=Vd[i.countType](l,u,t);let m=u+ul[i.countType];for(let g=0;g<d.length;g++)d[g]=Vd[i.type](l,m,t),m+=ul[i.type];return m}):e.push((l,u,A)=>(A[n]=Vd[i.type](l,u,t),u+ul[i.type]))}return(n,i,r)=>{let l=i;for(let u=0;u<e.length;u++)l=e[u](n,l,r);return l}}function jb(s){let t=0;for(;s[`f_rest_${t}`];)t+=1;const e=F8[t];if(e==null)throw new Error(`Unsupported number of SH coefficients: ${t}`);return e}const hT=`(function() {
  "use strict";
  let wasm;
  const cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
    throw Error("TextDecoder not available");
  } };
  if (typeof TextDecoder !== "undefined") {
    cachedTextDecoder.decode();
  }
  let cachedUint8ArrayMemory0 = null;
  function getUint8ArrayMemory0() {
    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
      cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8ArrayMemory0;
  }
  function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
  }
  function sort_splats(num_splats, readback, ordering) {
    const ret = wasm.sort_splats(num_splats, readback, ordering);
    return ret >>> 0;
  }
  function sort32_splats(num_splats, readback, ordering) {
    const ret = wasm.sort32_splats(num_splats, readback, ordering);
    return ret >>> 0;
  }
  async function __wbg_load(module, imports) {
    if (typeof Response === "function" && module instanceof Response) {
      if (typeof WebAssembly.instantiateStreaming === "function") {
        try {
          return await WebAssembly.instantiateStreaming(module, imports);
        } catch (e) {
          if (module.headers.get("Content-Type") != "application/wasm") {
            console.warn("\`WebAssembly.instantiateStreaming\` failed because your server does not serve Wasm with \`application/wasm\` MIME type. Falling back to \`WebAssembly.instantiate\` which is slower. Original error:\\n", e);
          } else {
            throw e;
          }
        }
      }
      const bytes = await module.arrayBuffer();
      return await WebAssembly.instantiate(bytes, imports);
    } else {
      const instance = await WebAssembly.instantiate(module, imports);
      if (instance instanceof WebAssembly.Instance) {
        return { instance, module };
      } else {
        return instance;
      }
    }
  }
  function __wbg_get_imports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {
      const ret = arg0.buffer;
      return ret;
    };
    imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {
      const ret = arg0.length;
      return ret;
    };
    imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {
      const ret = arg0.length;
      return ret;
    };
    imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {
      const ret = arg0.length;
      return ret;
    };
    imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {
      const ret = new Uint16Array(arg0);
      return ret;
    };
    imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {
      const ret = new Uint32Array(arg0);
      return ret;
    };
    imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(arg0, arg1, arg2) {
      const ret = new Float32Array(arg0, arg1 >>> 0, arg2 >>> 0);
      return ret;
    };
    imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(arg0, arg1, arg2) {
      const ret = new Uint32Array(arg0, arg1 >>> 0, arg2 >>> 0);
      return ret;
    };
    imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {
      const ret = new Float32Array(arg0 >>> 0);
      return ret;
    };
    imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {
      arg0.set(arg1, arg2 >>> 0);
    };
    imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {
      arg0.set(arg1, arg2 >>> 0);
    };
    imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {
      arg0.set(arg1, arg2 >>> 0);
    };
    imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {
      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
      return ret;
    };
    imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {
      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
      return ret;
    };
    imports.wbg.__wbindgen_init_externref_table = function() {
      const table = wasm.__wbindgen_export_0;
      const offset = table.grow(4);
      table.set(0, void 0);
      table.set(offset + 0, void 0);
      table.set(offset + 1, null);
      table.set(offset + 2, true);
      table.set(offset + 3, false);
    };
    imports.wbg.__wbindgen_memory = function() {
      const ret = wasm.memory;
      return ret;
    };
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    };
    return imports;
  }
  function __wbg_finalize_init(instance, module) {
    wasm = instance.exports;
    __wbg_init.__wbindgen_wasm_module = module;
    cachedUint8ArrayMemory0 = null;
    wasm.__wbindgen_start();
    return wasm;
  }
  async function __wbg_init(module_or_path) {
    if (wasm !== void 0) return wasm;
    if (typeof module_or_path !== "undefined") {
      if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
        ({ module_or_path } = module_or_path);
      } else {
        console.warn("using deprecated parameters for the initialization function; pass a single object instead");
      }
    }
    if (typeof module_or_path === "undefined") {
      module_or_path = new URL("data:application/wasm;base64,AGFzbQEAAAABzAEeYAJ/fwF/YAJ/fwBgA39/fwF/YAF/AX9gA39/fwBgAX8AYAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAFvAW9gA29vfwBgAW8Bf2AAAX9gBH9/f38AYAAAYAR/f39/AX9gA39vbwF/YAF/AW9gAAFvYAF9AX1gBn9/f39/fwBgDX19fX19fX19f29/fX0Bb2AGf39/f39/AX9gBX9/fH9/AGAEf3x/fwBgBX9/fX9/AGAEf31/fwBgBX9/fn9/AGAEf35/fwBgAn19AX0C8gQRA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZxpfX3diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwAKA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAALA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAcDd2JnGl9fd2JnX25ld19lM2IzMjFkY2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAoDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAsDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoX2U2YjdlNjlhY2Q0YzczNTQABwN3YmcaX193Ymdfc2V0XzEwYmFkOWJlZTBlOWM1OGIACgN3YmcdX193YmdfbGVuZ3RoXzNiNGYwMjIxODhhZThkYjYACwN3YmcfX193Ymdfc3ViYXJyYXlfNzY5ZTFlMGY4MWJiMjU5YgAHA3diZx9fX3diZ19zdWJhcnJheV8zYWFlZWM4OWJiMjU0NGYwAAcDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfNWE1ZWZlMzEzY2ZkNTlmMQARA3diZxBfX3diaW5kZ2VuX3Rocm93AAEDd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABIDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGUADgNhYAMAAQIIBQQCEwEMAAEBAgAAAQwBBAYFBQQAAQYFFAENBAAGBQQEAQQOAgECAQAIBAAVARYG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ACIDKAIEQXhxRgRAIAMhAgwBCyABQRkgAkEBdmtBACACQR9HG3QhBQNAIAMgBUEddkEEcWpBEGoiBCgCACICRQ0CIAVBAXQhBSACIQMgAigCBEF4cSABRw0ACwsgAigCCCIBIAA2AgwgAiAANgIIIABBADYCGCAAIAI2AgwgACABNgIIDwsgBCAANgIAIAAgAzYCGCAAIAA2AgwgACAANgIIC/MCAQR/IwBBMGsiACQAAkACQEGQksAAKAIARQRAQaiSwAAoAgAhAUGoksAAQQA2AgAgAUUNASAAQRhqIAERBQAgAEEQaiICIABBJGopAgA3AwAgACAAKQIcNwMIIAAoAhghAUGQksAAKAIAIgMNAgJAIANFDQBBlJLAACgCACICRQ0AQZiSwAAoAgAgAkECdBBlC0GUksAAIAE2AgBBkJLAAEEBNgIAQZiSwAAgACkDCDcCAEGgksAAIABBEGopAwA3AgALIABBMGokAEGUksAADwsgAEEANgIoIABBATYCHCAAQaCHwAA2AhggAEIENwIgIABBGGpBiIjAABBDAAsgAEEoaiACKQMANwIAIAAgACkDCDcCICAAIAE2AhwgAEEBNgIYAkAgAEEYaiIBKAIARQ0AIAEoAgQiAkUNACABKAIIIAJBAnQQZQsgAEEANgIoIABBATYCHCAAQaiIwAA2AhggAEIENwIgIAFBsIjAABBDAAuoAgIDfwF+IwBBQGoiAiQAIAEoAgBBgICAgHhGBEAgASgCDCEDIAJBJGoiBEEANgIAIAJCgICAgBA3AhwgAkEwaiADKAIAIgNBCGopAgA3AwAgAkE4aiADQRBqKQIANwMAIAIgAykCADcDKCACQRxqQcCIwAAgAkEoahAYGiACQRhqIAQoAgAiAzYCACACIAIpAhwiBTcDECABQQhqIAM2AgAgASAFNwIACyABKQIAIQUgAUKAgICAEDcCACACQQhqIgMgAUEIaiIBKAIANgIAIAFBADYCAEGxk8AALQAAGiACIAU3AwBBDEEEEF0iAUUEQEEEQQwQbQALIAEgAikDADcCACABQQhqIAMoAgA2AgAgAEHgisAANgIEIAAgATYCACACQUBrJAAL0gECBH8BfiMAQSBrIgMkACABIAEgAmoiAksEQEEAQQAQUgALQQggACgCACIEQQF0IgEgAiABIAJLGyICIAJBCEkb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QQRqrUKAgICA4ACENwMoIAEgAa1CgICAgOAAhDcDICABIAFBIGo2AhAgAUEIakHIj8AAEEMAC2kCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQfyNwAA2AgggA0ICNwIUIANCgICAgOAAIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhBDAAtpAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0H4kcAANgIIIANCAjcCFCADQoCAgIDgACIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQQwALZgAjAEEwayIAJABBsJPAAC0AAARAIABBAjYCDCAAQbCKwAA2AgggAEIBNwIUIAAgATYCLCAAIABBLGqtQoCAgIDgAIQ3AyAgACAAQSBqNgIQIABBCGpB0IrAABBDAAsgAEEwaiQAC5QBAgN/AW8jAEEgayIDJAAgAyAAKAIAEHAiBDYCACADIAI2AgQgAiAERwRAIANBADYCCCADIANBBGogA0EIahBAAAsQWyIEEFMiBSUBEAUhBhAbIgIgBiYBIAVBhAFPBEAgBRAtCyACIAAoAgAgAUECdhBkIAJBhAFPBEAgAhAtCyAEQYQBTwRAIAQQLQsgA0EgaiQAC08BAX8jAEEwayIAJAAgAEEBNgIMIABBwI3AADYCCCAAQgE3AhQgACAAQS9qrUKAgICAoAWENwMgIAAgAEEgajYCECAAQQhqQcSBwAAQQwALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhAlIAAoAgghAwsgACgCBCADaiABIAIQHxogACACIANqNgIIQQALTQECf0Gxk8AALQAAGiABKAIEIQIgASgCACEDQQhBBBBdIgFFBEBBBEEIEG0ACyABIAI2AgQgASADNgIAIABB8IrAADYCBCAAIAE2AgALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhApIAAoAgghAwsgACgCBCADaiABIAIQHxogACACIANqNgIIQQALQQEBfyMAQSBrIgIkACACQQA2AhAgAkEBNgIEIAJCBDcCCCACQS42AhwgAiAANgIYIAIgAkEYajYCACACIAEQQwALswIBA38gACgCACECIAEoAhwiAEEQcUUEQCAAQSBxRQRAIAIgARBnDwtBACEAIwBBgAFrIgQkACACKAIAIQIDQCAAIARqQf8AaiACQQ9xIgNBMHIgA0E3aiADQQpJGzoAACAAQQFrIQAgAkEQSSACQQR2IQJFDQALIABBgAFqIgJBgQFPBEAgAhA0AAsgAUHYj8AAQQIgACAEakGAAWpBACAAaxAVIARBgAFqJAAPC0EAIQAjAEGAAWsiBCQAIAIoAgAhAgNAIAAgBGpB/wBqIAJBD3EiA0EwciADQdcAaiADQQpJGzoAACAAQQFrIQAgAkEQSSACQQR2IQJFDQALIABBgAFqIgJBgQFPBEAgAhA0AAsgAUHYj8AAQQIgACAEakGAAWpBACAAaxAVIARBgAFqJAALOAACQCACQYCAxABGDQAgACACIAEoAhARAABFDQBBAQ8LIANFBEBBAA8LIAAgAyAEIAEoAgwRAgAL0AIBAX8jAEEQayIDJAAgAyABNgIMIAMgADYCCCMAQfAAayIAJAAgAEG0hsAANgIMIAAgA0EIajYCCCAAQbSGwAA2AhQgACADQQxqNgIQIABBjI7AADYCGCAAQQI2AhwCQCACKAIARQRAIABBAzYCXCAAQciOwAA2AlggAEIDNwJkIAAgAEEQaq1CgICAgLAFhDcDSCAAIABBCGqtQoCAgICwBYQ3A0AMAQsgAEEwaiACQRBqKQIANwMAIABBKGogAkEIaikCADcDACAAIAIpAgA3AyAgAEEENgJcIABB/I7AADYCWCAAQgQ3AmQgACAAQRBqrUKAgICAsAWENwNQIAAgAEEIaq1CgICAgLAFhDcDSCAAIABBIGqtQoCAgIDQBYQ3A0ALIAAgAEEYaq1CgICAgMAFhDcDOCAAIABBOGo2AmAgAEHYAGpBpIbAABBDAAuyAQECfyMAQRBrIgAkACABKAIUQYCKwABBCyABKAIYKAIMEQIAIQMgAEEIaiICQQA6AAUgAiADOgAEIAIgATYCACACIgEtAAQhAiABLQAFBEAgAQJ/QQEgAkEBcQ0AGiABKAIAIgEtABxBBHFFBEAgASgCFEGxj8AAQQIgASgCGCgCDBECAAwBCyABKAIUQbCPwABBASABKAIYKAIMEQIACyICOgAECyACQQFxIABBEGokAAvrEgIYfxB9EBsiDiAJJgEjAEGAAWsiDSQAIA0gDjYCLCANIAg2AiggDSAHOAIkIA0gBjgCICANIAU4AhwgDSAEOAIYIA0gAzgCFCANIAI4AhAgDSABOAIMIA0gADgCCCANIApBAEc6ADMgDSALOAI0IA0gDDgCOCANQQA2AkQgDUKAgICAwAA3AjwgDSANQThqNgJ8IA0gDUE0ajYCeCANIA1BJGo2AnQgDSANQSBqNgJwIA0gDUEcajYCbCANIA1BGGo2AmggDSANQRRqNgJkIA0gDUEQajYCYCANIA1BDGo2AlwgDSANQQhqNgJYIA0gDUE8ajYCVCANIA1BM2o2AlAgDSANQSxqNgJMIA0gDUEoajYCSCANQcgAaiIYIQgjAEEgayIQJAACQEEAQYiAwAAoAgARAwAiEwRAIBMoAgBFBEAgCCgCNCEZIAgoAjAhGiAIKAIsIRsgCCgCKCEcIAgoAiQhHSAIKAIgIR4gCCgCHCEfIAgoAhghICAIKAIUISEgCCgCECEiIAgoAgwhESAIKAIIISMgCCgCBCEkIAgoAgAhFiATQX82AgAgEyAWKAIAIggEfyATQQxqKAIAIRcgE0EIaigCACEKQQAhDgNAIBAgJCAOQQJ0IA5BgIAEIAggDmsiCCAIQYCABE8bIghqIhRBAnQQZjYCDAJAAkAgFyAIQQJ0Ig5PBEAgEEEMaiAKIA4QOCAZKgIAIQAgGioCACEDIBsqAgAhLyAcKgIAITAgHSoCACEEIB4qAgAhBSAfKgIAIQYgICoCACExICEqAgAhMiAiKgIAITMgIy0AAA0BIAAgA5NDAAB+Q5UhACAGIAaUIAUgBZSSIAQgBJSSIQsgCiEIA0AgDkEEIA5BBEkiDxshEgJAIAgtAAOzQwAAf0OVQ83MzD1dDQAgEEEQaiAIIBIQFwJ9AkAgD0UEQCAQKgIYIQEgECoCFCECIBAqAhAhB0MAAAAAIQxDAAAAACElIAgoAgwiD0H/AXEEQCADIAAgD0EBa0H/AXGzlJIQGSElCyAPQQh2IhVB/wFxBEAgAyAAIBVBAWtB/wFxs5SSEBkhDAsgMSABkyEBIDIgApMhAiAzIAeTIQcgD0EQdiIPQf8BcQ0BQwAAAAAMAgtBAyASQZSCwAAQNQALIAMgACAPQQFrQf8BcbOUkhAZCyEpIAYgB5QgBSAClJIgBCABlJIiJiAmlCALIAcgB5QgAiAClJIgASABlJIgJSAMkiApkkMAAEBAlSIBIAGUk5STIgFDAAAAAF0NACAmjCABkZMgC5UiASAwYEUgASAvX0VyDQAgESgCCCIPIBEoAgBGBEAgERAnCyARKAIEIA9BAnRqIAE4AgAgESAPQQFqNgIICyAIIBJBAnRqIQggDiASayIODQALDAILIA4gF0GIg8AAEDYACyAAIAOTQwAAfkOVISwgCiEIA0AgDkEEIA5BBEkiDxshEgJAIAgtAAOzQwAAf0OVQ83MzD1dDQAgEEEQaiAIIBIQFwJ9AkAgD0UEQCAQKgIYIQAgECoCFCEBIBAqAhAhAkMAAAAAIQdDAAAAACELIAgoAgwiD0H/AXEEQCADICwgD0EBa0H/AXGzlJIQGSELCyAPQQh2IhVB/wFxBEAgAyAsIBVBAWtB/wFxs5SSEBkhBwsgMSAAkyEnIDIgAZMhLSAzIAKTIS4gD0EQdiIVQf8BcQ0BQwAAAAAMAgtBAyASQZSCwAAQNQALIAMgLCAVQQFrQf8BcbOUkhAZCyEMIAQgCCgCCCIVQRh1skMAAP5ClSIAIAUgD0EYdbJDAAD+QpUiAZQgBCAAlJMiKJQgFUEQdsCyQwAA/kKVIgIgBCAClCAGIAGUkyIqlJMgBiAAlCAFIAKUkyIrQwAAgD8gAiAClJMgACAAlJMgASABlJNDAAAAABBQkSIllJIiJiAmkpIhJiAFIAIgK5QgASAolJMgKiAllJIiKSApkpIhKSAGIAEgKpQgACArlJMgKCAllJIiKCAokpIhKCAnIAAgLSABlCAnIACUkyIqlCACICcgApQgLiABlJMiK5STIC4gAJQgLSAClJMiNCAllJIiJyAnkpIhJyAtIAIgNJQgASAqlJMgKyAllJIiAiACkpIhAiAuIAEgK5QgACA0lJMgKiAllJIiACAAkpIhAAJAIAwgCyAHEFAgDBBQQwrXIzyUIgFdRQRAIAEgB15FBEAgASALXkUEQEMAAIA/IAyVIgwgJ5QiASAMICaUIgyUQwAAgD8gC5UiCyAAlCIAIAsgKJQiC5RDAACAPyAHlSIHIAKUIgIgByAplCIHlJKSIiUgJZQgDCAMlCALIAuUIAcgB5SSkiIHIAEgAZQgACAAlCACIAKUkpJDAACAv5KUkyIAQwAAAABdDQQgJYwgAJGTIAeVIQAMAwsgKItDvTeGNV0NAyACICkgAIwgKJUiAJSSIAeVIgEgAZQgJyAmIACUkiAMlSIBIAGUkkMAAIA/XkUNAgwDCyApi0O9N4Y1XQ0CIAAgKCACjCAplSIAlJIgC5UiASABlCAnICYgAJSSIAyVIgEgAZSSQwAAgD9eDQIMAQsgJotDvTeGNV0NASAAICggJ4wgJpUiAJSSIAuVIgEgAZQgAiApIACUkiAHlSIBIAGUkkMAAIA/Xg0BCyAAIDBgRSAAIC9fRXINACARKAIIIg8gESgCAEYEQCARECcLIBEoAgQgD0ECdGogADgCACARIA9BAWo2AggLIAggEkECdGohCCAOIBJrIg4NAAsLIBAoAgwiCEGEAU8EQCAIEC0LIBYoAgAiCCAUIg5LDQALIBMoAgBBAWoFQQALNgIAIBBBIGokAAwCCxA5AAtBnIDAAEHGACAQQR9qQYyAwABBtIHAABAzAAsgDSgCRBANIQkQGyIIIAkmASANIAg2AkggDSgCQCERIA0oAkQhDiMAQSBrIgokACAYKAIAIhMlARAKIRQgCiAONgIEIAogFDYCAAJAIA4gFEYEQBBbIhQQUyIQJQEgESAOEAghCRAbIg4gCSYBIBRBhAFPBEAgFBAtCyAQQYQBTwRAIBAQLQsgEyUBIA4lAUEAEAkgDkGEAU8EQCAOEC0LIApBIGokAAwBCyAKQQA2AgggCiAKQQRqIApBCGoQQAALIA0oAjwiCgRAIA0oAkAgCkECdBBlCyANKAIsIgpBhAFPBEAgChAtCyANQYABaiQAIAglASAIEC0L+gECAn8BfiMAQRBrIgIkACACQQE7AQwgAiABNgIIIAIgADYCBCMAQRBrIgEkACACQQRqIgApAgAhBCABIAA2AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEGci8AAIAEoAgQgASgCCCIALQAIIAAtAAkQLAALIAAgAzYCBCAAIAI2AgAgAEGAi8AAIAEoAgQgASgCCCIALQAIIAAtAAkQLAALJAAgAEUEQEHEhsAAQTIQaAALIAAgAiADIAQgBSABKAIQEQgACyIAIABFBEBBxIbAAEEyEGgACyAAIAIgAyAEIAEoAhARDQALIgAgAEUEQEHEhsAAQTIQaAALIAAgAiADIAQgASgCEBEPAAsiACAARQRAQcSGwABBMhBoAAsgACACIAMgBCABKAIQERgACyIAIABFBEBBxIbAAEEyEGgACyAAIAIgAyAEIAEoAhARGgALIgAgAEUEQEHEhsAAQTIQaAALIAAgAiADIAQgASgCEBEcAAslAQF/IAAoAgAiAUGAgICAeHJBgICAgHhHBEAgACgCBCABEGULCyAAIABFBEBBxIbAAEEyEGgACyAAIAIgAyABKAIQEQQACx4AIABFBEBBxIbAAEEyEGgACyAAIAIgASgCEBEAAAuvDwEPfxAbIgMgASYBEBsiBCACJgEjAEEgayIKJAAgCiAENgIIIAogAzYCBCAKIAA2AgAgCiAKQQRqIgAoAgAQbzYCDCAKIApBCGo2AhwgCiAKNgIYIAogADYCFCAKIApBDGo2AhAgCkEQaiEAIwBB0ABrIgckAAJAAkACQAJAQQBBgIDAACgCABEDACINBEAgDSgCAEUEQCAAKAIMIREgDUF/NgIAIAAoAgQgACgCCCEOIAAoAgAoAgAiBiANQQRqIgQoAggiA0sEQCAGIAMiAGsiCSAEKAIAIABrSwRAIAQgACAJQQJBAhAmIAQoAgghAAsgBCgCBCIMIABBAXRqIQUgCUECTwRAIAUgA0F/cyAGakEBdBAqGiAAIAZqQQF0IANBAXRrIAxqQQJrIQUgACAJakEBayEACyAFQQA7AQAgBCAAQQFqNgIICyAEKAIUIgMgBkkEQCAGIAMiAGsiCSAEKAIMIABrSwRAIARBDGogACAJQQRBBBAmIAQoAhQhAAsgBCgCECIMIABBAnRqIQUgCUECTwRAIAUgA0F/cyAGakECdBAqGiAAIAZqQQJ0IANBAnRrIAxqQQRrIQUgACAJakEBayEACyAFQQA2AgAgBCAAQQFqNgIUCyAEKAIgIgNBgPgBTQRAQYH4ASADIgBrIgUgBCgCGCAAa0sEQCAEQRhqIAAgBUEEQQQQJiAEKAIgIQALIAQoAhwiBiAAQQJ0IglqIQUgA0GA+AFHBH8gBUGA4AcgA0ECdCIFaxAqGiAAIANrQYD4AWohACAJIAVrIAZqQYDgB2oFIAULQQA2AgAgBCAAQQFqNgIgCygCACUBQQAgDigCACIJEAshARAbIgAgASYBIAcgADYCACAJIA0oAgwiAEsNAiANKAIIIQgjAEEgayIAJAAgACAHKAIAEG8iAzYCACAAIAk2AgQgAyAJRwRAIABBADYCCCAAIABBBGogAEEIahBAAAsQWyIFEFMiBiUBEAEhARAbIgMgASYBIAZBhAFPBEAgBhAtCyADJQEgBygCACUBIAhBAXYQAiADQYQBTwRAIAMQLQsgBUGEAU8EQCAFEC0LIABBIGokACAHQQRqIRBBACEAQQAhBSMAQTBrIgYkAAJAAkACQAJAIAkgBCgCCCIDTQRAIAQoAgQhAyAEQQA2AiAgBCgCGEGA+AFNBEAgBEEYakEAQYH4AUEEQQQQJiAEKAIgIQALIAQoAhwiDiAAQQJ0Ig9qQYDgBxAqIAQgAEGB+AFqIgw2AiBBgOAHakEANgIAAkAgCQRAIAlBAXQhCCADIQADQCAALwEAIgtBgPgBSQRAIAsgDE8NAyAOIAtBAnRqIgsgCygCAEEBajYCAAsgAEECaiEAIAhBAmsiCA0ACwsgBkEANgIEAkAgDEECSQ0AIA4gDEECdGpBCGsiACgCACEFIABBADYCACAGIAU2AgQgACAORg0AIA9B+N8HaiILQQJ2QQFqQQNxIggEQCAIQQJ0IQgDQCAAQQRrIgAoAgAhDyAAIAU2AgAgBiAFIA9qIgU2AgQgCEEEayIIDQALCyALQQxJDQAgAEEQayEAA0AgAEEMaiIIKAIAIQsgCCAFNgIAIAYgBSALaiIFNgIEIABBCGoiCCgCACELIAggBTYCACAGIAUgC2oiBTYCBCAAQQRqIggoAgAhCyAIIAU2AgAgBiAFIAtqIgU2AgQgACgCACEIIAAgBTYCACAGIAUgCGoiBTYCBCAAIA5GIABBEGshAEUNAAsLAkAgCQRAIAlBAXQhCCAEKAIQIQ8gBCgCFCEJQQAhAANAIAMvAQAiBEGA+AFJBEAgBCAMTw0DIAkgDiAEQQJ0aiIEKAIAIgtNBEAgCyAJQZiEwAAQNQALIA8gC0ECdGogADYCACAEIAQoAgBBAWo2AgALIANBAmohAyAAQQFqIQAgCEECayIIDQALCyAMRQ0FIA4oAgAgBUcNAyAQQYCAgIB4NgIAIBAgBTYCBAwECyAEIAxBiITAABA1AAsgCyAMQaiEwAAQNQALIAkgA0G4g8AAEDYACyAGQQI2AgwgBkH4g8AANgIIIAZCAjcCFCAGIA6tQoCAgIDgAIQ3AyggBiAGQQRqrUKAgICA4ACENwMgIAYgBkEgajYCECAQIAZBCGoQHQsgBkEwaiQADAELQQBBAEHIg8AAEDUACyAHKAIEQYCAgIB4Rw0DIAcoAggiAEUNBSAAIA0oAhgiA0sNBCANKAIUIQQgByARQQAgABBmIgM2AiggB0EoaiAEIAAQMSADQYQBSQ0FIAMQLQwFCxA5AAtBnIDAAEHGACAHQc8AakGMgMAAQbSBwAAQMwALIAkgAEHAgsAAEDYACyAHQRhqIAdBDGooAgA2AgAgByAHKQIENwMQIAdBATYCLCAHQeCCwAA2AiggB0IBNwI0IAcgB0EQaq1CgICAgMAAhDcDQCAHIAdBQGs2AjAgB0EcaiAHQShqEC8gBygCICAHKAIkEGgACyAAIANB0ILAABA2AAsgBygCACIDQYQBTwRAIAMQLQsgDSANKAIAQQFqNgIAIAdB0ABqJAAgCigCCCIDQYQBTwRAIAMQLQsgCigCBCIDQYQBTwRAIAMQLQsgCkEgaiQAIAALmA8BE38QGyIEIAEmARAbIg8gAiYBIwBBIGsiCiQAIAogDzYCCCAKIAQ2AgQgCiAANgIAIAogCkEEaiIAKAIAEHA2AgwgCiAKQQhqNgIcIAogCjYCGCAKIAA2AhQgCiAKQQxqNgIQIApBEGohACMAQdAAayIIJAACQAJAAkACQEEAQYSAwAAoAgARAwAiEARAIBAoAgBFBEAgACgCDCEUIBBBfzYCACAAKAIEIQQgACgCCCEPIBBBBGoiCSAAKAIAKAIAIgAQEyAIIARBACAPKAIAIgwQZjYCACAMIBAoAgwiBEsNAiAIIBAoAgggDBA4IwBBMGsiDSQAIAkgABATAkACQCAMIAkoAggiAE0EQCAJKAIEIQ8gCSgCHCEEIAkoAiAiDgRAIAQgDkECdBAqGgsgCSgCKCESIAkoAiwiEQRAIBIgEUECdBAqGgsgDARAIAxBAnQhBSAPIQADQAJAIAAoAgAiA0GAgID8B08NACAOIANBf3MiC0H//wNxIgNLBEAgBCADQQJ0aiIDIAMoAgBBAWo2AgAgESALQRB2IgNLBEAgEiADQQJ0aiIDIAMoAgBBAWo2AgAMAgsgAyARQbiFwAAQNQALIAMgDkGohcAAEDUACyAAQQRqIQAgBUEEayIFDQALCyAORQRAQQAhBQwDCyAOQQFrQf////8DcSIAQQFqIgVBB3EhAyAAQQdJBEBBACEFIAQhAAwCCyAFQfj///8HcSELQQAhBSAEIQADQCAAKAIAIQYgACAFNgIAIAAoAgQhByAAIAUgBmoiBTYCBCAAKAIIIQYgACAFIAdqIgU2AgggACgCDCEHIAAgBSAGaiIFNgIMIAAoAhAhBiAAIAUgB2oiBTYCECAAKAIUIQcgACAFIAZqIgU2AhQgACgCGCEGIAAgBSAHaiIFNgIYIAAoAhwhByAAIAUgBmoiBTYCHCAAQSBqIQAgBSAHaiEFIAtBCGsiCw0ACwwBCyAMIABBuITAABA2AAsgA0UNAANAIAAoAgAhCyAAIAU2AgAgAEEEaiEAIAUgC2ohBSADQQFrIgMNAAsLIA0gBTYCBCAMBEAgDEECdCELIAkoAjQhFSAJKAI4IQZBACEDIA8hAANAAkAgACgCACIHQYCAgPwHTw0AAkAgDiAHQX9zQf//A3EiB0sEQCAEIAdBAnRqIgcoAgAiEyAGTw0BIBUgE0ECdGogAzYCACAHIAcoAgBBAWo2AgAMAgsgByAOQYiFwAAQNQALIBMgBkGYhcAAEDUACyAAQQRqIQAgA0EBaiEDIAtBBGsiCw0ACwsgCEEEaiEOAkAgEUUNACARQQFrQf////8DcSIEQQFqIgZBB3EhC0EAIQMgEiEAIARBB08EQCAGQfj///8HcSEEA0AgACgCACEGIAAgAzYCACAAKAIEIQcgACADIAZqIgM2AgQgACgCCCEGIAAgAyAHaiIDNgIIIAAoAgwhByAAIAMgBmoiAzYCDCAAKAIQIQYgACADIAdqIgM2AhAgACgCFCEHIAAgAyAGaiIDNgIUIAAoAhghBiAAIAMgB2oiAzYCGCAAKAIcIQcgACADIAZqIgM2AhwgAEEgaiEAIAMgB2ohAyAEQQhrIgQNAAsLIAtFDQADQCAAKAIAIQQgACADNgIAIABBBGohACADIARqIQMgC0EBayILDQALCwJAIAVFDQAgCSgCNCEDIAkoAjhBAnQhACAJKAIQIRMgCSgCFCELIAUhBAJAAkADQCAARQ0DIAMoAgAiCSAMTw0CIBEgDyAJQQJ0aigCAEF/c0EQdiIGSwRAIBIgBkECdGoiBigCACIHIAtPDQIgA0EEaiEDIBMgB0ECdGogCTYCACAGIAYoAgBBAWo2AgAgAEEEayEAIARBAWsiBA0BDAQLCyAGIBFB6ITAABA1AAsgByALQfiEwAAQNQALIAkgDEHYhMAAEDUACwJAIBFB//8DSwRAAkAgBSASKAL8/w9GBEAgDkGAgICAeDYCACAOIAU2AgQMAQsgDUECNgIMIA1B+IPAADYCCCANQgI3AhQgDSASQfz/D2qtQoCAgIDgAIQ3AyggDSANQQRqrUKAgICA4ACENwMgIA0gDUEgajYCECAOIA1BCGoQHQsgDUEwaiQADAELQf//AyARQciEwAAQNQALIAgoAgRBgICAgHhHDQMgCCgCCCIARQ0FIAAgECgCGCIESw0EIBAoAhQhDyAIIBRBACAAEGYiBDYCKCAIQShqIA8gABAxIARBhAFJDQUgBBAtDAULEDkAC0GcgMAAQcYAIAhBzwBqQYyAwABBtIHAABAzAAsgDCAEQeiCwAAQNgALIAhBGGogCEEMaigCADYCACAIIAgpAgQ3AxAgCEEBNgIsIAhB4ILAADYCKCAIQgE3AjQgCCAIQRBqrUKAgICAwACENwNAIAggCEFAazYCMCAIQRxqIAhBKGoQLyAIKAIgIAgoAiQQaAALIAAgBEH4gsAAEDYACyAIKAIAIgRBhAFPBEAgBBAtCyAQIBAoAgBBAWo2AgAgCEHQAGokACAKKAIIIgRBhAFPBEAgBBAtCyAKKAIEIgRBhAFPBEAgBBAtCyAKQSBqJAAgAAsXAQF/IAAoAgAiAQRAIAAoAgQgARBlCwsUACABIAEgACAAIAFdGyAAIABcGwscACAAQQA2AhAgAEIANwIIIABCgICAgMAANwIAC0QAIABFBEAjAEEgayIAJAAgAEEANgIYIABBATYCDCAAQeyLwAA2AgggAEIENwIQIABBCGpBiIzAABBDAAsgACABEG0ACxYBAW8gACUBEAAhARAbIgAgASYBIAALzgYBBn8CfwJAAkACQAJAAkAgAEEEayIFKAIAIgZBeHEiBEEEQQggBkEDcSIHGyABak8EQCAHQQAgAUEnaiIJIARJGw0BAkACQCACQQlPBEAgAiADEBwiCA0BQQAMCQsgA0HM/3tLDQFBECADQQtqQXhxIANBC0kbIQECQCAHRQRAIAFBgAJJIAQgAUEEcklyIAQgAWtBgYAIT3INAQwJCyAAQQhrIgIgBGohBwJAAkACQAJAIAEgBEsEQCAHQfyWwAAoAgBGDQQgB0H4lsAAKAIARg0CIAcoAgQiBkECcQ0FIAZBeHEiBiAEaiIEIAFJDQUgByAGEB4gBCABayIDQRBJDQEgBSABIAUoAgBBAXFyQQJyNgIAIAEgAmoiASADQQNyNgIEIAIgBGoiAiACKAIEQQFyNgIEIAEgAxAaDA0LIAQgAWsiA0EPSw0CDAwLIAUgBCAFKAIAQQFxckECcjYCACACIARqIgEgASgCBEEBcjYCBAwLC0HwlsAAKAIAIARqIgQgAUkNAgJAIAQgAWsiA0EPTQRAIAUgBkEBcSAEckECcjYCACACIARqIgEgASgCBEEBcjYCBEEAIQNBACEBDAELIAUgASAGQQFxckECcjYCACABIAJqIgEgA0EBcjYCBCACIARqIgIgAzYCACACIAIoAgRBfnE2AgQLQfiWwAAgATYCAEHwlsAAIAM2AgAMCgsgBSABIAZBAXFyQQJyNgIAIAEgAmoiASADQQNyNgIEIAcgBygCBEEBcjYCBCABIAMQGgwJC0H0lsAAKAIAIARqIgQgAUsNBwsgAxARIgFFDQEgASAAQXxBeCAFKAIAIgFBA3EbIAFBeHFqIgEgAyABIANJGxAfIAAQFgwICyAIIAAgASADIAEgA0kbEB8aIAUoAgAiAkF4cSIDIAFBBEEIIAJBA3EiAhtqSQ0DIAJBACADIAlLGw0EIAAQFgsgCAwGC0GBicAAQbCJwAAQPQALQcCJwABB8InAABA9AAtBgYnAAEGwicAAED0AC0HAicAAQfCJwAAQPQALIAUgASAGQQFxckECcjYCACABIAJqIgIgBCABayIBQQFyNgIEQfSWwAAgATYCAEH8lsAAIAI2AgAgAAwBCyAACwsZACABKAIUQaCNwABBDiABKAIYKAIMEQIACxYAIAAoAhQgASACIAAoAhgoAgwRAgALhwIBA39BnJPAACgCAEUEQAJAAkACQAJAIABFDQAgACgCACAAQQA2AgBBAXFFDQAgACgCECECIAAoAgwhASAAKAIIIQMgACgCBCEADAELQQAhAEGxk8AALQAAGkGAgBAhAkGAgBAhAwJAQYCAwAAQESIBRQ0AIAFBBGstAABBA3FFDQAgAUGAgMAAECoaCyABRQ0BC0Gsk8AAIAI2AgBBoJPAACAANgIAQaiTwAAoAgAhAkGok8AAIAE2AgBBpJPAACgCACEAQaSTwAAgAzYCAEGck8AAKAIAQZyTwABBATYCAEUgAEVyRQRAIAIgAEECdBBlCwwBC0EEQYCAwAAQUgALC0Ggk8AAC/ICAQl/QaySwAAoAgBFBEACfwJAIABFDQAgACgCACAAQQA2AgBBAXFFDQAgACgCKCEBIAAoAiQhByAAKAIgIQIgACgCHCEDIAAoAhghCCAAKAIUIQQgACgCECEFIAAoAgwhCSAAKAIIIQYgACgCBAwBC0ECIQlBBCEHQQAhAUEEIQhBAAshAEHUksAAIAE2AgBByJLAACADNgIAQbySwAAgBTYCAEGwksAAIAA2AgBB0JLAACgCACEFQdCSwAAgBzYCAEHMksAAKAIAIQBBzJLAACACNgIAQcSSwAAoAgAhAUHEksAAIAg2AgBBwJLAACgCACECQcCSwAAgBDYCAEG4ksAAKAIAIQRBuJLAACAJNgIAQbSSwAAoAgAhA0G0ksAAIAY2AgBBrJLAACgCACEGQaySwABBATYCAAJAIAZFDQAgAwRAIAQgA0EBdBBlCyACBEAgASACQQJ0EGULIABFDQAgBSAAQQJ0EGULC0GwksAAC8QEARF/QdiSwAAoAgBFBEACQCAABEAgACgCQCEBIAAoAjwhAiAAKAI4IQMgACgCNCEEIAAoAjAhBSAAKAIsIQYgACgCKCEHIAAoAiQhCCAAKAIgIQkgACgCHCEKIAAoAhghCyAAKAIUIQwgACgCECENIAAoAgwhDiAAKAIIIQ8gACgCBCEQIAAoAgAgAEEANgIAQQFxDQELQQQhAkEAIQFBACEDQQAhBEEEIQVBACEGQQAhB0EEIQhBACEJQQAhCkEEIQtBACEMQQAhDUEEIQ5BACEPQQAhEAtBmJPAACABNgIAQYyTwAAgBDYCAEGAk8AAIAc2AgBB9JLAACAKNgIAQeiSwAAgDTYCAEHcksAAIBA2AgBBlJPAACgCACEHQZSTwAAgAjYCAEGQk8AAKAIAIQBBkJPAACADNgIAQYiTwAAoAgAhCkGIk8AAIAU2AgBBhJPAACgCACEBQYSTwAAgBjYCAEH8ksAAKAIAIQVB/JLAACAINgIAQfiSwAAoAgAhAkH4ksAAIAk2AgBB8JLAACgCACEGQfCSwAAgCzYCAEHsksAAKAIAIQNB7JLAACAMNgIAQeSSwAAoAgAhCEHkksAAIA42AgBB4JLAACgCACEEQeCSwAAgDzYCAEHYksAAKAIAIQlB2JLAAEEBNgIAAkAgCUUNACAEBEAgCCAEQQJ0EGULIAMEQCAGIANBAnQQZQsgAgRAIAUgAkECdBBlCyABBEAgCiABQQJ0EGULIABFDQAgByAAQQJ0EGULC0HcksAACxQAIAAoAgAgASAAKAIEKAIMEQAACxQCAW8BfxAPIQAQGyIBIAAmASABCxAAIAEgACgCBCAAKAIIEBQLGQACfyABQQlPBEAgASAAEBwMAQsgABARCwsiACAAQu26rbbNhdT14wA3AwggAEL4gpm9le7Gxbl/NwMACyAAIABC2KGkg7Hi0d18NwMIIABCldfdmMOXiowLNwMACxMAIABB8IrAADYCBCAAIAE2AgALEAAgASAAKAIAIAAoAgQQVgsQACABIAAoAgAgACgCBBAUCxAAIAEoAhQgASgCGCAAEBgLDgAgACUBIAElASACEAYLWwECfwJAAkAgAEEEaygCACICQXhxIgNBBEEIIAJBA3EiAhsgAWpPBEAgAkEAIAMgAUEnaksbDQEgABAWDAILQYGJwABBsInAABA9AAtBwInAAEHwicAAED0ACwsdAQFvIAAoAgAlASABIAIQDCEDEBsiACADJgEgAAvCAgEGfyAAKAIAIQIjAEEQayIEJABBCiEDAkAgAkGQzgBJBEAgAiEADAELA0AgBEEGaiADaiIGQQRrIAIgAkGQzgBuIgBBkM4AbGsiB0H//wNxQeQAbiIFQQF0QdqPwABqLwAAOwAAIAZBAmsgByAFQeQAbGtB//8DcUEBdEHaj8AAai8AADsAACADQQRrIQMgAkH/wdcvSyAAIQINAAsLAkAgAEHjAE0EQCAAIQIMAQsgA0ECayIDIARBBmpqIAAgAEH//wNxQeQAbiICQeQAbGtB//8DcUEBdEHaj8AAai8AADsAAAsCQCACQQpPBEAgA0ECayIDIARBBmpqIAJBAXRB2o/AAGovAAA7AAAMAQsgA0EBayIDIARBBmpqIAJBMHI6AAALIAFBAUEAIARBBmogA2pBCiADaxAVIARBEGokAAsJACAAIAEQDgALDQAgAEHAiMAAIAEQGAsMACAAIAEpAgA3AwALDQAgAEHAi8AAIAEQGAsNACABQbiLwABBBRBWCxkAIAAgAUG8k8AAKAIAIgBBFSAAGxEBAAALCQAgAEEANgIACwgAIAAlARADCwgAIAAlARAHCwueEgQAQYCAwAALCQEAAAACAAAAAwBBlIDAAAuBDAEAAAAFAAAAY2Fubm90IGFjY2VzcyBhIFRocmVhZCBMb2NhbCBTdG9yYWdlIHZhbHVlIGR1cmluZyBvciBhZnRlciBkZXN0cnVjdGlvbi9ydXN0Yy85MGIzNWE2MjM5YzNkOGJkYWJjNTMwYTZhMDgxNmY3ZmY4OWEwYWFmL2xpYnJhcnkvc3RkL3NyYy90aHJlYWQvbG9jYWwucnMAAABiABAATwAAAAQBAAAaAAAAYgAQAE8AAAD4AQAAJgAAAHNwYXJrLWludGVybmFsLXJzL3NyYy9yYXljYXN0LnJz1AAQACAAAAB+AAAAHAAAANQAEAAgAAAAgAAAABwAAADUABAAIAAAAIUAAAAgAAAAc3BhcmstaW50ZXJuYWwtcnMvc3JjL2xpYi5ycyQBEAAcAAAAHQAAADMAAAAkARAAHAAAACgAAAAtAAAAAQAAAAAAAAAkARAAHAAAADoAAAAzAAAAJAEQABwAAABFAAAALQAAACQBEAAcAAAAXgAAACgAAABzcGFyay1pbnRlcm5hbC1ycy9zcmMvc29ydC5ycwAAAJgBEAAdAAAAGwAAAB0AAACYARAAHQAAADkAAAAPAAAARXhwZWN0ZWQgIGFjdGl2ZSBzcGxhdHMgYnV0IGdvdCDYARAACQAAAOEBEAAXAAAAmAEQAB0AAAAzAAAAHQAAAJgBEAAdAAAAMwAAABUAAACYARAAHQAAACQAAAAUAAAAmAEQAB0AAAB0AAAAGQAAAJgBEAAdAAAApwAAABMAAACYARAAHQAAAJ8AAAATAAAAmAEQAB0AAACiAAAAHQAAAJgBEAAdAAAAogAAABEAAACYARAAHQAAAJAAAAAgAAAAmAEQAB0AAACQAAAAFAAAAJgBEAAdAAAAfAAAABgAAACYARAAHQAAAH0AAAAYAAAAL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9qcy1zeXMtMC4zLjc3L3NyYy9saWIucnPIAhAAXAAAAPsYAAABAAAAAAAAAAQAAAAEAAAAEwAAAGNsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkTGF6eSBpbnN0YW5jZSBoYXMgcHJldmlvdXNseSBiZWVuIHBvaXNvbmVkdgMQACoAAAAvVXNlcnMvZG1hcmNvcy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL29uY2VfY2VsbC0xLjIxLjMvc3JjL2xpYi5ycwCoAxAAXwAAAAgDAAAZAAAAcmVlbnRyYW50IGluaXQAABgEEAAOAAAAqAMQAF8AAAB6AgAADQAAABYAAAAMAAAABAAAABcAAAAYAAAAGQAAAC9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjYvc3JjL2RsbWFsbG9jLnJzYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPj0gc2l6ZSArIG1pbl9vdmVyaGVhZABYBBAAKQAAAKgEAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPD0gc2l6ZSArIG1heF9vdmVyaGVhZAAAWAQQACkAAACuBAAADQAAAEFjY2Vzc0Vycm9ybWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAAAAAsFEAAVAAAAIAUQAA0AAABzdGQvc3JjL2FsbG9jLnJzQAUQABAAAABjAQAACQAAABYAAAAMAAAABAAAABoAAAAAAAAACAAAAAQAAAAbAAAAAAAAAAgAAAAEAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAQAAAABAAAACEAAAAiAAAAIwAAACQAAABFcnJvcgAAACUAAAAMAAAABAAAACYAAAAnAAAAKAAAAGNhcGFjaXR5IG92ZXJmbG93AAAA2AUQABEAAABhbGxvYy9zcmMvcmF3X3ZlYy5yc/QFEAAUAAAAGAAAAAUAQaCMwAAL8AUBAAAAKQAAAGEgZm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAfgYQABAAAAB+AgAADgAAAEJvcnJvd011dEVycm9yYWxyZWFkeSBib3Jyb3dlZDogrgYQABIAAABpbmRleCBvdXQgb2YgYm91bmRzOiB0aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIAAAyAYQACAAAADoBhAAEgAAAD09IT1tYXRjaGVzYXNzZXJ0aW9uIGBsZWZ0ICByaWdodGAgZmFpbGVkCiAgbGVmdDogCiByaWdodDogABcHEAAQAAAAJwcQABcAAAA+BxAACQAAACByaWdodGAgZmFpbGVkOiAKICBsZWZ0OiAAAAAXBxAAEAAAAGAHEAAQAAAAcAcQAAkAAAA+BxAACQAAADogAAABAAAAAAAAAJwHEAACAAAAfSB9Y29yZS9zcmMvZm10L251bS5ycwAAswcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTlyYW5nZSBzdGFydCBpbmRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggAACiCBAAEgAAALQIEAAiAAAAcmFuZ2UgZW5kIGluZGV4IOgIEAAQAAAAtAgQACIAAAAAAAA/AAAAvwBBqJLAAAsBFABwCXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS44My4wICg5MGIzNWE2MjMgMjAyNC0xMS0yNikGd2FscnVzBjAuMjMuMwx3YXNtLWJpbmRnZW4HMC4yLjEwMABJD3RhcmdldF9mZWF0dXJlcwQrD211dGFibGUtZ2xvYmFscysIc2lnbi1leHQrD3JlZmVyZW5jZS10eXBlcysKbXVsdGl2YWx1ZQ==", self.location.href);
    }
    const imports = __wbg_get_imports();
    if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {
      module_or_path = fetch(module_or_path);
    }
    const { instance, module } = await __wbg_load(await module_or_path, imports);
    return __wbg_finalize_init(instance, module);
  }
  var ch2 = {};
  var wk = function(c, id, msg, transfer, cb) {
    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([
      c + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
    ], { type: "text/javascript" }))));
    w.onmessage = function(e) {
      var d = e.data, ed = d.$e$;
      if (ed) {
        var err2 = new Error(ed[0]);
        err2["code"] = ed[1];
        err2.stack = ed[2];
        cb(err2, null);
      } else
        cb(null, d);
    };
    w.postMessage(msg, transfer);
    return w;
  };
  var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
  var fleb = new u8([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    /* unused */
    0,
    0,
    /* impossible */
    0
  ]);
  var fdeb = new u8([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    /* unused */
    0,
    0
  ]);
  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var freb = function(eb, start) {
    var b = new u16(31);
    for (var i2 = 0; i2 < 31; ++i2) {
      b[i2] = start += 1 << eb[i2 - 1];
    }
    var r = new i32(b[30]);
    for (var i2 = 1; i2 < 30; ++i2) {
      for (var j = b[i2]; j < b[i2 + 1]; ++j) {
        r[j] = j - b[i2] << 5 | i2;
      }
    }
    return { b, r };
  };
  var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
  fl[28] = 258, revfl[258] = 28;
  var _b = freb(fdeb, 0), fd = _b.b;
  var rev = new u16(32768);
  for (var i = 0; i < 32768; ++i) {
    var x = (i & 43690) >> 1 | (i & 21845) << 1;
    x = (x & 52428) >> 2 | (x & 13107) << 2;
    x = (x & 61680) >> 4 | (x & 3855) << 4;
    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
  }
  var hMap = function(cd, mb, r) {
    var s = cd.length;
    var i2 = 0;
    var l = new u16(mb);
    for (; i2 < s; ++i2) {
      if (cd[i2])
        ++l[cd[i2] - 1];
    }
    var le = new u16(mb);
    for (i2 = 1; i2 < mb; ++i2) {
      le[i2] = le[i2 - 1] + l[i2 - 1] << 1;
    }
    var co;
    if (r) {
      co = new u16(1 << mb);
      var rvb = 15 - mb;
      for (i2 = 0; i2 < s; ++i2) {
        if (cd[i2]) {
          var sv = i2 << 4 | cd[i2];
          var r_1 = mb - cd[i2];
          var v = le[cd[i2] - 1]++ << r_1;
          for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
            co[rev[v] >> rvb] = sv;
          }
        }
      }
    } else {
      co = new u16(s);
      for (i2 = 0; i2 < s; ++i2) {
        if (cd[i2]) {
          co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];
        }
      }
    }
    return co;
  };
  var flt = new u8(288);
  for (var i = 0; i < 144; ++i)
    flt[i] = 8;
  for (var i = 144; i < 256; ++i)
    flt[i] = 9;
  for (var i = 256; i < 280; ++i)
    flt[i] = 7;
  for (var i = 280; i < 288; ++i)
    flt[i] = 8;
  var fdt = new u8(32);
  for (var i = 0; i < 32; ++i)
    fdt[i] = 5;
  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
  var max = function(a) {
    var m = a[0];
    for (var i2 = 1; i2 < a.length; ++i2) {
      if (a[i2] > m)
        m = a[i2];
    }
    return m;
  };
  var bits = function(d, p, m) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
  };
  var bits16 = function(d, p) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
  };
  var shft = function(p) {
    return (p + 7) / 8 | 0;
  };
  var slc = function(v, s, e) {
    if (s == null || s < 0)
      s = 0;
    if (e == null || e > v.length)
      e = v.length;
    return new u8(v.subarray(s, e));
  };
  var ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
    // determined by unknown compression method
  ];
  var err = function(ind, msg, nt) {
    var e = new Error(msg || ec[ind]);
    e.code = ind;
    if (Error.captureStackTrace)
      Error.captureStackTrace(e, err);
    if (!nt)
      throw e;
    return e;
  };
  var inflt = function(dat, st, buf, dict) {
    var sl = dat.length, dl = dict ? dict.length : 0;
    if (!sl || st.f && !st.l)
      return buf || new u8(0);
    var noBuf = !buf;
    var resize = noBuf || st.i != 2;
    var noSt = st.i;
    if (noBuf)
      buf = new u8(sl * 3);
    var cbuf = function(l2) {
      var bl = buf.length;
      if (l2 > bl) {
        var nbuf = new u8(Math.max(bl * 2, l2));
        nbuf.set(buf);
        buf = nbuf;
      }
    };
    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    var tbts = sl * 8;
    do {
      if (!lm) {
        final = bits(dat, pos, 1);
        var type = bits(dat, pos + 1, 3);
        pos += 3;
        if (!type) {
          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
          if (t > sl) {
            if (noSt)
              err(0);
            break;
          }
          if (resize)
            cbuf(bt + l);
          buf.set(dat.subarray(s, t), bt);
          st.b = bt += l, st.p = pos = t * 8, st.f = final;
          continue;
        } else if (type == 1)
          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
        else if (type == 2) {
          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
          var tl = hLit + bits(dat, pos + 5, 31) + 1;
          pos += 14;
          var ldt = new u8(tl);
          var clt = new u8(19);
          for (var i2 = 0; i2 < hcLen; ++i2) {
            clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
          }
          pos += hcLen * 3;
          var clb = max(clt), clbmsk = (1 << clb) - 1;
          var clm = hMap(clt, clb, 1);
          for (var i2 = 0; i2 < tl; ) {
            var r = clm[bits(dat, pos, clbmsk)];
            pos += r & 15;
            var s = r >> 4;
            if (s < 16) {
              ldt[i2++] = s;
            } else {
              var c = 0, n = 0;
              if (s == 16)
                n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];
              else if (s == 17)
                n = 3 + bits(dat, pos, 7), pos += 3;
              else if (s == 18)
                n = 11 + bits(dat, pos, 127), pos += 7;
              while (n--)
                ldt[i2++] = c;
            }
          }
          var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
          lbt = max(lt);
          dbt = max(dt);
          lm = hMap(lt, lbt, 1);
          dm = hMap(dt, dbt, 1);
        } else
          err(1);
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
      }
      if (resize)
        cbuf(bt + 131072);
      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
      var lpos = pos;
      for (; ; lpos = pos) {
        var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
        pos += c & 15;
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (!c)
          err(2);
        if (sym < 256)
          buf[bt++] = sym;
        else if (sym == 256) {
          lpos = pos, lm = null;
          break;
        } else {
          var add = sym - 254;
          if (sym > 264) {
            var i2 = sym - 257, b = fleb[i2];
            add = bits(dat, pos, (1 << b) - 1) + fl[i2];
            pos += b;
          }
          var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
          if (!d)
            err(3);
          pos += d & 15;
          var dt = fd[dsym];
          if (dsym > 3) {
            var b = fdeb[dsym];
            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
          }
          if (pos > tbts) {
            if (noSt)
              err(0);
            break;
          }
          if (resize)
            cbuf(bt + 131072);
          var end = bt + add;
          if (bt < dt) {
            var shift = dl - dt, dend = Math.min(dt, end);
            if (shift + bt < 0)
              err(3);
            for (; bt < dend; ++bt)
              buf[bt] = dict[shift + bt];
          }
          for (; bt < end; ++bt)
            buf[bt] = buf[bt - dt];
        }
      }
      st.l = lm, st.p = lpos, st.b = bt, st.f = final;
      if (lm)
        final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!final);
    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
  };
  var et = /* @__PURE__ */ new u8(0);
  var mrg = function(a, b) {
    var o = {};
    for (var k in a)
      o[k] = a[k];
    for (var k in b)
      o[k] = b[k];
    return o;
  };
  var wcln = function(fn, fnStr, td2) {
    var dt = fn();
    var st = fn.toString();
    var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\\s+/g, "").split(",");
    for (var i2 = 0; i2 < dt.length; ++i2) {
      var v = dt[i2], k = ks[i2];
      if (typeof v == "function") {
        fnStr += ";" + k + "=";
        var st_1 = v.toString();
        if (v.prototype) {
          if (st_1.indexOf("[native code]") != -1) {
            var spInd = st_1.indexOf(" ", 8) + 1;
            fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
          } else {
            fnStr += st_1;
            for (var t in v.prototype)
              fnStr += ";" + k + ".prototype." + t + "=" + v.prototype[t].toString();
          }
        } else
          fnStr += st_1;
      } else
        td2[k] = v;
    }
    return fnStr;
  };
  var ch = [];
  var cbfs = function(v) {
    var tl = [];
    for (var k in v) {
      if (v[k].buffer) {
        tl.push((v[k] = new v[k].constructor(v[k])).buffer);
      }
    }
    return tl;
  };
  var wrkr = function(fns, init, id, cb) {
    if (!ch[id]) {
      var fnStr = "", td_1 = {}, m = fns.length - 1;
      for (var i2 = 0; i2 < m; ++i2)
        fnStr = wcln(fns[i2], fnStr, td_1);
      ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };
    }
    var td2 = mrg({}, ch[id].e);
    return wk(ch[id].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id, td2, cbfs(td2), cb);
  };
  var bInflt = function() {
    return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt];
  };
  var pbf = function(msg) {
    return postMessage(msg, [msg.buffer]);
  };
  var gopt = function(o) {
    return o && {
      out: o.size && new u8(o.size),
      dictionary: o.dictionary
    };
  };
  var cbify = function(dat, opts, fns, init, id, cb) {
    var w = wrkr(fns, init, id, function(err2, dat2) {
      w.terminate();
      cb(err2, dat2);
    });
    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);
    return function() {
      w.terminate();
    };
  };
  var b2 = function(d, b) {
    return d[b] | d[b + 1] << 8;
  };
  var b4 = function(d, b) {
    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
  };
  var b8 = function(d, b) {
    return b4(d, b) + b4(d, b + 4) * 4294967296;
  };
  var gzs = function(d) {
    if (d[0] != 31 || d[1] != 139 || d[2] != 8)
      err(6, "invalid gzip data");
    var flg = d[3];
    var st = 10;
    if (flg & 4)
      st += (d[10] | d[11] << 8) + 2;
    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
      ;
    return st + (flg & 2);
  };
  var Inflate = /* @__PURE__ */ function() {
    function Inflate2(opts, cb) {
      if (typeof opts == "function")
        cb = opts, opts = {};
      this.ondata = cb;
      var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
      this.s = { i: 0, b: dict ? dict.length : 0 };
      this.o = new u8(32768);
      this.p = new u8(0);
      if (dict)
        this.o.set(dict);
    }
    Inflate2.prototype.e = function(c) {
      if (!this.ondata)
        err(5);
      if (this.d)
        err(4);
      if (!this.p.length)
        this.p = c;
      else if (c.length) {
        var n = new u8(this.p.length + c.length);
        n.set(this.p), n.set(c, this.p.length), this.p = n;
      }
    };
    Inflate2.prototype.c = function(final) {
      this.s.i = +(this.d = final || false);
      var bts = this.s.b;
      var dt = inflt(this.p, this.s, this.o);
      this.ondata(slc(dt, bts, this.s.b), this.d);
      this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
      this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
    };
    Inflate2.prototype.push = function(chunk, final) {
      this.e(chunk), this.c(final);
    };
    return Inflate2;
  }();
  function inflate(data, opts, cb) {
    if (!cb)
      cb = opts, opts = {};
    if (typeof cb != "function")
      err(7);
    return cbify(data, opts, [
      bInflt
    ], function(ev) {
      return pbf(inflateSync(ev.data[0], gopt(ev.data[1])));
    }, 1, cb);
  }
  function inflateSync(data, opts) {
    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
  }
  var Gunzip = /* @__PURE__ */ function() {
    function Gunzip2(opts, cb) {
      this.v = 1;
      this.r = 0;
      Inflate.call(this, opts, cb);
    }
    Gunzip2.prototype.push = function(chunk, final) {
      Inflate.prototype.e.call(this, chunk);
      this.r += chunk.length;
      if (this.v) {
        var p = this.p.subarray(this.v - 1);
        var s = p.length > 3 ? gzs(p) : 4;
        if (s > p.length) {
          if (!final)
            return;
        } else if (this.v > 1 && this.onmember) {
          this.onmember(this.r - p.length);
        }
        this.p = p.subarray(s), this.v = 0;
      }
      Inflate.prototype.c.call(this, final);
      if (this.s.f && !this.s.l && !final) {
        this.v = shft(this.s.p) + 9;
        this.s = { i: 0 };
        this.o = new u8(0);
        this.push(new u8(0), final);
      }
    };
    return Gunzip2;
  }();
  var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
  try {
    td.decode(et, { stream: true });
  } catch (e) {
  }
  var dutf8 = function(d) {
    for (var r = "", i2 = 0; ; ) {
      var c = d[i2++];
      var eb = (c > 127) + (c > 223) + (c > 239);
      if (i2 + eb > d.length)
        return { s: r, r: slc(d, i2 - 1) };
      if (!eb)
        r += String.fromCharCode(c);
      else if (eb == 3) {
        c = ((c & 15) << 18 | (d[i2++] & 63) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
      } else if (eb & 1)
        r += String.fromCharCode((c & 31) << 6 | d[i2++] & 63);
      else
        r += String.fromCharCode((c & 15) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63);
    }
  };
  function strFromU8(dat, latin1) {
    if (latin1) {
      var r = "";
      for (var i2 = 0; i2 < dat.length; i2 += 16384)
        r += String.fromCharCode.apply(null, dat.subarray(i2, i2 + 16384));
      return r;
    } else if (td) {
      return td.decode(dat);
    } else {
      var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;
      if (r.length)
        err(8);
      return s;
    }
  }
  var slzh = function(d, b) {
    return b + 30 + b2(d, b + 26) + b2(d, b + 28);
  };
  var zh = function(d, b, z) {
    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);
    var _a2 = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a2[0], su = _a2[1], off = _a2[2];
    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];
  };
  var z64e = function(d, b) {
    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
      ;
    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
  };
  var mt = typeof queueMicrotask == "function" ? queueMicrotask : typeof setTimeout == "function" ? setTimeout : function(fn) {
    fn();
  };
  function unzip(data, opts, cb) {
    if (!cb)
      cb = opts, opts = {};
    if (typeof cb != "function")
      err(7);
    var term = [];
    var tAll = function() {
      for (var i3 = 0; i3 < term.length; ++i3)
        term[i3]();
    };
    var files = {};
    var cbd = function(a, b) {
      mt(function() {
        cb(a, b);
      });
    };
    mt(function() {
      cbd = cb;
    });
    var e = data.length - 22;
    for (; b4(data, e) != 101010256; --e) {
      if (!e || data.length - e > 65558) {
        cbd(err(13, 0, 1), null);
        return tAll;
      }
    }
    var lft = b2(data, e + 8);
    if (lft) {
      var c = lft;
      var o = b4(data, e + 16);
      var z = o == 4294967295 || c == 65535;
      if (z) {
        var ze = b4(data, e - 12);
        z = b4(data, ze) == 101075792;
        if (z) {
          c = lft = b4(data, ze + 32);
          o = b4(data, ze + 48);
        }
      }
      var fltr = opts && opts.filter;
      var _loop_3 = function(i3) {
        var _a2 = zh(data, o, z), c_1 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);
        o = no;
        var cbl = function(e2, d) {
          if (e2) {
            tAll();
            cbd(e2, null);
          } else {
            if (d)
              files[fn] = d;
            if (!--lft)
              cbd(null, files);
          }
        };
        if (!fltr || fltr({
          name: fn,
          size: sc,
          originalSize: su,
          compression: c_1
        })) {
          if (!c_1)
            cbl(null, slc(data, b, b + sc));
          else if (c_1 == 8) {
            var infl = data.subarray(b, b + sc);
            if (su < 524288 || sc > 0.8 * su) {
              try {
                cbl(null, inflateSync(infl, { out: new u8(su) }));
              } catch (e2) {
                cbl(e2, null);
              }
            } else
              term.push(inflate(infl, { size: su }, cbl));
          } else
            cbl(err(14, "unknown compression type " + c_1, 1), null);
        } else
          cbl(null, null);
      };
      for (var i2 = 0; i2 < c; ++i2) {
        _loop_3(i2);
      }
    } else
      cbd(null, {});
    return tAll;
  }
  function unzipSync(data, opts) {
    var files = {};
    var e = data.length - 22;
    for (; b4(data, e) != 101010256; --e) {
      if (!e || data.length - e > 65558)
        err(13);
    }
    var c = b2(data, e + 8);
    if (!c)
      return {};
    var o = b4(data, e + 16);
    var z = o == 4294967295 || c == 65535;
    if (z) {
      var ze = b4(data, e - 12);
      z = b4(data, ze) == 101075792;
      if (z) {
        c = b4(data, ze + 32);
        o = b4(data, ze + 48);
      }
    }
    var fltr = opts && opts.filter;
    for (var i2 = 0; i2 < c; ++i2) {
      var _a2 = zh(data, o, z), c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);
      o = no;
      if (!fltr || fltr({
        name: fn,
        size: sc,
        originalSize: su,
        compression: c_2
      })) {
        if (!c_2)
          files[fn] = slc(data, b, b + sc);
        else if (c_2 == 8)
          files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });
        else
          err(14, "unknown compression type " + c_2);
      }
    }
    return files;
  }
  /**
   * @license
   * Copyright 2010-2025 Three.js Authors
   * SPDX-License-Identifier: MIT
   */
  const REVISION = "178";
  const NoColorSpace = "";
  const SRGBColorSpace = "srgb";
  const LinearSRGBColorSpace = "srgb-linear";
  const LinearTransfer = "linear";
  const SRGBTransfer = "srgb";
  function clamp(value, min, max2) {
    return Math.max(min, Math.min(max2, value));
  }
  function euclideanModulo(n, m) {
    return (n % m + m) % m;
  }
  function lerp(x2, y, t) {
    return (1 - t) * x2 + t * y;
  }
  class Quaternion {
    /**
     * Constructs a new quaternion.
     *
     * @param {number} [x=0] - The x value of this quaternion.
     * @param {number} [y=0] - The y value of this quaternion.
     * @param {number} [z=0] - The z value of this quaternion.
     * @param {number} [w=1] - The w value of this quaternion.
     */
    constructor(x2 = 0, y = 0, z = 0, w = 1) {
      this.isQuaternion = true;
      this._x = x2;
      this._y = y;
      this._z = z;
      this._w = w;
    }
    /**
     * Interpolates between two quaternions via SLERP. This implementation assumes the
     * quaternion data are managed  in flat arrays.
     *
     * @param {Array<number>} dst - The destination array.
     * @param {number} dstOffset - An offset into the destination array.
     * @param {Array<number>} src0 - The source array of the first quaternion.
     * @param {number} srcOffset0 - An offset into the first source array.
     * @param {Array<number>} src1 -  The source array of the second quaternion.
     * @param {number} srcOffset1 - An offset into the second source array.
     * @param {number} t - The interpolation factor in the range \`[0,1]\`.
     * @see {@link Quaternion#slerp}
     */
    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
      let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
      if (t === 0) {
        dst[dstOffset + 0] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
        return;
      }
      if (t === 1) {
        dst[dstOffset + 0] = x1;
        dst[dstOffset + 1] = y1;
        dst[dstOffset + 2] = z1;
        dst[dstOffset + 3] = w1;
        return;
      }
      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
        let s = 1 - t;
        const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
        if (sqrSin > Number.EPSILON) {
          const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
          s = Math.sin(s * len) / sin;
          t = Math.sin(t * len) / sin;
        }
        const tDir = t * dir;
        x0 = x0 * s + x1 * tDir;
        y0 = y0 * s + y1 * tDir;
        z0 = z0 * s + z1 * tDir;
        w0 = w0 * s + w1 * tDir;
        if (s === 1 - t) {
          const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
          x0 *= f;
          y0 *= f;
          z0 *= f;
          w0 *= f;
        }
      }
      dst[dstOffset] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
    }
    /**
     * Multiplies two quaternions. This implementation assumes the quaternion data are managed
     * in flat arrays.
     *
     * @param {Array<number>} dst - The destination array.
     * @param {number} dstOffset - An offset into the destination array.
     * @param {Array<number>} src0 - The source array of the first quaternion.
     * @param {number} srcOffset0 - An offset into the first source array.
     * @param {Array<number>} src1 -  The source array of the second quaternion.
     * @param {number} srcOffset1 - An offset into the second source array.
     * @return {Array<number>} The destination array.
     * @see {@link Quaternion#multiplyQuaternions}.
     */
    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
      const x0 = src0[srcOffset0];
      const y0 = src0[srcOffset0 + 1];
      const z0 = src0[srcOffset0 + 2];
      const w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1];
      const y1 = src1[srcOffset1 + 1];
      const z1 = src1[srcOffset1 + 2];
      const w1 = src1[srcOffset1 + 3];
      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
      return dst;
    }
    /**
     * The x value of this quaternion.
     *
     * @type {number}
     * @default 0
     */
    get x() {
      return this._x;
    }
    set x(value) {
      this._x = value;
      this._onChangeCallback();
    }
    /**
     * The y value of this quaternion.
     *
     * @type {number}
     * @default 0
     */
    get y() {
      return this._y;
    }
    set y(value) {
      this._y = value;
      this._onChangeCallback();
    }
    /**
     * The z value of this quaternion.
     *
     * @type {number}
     * @default 0
     */
    get z() {
      return this._z;
    }
    set z(value) {
      this._z = value;
      this._onChangeCallback();
    }
    /**
     * The w value of this quaternion.
     *
     * @type {number}
     * @default 1
     */
    get w() {
      return this._w;
    }
    set w(value) {
      this._w = value;
      this._onChangeCallback();
    }
    /**
     * Sets the quaternion components.
     *
     * @param {number} x - The x value of this quaternion.
     * @param {number} y - The y value of this quaternion.
     * @param {number} z - The z value of this quaternion.
     * @param {number} w - The w value of this quaternion.
     * @return {Quaternion} A reference to this quaternion.
     */
    set(x2, y, z, w) {
      this._x = x2;
      this._y = y;
      this._z = z;
      this._w = w;
      this._onChangeCallback();
      return this;
    }
    /**
     * Returns a new quaternion with copied values from this instance.
     *
     * @return {Quaternion} A clone of this instance.
     */
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    /**
     * Copies the values of the given quaternion to this instance.
     *
     * @param {Quaternion} quaternion - The quaternion to copy.
     * @return {Quaternion} A reference to this quaternion.
     */
    copy(quaternion) {
      this._x = quaternion.x;
      this._y = quaternion.y;
      this._z = quaternion.z;
      this._w = quaternion.w;
      this._onChangeCallback();
      return this;
    }
    /**
     * Sets this quaternion from the rotation specified by the given
     * Euler angles.
     *
     * @param {Euler} euler - The Euler angles.
     * @param {boolean} [update=true] - Whether the internal \`onChange\` callback should be executed or not.
     * @return {Quaternion} A reference to this quaternion.
     */
    setFromEuler(euler, update = true) {
      const x2 = euler._x, y = euler._y, z = euler._z, order = euler._order;
      const cos = Math.cos;
      const sin = Math.sin;
      const c1 = cos(x2 / 2);
      const c2 = cos(y / 2);
      const c3 = cos(z / 2);
      const s1 = sin(x2 / 2);
      const s2 = sin(y / 2);
      const s3 = sin(z / 2);
      switch (order) {
        case "XYZ":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "YXZ":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case "ZXY":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "ZYX":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case "YZX":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "XZY":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
      }
      if (update === true) this._onChangeCallback();
      return this;
    }
    /**
     * Sets this quaternion from the given axis and angle.
     *
     * @param {Vector3} axis - The normalized axis.
     * @param {number} angle - The angle in radians.
     * @return {Quaternion} A reference to this quaternion.
     */
    setFromAxisAngle(axis, angle) {
      const halfAngle = angle / 2, s = Math.sin(halfAngle);
      this._x = axis.x * s;
      this._y = axis.y * s;
      this._z = axis.z * s;
      this._w = Math.cos(halfAngle);
      this._onChangeCallback();
      return this;
    }
    /**
     * Sets this quaternion from the given rotation matrix.
     *
     * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
     * @return {Quaternion} A reference to this quaternion.
     */
    setFromRotationMatrix(m) {
      const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
      if (trace > 0) {
        const s = 0.5 / Math.sqrt(trace + 1);
        this._w = 0.25 / s;
        this._x = (m32 - m23) * s;
        this._y = (m13 - m31) * s;
        this._z = (m21 - m12) * s;
      } else if (m11 > m22 && m11 > m33) {
        const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
        this._w = (m32 - m23) / s;
        this._x = 0.25 * s;
        this._y = (m12 + m21) / s;
        this._z = (m13 + m31) / s;
      } else if (m22 > m33) {
        const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
        this._w = (m13 - m31) / s;
        this._x = (m12 + m21) / s;
        this._y = 0.25 * s;
        this._z = (m23 + m32) / s;
      } else {
        const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
        this._w = (m21 - m12) / s;
        this._x = (m13 + m31) / s;
        this._y = (m23 + m32) / s;
        this._z = 0.25 * s;
      }
      this._onChangeCallback();
      return this;
    }
    /**
     * Sets this quaternion to the rotation required to rotate the direction vector
     * \`vFrom\` to the direction vector \`vTo\`.
     *
     * @param {Vector3} vFrom - The first (normalized) direction vector.
     * @param {Vector3} vTo - The second (normalized) direction vector.
     * @return {Quaternion} A reference to this quaternion.
     */
    setFromUnitVectors(vFrom, vTo) {
      let r = vFrom.dot(vTo) + 1;
      if (r < 1e-8) {
        r = 0;
        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          this._x = -vFrom.y;
          this._y = vFrom.x;
          this._z = 0;
          this._w = r;
        } else {
          this._x = 0;
          this._y = -vFrom.z;
          this._z = vFrom.y;
          this._w = r;
        }
      } else {
        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
        this._w = r;
      }
      return this.normalize();
    }
    /**
     * Returns the angle between this quaternion and the given one in radians.
     *
     * @param {Quaternion} q - The quaternion to compute the angle with.
     * @return {number} The angle in radians.
     */
    angleTo(q) {
      return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
    }
    /**
     * Rotates this quaternion by a given angular step to the given quaternion.
     * The method ensures that the final quaternion will not overshoot \`q\`.
     *
     * @param {Quaternion} q - The target quaternion.
     * @param {number} step - The angular step in radians.
     * @return {Quaternion} A reference to this quaternion.
     */
    rotateTowards(q, step) {
      const angle = this.angleTo(q);
      if (angle === 0) return this;
      const t = Math.min(1, step / angle);
      this.slerp(q, t);
      return this;
    }
    /**
     * Sets this quaternion to the identity quaternion; that is, to the
     * quaternion that represents "no rotation".
     *
     * @return {Quaternion} A reference to this quaternion.
     */
    identity() {
      return this.set(0, 0, 0, 1);
    }
    /**
     * Inverts this quaternion via {@link Quaternion#conjugate}. The
     * quaternion is assumed to have unit length.
     *
     * @return {Quaternion} A reference to this quaternion.
     */
    invert() {
      return this.conjugate();
    }
    /**
     * Returns the rotational conjugate of this quaternion. The conjugate of a
     * quaternion represents the same rotation in the opposite direction about
     * the rotational axis.
     *
     * @return {Quaternion} A reference to this quaternion.
     */
    conjugate() {
      this._x *= -1;
      this._y *= -1;
      this._z *= -1;
      this._onChangeCallback();
      return this;
    }
    /**
     * Calculates the dot product of this quaternion and the given one.
     *
     * @param {Quaternion} v - The quaternion to compute the dot product with.
     * @return {number} The result of the dot product.
     */
    dot(v) {
      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    }
    /**
     * Computes the squared Euclidean length (straight-line length) of this quaternion,
     * considered as a 4 dimensional vector. This can be useful if you are comparing the
     * lengths of two quaternions, as this is a slightly more efficient calculation than
     * {@link Quaternion#length}.
     *
     * @return {number} The squared Euclidean length.
     */
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    /**
     * Computes the Euclidean length (straight-line length) of this quaternion,
     * considered as a 4 dimensional vector.
     *
     * @return {number} The Euclidean length.
     */
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    /**
     * Normalizes this quaternion - that is, calculated the quaternion that performs
     * the same rotation as this one, but has a length equal to \`1\`.
     *
     * @return {Quaternion} A reference to this quaternion.
     */
    normalize() {
      let l = this.length();
      if (l === 0) {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
      } else {
        l = 1 / l;
        this._x = this._x * l;
        this._y = this._y * l;
        this._z = this._z * l;
        this._w = this._w * l;
      }
      this._onChangeCallback();
      return this;
    }
    /**
     * Multiplies this quaternion by the given one.
     *
     * @param {Quaternion} q - The quaternion.
     * @return {Quaternion} A reference to this quaternion.
     */
    multiply(q) {
      return this.multiplyQuaternions(this, q);
    }
    /**
     * Pre-multiplies this quaternion by the given one.
     *
     * @param {Quaternion} q - The quaternion.
     * @return {Quaternion} A reference to this quaternion.
     */
    premultiply(q) {
      return this.multiplyQuaternions(q, this);
    }
    /**
     * Multiplies the given quaternions and stores the result in this instance.
     *
     * @param {Quaternion} a - The first quaternion.
     * @param {Quaternion} b - The second quaternion.
     * @return {Quaternion} A reference to this quaternion.
     */
    multiplyQuaternions(a, b) {
      const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
      const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
      this._onChangeCallback();
      return this;
    }
    /**
     * Performs a spherical linear interpolation between quaternions.
     *
     * @param {Quaternion} qb - The target quaternion.
     * @param {number} t - The interpolation factor in the closed interval \`[0, 1]\`.
     * @return {Quaternion} A reference to this quaternion.
     */
    slerp(qb, t) {
      if (t === 0) return this;
      if (t === 1) return this.copy(qb);
      const x2 = this._x, y = this._y, z = this._z, w = this._w;
      let cosHalfTheta = w * qb._w + x2 * qb._x + y * qb._y + z * qb._z;
      if (cosHalfTheta < 0) {
        this._w = -qb._w;
        this._x = -qb._x;
        this._y = -qb._y;
        this._z = -qb._z;
        cosHalfTheta = -cosHalfTheta;
      } else {
        this.copy(qb);
      }
      if (cosHalfTheta >= 1) {
        this._w = w;
        this._x = x2;
        this._y = y;
        this._z = z;
        return this;
      }
      const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
      if (sqrSinHalfTheta <= Number.EPSILON) {
        const s = 1 - t;
        this._w = s * w + t * this._w;
        this._x = s * x2 + t * this._x;
        this._y = s * y + t * this._y;
        this._z = s * z + t * this._z;
        this.normalize();
        return this;
      }
      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
      const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
      const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
      this._w = w * ratioA + this._w * ratioB;
      this._x = x2 * ratioA + this._x * ratioB;
      this._y = y * ratioA + this._y * ratioB;
      this._z = z * ratioA + this._z * ratioB;
      this._onChangeCallback();
      return this;
    }
    /**
     * Performs a spherical linear interpolation between the given quaternions
     * and stores the result in this quaternion.
     *
     * @param {Quaternion} qa - The source quaternion.
     * @param {Quaternion} qb - The target quaternion.
     * @param {number} t - The interpolation factor in the closed interval \`[0, 1]\`.
     * @return {Quaternion} A reference to this quaternion.
     */
    slerpQuaternions(qa, qb, t) {
      return this.copy(qa).slerp(qb, t);
    }
    /**
     * Sets this quaternion to a uniformly random, normalized quaternion.
     *
     * @return {Quaternion} A reference to this quaternion.
     */
    random() {
      const theta1 = 2 * Math.PI * Math.random();
      const theta2 = 2 * Math.PI * Math.random();
      const x0 = Math.random();
      const r1 = Math.sqrt(1 - x0);
      const r2 = Math.sqrt(x0);
      return this.set(
        r1 * Math.sin(theta1),
        r1 * Math.cos(theta1),
        r2 * Math.sin(theta2),
        r2 * Math.cos(theta2)
      );
    }
    /**
     * Returns \`true\` if this quaternion is equal with the given one.
     *
     * @param {Quaternion} quaternion - The quaternion to test for equality.
     * @return {boolean} Whether this quaternion is equal with the given one.
     */
    equals(quaternion) {
      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
    /**
     * Sets this quaternion's components from the given array.
     *
     * @param {Array<number>} array - An array holding the quaternion component values.
     * @param {number} [offset=0] - The offset into the array.
     * @return {Quaternion} A reference to this quaternion.
     */
    fromArray(array, offset = 0) {
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this._w = array[offset + 3];
      this._onChangeCallback();
      return this;
    }
    /**
     * Writes the components of this quaternion to the given array. If no array is provided,
     * the method returns a new instance.
     *
     * @param {Array<number>} [array=[]] - The target array holding the quaternion components.
     * @param {number} [offset=0] - Index of the first element in the array.
     * @return {Array<number>} The quaternion components.
     */
    toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._w;
      return array;
    }
    /**
     * Sets the components of this quaternion from the given buffer attribute.
     *
     * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.
     * @param {number} index - The index into the attribute.
     * @return {Quaternion} A reference to this quaternion.
     */
    fromBufferAttribute(attribute, index) {
      this._x = attribute.getX(index);
      this._y = attribute.getY(index);
      this._z = attribute.getZ(index);
      this._w = attribute.getW(index);
      this._onChangeCallback();
      return this;
    }
    /**
     * This methods defines the serialization result of this class. Returns the
     * numerical elements of this quaternion in an array of format \`[x, y, z, w]\`.
     *
     * @return {Array<number>} The serialized quaternion.
     */
    toJSON() {
      return this.toArray();
    }
    _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x;
      yield this._y;
      yield this._z;
      yield this._w;
    }
  }
  class Vector3 {
    /**
     * Constructs a new 3D vector.
     *
     * @param {number} [x=0] - The x value of this vector.
     * @param {number} [y=0] - The y value of this vector.
     * @param {number} [z=0] - The z value of this vector.
     */
    constructor(x2 = 0, y = 0, z = 0) {
      Vector3.prototype.isVector3 = true;
      this.x = x2;
      this.y = y;
      this.z = z;
    }
    /**
     * Sets the vector components.
     *
     * @param {number} x - The value of the x component.
     * @param {number} y - The value of the y component.
     * @param {number} z - The value of the z component.
     * @return {Vector3} A reference to this vector.
     */
    set(x2, y, z) {
      if (z === void 0) z = this.z;
      this.x = x2;
      this.y = y;
      this.z = z;
      return this;
    }
    /**
     * Sets the vector components to the same value.
     *
     * @param {number} scalar - The value to set for all vector components.
     * @return {Vector3} A reference to this vector.
     */
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      return this;
    }
    /**
     * Sets the vector's x component to the given value
     *
     * @param {number} x - The value to set.
     * @return {Vector3} A reference to this vector.
     */
    setX(x2) {
      this.x = x2;
      return this;
    }
    /**
     * Sets the vector's y component to the given value
     *
     * @param {number} y - The value to set.
     * @return {Vector3} A reference to this vector.
     */
    setY(y) {
      this.y = y;
      return this;
    }
    /**
     * Sets the vector's z component to the given value
     *
     * @param {number} z - The value to set.
     * @return {Vector3} A reference to this vector.
     */
    setZ(z) {
      this.z = z;
      return this;
    }
    /**
     * Allows to set a vector component with an index.
     *
     * @param {number} index - The component index. \`0\` equals to x, \`1\` equals to y, \`2\` equals to z.
     * @param {number} value - The value to set.
     * @return {Vector3} A reference to this vector.
     */
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    /**
     * Returns the value of the vector component which matches the given index.
     *
     * @param {number} index - The component index. \`0\` equals to x, \`1\` equals to y, \`2\` equals to z.
     * @return {number} A vector component value.
     */
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    /**
     * Returns a new vector with copied values from this instance.
     *
     * @return {Vector3} A clone of this instance.
     */
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    /**
     * Copies the values of the given vector to this instance.
     *
     * @param {Vector3} v - The vector to copy.
     * @return {Vector3} A reference to this vector.
     */
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      return this;
    }
    /**
     * Adds the given vector to this instance.
     *
     * @param {Vector3} v - The vector to add.
     * @return {Vector3} A reference to this vector.
     */
    add(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    }
    /**
     * Adds the given scalar value to all components of this instance.
     *
     * @param {number} s - The scalar to add.
     * @return {Vector3} A reference to this vector.
     */
    addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      return this;
    }
    /**
     * Adds the given vectors and stores the result in this instance.
     *
     * @param {Vector3} a - The first vector.
     * @param {Vector3} b - The second vector.
     * @return {Vector3} A reference to this vector.
     */
    addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      return this;
    }
    /**
     * Adds the given vector scaled by the given factor to this instance.
     *
     * @param {Vector3|Vector4} v - The vector.
     * @param {number} s - The factor that scales \`v\`.
     * @return {Vector3} A reference to this vector.
     */
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      return this;
    }
    /**
     * Subtracts the given vector from this instance.
     *
     * @param {Vector3} v - The vector to subtract.
     * @return {Vector3} A reference to this vector.
     */
    sub(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    }
    /**
     * Subtracts the given scalar value from all components of this instance.
     *
     * @param {number} s - The scalar to subtract.
     * @return {Vector3} A reference to this vector.
     */
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      return this;
    }
    /**
     * Subtracts the given vectors and stores the result in this instance.
     *
     * @param {Vector3} a - The first vector.
     * @param {Vector3} b - The second vector.
     * @return {Vector3} A reference to this vector.
     */
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      return this;
    }
    /**
     * Multiplies the given vector with this instance.
     *
     * @param {Vector3} v - The vector to multiply.
     * @return {Vector3} A reference to this vector.
     */
    multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      return this;
    }
    /**
     * Multiplies the given scalar value with all components of this instance.
     *
     * @param {number} scalar - The scalar to multiply.
     * @return {Vector3} A reference to this vector.
     */
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      return this;
    }
    /**
     * Multiplies the given vectors and stores the result in this instance.
     *
     * @param {Vector3} a - The first vector.
     * @param {Vector3} b - The second vector.
     * @return {Vector3} A reference to this vector.
     */
    multiplyVectors(a, b) {
      this.x = a.x * b.x;
      this.y = a.y * b.y;
      this.z = a.z * b.z;
      return this;
    }
    /**
     * Applies the given Euler rotation to this vector.
     *
     * @param {Euler} euler - The Euler angles.
     * @return {Vector3} A reference to this vector.
     */
    applyEuler(euler) {
      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
    }
    /**
     * Applies a rotation specified by an axis and an angle to this vector.
     *
     * @param {Vector3} axis - A normalized vector representing the rotation axis.
     * @param {number} angle - The angle in radians.
     * @return {Vector3} A reference to this vector.
     */
    applyAxisAngle(axis, angle) {
      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
    }
    /**
     * Multiplies this vector with the given 3x3 matrix.
     *
     * @param {Matrix3} m - The 3x3 matrix.
     * @return {Vector3} A reference to this vector.
     */
    applyMatrix3(m) {
      const x2 = this.x, y = this.y, z = this.z;
      const e = m.elements;
      this.x = e[0] * x2 + e[3] * y + e[6] * z;
      this.y = e[1] * x2 + e[4] * y + e[7] * z;
      this.z = e[2] * x2 + e[5] * y + e[8] * z;
      return this;
    }
    /**
     * Multiplies this vector by the given normal matrix and normalizes
     * the result.
     *
     * @param {Matrix3} m - The normal matrix.
     * @return {Vector3} A reference to this vector.
     */
    applyNormalMatrix(m) {
      return this.applyMatrix3(m).normalize();
    }
    /**
     * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
     * divides by perspective.
     *
     * @param {Matrix4} m - The matrix to apply.
     * @return {Vector3} A reference to this vector.
     */
    applyMatrix4(m) {
      const x2 = this.x, y = this.y, z = this.z;
      const e = m.elements;
      const w = 1 / (e[3] * x2 + e[7] * y + e[11] * z + e[15]);
      this.x = (e[0] * x2 + e[4] * y + e[8] * z + e[12]) * w;
      this.y = (e[1] * x2 + e[5] * y + e[9] * z + e[13]) * w;
      this.z = (e[2] * x2 + e[6] * y + e[10] * z + e[14]) * w;
      return this;
    }
    /**
     * Applies the given Quaternion to this vector.
     *
     * @param {Quaternion} q - The Quaternion.
     * @return {Vector3} A reference to this vector.
     */
    applyQuaternion(q) {
      const vx = this.x, vy = this.y, vz = this.z;
      const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
      const tx = 2 * (qy * vz - qz * vy);
      const ty = 2 * (qz * vx - qx * vz);
      const tz = 2 * (qx * vy - qy * vx);
      this.x = vx + qw * tx + qy * tz - qz * ty;
      this.y = vy + qw * ty + qz * tx - qx * tz;
      this.z = vz + qw * tz + qx * ty - qy * tx;
      return this;
    }
    /**
     * Projects this vector from world space into the camera's normalized
     * device coordinate (NDC) space.
     *
     * @param {Camera} camera - The camera.
     * @return {Vector3} A reference to this vector.
     */
    project(camera) {
      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    }
    /**
     * Unprojects this vector from the camera's normalized device coordinate (NDC)
     * space into world space.
     *
     * @param {Camera} camera - The camera.
     * @return {Vector3} A reference to this vector.
     */
    unproject(camera) {
      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    }
    /**
     * Transforms the direction of this vector by a matrix (the upper left 3 x 3
     * subset of the given 4x4 matrix and then normalizes the result.
     *
     * @param {Matrix4} m - The matrix.
     * @return {Vector3} A reference to this vector.
     */
    transformDirection(m) {
      const x2 = this.x, y = this.y, z = this.z;
      const e = m.elements;
      this.x = e[0] * x2 + e[4] * y + e[8] * z;
      this.y = e[1] * x2 + e[5] * y + e[9] * z;
      this.z = e[2] * x2 + e[6] * y + e[10] * z;
      return this.normalize();
    }
    /**
     * Divides this instance by the given vector.
     *
     * @param {Vector3} v - The vector to divide.
     * @return {Vector3} A reference to this vector.
     */
    divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
      return this;
    }
    /**
     * Divides this vector by the given scalar.
     *
     * @param {number} scalar - The scalar to divide.
     * @return {Vector3} A reference to this vector.
     */
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    /**
     * If this vector's x, y or z value is greater than the given vector's x, y or z
     * value, replace that value with the corresponding min value.
     *
     * @param {Vector3} v - The vector.
     * @return {Vector3} A reference to this vector.
     */
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      return this;
    }
    /**
     * If this vector's x, y or z value is less than the given vector's x, y or z
     * value, replace that value with the corresponding max value.
     *
     * @param {Vector3} v - The vector.
     * @return {Vector3} A reference to this vector.
     */
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      return this;
    }
    /**
     * If this vector's x, y or z value is greater than the max vector's x, y or z
     * value, it is replaced by the corresponding value.
     * If this vector's x, y or z value is less than the min vector's x, y or z value,
     * it is replaced by the corresponding value.
     *
     * @param {Vector3} min - The minimum x, y and z values.
     * @param {Vector3} max - The maximum x, y and z values in the desired range.
     * @return {Vector3} A reference to this vector.
     */
    clamp(min, max2) {
      this.x = clamp(this.x, min.x, max2.x);
      this.y = clamp(this.y, min.y, max2.y);
      this.z = clamp(this.z, min.z, max2.z);
      return this;
    }
    /**
     * If this vector's x, y or z values are greater than the max value, they are
     * replaced by the max value.
     * If this vector's x, y or z values are less than the min value, they are
     * replaced by the min value.
     *
     * @param {number} minVal - The minimum value the components will be clamped to.
     * @param {number} maxVal - The maximum value the components will be clamped to.
     * @return {Vector3} A reference to this vector.
     */
    clampScalar(minVal, maxVal) {
      this.x = clamp(this.x, minVal, maxVal);
      this.y = clamp(this.y, minVal, maxVal);
      this.z = clamp(this.z, minVal, maxVal);
      return this;
    }
    /**
     * If this vector's length is greater than the max value, it is replaced by
     * the max value.
     * If this vector's length is less than the min value, it is replaced by the
     * min value.
     *
     * @param {number} min - The minimum value the vector length will be clamped to.
     * @param {number} max - The maximum value the vector length will be clamped to.
     * @return {Vector3} A reference to this vector.
     */
    clampLength(min, max2) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));
    }
    /**
     * The components of this vector are rounded down to the nearest integer value.
     *
     * @return {Vector3} A reference to this vector.
     */
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      return this;
    }
    /**
     * The components of this vector are rounded up to the nearest integer value.
     *
     * @return {Vector3} A reference to this vector.
     */
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      return this;
    }
    /**
     * The components of this vector are rounded to the nearest integer value
     *
     * @return {Vector3} A reference to this vector.
     */
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      return this;
    }
    /**
     * The components of this vector are rounded towards zero (up if negative,
     * down if positive) to an integer value.
     *
     * @return {Vector3} A reference to this vector.
     */
    roundToZero() {
      this.x = Math.trunc(this.x);
      this.y = Math.trunc(this.y);
      this.z = Math.trunc(this.z);
      return this;
    }
    /**
     * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.
     *
     * @return {Vector3} A reference to this vector.
     */
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    }
    /**
     * Calculates the dot product of the given vector with this instance.
     *
     * @param {Vector3} v - The vector to compute the dot product with.
     * @return {number} The result of the dot product.
     */
    dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    }
    // TODO lengthSquared?
    /**
     * Computes the square of the Euclidean length (straight-line length) from
     * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
     * compare the length squared instead as it is slightly more efficient to calculate.
     *
     * @return {number} The square length of this vector.
     */
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    /**
     * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).
     *
     * @return {number} The length of this vector.
     */
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    /**
     * Computes the Manhattan length of this vector.
     *
     * @return {number} The length of this vector.
     */
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    /**
     * Converts this vector to a unit vector - that is, sets it equal to a vector
     * with the same direction as this one, but with a vector length of \`1\`.
     *
     * @return {Vector3} A reference to this vector.
     */
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    /**
     * Sets this vector to a vector with the same direction as this one, but
     * with the specified length.
     *
     * @param {number} length - The new length of this vector.
     * @return {Vector3} A reference to this vector.
     */
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    /**
     * Linearly interpolates between the given vector and this instance, where
     * alpha is the percent distance along the line - alpha = 0 will be this
     * vector, and alpha = 1 will be the given one.
     *
     * @param {Vector3} v - The vector to interpolate towards.
     * @param {number} alpha - The interpolation factor, typically in the closed interval \`[0, 1]\`.
     * @return {Vector3} A reference to this vector.
     */
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      return this;
    }
    /**
     * Linearly interpolates between the given vectors, where alpha is the percent
     * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
     * be the second one. The result is stored in this instance.
     *
     * @param {Vector3} v1 - The first vector.
     * @param {Vector3} v2 - The second vector.
     * @param {number} alpha - The interpolation factor, typically in the closed interval \`[0, 1]\`.
     * @return {Vector3} A reference to this vector.
     */
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      return this;
    }
    /**
     * Calculates the cross product of the given vector with this instance.
     *
     * @param {Vector3} v - The vector to compute the cross product with.
     * @return {Vector3} The result of the cross product.
     */
    cross(v) {
      return this.crossVectors(this, v);
    }
    /**
     * Calculates the cross product of the given vectors and stores the result
     * in this instance.
     *
     * @param {Vector3} a - The first vector.
     * @param {Vector3} b - The second vector.
     * @return {Vector3} A reference to this vector.
     */
    crossVectors(a, b) {
      const ax = a.x, ay = a.y, az = a.z;
      const bx = b.x, by = b.y, bz = b.z;
      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;
      return this;
    }
    /**
     * Projects this vector onto the given one.
     *
     * @param {Vector3} v - The vector to project to.
     * @return {Vector3} A reference to this vector.
     */
    projectOnVector(v) {
      const denominator = v.lengthSq();
      if (denominator === 0) return this.set(0, 0, 0);
      const scalar = v.dot(this) / denominator;
      return this.copy(v).multiplyScalar(scalar);
    }
    /**
     * Projects this vector onto a plane by subtracting this
     * vector projected onto the plane's normal from this vector.
     *
     * @param {Vector3} planeNormal - The plane normal.
     * @return {Vector3} A reference to this vector.
     */
    projectOnPlane(planeNormal) {
      _vector$c.copy(this).projectOnVector(planeNormal);
      return this.sub(_vector$c);
    }
    /**
     * Reflects this vector off a plane orthogonal to the given normal vector.
     *
     * @param {Vector3} normal - The (normalized) normal vector.
     * @return {Vector3} A reference to this vector.
     */
    reflect(normal) {
      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
    /**
     * Returns the angle between the given vector and this instance in radians.
     *
     * @param {Vector3} v - The vector to compute the angle with.
     * @return {number} The angle in radians.
     */
    angleTo(v) {
      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
      if (denominator === 0) return Math.PI / 2;
      const theta = this.dot(v) / denominator;
      return Math.acos(clamp(theta, -1, 1));
    }
    /**
     * Computes the distance from the given vector to this instance.
     *
     * @param {Vector3} v - The vector to compute the distance to.
     * @return {number} The distance.
     */
    distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
    /**
     * Computes the squared distance from the given vector to this instance.
     * If you are just comparing the distance with another distance, you should compare
     * the distance squared instead as it is slightly more efficient to calculate.
     *
     * @param {Vector3} v - The vector to compute the squared distance to.
     * @return {number} The squared distance.
     */
    distanceToSquared(v) {
      const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
      return dx * dx + dy * dy + dz * dz;
    }
    /**
     * Computes the Manhattan distance from the given vector to this instance.
     *
     * @param {Vector3} v - The vector to compute the Manhattan distance to.
     * @return {number} The Manhattan distance.
     */
    manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    }
    /**
     * Sets the vector components from the given spherical coordinates.
     *
     * @param {Spherical} s - The spherical coordinates.
     * @return {Vector3} A reference to this vector.
     */
    setFromSpherical(s) {
      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }
    /**
     * Sets the vector components from the given spherical coordinates.
     *
     * @param {number} radius - The radius.
     * @param {number} phi - The phi angle in radians.
     * @param {number} theta - The theta angle in radians.
     * @return {Vector3} A reference to this vector.
     */
    setFromSphericalCoords(radius, phi, theta) {
      const sinPhiRadius = Math.sin(phi) * radius;
      this.x = sinPhiRadius * Math.sin(theta);
      this.y = Math.cos(phi) * radius;
      this.z = sinPhiRadius * Math.cos(theta);
      return this;
    }
    /**
     * Sets the vector components from the given cylindrical coordinates.
     *
     * @param {Cylindrical} c - The cylindrical coordinates.
     * @return {Vector3} A reference to this vector.
     */
    setFromCylindrical(c) {
      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    }
    /**
     * Sets the vector components from the given cylindrical coordinates.
     *
     * @param {number} radius - The radius.
     * @param {number} theta - The theta angle in radians.
     * @param {number} y - The y value.
     * @return {Vector3} A reference to this vector.
     */
    setFromCylindricalCoords(radius, theta, y) {
      this.x = radius * Math.sin(theta);
      this.y = y;
      this.z = radius * Math.cos(theta);
      return this;
    }
    /**
     * Sets the vector components to the position elements of the
     * given transformation matrix.
     *
     * @param {Matrix4} m - The 4x4 matrix.
     * @return {Vector3} A reference to this vector.
     */
    setFromMatrixPosition(m) {
      const e = m.elements;
      this.x = e[12];
      this.y = e[13];
      this.z = e[14];
      return this;
    }
    /**
     * Sets the vector components to the scale elements of the
     * given transformation matrix.
     *
     * @param {Matrix4} m - The 4x4 matrix.
     * @return {Vector3} A reference to this vector.
     */
    setFromMatrixScale(m) {
      const sx = this.setFromMatrixColumn(m, 0).length();
      const sy = this.setFromMatrixColumn(m, 1).length();
      const sz = this.setFromMatrixColumn(m, 2).length();
      this.x = sx;
      this.y = sy;
      this.z = sz;
      return this;
    }
    /**
     * Sets the vector components from the specified matrix column.
     *
     * @param {Matrix4} m - The 4x4 matrix.
     * @param {number} index - The column index.
     * @return {Vector3} A reference to this vector.
     */
    setFromMatrixColumn(m, index) {
      return this.fromArray(m.elements, index * 4);
    }
    /**
     * Sets the vector components from the specified matrix column.
     *
     * @param {Matrix3} m - The 3x3 matrix.
     * @param {number} index - The column index.
     * @return {Vector3} A reference to this vector.
     */
    setFromMatrix3Column(m, index) {
      return this.fromArray(m.elements, index * 3);
    }
    /**
     * Sets the vector components from the given Euler angles.
     *
     * @param {Euler} e - The Euler angles to set.
     * @return {Vector3} A reference to this vector.
     */
    setFromEuler(e) {
      this.x = e._x;
      this.y = e._y;
      this.z = e._z;
      return this;
    }
    /**
     * Sets the vector components from the RGB components of the
     * given color.
     *
     * @param {Color} c - The color to set.
     * @return {Vector3} A reference to this vector.
     */
    setFromColor(c) {
      this.x = c.r;
      this.y = c.g;
      this.z = c.b;
      return this;
    }
    /**
     * Returns \`true\` if this vector is equal with the given one.
     *
     * @param {Vector3} v - The vector to test for equality.
     * @return {boolean} Whether this vector is equal with the given one.
     */
    equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z;
    }
    /**
     * Sets this vector's x value to be \`array[ offset ]\`, y value to be \`array[ offset + 1 ]\`
     * and z value to be \`array[ offset + 2 ]\`.
     *
     * @param {Array<number>} array - An array holding the vector component values.
     * @param {number} [offset=0] - The offset into the array.
     * @return {Vector3} A reference to this vector.
     */
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      return this;
    }
    /**
     * Writes the components of this vector to the given array. If no array is provided,
     * the method returns a new instance.
     *
     * @param {Array<number>} [array=[]] - The target array holding the vector components.
     * @param {number} [offset=0] - Index of the first element in the array.
     * @return {Array<number>} The vector components.
     */
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      return array;
    }
    /**
     * Sets the components of this vector from the given buffer attribute.
     *
     * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
     * @param {number} index - The index into the attribute.
     * @return {Vector3} A reference to this vector.
     */
    fromBufferAttribute(attribute, index) {
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      return this;
    }
    /**
     * Sets each component of this vector to a pseudo-random value between \`0\` and
     * \`1\`, excluding \`1\`.
     *
     * @return {Vector3} A reference to this vector.
     */
    random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      return this;
    }
    /**
     * Sets this vector to a uniformly random point on a unit sphere.
     *
     * @return {Vector3} A reference to this vector.
     */
    randomDirection() {
      const theta = Math.random() * Math.PI * 2;
      const u = Math.random() * 2 - 1;
      const c = Math.sqrt(1 - u * u);
      this.x = c * Math.cos(theta);
      this.y = u;
      this.z = c * Math.sin(theta);
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
      yield this.z;
    }
  }
  const _vector$c = /* @__PURE__ */ new Vector3();
  const _quaternion$4 = /* @__PURE__ */ new Quaternion();
  class Matrix3 {
    /**
     * Constructs a new 3x3 matrix. The arguments are supposed to be
     * in row-major order. If no arguments are provided, the constructor
     * initializes the matrix as an identity matrix.
     *
     * @param {number} [n11] - 1-1 matrix element.
     * @param {number} [n12] - 1-2 matrix element.
     * @param {number} [n13] - 1-3 matrix element.
     * @param {number} [n21] - 2-1 matrix element.
     * @param {number} [n22] - 2-2 matrix element.
     * @param {number} [n23] - 2-3 matrix element.
     * @param {number} [n31] - 3-1 matrix element.
     * @param {number} [n32] - 3-2 matrix element.
     * @param {number} [n33] - 3-3 matrix element.
     */
    constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      Matrix3.prototype.isMatrix3 = true;
      this.elements = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ];
      if (n11 !== void 0) {
        this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
      }
    }
    /**
     * Sets the elements of the matrix.The arguments are supposed to be
     * in row-major order.
     *
     * @param {number} [n11] - 1-1 matrix element.
     * @param {number} [n12] - 1-2 matrix element.
     * @param {number} [n13] - 1-3 matrix element.
     * @param {number} [n21] - 2-1 matrix element.
     * @param {number} [n22] - 2-2 matrix element.
     * @param {number} [n23] - 2-3 matrix element.
     * @param {number} [n31] - 3-1 matrix element.
     * @param {number} [n32] - 3-2 matrix element.
     * @param {number} [n33] - 3-3 matrix element.
     * @return {Matrix3} A reference to this matrix.
     */
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      const te = this.elements;
      te[0] = n11;
      te[1] = n21;
      te[2] = n31;
      te[3] = n12;
      te[4] = n22;
      te[5] = n32;
      te[6] = n13;
      te[7] = n23;
      te[8] = n33;
      return this;
    }
    /**
     * Sets this matrix to the 3x3 identity matrix.
     *
     * @return {Matrix3} A reference to this matrix.
     */
    identity() {
      this.set(
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      );
      return this;
    }
    /**
     * Copies the values of the given matrix to this instance.
     *
     * @param {Matrix3} m - The matrix to copy.
     * @return {Matrix3} A reference to this matrix.
     */
    copy(m) {
      const te = this.elements;
      const me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      return this;
    }
    /**
     * Extracts the basis of this matrix into the three axis vectors provided.
     *
     * @param {Vector3} xAxis - The basis's x axis.
     * @param {Vector3} yAxis - The basis's y axis.
     * @param {Vector3} zAxis - The basis's z axis.
     * @return {Matrix3} A reference to this matrix.
     */
    extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrix3Column(this, 0);
      yAxis.setFromMatrix3Column(this, 1);
      zAxis.setFromMatrix3Column(this, 2);
      return this;
    }
    /**
     * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.
     *
     * @param {Matrix4} m - The 4x4 matrix.
     * @return {Matrix3} A reference to this matrix.
     */
    setFromMatrix4(m) {
      const me = m.elements;
      this.set(
        me[0],
        me[4],
        me[8],
        me[1],
        me[5],
        me[9],
        me[2],
        me[6],
        me[10]
      );
      return this;
    }
    /**
     * Post-multiplies this matrix by the given 3x3 matrix.
     *
     * @param {Matrix3} m - The matrix to multiply with.
     * @return {Matrix3} A reference to this matrix.
     */
    multiply(m) {
      return this.multiplyMatrices(this, m);
    }
    /**
     * Pre-multiplies this matrix by the given 3x3 matrix.
     *
     * @param {Matrix3} m - The matrix to multiply with.
     * @return {Matrix3} A reference to this matrix.
     */
    premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
    /**
     * Multiples the given 3x3 matrices and stores the result
     * in this matrix.
     *
     * @param {Matrix3} a - The first matrix.
     * @param {Matrix3} b - The second matrix.
     * @return {Matrix3} A reference to this matrix.
     */
    multiplyMatrices(a, b) {
      const ae = a.elements;
      const be = b.elements;
      const te = this.elements;
      const a11 = ae[0], a12 = ae[3], a13 = ae[6];
      const a21 = ae[1], a22 = ae[4], a23 = ae[7];
      const a31 = ae[2], a32 = ae[5], a33 = ae[8];
      const b11 = be[0], b12 = be[3], b13 = be[6];
      const b21 = be[1], b22 = be[4], b23 = be[7];
      const b31 = be[2], b32 = be[5], b33 = be[8];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31;
      te[3] = a11 * b12 + a12 * b22 + a13 * b32;
      te[6] = a11 * b13 + a12 * b23 + a13 * b33;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31;
      te[4] = a21 * b12 + a22 * b22 + a23 * b32;
      te[7] = a21 * b13 + a22 * b23 + a23 * b33;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31;
      te[5] = a31 * b12 + a32 * b22 + a33 * b32;
      te[8] = a31 * b13 + a32 * b23 + a33 * b33;
      return this;
    }
    /**
     * Multiplies every component of the matrix by the given scalar.
     *
     * @param {number} s - The scalar.
     * @return {Matrix3} A reference to this matrix.
     */
    multiplyScalar(s) {
      const te = this.elements;
      te[0] *= s;
      te[3] *= s;
      te[6] *= s;
      te[1] *= s;
      te[4] *= s;
      te[7] *= s;
      te[2] *= s;
      te[5] *= s;
      te[8] *= s;
      return this;
    }
    /**
     * Computes and returns the determinant of this matrix.
     *
     * @return {number} The determinant.
     */
    determinant() {
      const te = this.elements;
      const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];
      return a * e * i2 - a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;
    }
    /**
     * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
     * You can not invert with a determinant of zero. If you attempt this, the method produces
     * a zero matrix instead.
     *
     * @return {Matrix3} A reference to this matrix.
     */
    invert() {
      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n31 * n23 - n33 * n21) * detInv;
      te[2] = (n32 * n21 - n31 * n22) * detInv;
      te[3] = t12 * detInv;
      te[4] = (n33 * n11 - n31 * n13) * detInv;
      te[5] = (n31 * n12 - n32 * n11) * detInv;
      te[6] = t13 * detInv;
      te[7] = (n21 * n13 - n23 * n11) * detInv;
      te[8] = (n22 * n11 - n21 * n12) * detInv;
      return this;
    }
    /**
     * Transposes this matrix in place.
     *
     * @return {Matrix3} A reference to this matrix.
     */
    transpose() {
      let tmp;
      const m = this.elements;
      tmp = m[1];
      m[1] = m[3];
      m[3] = tmp;
      tmp = m[2];
      m[2] = m[6];
      m[6] = tmp;
      tmp = m[5];
      m[5] = m[7];
      m[7] = tmp;
      return this;
    }
    /**
     * Computes the normal matrix which is the inverse transpose of the upper
     * left 3x3 portion of the given 4x4 matrix.
     *
     * @param {Matrix4} matrix4 - The 4x4 matrix.
     * @return {Matrix3} A reference to this matrix.
     */
    getNormalMatrix(matrix4) {
      return this.setFromMatrix4(matrix4).invert().transpose();
    }
    /**
     * Transposes this matrix into the supplied array, and returns itself unchanged.
     *
     * @param {Array<number>} r - An array to store the transposed matrix elements.
     * @return {Matrix3} A reference to this matrix.
     */
    transposeIntoArray(r) {
      const m = this.elements;
      r[0] = m[0];
      r[1] = m[3];
      r[2] = m[6];
      r[3] = m[1];
      r[4] = m[4];
      r[5] = m[7];
      r[6] = m[2];
      r[7] = m[5];
      r[8] = m[8];
      return this;
    }
    /**
     * Sets the UV transform matrix from offset, repeat, rotation, and center.
     *
     * @param {number} tx - Offset x.
     * @param {number} ty - Offset y.
     * @param {number} sx - Repeat x.
     * @param {number} sy - Repeat y.
     * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.
     * @param {number} cx - Center x of rotation.
     * @param {number} cy - Center y of rotation
     * @return {Matrix3} A reference to this matrix.
     */
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
      const c = Math.cos(rotation);
      const s = Math.sin(rotation);
      this.set(
        sx * c,
        sx * s,
        -sx * (c * cx + s * cy) + cx + tx,
        -sy * s,
        sy * c,
        -sy * (-s * cx + c * cy) + cy + ty,
        0,
        0,
        1
      );
      return this;
    }
    /**
     * Scales this matrix with the given scalar values.
     *
     * @param {number} sx - The amount to scale in the X axis.
     * @param {number} sy - The amount to scale in the Y axis.
     * @return {Matrix3} A reference to this matrix.
     */
    scale(sx, sy) {
      this.premultiply(_m3.makeScale(sx, sy));
      return this;
    }
    /**
     * Rotates this matrix by the given angle.
     *
     * @param {number} theta - The rotation in radians.
     * @return {Matrix3} A reference to this matrix.
     */
    rotate(theta) {
      this.premultiply(_m3.makeRotation(-theta));
      return this;
    }
    /**
     * Translates this matrix by the given scalar values.
     *
     * @param {number} tx - The amount to translate in the X axis.
     * @param {number} ty - The amount to translate in the Y axis.
     * @return {Matrix3} A reference to this matrix.
     */
    translate(tx, ty) {
      this.premultiply(_m3.makeTranslation(tx, ty));
      return this;
    }
    // for 2D Transforms
    /**
     * Sets this matrix as a 2D translation transform.
     *
     * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.
     * @param {number} y - The amount to translate in the Y axis.
     * @return {Matrix3} A reference to this matrix.
     */
    makeTranslation(x2, y) {
      if (x2.isVector2) {
        this.set(
          1,
          0,
          x2.x,
          0,
          1,
          x2.y,
          0,
          0,
          1
        );
      } else {
        this.set(
          1,
          0,
          x2,
          0,
          1,
          y,
          0,
          0,
          1
        );
      }
      return this;
    }
    /**
     * Sets this matrix as a 2D rotational transformation.
     *
     * @param {number} theta - The rotation in radians.
     * @return {Matrix3} A reference to this matrix.
     */
    makeRotation(theta) {
      const c = Math.cos(theta);
      const s = Math.sin(theta);
      this.set(
        c,
        -s,
        0,
        s,
        c,
        0,
        0,
        0,
        1
      );
      return this;
    }
    /**
     * Sets this matrix as a 2D scale transform.
     *
     * @param {number} x - The amount to scale in the X axis.
     * @param {number} y - The amount to scale in the Y axis.
     * @return {Matrix3} A reference to this matrix.
     */
    makeScale(x2, y) {
      this.set(
        x2,
        0,
        0,
        0,
        y,
        0,
        0,
        0,
        1
      );
      return this;
    }
    /**
     * Returns \`true\` if this matrix is equal with the given one.
     *
     * @param {Matrix3} matrix - The matrix to test for equality.
     * @return {boolean} Whether this matrix is equal with the given one.
     */
    equals(matrix) {
      const te = this.elements;
      const me = matrix.elements;
      for (let i2 = 0; i2 < 9; i2++) {
        if (te[i2] !== me[i2]) return false;
      }
      return true;
    }
    /**
     * Sets the elements of the matrix from the given array.
     *
     * @param {Array<number>} array - The matrix elements in column-major order.
     * @param {number} [offset=0] - Index of the first element in the array.
     * @return {Matrix3} A reference to this matrix.
     */
    fromArray(array, offset = 0) {
      for (let i2 = 0; i2 < 9; i2++) {
        this.elements[i2] = array[i2 + offset];
      }
      return this;
    }
    /**
     * Writes the elements of this matrix to the given array. If no array is provided,
     * the method returns a new instance.
     *
     * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
     * @param {number} [offset=0] - Index of the first element in the array.
     * @return {Array<number>} The matrix elements in column-major order.
     */
    toArray(array = [], offset = 0) {
      const te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      return array;
    }
    /**
     * Returns a matrix with copied values from this instance.
     *
     * @return {Matrix3} A clone of this instance.
     */
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  const _m3 = /* @__PURE__ */ new Matrix3();
  const _cache = {};
  function warnOnce(message) {
    if (message in _cache) return;
    _cache[message] = true;
    console.warn(message);
  }
  const LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322
  );
  const XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715
  );
  function createColorManagement() {
    const ColorManagement2 = {
      enabled: true,
      workingColorSpace: LinearSRGBColorSpace,
      /**
       * Implementations of supported color spaces.
       *
       * Required:
       *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
       *	- whitePoint: reference white [ x y ]
       *	- transfer: transfer function (pre-defined)
       *	- toXYZ: Matrix3 RGB to XYZ transform
       *	- fromXYZ: Matrix3 XYZ to RGB transform
       *	- luminanceCoefficients: RGB luminance coefficients
       *
       * Optional:
       *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
       *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
       *
       * Reference:
       * - https://www.russellcottrell.com/photo/matrixCalculator.htm
       */
      spaces: {},
      convert: function(color, sourceColorSpace, targetColorSpace) {
        if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
          return color;
        }
        if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {
          color.r = SRGBToLinear(color.r);
          color.g = SRGBToLinear(color.g);
          color.b = SRGBToLinear(color.b);
        }
        if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {
          color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);
          color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);
        }
        if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {
          color.r = LinearToSRGB(color.r);
          color.g = LinearToSRGB(color.g);
          color.b = LinearToSRGB(color.b);
        }
        return color;
      },
      workingToColorSpace: function(color, targetColorSpace) {
        return this.convert(color, this.workingColorSpace, targetColorSpace);
      },
      colorSpaceToWorking: function(color, sourceColorSpace) {
        return this.convert(color, sourceColorSpace, this.workingColorSpace);
      },
      getPrimaries: function(colorSpace) {
        return this.spaces[colorSpace].primaries;
      },
      getTransfer: function(colorSpace) {
        if (colorSpace === NoColorSpace) return LinearTransfer;
        return this.spaces[colorSpace].transfer;
      },
      getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {
        return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);
      },
      define: function(colorSpaces) {
        Object.assign(this.spaces, colorSpaces);
      },
      // Internal APIs
      _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {
        return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);
      },
      _getDrawingBufferColorSpace: function(colorSpace) {
        return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;
      },
      _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {
        return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;
      },
      // Deprecated
      fromWorkingColorSpace: function(color, targetColorSpace) {
        warnOnce("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace().");
        return ColorManagement2.workingToColorSpace(color, targetColorSpace);
      },
      toWorkingColorSpace: function(color, sourceColorSpace) {
        warnOnce("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking().");
        return ColorManagement2.colorSpaceToWorking(color, sourceColorSpace);
      }
    };
    const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];
    const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];
    const D65 = [0.3127, 0.329];
    ColorManagement2.define({
      [LinearSRGBColorSpace]: {
        primaries: REC709_PRIMARIES,
        whitePoint: D65,
        transfer: LinearTransfer,
        toXYZ: LINEAR_REC709_TO_XYZ,
        fromXYZ: XYZ_TO_LINEAR_REC709,
        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
        workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },
        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
      },
      [SRGBColorSpace]: {
        primaries: REC709_PRIMARIES,
        whitePoint: D65,
        transfer: SRGBTransfer,
        toXYZ: LINEAR_REC709_TO_XYZ,
        fromXYZ: XYZ_TO_LINEAR_REC709,
        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
      }
    });
    return ColorManagement2;
  }
  const ColorManagement = /* @__PURE__ */ createColorManagement();
  function SRGBToLinear(c) {
    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
  }
  function LinearToSRGB(c) {
    return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
  }
  class Box3 {
    /**
     * Constructs a new bounding box.
     *
     * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.
     * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
     */
    constructor(min = new Vector3(Infinity, Infinity, Infinity), max2 = new Vector3(-Infinity, -Infinity, -Infinity)) {
      this.isBox3 = true;
      this.min = min;
      this.max = max2;
    }
    /**
     * Sets the lower and upper boundaries of this box.
     * Please note that this method only copies the values from the given objects.
     *
     * @param {Vector3} min - The lower boundary of the box.
     * @param {Vector3} max - The upper boundary of the box.
     * @return {Box3} A reference to this bounding box.
     */
    set(min, max2) {
      this.min.copy(min);
      this.max.copy(max2);
      return this;
    }
    /**
     * Sets the upper and lower bounds of this box so it encloses the position data
     * in the given array.
     *
     * @param {Array<number>} array - An array holding 3D position data.
     * @return {Box3} A reference to this bounding box.
     */
    setFromArray(array) {
      this.makeEmpty();
      for (let i2 = 0, il = array.length; i2 < il; i2 += 3) {
        this.expandByPoint(_vector$b.fromArray(array, i2));
      }
      return this;
    }
    /**
     * Sets the upper and lower bounds of this box so it encloses the position data
     * in the given buffer attribute.
     *
     * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.
     * @return {Box3} A reference to this bounding box.
     */
    setFromBufferAttribute(attribute) {
      this.makeEmpty();
      for (let i2 = 0, il = attribute.count; i2 < il; i2++) {
        this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i2));
      }
      return this;
    }
    /**
     * Sets the upper and lower bounds of this box so it encloses the position data
     * in the given array.
     *
     * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.
     * @return {Box3} A reference to this bounding box.
     */
    setFromPoints(points) {
      this.makeEmpty();
      for (let i2 = 0, il = points.length; i2 < il; i2++) {
        this.expandByPoint(points[i2]);
      }
      return this;
    }
    /**
     * Centers this box on the given center vector and sets this box's width, height and
     * depth to the given size values.
     *
     * @param {Vector3} center - The center of the box.
     * @param {Vector3} size - The x, y and z dimensions of the box.
     * @return {Box3} A reference to this bounding box.
     */
    setFromCenterAndSize(center, size) {
      const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
    /**
     * Computes the world-axis-aligned bounding box for the given 3D object
     * (including its children), accounting for the object's, and children's,
     * world transforms. The function may result in a larger box than strictly necessary.
     *
     * @param {Object3D} object - The 3D object to compute the bounding box for.
     * @param {boolean} [precise=false] - If set to \`true\`, the method computes the smallest
     * world-axis-aligned bounding box at the expense of more computation.
     * @return {Box3} A reference to this bounding box.
     */
    setFromObject(object, precise = false) {
      this.makeEmpty();
      return this.expandByObject(object, precise);
    }
    /**
     * Returns a new box with copied values from this instance.
     *
     * @return {Box3} A clone of this instance.
     */
    clone() {
      return new this.constructor().copy(this);
    }
    /**
     * Copies the values of the given box to this instance.
     *
     * @param {Box3} box - The box to copy.
     * @return {Box3} A reference to this bounding box.
     */
    copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
    /**
     * Makes this box empty which means in encloses a zero space in 3D.
     *
     * @return {Box3} A reference to this bounding box.
     */
    makeEmpty() {
      this.min.x = this.min.y = this.min.z = Infinity;
      this.max.x = this.max.y = this.max.z = -Infinity;
      return this;
    }
    /**
     * Returns true if this box includes zero points within its bounds.
     * Note that a box with equal lower and upper bounds still includes one
     * point, the one both bounds share.
     *
     * @return {boolean} Whether this box is empty or not.
     */
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    /**
     * Returns the center point of this box.
     *
     * @param {Vector3} target - The target vector that is used to store the method's result.
     * @return {Vector3} The center point.
     */
    getCenter(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    /**
     * Returns the dimensions of this box.
     *
     * @param {Vector3} target - The target vector that is used to store the method's result.
     * @return {Vector3} The size.
     */
    getSize(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    }
    /**
     * Expands the boundaries of this box to include the given point.
     *
     * @param {Vector3} point - The point that should be included by the bounding box.
     * @return {Box3} A reference to this bounding box.
     */
    expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
    /**
     * Expands this box equilaterally by the given vector. The width of this
     * box will be expanded by the x component of the vector in both
     * directions. The height of this box will be expanded by the y component of
     * the vector in both directions. The depth of this box will be
     * expanded by the z component of the vector in both directions.
     *
     * @param {Vector3} vector - The vector that should expand the bounding box.
     * @return {Box3} A reference to this bounding box.
     */
    expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
    /**
     * Expands each dimension of the box by the given scalar. If negative, the
     * dimensions of the box will be contracted.
     *
     * @param {number} scalar - The scalar value that should expand the bounding box.
     * @return {Box3} A reference to this bounding box.
     */
    expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
    /**
     * Expands the boundaries of this box to include the given 3D object and
     * its children, accounting for the object's, and children's, world
     * transforms. The function may result in a larger box than strictly
     * necessary (unless the precise parameter is set to true).
     *
     * @param {Object3D} object - The 3D object that should expand the bounding box.
     * @param {boolean} precise - If set to \`true\`, the method expands the bounding box
     * as little as necessary at the expense of more computation.
     * @return {Box3} A reference to this bounding box.
     */
    expandByObject(object, precise = false) {
      object.updateWorldMatrix(false, false);
      const geometry = object.geometry;
      if (geometry !== void 0) {
        const positionAttribute = geometry.getAttribute("position");
        if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {
          for (let i2 = 0, l = positionAttribute.count; i2 < l; i2++) {
            if (object.isMesh === true) {
              object.getVertexPosition(i2, _vector$b);
            } else {
              _vector$b.fromBufferAttribute(positionAttribute, i2);
            }
            _vector$b.applyMatrix4(object.matrixWorld);
            this.expandByPoint(_vector$b);
          }
        } else {
          if (object.boundingBox !== void 0) {
            if (object.boundingBox === null) {
              object.computeBoundingBox();
            }
            _box$4.copy(object.boundingBox);
          } else {
            if (geometry.boundingBox === null) {
              geometry.computeBoundingBox();
            }
            _box$4.copy(geometry.boundingBox);
          }
          _box$4.applyMatrix4(object.matrixWorld);
          this.union(_box$4);
        }
      }
      const children = object.children;
      for (let i2 = 0, l = children.length; i2 < l; i2++) {
        this.expandByObject(children[i2], precise);
      }
      return this;
    }
    /**
     * Returns \`true\` if the given point lies within or on the boundaries of this box.
     *
     * @param {Vector3} point - The point to test.
     * @return {boolean} Whether the bounding box contains the given point or not.
     */
    containsPoint(point) {
      return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;
    }
    /**
     * Returns \`true\` if this bounding box includes the entirety of the given bounding box.
     * If this box and the given one are identical, this function also returns \`true\`.
     *
     * @param {Box3} box - The bounding box to test.
     * @return {boolean} Whether the bounding box contains the given bounding box or not.
     */
    containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    }
    /**
     * Returns a point as a proportion of this box's width, height and depth.
     *
     * @param {Vector3} point - A point in 3D space.
     * @param {Vector3} target - The target vector that is used to store the method's result.
     * @return {Vector3} A point as a proportion of this box's width, height and depth.
     */
    getParameter(point, target) {
      return target.set(
        (point.x - this.min.x) / (this.max.x - this.min.x),
        (point.y - this.min.y) / (this.max.y - this.min.y),
        (point.z - this.min.z) / (this.max.z - this.min.z)
      );
    }
    /**
     * Returns \`true\` if the given bounding box intersects with this bounding box.
     *
     * @param {Box3} box - The bounding box to test.
     * @return {boolean} Whether the given bounding box intersects with this bounding box.
     */
    intersectsBox(box) {
      return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;
    }
    /**
     * Returns \`true\` if the given bounding sphere intersects with this bounding box.
     *
     * @param {Sphere} sphere - The bounding sphere to test.
     * @return {boolean} Whether the given bounding sphere intersects with this bounding box.
     */
    intersectsSphere(sphere) {
      this.clampPoint(sphere.center, _vector$b);
      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
    /**
     * Returns \`true\` if the given plane intersects with this bounding box.
     *
     * @param {Plane} plane - The plane to test.
     * @return {boolean} Whether the given plane intersects with this bounding box.
     */
    intersectsPlane(plane) {
      let min, max2;
      if (plane.normal.x > 0) {
        min = plane.normal.x * this.min.x;
        max2 = plane.normal.x * this.max.x;
      } else {
        min = plane.normal.x * this.max.x;
        max2 = plane.normal.x * this.min.x;
      }
      if (plane.normal.y > 0) {
        min += plane.normal.y * this.min.y;
        max2 += plane.normal.y * this.max.y;
      } else {
        min += plane.normal.y * this.max.y;
        max2 += plane.normal.y * this.min.y;
      }
      if (plane.normal.z > 0) {
        min += plane.normal.z * this.min.z;
        max2 += plane.normal.z * this.max.z;
      } else {
        min += plane.normal.z * this.max.z;
        max2 += plane.normal.z * this.min.z;
      }
      return min <= -plane.constant && max2 >= -plane.constant;
    }
    /**
     * Returns \`true\` if the given triangle intersects with this bounding box.
     *
     * @param {Triangle} triangle - The triangle to test.
     * @return {boolean} Whether the given triangle intersects with this bounding box.
     */
    intersectsTriangle(triangle) {
      if (this.isEmpty()) {
        return false;
      }
      this.getCenter(_center);
      _extents.subVectors(this.max, _center);
      _v0$2.subVectors(triangle.a, _center);
      _v1$7.subVectors(triangle.b, _center);
      _v2$4.subVectors(triangle.c, _center);
      _f0.subVectors(_v1$7, _v0$2);
      _f1.subVectors(_v2$4, _v1$7);
      _f2.subVectors(_v0$2, _v2$4);
      let axes = [
        0,
        -_f0.z,
        _f0.y,
        0,
        -_f1.z,
        _f1.y,
        0,
        -_f2.z,
        _f2.y,
        _f0.z,
        0,
        -_f0.x,
        _f1.z,
        0,
        -_f1.x,
        _f2.z,
        0,
        -_f2.x,
        -_f0.y,
        _f0.x,
        0,
        -_f1.y,
        _f1.x,
        0,
        -_f2.y,
        _f2.x,
        0
      ];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
        return false;
      }
      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
        return false;
      }
      _triangleNormal.crossVectors(_f0, _f1);
      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
      return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
    }
    /**
     * Clamps the given point within the bounds of this box.
     *
     * @param {Vector3} point - The point to clamp.
     * @param {Vector3} target - The target vector that is used to store the method's result.
     * @return {Vector3} The clamped point.
     */
    clampPoint(point, target) {
      return target.copy(point).clamp(this.min, this.max);
    }
    /**
     * Returns the euclidean distance from any edge of this box to the specified point. If
     * the given point lies inside of this box, the distance will be \`0\`.
     *
     * @param {Vector3} point - The point to compute the distance to.
     * @return {number} The euclidean distance.
     */
    distanceToPoint(point) {
      return this.clampPoint(point, _vector$b).distanceTo(point);
    }
    /**
     * Returns a bounding sphere that encloses this bounding box.
     *
     * @param {Sphere} target - The target sphere that is used to store the method's result.
     * @return {Sphere} The bounding sphere that encloses this bounding box.
     */
    getBoundingSphere(target) {
      if (this.isEmpty()) {
        target.makeEmpty();
      } else {
        this.getCenter(target.center);
        target.radius = this.getSize(_vector$b).length() * 0.5;
      }
      return target;
    }
    /**
     * Computes the intersection of this bounding box and the given one, setting the upper
     * bound of this box to the lesser of the two boxes' upper bounds and the
     * lower bound of this box to the greater of the two boxes' lower bounds. If
     * there's no overlap, makes this box empty.
     *
     * @param {Box3} box - The bounding box to intersect with.
     * @return {Box3} A reference to this bounding box.
     */
    intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      if (this.isEmpty()) this.makeEmpty();
      return this;
    }
    /**
     * Computes the union of this box and another and the given one, setting the upper
     * bound of this box to the greater of the two boxes' upper bounds and the
     * lower bound of this box to the lesser of the two boxes' lower bounds.
     *
     * @param {Box3} box - The bounding box that will be unioned with this instance.
     * @return {Box3} A reference to this bounding box.
     */
    union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
    /**
     * Transforms this bounding box by the given 4x4 transformation matrix.
     *
     * @param {Matrix4} matrix - The transformation matrix.
     * @return {Box3} A reference to this bounding box.
     */
    applyMatrix4(matrix) {
      if (this.isEmpty()) return this;
      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
      this.setFromPoints(_points);
      return this;
    }
    /**
     * Adds the given offset to both the upper and lower bounds of this bounding box,
     * effectively moving it in 3D space.
     *
     * @param {Vector3} offset - The offset that should be used to translate the bounding box.
     * @return {Box3} A reference to this bounding box.
     */
    translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
    /**
     * Returns \`true\` if this bounding box is equal with the given one.
     *
     * @param {Box3} box - The box to test for equality.
     * @return {boolean} Whether this bounding box is equal with the given one.
     */
    equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
    /**
     * Returns a serialized structure of the bounding box.
     *
     * @return {Object} Serialized structure with fields representing the object state.
     */
    toJSON() {
      return {
        min: this.min.toArray(),
        max: this.max.toArray()
      };
    }
    /**
     * Returns a serialized structure of the bounding box.
     *
     * @param {Object} json - The serialized json to set the box from.
     * @return {Box3} A reference to this bounding box.
     */
    fromJSON(json) {
      this.min.fromArray(json.min);
      this.max.fromArray(json.max);
      return this;
    }
  }
  const _points = [
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3()
  ];
  const _vector$b = /* @__PURE__ */ new Vector3();
  const _box$4 = /* @__PURE__ */ new Box3();
  const _v0$2 = /* @__PURE__ */ new Vector3();
  const _v1$7 = /* @__PURE__ */ new Vector3();
  const _v2$4 = /* @__PURE__ */ new Vector3();
  const _f0 = /* @__PURE__ */ new Vector3();
  const _f1 = /* @__PURE__ */ new Vector3();
  const _f2 = /* @__PURE__ */ new Vector3();
  const _center = /* @__PURE__ */ new Vector3();
  const _extents = /* @__PURE__ */ new Vector3();
  const _triangleNormal = /* @__PURE__ */ new Vector3();
  const _testAxis = /* @__PURE__ */ new Vector3();
  function satForAxes(axes, v0, v1, v2, extents) {
    for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {
      _testAxis.fromArray(axes, i2);
      const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
      const p0 = v0.dot(_testAxis);
      const p1 = v1.dot(_testAxis);
      const p2 = v2.dot(_testAxis);
      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
        return false;
      }
    }
    return true;
  }
  const _colorKeywords = {
    "aliceblue": 15792383,
    "antiquewhite": 16444375,
    "aqua": 65535,
    "aquamarine": 8388564,
    "azure": 15794175,
    "beige": 16119260,
    "bisque": 16770244,
    "black": 0,
    "blanchedalmond": 16772045,
    "blue": 255,
    "blueviolet": 9055202,
    "brown": 10824234,
    "burlywood": 14596231,
    "cadetblue": 6266528,
    "chartreuse": 8388352,
    "chocolate": 13789470,
    "coral": 16744272,
    "cornflowerblue": 6591981,
    "cornsilk": 16775388,
    "crimson": 14423100,
    "cyan": 65535,
    "darkblue": 139,
    "darkcyan": 35723,
    "darkgoldenrod": 12092939,
    "darkgray": 11119017,
    "darkgreen": 25600,
    "darkgrey": 11119017,
    "darkkhaki": 12433259,
    "darkmagenta": 9109643,
    "darkolivegreen": 5597999,
    "darkorange": 16747520,
    "darkorchid": 10040012,
    "darkred": 9109504,
    "darksalmon": 15308410,
    "darkseagreen": 9419919,
    "darkslateblue": 4734347,
    "darkslategray": 3100495,
    "darkslategrey": 3100495,
    "darkturquoise": 52945,
    "darkviolet": 9699539,
    "deeppink": 16716947,
    "deepskyblue": 49151,
    "dimgray": 6908265,
    "dimgrey": 6908265,
    "dodgerblue": 2003199,
    "firebrick": 11674146,
    "floralwhite": 16775920,
    "forestgreen": 2263842,
    "fuchsia": 16711935,
    "gainsboro": 14474460,
    "ghostwhite": 16316671,
    "gold": 16766720,
    "goldenrod": 14329120,
    "gray": 8421504,
    "green": 32768,
    "greenyellow": 11403055,
    "grey": 8421504,
    "honeydew": 15794160,
    "hotpink": 16738740,
    "indianred": 13458524,
    "indigo": 4915330,
    "ivory": 16777200,
    "khaki": 15787660,
    "lavender": 15132410,
    "lavenderblush": 16773365,
    "lawngreen": 8190976,
    "lemonchiffon": 16775885,
    "lightblue": 11393254,
    "lightcoral": 15761536,
    "lightcyan": 14745599,
    "lightgoldenrodyellow": 16448210,
    "lightgray": 13882323,
    "lightgreen": 9498256,
    "lightgrey": 13882323,
    "lightpink": 16758465,
    "lightsalmon": 16752762,
    "lightseagreen": 2142890,
    "lightskyblue": 8900346,
    "lightslategray": 7833753,
    "lightslategrey": 7833753,
    "lightsteelblue": 11584734,
    "lightyellow": 16777184,
    "lime": 65280,
    "limegreen": 3329330,
    "linen": 16445670,
    "magenta": 16711935,
    "maroon": 8388608,
    "mediumaquamarine": 6737322,
    "mediumblue": 205,
    "mediumorchid": 12211667,
    "mediumpurple": 9662683,
    "mediumseagreen": 3978097,
    "mediumslateblue": 8087790,
    "mediumspringgreen": 64154,
    "mediumturquoise": 4772300,
    "mediumvioletred": 13047173,
    "midnightblue": 1644912,
    "mintcream": 16121850,
    "mistyrose": 16770273,
    "moccasin": 16770229,
    "navajowhite": 16768685,
    "navy": 128,
    "oldlace": 16643558,
    "olive": 8421376,
    "olivedrab": 7048739,
    "orange": 16753920,
    "orangered": 16729344,
    "orchid": 14315734,
    "palegoldenrod": 15657130,
    "palegreen": 10025880,
    "paleturquoise": 11529966,
    "palevioletred": 14381203,
    "papayawhip": 16773077,
    "peachpuff": 16767673,
    "peru": 13468991,
    "pink": 16761035,
    "plum": 14524637,
    "powderblue": 11591910,
    "purple": 8388736,
    "rebeccapurple": 6697881,
    "red": 16711680,
    "rosybrown": 12357519,
    "royalblue": 4286945,
    "saddlebrown": 9127187,
    "salmon": 16416882,
    "sandybrown": 16032864,
    "seagreen": 3050327,
    "seashell": 16774638,
    "sienna": 10506797,
    "silver": 12632256,
    "skyblue": 8900331,
    "slateblue": 6970061,
    "slategray": 7372944,
    "slategrey": 7372944,
    "snow": 16775930,
    "springgreen": 65407,
    "steelblue": 4620980,
    "tan": 13808780,
    "teal": 32896,
    "thistle": 14204888,
    "tomato": 16737095,
    "turquoise": 4251856,
    "violet": 15631086,
    "wheat": 16113331,
    "white": 16777215,
    "whitesmoke": 16119285,
    "yellow": 16776960,
    "yellowgreen": 10145074
  };
  const _hslA = { h: 0, s: 0, l: 0 };
  const _hslB = { h: 0, s: 0, l: 0 };
  function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
    return p;
  }
  class Color {
    /**
     * Constructs a new color.
     *
     * Note that standard method of specifying color in three.js is with a hexadecimal triplet,
     * and that method is used throughout the rest of the documentation.
     *
     * @param {(number|string|Color)} [r] - The red component of the color. If \`g\` and \`b\` are
     * not provided, it can be hexadecimal triplet, a CSS-style string or another \`Color\` instance.
     * @param {number} [g] - The green component.
     * @param {number} [b] - The blue component.
     */
    constructor(r, g, b) {
      this.isColor = true;
      this.r = 1;
      this.g = 1;
      this.b = 1;
      return this.set(r, g, b);
    }
    /**
     * Sets the colors's components from the given values.
     *
     * @param {(number|string|Color)} [r] - The red component of the color. If \`g\` and \`b\` are
     * not provided, it can be hexadecimal triplet, a CSS-style string or another \`Color\` instance.
     * @param {number} [g] - The green component.
     * @param {number} [b] - The blue component.
     * @return {Color} A reference to this color.
     */
    set(r, g, b) {
      if (g === void 0 && b === void 0) {
        const value = r;
        if (value && value.isColor) {
          this.copy(value);
        } else if (typeof value === "number") {
          this.setHex(value);
        } else if (typeof value === "string") {
          this.setStyle(value);
        }
      } else {
        this.setRGB(r, g, b);
      }
      return this;
    }
    /**
     * Sets the colors's components to the given scalar value.
     *
     * @param {number} scalar - The scalar value.
     * @return {Color} A reference to this color.
     */
    setScalar(scalar) {
      this.r = scalar;
      this.g = scalar;
      this.b = scalar;
      return this;
    }
    /**
     * Sets this color from a hexadecimal value.
     *
     * @param {number} hex - The hexadecimal value.
     * @param {string} [colorSpace=SRGBColorSpace] - The color space.
     * @return {Color} A reference to this color.
     */
    setHex(hex, colorSpace = SRGBColorSpace) {
      hex = Math.floor(hex);
      this.r = (hex >> 16 & 255) / 255;
      this.g = (hex >> 8 & 255) / 255;
      this.b = (hex & 255) / 255;
      ColorManagement.colorSpaceToWorking(this, colorSpace);
      return this;
    }
    /**
     * Sets this color from RGB values.
     *
     * @param {number} r - Red channel value between \`0.0\` and \`1.0\`.
     * @param {number} g - Green channel value between \`0.0\` and \`1.0\`.
     * @param {number} b - Blue channel value between \`0.0\` and \`1.0\`.
     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
     * @return {Color} A reference to this color.
     */
    setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {
      this.r = r;
      this.g = g;
      this.b = b;
      ColorManagement.colorSpaceToWorking(this, colorSpace);
      return this;
    }
    /**
     * Sets this color from RGB values.
     *
     * @param {number} h - Hue value between \`0.0\` and \`1.0\`.
     * @param {number} s - Saturation value between \`0.0\` and \`1.0\`.
     * @param {number} l - Lightness value between \`0.0\` and \`1.0\`.
     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
     * @return {Color} A reference to this color.
     */
    setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {
      h = euclideanModulo(h, 1);
      s = clamp(s, 0, 1);
      l = clamp(l, 0, 1);
      if (s === 0) {
        this.r = this.g = this.b = l;
      } else {
        const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        const q = 2 * l - p;
        this.r = hue2rgb(q, p, h + 1 / 3);
        this.g = hue2rgb(q, p, h);
        this.b = hue2rgb(q, p, h - 1 / 3);
      }
      ColorManagement.colorSpaceToWorking(this, colorSpace);
      return this;
    }
    /**
     * Sets this color from a CSS-style string. For example, \`rgb(250, 0,0)\`,
     * \`rgb(100%, 0%, 0%)\`, \`hsl(0, 100%, 50%)\`, \`#ff0000\`, \`#f00\`, or \`red\` ( or
     * any [X11 color name]{@link https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart} -
     * all 140 color names are supported).
     *
     * @param {string} style - Color as a CSS-style string.
     * @param {string} [colorSpace=SRGBColorSpace] - The color space.
     * @return {Color} A reference to this color.
     */
    setStyle(style, colorSpace = SRGBColorSpace) {
      function handleAlpha(string) {
        if (string === void 0) return;
        if (parseFloat(string) < 1) {
          console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
        }
      }
      let m;
      if (m = /^(\\w+)\\(([^\\)]*)\\)/.exec(style)) {
        let color;
        const name = m[1];
        const components = m[2];
        switch (name) {
          case "rgb":
          case "rgba":
            if (color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {
              handleAlpha(color[4]);
              return this.setRGB(
                Math.min(255, parseInt(color[1], 10)) / 255,
                Math.min(255, parseInt(color[2], 10)) / 255,
                Math.min(255, parseInt(color[3], 10)) / 255,
                colorSpace
              );
            }
            if (color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {
              handleAlpha(color[4]);
              return this.setRGB(
                Math.min(100, parseInt(color[1], 10)) / 100,
                Math.min(100, parseInt(color[2], 10)) / 100,
                Math.min(100, parseInt(color[3], 10)) / 100,
                colorSpace
              );
            }
            break;
          case "hsl":
          case "hsla":
            if (color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {
              handleAlpha(color[4]);
              return this.setHSL(
                parseFloat(color[1]) / 360,
                parseFloat(color[2]) / 100,
                parseFloat(color[3]) / 100,
                colorSpace
              );
            }
            break;
          default:
            console.warn("THREE.Color: Unknown color model " + style);
        }
      } else if (m = /^\\#([A-Fa-f\\d]+)$/.exec(style)) {
        const hex = m[1];
        const size = hex.length;
        if (size === 3) {
          return this.setRGB(
            parseInt(hex.charAt(0), 16) / 15,
            parseInt(hex.charAt(1), 16) / 15,
            parseInt(hex.charAt(2), 16) / 15,
            colorSpace
          );
        } else if (size === 6) {
          return this.setHex(parseInt(hex, 16), colorSpace);
        } else {
          console.warn("THREE.Color: Invalid hex color " + style);
        }
      } else if (style && style.length > 0) {
        return this.setColorName(style, colorSpace);
      }
      return this;
    }
    /**
     * Sets this color from a color name. Faster than {@link Color#setStyle} if
     * you don't need the other CSS-style formats.
     *
     * For convenience, the list of names is exposed in \`Color.NAMES\` as a hash.
     * \`\`\`js
     * Color.NAMES.aliceblue // returns 0xF0F8FF
     * \`\`\`
     *
     * @param {string} style - The color name.
     * @param {string} [colorSpace=SRGBColorSpace] - The color space.
     * @return {Color} A reference to this color.
     */
    setColorName(style, colorSpace = SRGBColorSpace) {
      const hex = _colorKeywords[style.toLowerCase()];
      if (hex !== void 0) {
        this.setHex(hex, colorSpace);
      } else {
        console.warn("THREE.Color: Unknown color " + style);
      }
      return this;
    }
    /**
     * Returns a new color with copied values from this instance.
     *
     * @return {Color} A clone of this instance.
     */
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    /**
     * Copies the values of the given color to this instance.
     *
     * @param {Color} color - The color to copy.
     * @return {Color} A reference to this color.
     */
    copy(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      return this;
    }
    /**
     * Copies the given color into this color, and then converts this color from
     * \`SRGBColorSpace\` to \`LinearSRGBColorSpace\`.
     *
     * @param {Color} color - The color to copy/convert.
     * @return {Color} A reference to this color.
     */
    copySRGBToLinear(color) {
      this.r = SRGBToLinear(color.r);
      this.g = SRGBToLinear(color.g);
      this.b = SRGBToLinear(color.b);
      return this;
    }
    /**
     * Copies the given color into this color, and then converts this color from
     * \`LinearSRGBColorSpace\` to \`SRGBColorSpace\`.
     *
     * @param {Color} color - The color to copy/convert.
     * @return {Color} A reference to this color.
     */
    copyLinearToSRGB(color) {
      this.r = LinearToSRGB(color.r);
      this.g = LinearToSRGB(color.g);
      this.b = LinearToSRGB(color.b);
      return this;
    }
    /**
     * Converts this color from \`SRGBColorSpace\` to \`LinearSRGBColorSpace\`.
     *
     * @return {Color} A reference to this color.
     */
    convertSRGBToLinear() {
      this.copySRGBToLinear(this);
      return this;
    }
    /**
     * Converts this color from \`LinearSRGBColorSpace\` to \`SRGBColorSpace\`.
     *
     * @return {Color} A reference to this color.
     */
    convertLinearToSRGB() {
      this.copyLinearToSRGB(this);
      return this;
    }
    /**
     * Returns the hexadecimal value of this color.
     *
     * @param {string} [colorSpace=SRGBColorSpace] - The color space.
     * @return {number} The hexadecimal value.
     */
    getHex(colorSpace = SRGBColorSpace) {
      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
      return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));
    }
    /**
     * Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').
     *
     * @param {string} [colorSpace=SRGBColorSpace] - The color space.
     * @return {string} The hexadecimal value as a string.
     */
    getHexString(colorSpace = SRGBColorSpace) {
      return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
    }
    /**
     * Converts the colors RGB values into the HSL format and stores them into the
     * given target object.
     *
     * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method's result.
     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
     * @return {{h:number,s:number,l:number}} The HSL representation of this color.
     */
    getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
      const r = _color.r, g = _color.g, b = _color.b;
      const max2 = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let hue, saturation;
      const lightness = (min + max2) / 2;
      if (min === max2) {
        hue = 0;
        saturation = 0;
      } else {
        const delta = max2 - min;
        saturation = lightness <= 0.5 ? delta / (max2 + min) : delta / (2 - max2 - min);
        switch (max2) {
          case r:
            hue = (g - b) / delta + (g < b ? 6 : 0);
            break;
          case g:
            hue = (b - r) / delta + 2;
            break;
          case b:
            hue = (r - g) / delta + 4;
            break;
        }
        hue /= 6;
      }
      target.h = hue;
      target.s = saturation;
      target.l = lightness;
      return target;
    }
    /**
     * Returns the RGB values of this color and stores them into the given target object.
     *
     * @param {Color} target - The target color that is used to store the method's result.
     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
     * @return {Color} The RGB representation of this color.
     */
    getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
      target.r = _color.r;
      target.g = _color.g;
      target.b = _color.b;
      return target;
    }
    /**
     * Returns the value of this color as a CSS style string. Example: \`rgb(255,0,0)\`.
     *
     * @param {string} [colorSpace=SRGBColorSpace] - The color space.
     * @return {string} The CSS representation of this color.
     */
    getStyle(colorSpace = SRGBColorSpace) {
      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
      const r = _color.r, g = _color.g, b = _color.b;
      if (colorSpace !== SRGBColorSpace) {
        return \`color(\${colorSpace} \${r.toFixed(3)} \${g.toFixed(3)} \${b.toFixed(3)})\`;
      }
      return \`rgb(\${Math.round(r * 255)},\${Math.round(g * 255)},\${Math.round(b * 255)})\`;
    }
    /**
     * Adds the given HSL values to this color's values.
     * Internally, this converts the color's RGB values to HSL, adds HSL
     * and then converts the color back to RGB.
     *
     * @param {number} h - Hue value between \`0.0\` and \`1.0\`.
     * @param {number} s - Saturation value between \`0.0\` and \`1.0\`.
     * @param {number} l - Lightness value between \`0.0\` and \`1.0\`.
     * @return {Color} A reference to this color.
     */
    offsetHSL(h, s, l) {
      this.getHSL(_hslA);
      return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);
    }
    /**
     * Adds the RGB values of the given color to the RGB values of this color.
     *
     * @param {Color} color - The color to add.
     * @return {Color} A reference to this color.
     */
    add(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      return this;
    }
    /**
     * Adds the RGB values of the given colors and stores the result in this instance.
     *
     * @param {Color} color1 - The first color.
     * @param {Color} color2 - The second color.
     * @return {Color} A reference to this color.
     */
    addColors(color1, color2) {
      this.r = color1.r + color2.r;
      this.g = color1.g + color2.g;
      this.b = color1.b + color2.b;
      return this;
    }
    /**
     * Adds the given scalar value to the RGB values of this color.
     *
     * @param {number} s - The scalar to add.
     * @return {Color} A reference to this color.
     */
    addScalar(s) {
      this.r += s;
      this.g += s;
      this.b += s;
      return this;
    }
    /**
     * Subtracts the RGB values of the given color from the RGB values of this color.
     *
     * @param {Color} color - The color to subtract.
     * @return {Color} A reference to this color.
     */
    sub(color) {
      this.r = Math.max(0, this.r - color.r);
      this.g = Math.max(0, this.g - color.g);
      this.b = Math.max(0, this.b - color.b);
      return this;
    }
    /**
     * Multiplies the RGB values of the given color with the RGB values of this color.
     *
     * @param {Color} color - The color to multiply.
     * @return {Color} A reference to this color.
     */
    multiply(color) {
      this.r *= color.r;
      this.g *= color.g;
      this.b *= color.b;
      return this;
    }
    /**
     * Multiplies the given scalar value with the RGB values of this color.
     *
     * @param {number} s - The scalar to multiply.
     * @return {Color} A reference to this color.
     */
    multiplyScalar(s) {
      this.r *= s;
      this.g *= s;
      this.b *= s;
      return this;
    }
    /**
     * Linearly interpolates this color's RGB values toward the RGB values of the
     * given color. The alpha argument can be thought of as the ratio between
     * the two colors, where \`0.0\` is this color and \`1.0\` is the first argument.
     *
     * @param {Color} color - The color to converge on.
     * @param {number} alpha - The interpolation factor in the closed interval \`[0,1]\`.
     * @return {Color} A reference to this color.
     */
    lerp(color, alpha) {
      this.r += (color.r - this.r) * alpha;
      this.g += (color.g - this.g) * alpha;
      this.b += (color.b - this.b) * alpha;
      return this;
    }
    /**
     * Linearly interpolates between the given colors and stores the result in this instance.
     * The alpha argument can be thought of as the ratio between the two colors, where \`0.0\`
     * is the first and \`1.0\` is the second color.
     *
     * @param {Color} color1 - The first color.
     * @param {Color} color2 - The second color.
     * @param {number} alpha - The interpolation factor in the closed interval \`[0,1]\`.
     * @return {Color} A reference to this color.
     */
    lerpColors(color1, color2, alpha) {
      this.r = color1.r + (color2.r - color1.r) * alpha;
      this.g = color1.g + (color2.g - color1.g) * alpha;
      this.b = color1.b + (color2.b - color1.b) * alpha;
      return this;
    }
    /**
     * Linearly interpolates this color's HSL values toward the HSL values of the
     * given color. It differs from {@link Color#lerp} by not interpolating straight
     * from one color to the other, but instead going through all the hues in between
     * those two colors. The alpha argument can be thought of as the ratio between
     * the two colors, where 0.0 is this color and 1.0 is the first argument.
     *
     * @param {Color} color - The color to converge on.
     * @param {number} alpha - The interpolation factor in the closed interval \`[0,1]\`.
     * @return {Color} A reference to this color.
     */
    lerpHSL(color, alpha) {
      this.getHSL(_hslA);
      color.getHSL(_hslB);
      const h = lerp(_hslA.h, _hslB.h, alpha);
      const s = lerp(_hslA.s, _hslB.s, alpha);
      const l = lerp(_hslA.l, _hslB.l, alpha);
      this.setHSL(h, s, l);
      return this;
    }
    /**
     * Sets the color's RGB components from the given 3D vector.
     *
     * @param {Vector3} v - The vector to set.
     * @return {Color} A reference to this color.
     */
    setFromVector3(v) {
      this.r = v.x;
      this.g = v.y;
      this.b = v.z;
      return this;
    }
    /**
     * Transforms this color with the given 3x3 matrix.
     *
     * @param {Matrix3} m - The matrix.
     * @return {Color} A reference to this color.
     */
    applyMatrix3(m) {
      const r = this.r, g = this.g, b = this.b;
      const e = m.elements;
      this.r = e[0] * r + e[3] * g + e[6] * b;
      this.g = e[1] * r + e[4] * g + e[7] * b;
      this.b = e[2] * r + e[5] * g + e[8] * b;
      return this;
    }
    /**
     * Returns \`true\` if this color is equal with the given one.
     *
     * @param {Color} c - The color to test for equality.
     * @return {boolean} Whether this bounding color is equal with the given one.
     */
    equals(c) {
      return c.r === this.r && c.g === this.g && c.b === this.b;
    }
    /**
     * Sets this color's RGB components from the given array.
     *
     * @param {Array<number>} array - An array holding the RGB values.
     * @param {number} [offset=0] - The offset into the array.
     * @return {Color} A reference to this color.
     */
    fromArray(array, offset = 0) {
      this.r = array[offset];
      this.g = array[offset + 1];
      this.b = array[offset + 2];
      return this;
    }
    /**
     * Writes the RGB components of this color to the given array. If no array is provided,
     * the method returns a new instance.
     *
     * @param {Array<number>} [array=[]] - The target array holding the color components.
     * @param {number} [offset=0] - Index of the first element in the array.
     * @return {Array<number>} The color components.
     */
    toArray(array = [], offset = 0) {
      array[offset] = this.r;
      array[offset + 1] = this.g;
      array[offset + 2] = this.b;
      return array;
    }
    /**
     * Sets the components of this color from the given buffer attribute.
     *
     * @param {BufferAttribute} attribute - The buffer attribute holding color data.
     * @param {number} index - The index into the attribute.
     * @return {Color} A reference to this color.
     */
    fromBufferAttribute(attribute, index) {
      this.r = attribute.getX(index);
      this.g = attribute.getY(index);
      this.b = attribute.getZ(index);
      return this;
    }
    /**
     * This methods defines the serialization result of this class. Returns the color
     * as a hexadecimal value.
     *
     * @return {number} The hexadecimal value.
     */
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r;
      yield this.g;
      yield this.b;
    }
  }
  const _color = /* @__PURE__ */ new Color();
  Color.NAMES = _colorKeywords;
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
      revision: REVISION
    } }));
  }
  if (typeof window !== "undefined") {
    if (window.__THREE__) {
      console.warn("WARNING: Multiple instances of Three.js being imported.");
    } else {
      window.__THREE__ = REVISION;
    }
  }
  const LN_SCALE_MIN = -12;
  const LN_SCALE_MAX = 9;
  const LN_SCALE_ZERO = -30;
  const SCALE_ZERO = Math.exp(LN_SCALE_ZERO);
  const SPLAT_TEX_WIDTH_BITS = 11;
  const SPLAT_TEX_HEIGHT_BITS = 11;
  const SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS;
  const SPLAT_TEX_HEIGHT = 1 << SPLAT_TEX_HEIGHT_BITS;
  const SPLAT_TEX_MIN_HEIGHT = 1;
  function unindentLines(s) {
    var _a2;
    let seenNonEmpty = false;
    const lines = s.split("\\n").map((line) => {
      const trimmedLine = line.trimEnd();
      if (seenNonEmpty) {
        return trimmedLine;
      }
      if (trimmedLine.length > 0) {
        seenNonEmpty = true;
        return trimmedLine;
      }
      return null;
    }).filter((line) => line != null);
    while (lines.length > 0 && lines[lines.length - 1].length === 0) {
      lines.pop();
    }
    if (lines.length === 0) {
      return [];
    }
    const indent = (_a2 = lines[0].match(/^\\s*/)) == null ? void 0 : _a2[0];
    if (!indent) {
      return lines;
    }
    const regex = new RegExp(\`^\${indent}\`);
    return lines.map((line) => line.replace(regex, ""));
  }
  function unindent(s) {
    return unindentLines(s).join("\\n");
  }
  const f32buffer = new Float32Array(1);
  const u32buffer = new Uint32Array(f32buffer.buffer);
  const supportsFloat16Array = "Float16Array" in globalThis;
  const f16buffer = supportsFloat16Array ? new globalThis["Float16Array"](1) : null;
  const u16buffer = new Uint16Array(f16buffer == null ? void 0 : f16buffer.buffer);
  function normalize(vec) {
    const norm = Math.sqrt(vec.reduce((acc, v) => acc + v * v, 0));
    return vec.map((v) => v / norm);
  }
  const toHalf = supportsFloat16Array ? toHalfNative : toHalfJS;
  const fromHalf = supportsFloat16Array ? fromHalfNative : fromHalfJS;
  function toHalfNative(f) {
    f16buffer[0] = f;
    return u16buffer[0];
  }
  function toHalfJS(f) {
    f32buffer[0] = f;
    const bits2 = u32buffer[0];
    const sign = bits2 >> 31 & 1;
    const exp = bits2 >> 23 & 255;
    const frac = bits2 & 8388607;
    const halfSign = sign << 15;
    if (exp === 255) {
      if (frac !== 0) {
        return halfSign | 32767;
      }
      return halfSign | 31744;
    }
    const newExp = exp - 127 + 15;
    if (newExp >= 31) {
      return halfSign | 31744;
    }
    if (newExp <= 0) {
      if (newExp < -10) {
        return halfSign;
      }
      const subFrac = (frac | 8388608) >> 1 - newExp + 13;
      return halfSign | subFrac;
    }
    const halfFrac = frac >> 13;
    return halfSign | newExp << 10 | halfFrac;
  }
  function fromHalfNative(u) {
    u16buffer[0] = u;
    return f16buffer[0];
  }
  function fromHalfJS(h) {
    const sign = h >> 15 & 1;
    const exp = h >> 10 & 31;
    const frac = h & 1023;
    let f32bits;
    if (exp === 0) {
      if (frac === 0) {
        f32bits = sign << 31;
      } else {
        let mant = frac;
        let e = -14;
        while ((mant & 1024) === 0) {
          mant <<= 1;
          e--;
        }
        mant &= 1023;
        const newExp = e + 127;
        const newFrac = mant << 13;
        f32bits = sign << 31 | newExp << 23 | newFrac;
      }
    } else if (exp === 31) {
      if (frac === 0) {
        f32bits = sign << 31 | 2139095040;
      } else {
        f32bits = sign << 31 | 2143289344;
      }
    } else {
      const newExp = exp - 15 + 127;
      const newFrac = frac << 13;
      f32bits = sign << 31 | newExp << 23 | newFrac;
    }
    u32buffer[0] = f32bits;
    return f32buffer[0];
  }
  function floatToUint8(v) {
    return Math.max(0, Math.min(255, Math.round(v * 255)));
  }
  function getArrayBuffers(ctx) {
    const buffers = [];
    const seen = /* @__PURE__ */ new Set();
    function traverse(obj) {
      if (obj && typeof obj === "object" && !seen.has(obj)) {
        seen.add(obj);
        if (obj instanceof ArrayBuffer) {
          buffers.push(obj);
        } else if (ArrayBuffer.isView(obj)) {
          buffers.push(obj.buffer);
        } else if (Array.isArray(obj)) {
          obj.forEach(traverse);
        } else {
          Object.values(obj).forEach(traverse);
        }
      }
    }
    traverse(ctx);
    return buffers;
  }
  function setPackedSplat(packedSplats, index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b, encoding) {
    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;
    const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;
    const rgbRange = rgbMax - rgbMin;
    const uR = floatToUint8((r - rgbMin) / rgbRange);
    const uG = floatToUint8((g - rgbMin) / rgbRange);
    const uB = floatToUint8((b - rgbMin) / rgbRange);
    const uA = floatToUint8(opacity);
    const uQuat = encodeQuatOctXy88R8(
      tempQuaternion.set(quatX, quatY, quatZ, quatW)
    );
    const uQuatX = uQuat & 255;
    const uQuatY = uQuat >>> 8 & 255;
    const uQuatZ = uQuat >>> 16 & 255;
    const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;
    const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;
    const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);
    const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(
      255,
      Math.max(
        1,
        Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1
      )
    );
    const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(
      255,
      Math.max(
        1,
        Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1
      )
    );
    const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(
      255,
      Math.max(
        1,
        Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1
      )
    );
    const uCenterX = toHalf(x2);
    const uCenterY = toHalf(y);
    const uCenterZ = toHalf(z);
    const i4 = index * 4;
    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;
    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;
    packedSplats[i4 + 2] = uCenterZ | uQuatX << 16 | uQuatY << 24;
    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | uQuatZ << 24;
  }
  function setPackedSplatCenter(packedSplats, index, x2, y, z) {
    const uCenterX = toHalf(x2);
    const uCenterY = toHalf(y);
    const uCenterZ = toHalf(z);
    const i4 = index * 4;
    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;
    packedSplats[i4 + 2] = uCenterZ | packedSplats[i4 + 2] & 4294901760;
  }
  function setPackedSplatScales(packedSplats, index, scaleX, scaleY, scaleZ, encoding) {
    const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;
    const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;
    const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);
    const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(
      255,
      Math.max(
        1,
        Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1
      )
    );
    const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(
      255,
      Math.max(
        1,
        Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1
      )
    );
    const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(
      255,
      Math.max(
        1,
        Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1
      )
    );
    const i4 = index * 4;
    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | packedSplats[i4 + 3] & 4278190080;
  }
  const tempQuaternion = new Quaternion();
  function setPackedSplatQuat(packedSplats, index, quatX, quatY, quatZ, quatW) {
    const uQuat = encodeQuatOctXy88R8(
      tempQuaternion.set(quatX, quatY, quatZ, quatW)
    );
    const uQuatX = uQuat & 255;
    const uQuatY = uQuat >>> 8 & 255;
    const uQuatZ = uQuat >>> 16 & 255;
    const i4 = index * 4;
    packedSplats[i4 + 2] = packedSplats[i4 + 2] & 65535 | uQuatX << 16 | uQuatY << 24;
    packedSplats[i4 + 3] = packedSplats[i4 + 3] & 16777215 | uQuatZ << 24;
  }
  function setPackedSplatRgba(packedSplats, index, r, g, b, a, encoding) {
    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;
    const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;
    const rgbRange = rgbMax - rgbMin;
    const uR = floatToUint8((r - rgbMin) / rgbRange);
    const uG = floatToUint8((g - rgbMin) / rgbRange);
    const uB = floatToUint8((b - rgbMin) / rgbRange);
    const uA = floatToUint8(a);
    const i4 = index * 4;
    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;
  }
  function setPackedSplatRgb(packedSplats, index, r, g, b, encoding) {
    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;
    const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;
    const rgbRange = rgbMax - rgbMin;
    const uR = floatToUint8((r - rgbMin) / rgbRange);
    const uG = floatToUint8((g - rgbMin) / rgbRange);
    const uB = floatToUint8((b - rgbMin) / rgbRange);
    const i4 = index * 4;
    packedSplats[i4] = uR | uG << 8 | uB << 16 | packedSplats[i4] & 4278190080;
  }
  function setPackedSplatOpacity(packedSplats, index, opacity) {
    const uA = floatToUint8(opacity);
    const i4 = index * 4;
    packedSplats[i4] = packedSplats[i4] & 16777215 | uA << 24;
  }
  new Vector3();
  new Vector3();
  new Color();
  function getTextureSize(numSplats) {
    const width = SPLAT_TEX_WIDTH;
    const height = Math.max(
      SPLAT_TEX_MIN_HEIGHT,
      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))
    );
    const depth = Math.ceil(numSplats / (width * height));
    const maxSplats = width * height * depth;
    return { width, height, depth, maxSplats };
  }
  function computeMaxSplats(numSplats) {
    const width = SPLAT_TEX_WIDTH;
    const height = Math.max(
      SPLAT_TEX_MIN_HEIGHT,
      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))
    );
    const depth = Math.ceil(numSplats / (width * height));
    return width * height * depth;
  }
  unindent(\`
  precision highp float;

  in vec3 position;

  void main() {
    gl_Position = vec4(position.xy, 0.0, 1.0);
  }
\`);
  const tempNormalizedQuaternion = new Quaternion();
  const tempAxis = new Vector3();
  function encodeQuatOctXy88R8(q) {
    const qnorm = tempNormalizedQuaternion.copy(q).normalize();
    if (qnorm.w < 0) {
      qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);
    }
    const theta = 2 * Math.acos(qnorm.w);
    const xyz_norm = Math.sqrt(
      qnorm.x * qnorm.x + qnorm.y * qnorm.y + qnorm.z * qnorm.z
    );
    const axis = xyz_norm < 1e-6 ? tempAxis.set(1, 0, 0) : tempAxis.set(qnorm.x, qnorm.y, qnorm.z).divideScalar(xyz_norm);
    const sum = Math.abs(axis.x) + Math.abs(axis.y) + Math.abs(axis.z);
    let p_x = axis.x / sum;
    let p_y = axis.y / sum;
    if (axis.z < 0) {
      const tmp = p_x;
      p_x = (1 - Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);
      p_y = (1 - Math.abs(tmp)) * (p_y >= 0 ? 1 : -1);
    }
    const u_f = p_x * 0.5 + 0.5;
    const v_f = p_y * 0.5 + 0.5;
    const quantU = Math.round(u_f * 255);
    const quantV = Math.round(v_f * 255);
    const angleInt = Math.round(theta * (255 / Math.PI));
    return angleInt << 16 | quantV << 8 | quantU;
  }
  function packSint8Bytes(b0, b1, b22, b3) {
    const clampedB0 = Math.max(-127, Math.min(127, b0 * 127));
    const clampedB1 = Math.max(-127, Math.min(127, b1 * 127));
    const clampedB2 = Math.max(-127, Math.min(127, b22 * 127));
    const clampedB3 = Math.max(-127, Math.min(127, b3 * 127));
    return clampedB0 & 255 | (clampedB1 & 255) << 8 | (clampedB2 & 255) << 16 | (clampedB3 & 255) << 24;
  }
  function encodeSh1Rgb(sh1Array, index, sh1Rgb, encoding) {
    const sh1Min = (encoding == null ? void 0 : encoding.sh1Min) ?? -1;
    const sh1Max = (encoding == null ? void 0 : encoding.sh1Max) ?? 1;
    const sh1Mid = 0.5 * (sh1Min + sh1Max);
    const sh1Scale = 126 / (sh1Max - sh1Min);
    const base = index * 2;
    for (let i2 = 0; i2 < 9; ++i2) {
      const s = (sh1Rgb[i2] - sh1Mid) * sh1Scale;
      const value = Math.round(Math.max(-63, Math.min(63, s))) & 127;
      const bitStart = i2 * 7;
      const bitEnd = bitStart + 7;
      const wordStart = Math.floor(bitStart / 32);
      const bitOffset = bitStart - wordStart * 32;
      const firstWord = value << bitOffset & 4294967295;
      sh1Array[base + wordStart] |= firstWord;
      if (bitEnd > wordStart * 32 + 32) {
        const secondWord = value >>> 32 - bitOffset & 4294967295;
        sh1Array[base + wordStart + 1] |= secondWord;
      }
    }
  }
  function encodeSh2Rgb(sh2Array, index, sh2Rgb, encoding) {
    const sh2Min = (encoding == null ? void 0 : encoding.sh2Min) ?? -1;
    const sh2Max = (encoding == null ? void 0 : encoding.sh2Max) ?? 1;
    const sh2Mid = 0.5 * (sh2Min + sh2Max);
    const sh2Scale = 2 / (sh2Max - sh2Min);
    sh2Array[index * 4 + 0] = packSint8Bytes(
      (sh2Rgb[0] - sh2Mid) * sh2Scale,
      (sh2Rgb[1] - sh2Mid) * sh2Scale,
      (sh2Rgb[2] - sh2Mid) * sh2Scale,
      (sh2Rgb[3] - sh2Mid) * sh2Scale
    );
    sh2Array[index * 4 + 1] = packSint8Bytes(
      (sh2Rgb[4] - sh2Mid) * sh2Scale,
      (sh2Rgb[5] - sh2Mid) * sh2Scale,
      (sh2Rgb[6] - sh2Mid) * sh2Scale,
      (sh2Rgb[7] - sh2Mid) * sh2Scale
    );
    sh2Array[index * 4 + 2] = packSint8Bytes(
      (sh2Rgb[8] - sh2Mid) * sh2Scale,
      (sh2Rgb[9] - sh2Mid) * sh2Scale,
      (sh2Rgb[10] - sh2Mid) * sh2Scale,
      (sh2Rgb[11] - sh2Mid) * sh2Scale
    );
    sh2Array[index * 4 + 3] = packSint8Bytes(
      (sh2Rgb[12] - sh2Mid) * sh2Scale,
      (sh2Rgb[13] - sh2Mid) * sh2Scale,
      (sh2Rgb[14] - sh2Mid) * sh2Scale,
      0
    );
  }
  function encodeSh3Rgb(sh3Array, index, sh3Rgb, encoding) {
    const sh3Min = (encoding == null ? void 0 : encoding.sh3Min) ?? -1;
    const sh3Max = (encoding == null ? void 0 : encoding.sh3Max) ?? 1;
    const sh3Mid = 0.5 * (sh3Min + sh3Max);
    const sh3Scale = 62 / (sh3Max - sh3Min);
    const base = index * 4;
    for (let i2 = 0; i2 < 21; ++i2) {
      const s = (sh3Rgb[i2] - sh3Mid) * sh3Scale;
      const value = Math.round(Math.max(-31, Math.min(31, s))) & 63;
      const bitStart = i2 * 6;
      const bitEnd = bitStart + 6;
      const wordStart = Math.floor(bitStart / 32);
      const bitOffset = bitStart - wordStart * 32;
      const firstWord = value << bitOffset & 4294967295;
      sh3Array[base + wordStart] |= firstWord;
      if (bitEnd > wordStart * 32 + 32) {
        const secondWord = value >>> 32 - bitOffset & 4294967295;
        sh3Array[base + wordStart + 1] |= secondWord;
      }
    }
  }
  function decompressPartialGzip(fileBytes, numBytes) {
    const chunks = [];
    let totalBytes = 0;
    let result = null;
    const gunzip = new Gunzip((data, final) => {
      chunks.push(data);
      totalBytes += data.length;
      if (final || totalBytes >= numBytes) {
        const allBytes = new Uint8Array(totalBytes);
        let offset2 = 0;
        for (const chunk of chunks) {
          allBytes.set(chunk, offset2);
          offset2 += chunk.length;
        }
        result = allBytes.slice(0, numBytes);
      }
    });
    const CHUNK_SIZE = 1024;
    let offset = 0;
    while (result == null && offset < fileBytes.length) {
      const chunk = fileBytes.slice(offset, offset + CHUNK_SIZE);
      gunzip.push(chunk, false);
      offset += CHUNK_SIZE;
    }
    if (result == null) {
      gunzip.push(new Uint8Array(), true);
      if (result == null) {
        throw new Error("Failed to decompress partial gzip");
      }
    }
    return result;
  }
  class GunzipReader {
    constructor({
      fileBytes,
      chunkBytes = 64 * 1024
    }) {
      this.fileBytes = fileBytes;
      this.chunkBytes = chunkBytes;
      this.chunks = [];
      this.totalBytes = 0;
      const ds = new DecompressionStream("gzip");
      const decompressionStream = new Blob([fileBytes]).stream().pipeThrough(ds);
      this.reader = decompressionStream.getReader();
    }
    async read(numBytes) {
      while (this.totalBytes < numBytes) {
        const { value: chunk, done: readerDone } = await this.reader.read();
        if (readerDone) {
          break;
        }
        this.chunks.push(chunk);
        this.totalBytes += chunk.length;
      }
      if (this.totalBytes < numBytes) {
        throw new Error(
          \`Unexpected EOF: needed \${numBytes}, got \${this.totalBytes}\`
        );
      }
      const allBytes = new Uint8Array(this.totalBytes);
      let outOffset = 0;
      for (const chunk of this.chunks) {
        allBytes.set(chunk, outOffset);
        outOffset += chunk.length;
      }
      const result = allBytes.subarray(0, numBytes);
      this.chunks = [allBytes.subarray(numBytes)];
      this.totalBytes -= numBytes;
      return result;
    }
  }
  function decodeAntiSplat(fileBytes, initNumSplats, splatCallback) {
    const numSplats = Math.floor(fileBytes.length / 32);
    if (numSplats * 32 !== fileBytes.length) {
      throw new Error("Invalid .splat file size");
    }
    initNumSplats(numSplats);
    const f32 = new Float32Array(fileBytes.buffer);
    for (let i2 = 0; i2 < numSplats; ++i2) {
      const i322 = i2 * 32;
      const i8 = i2 * 8;
      const x2 = f32[i8 + 0];
      const y = f32[i8 + 1];
      const z = f32[i8 + 2];
      const scaleX = f32[i8 + 3];
      const scaleY = f32[i8 + 4];
      const scaleZ = f32[i8 + 5];
      const r = fileBytes[i322 + 24] / 255;
      const g = fileBytes[i322 + 25] / 255;
      const b = fileBytes[i322 + 26] / 255;
      const opacity = fileBytes[i322 + 27] / 255;
      const quatW = (fileBytes[i322 + 28] - 128) / 128;
      const quatX = (fileBytes[i322 + 29] - 128) / 128;
      const quatY = (fileBytes[i322 + 30] - 128) / 128;
      const quatZ = (fileBytes[i322 + 31] - 128) / 128;
      splatCallback(
        i2,
        x2,
        y,
        z,
        scaleX,
        scaleY,
        scaleZ,
        quatX,
        quatY,
        quatZ,
        quatW,
        opacity,
        r,
        g,
        b
      );
    }
  }
  function unpackAntiSplat(fileBytes, splatEncoding) {
    let numSplats = 0;
    let maxSplats = 0;
    let packedArray = new Uint32Array(0);
    decodeAntiSplat(
      fileBytes,
      (cbNumSplats) => {
        numSplats = cbNumSplats;
        maxSplats = computeMaxSplats(numSplats);
        packedArray = new Uint32Array(maxSplats * 4);
      },
      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
        setPackedSplat(
          packedArray,
          index,
          x2,
          y,
          z,
          scaleX,
          scaleY,
          scaleZ,
          quatX,
          quatY,
          quatZ,
          quatW,
          opacity,
          r,
          g,
          b,
          splatEncoding
        );
      }
    );
    return { packedArray, numSplats };
  }
  const KSPLAT_COMPRESSION = {
    0: {
      bytesPerCenter: 12,
      bytesPerScale: 12,
      bytesPerRotation: 16,
      bytesPerColor: 4,
      bytesPerSphericalHarmonicsComponent: 4,
      scaleOffsetBytes: 12,
      rotationOffsetBytes: 24,
      colorOffsetBytes: 40,
      sphericalHarmonicsOffsetBytes: 44,
      scaleRange: 1
    },
    1: {
      bytesPerCenter: 6,
      bytesPerScale: 6,
      bytesPerRotation: 8,
      bytesPerColor: 4,
      bytesPerSphericalHarmonicsComponent: 2,
      scaleOffsetBytes: 6,
      rotationOffsetBytes: 12,
      colorOffsetBytes: 20,
      sphericalHarmonicsOffsetBytes: 24,
      scaleRange: 32767
    },
    2: {
      bytesPerCenter: 6,
      bytesPerScale: 6,
      bytesPerRotation: 8,
      bytesPerColor: 4,
      bytesPerSphericalHarmonicsComponent: 1,
      scaleOffsetBytes: 6,
      rotationOffsetBytes: 12,
      colorOffsetBytes: 20,
      sphericalHarmonicsOffsetBytes: 24,
      scaleRange: 32767
    }
  };
  const KSPLAT_SH_DEGREE_TO_COMPONENTS = {
    0: 0,
    1: 9,
    2: 24,
    3: 45
  };
  function decodeKsplat(fileBytes, initNumSplats, splatCallback, shCallback) {
    var _a2;
    const HEADER_BYTES = 4096;
    const SECTION_BYTES = 1024;
    let headerOffset = 0;
    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);
    headerOffset += HEADER_BYTES;
    const versionMajor = header.getUint8(0);
    const versionMinor = header.getUint8(1);
    if (versionMajor !== 0 || versionMinor < 1) {
      throw new Error(
        \`Unsupported .ksplat version: \${versionMajor}.\${versionMinor}\`
      );
    }
    const maxSectionCount = header.getUint32(4, true);
    header.getUint32(16, true);
    const compressionLevel = header.getUint16(20, true);
    if (compressionLevel < 0 || compressionLevel > 2) {
      throw new Error(\`Invalid .ksplat compression level: \${compressionLevel}\`);
    }
    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;
    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;
    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;
    for (let section = 0; section < maxSectionCount; ++section) {
      let getSh = function(splatOffset, component) {
        if (compressionLevel === 0) {
          return data.getFloat32(
            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,
            true
          );
        }
        if (compressionLevel === 1) {
          return fromHalf(
            data.getUint16(
              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,
              true
            )
          );
        }
        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;
        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);
      };
      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);
      headerOffset += SECTION_BYTES;
      const sectionSplatCount = section2.getUint32(0, true);
      const sectionMaxSplatCount = section2.getUint32(4, true);
      const bucketSize = section2.getUint32(8, true);
      const bucketCount = section2.getUint32(12, true);
      const bucketBlockSize = section2.getFloat32(16, true);
      const bucketStorageSizeBytes = section2.getUint16(20, true);
      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;
      const fullBucketCount = section2.getUint32(32, true);
      const fullBucketSplats = fullBucketCount * bucketSize;
      const partiallyFilledBucketCount = section2.getUint32(36, true);
      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;
      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;
      const sphericalHarmonicsDegree = section2.getUint16(40, true);
      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];
      const {
        bytesPerCenter,
        bytesPerScale,
        bytesPerRotation,
        bytesPerColor,
        bytesPerSphericalHarmonicsComponent,
        scaleOffsetBytes,
        rotationOffsetBytes,
        colorOffsetBytes,
        sphericalHarmonicsOffsetBytes
      } = KSPLAT_COMPRESSION[compressionLevel];
      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;
      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;
      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;
      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];
      const sh2Index = [
        9,
        14,
        19,
        10,
        15,
        20,
        11,
        16,
        21,
        12,
        17,
        22,
        13,
        18,
        23
      ];
      const sh3Index = [
        24,
        31,
        38,
        25,
        32,
        39,
        26,
        33,
        40,
        27,
        34,
        41,
        28,
        35,
        42,
        29,
        36,
        43,
        30,
        37,
        44
      ];
      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;
      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;
      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;
      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;
      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;
      const dataBase = sectionBase + bucketsStorageSizeBytes;
      const data = new DataView(
        fileBytes.buffer,
        dataBase,
        splatDataStorageSizeBytes
      );
      const bucketArray = new Float32Array(
        fileBytes.buffer,
        bucketsBase,
        bucketCount * 3
      );
      const partiallyFilledBucketLengths = new Uint32Array(
        fileBytes.buffer,
        sectionBase,
        partiallyFilledBucketCount
      );
      let partialBucketIndex = fullBucketCount;
      let partialBucketBase = fullBucketSplats;
      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {
        const splatOffset = i2 * bytesPerSplat;
        let bucketIndex;
        if (i2 < fullBucketSplats) {
          bucketIndex = Math.floor(i2 / bucketSize);
        } else {
          const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];
          if (i2 >= partialBucketBase + bucketLength) {
            partialBucketIndex += 1;
            partialBucketBase += bucketLength;
          }
          bucketIndex = partialBucketIndex;
        }
        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];
        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];
        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];
        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));
        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));
        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));
        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)
        );
        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)
        );
        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)
        );
        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)
        );
        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;
        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;
        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;
        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;
        splatCallback(
          i2,
          x2,
          y,
          z,
          scaleX,
          scaleY,
          scaleZ,
          quatX,
          quatY,
          quatZ,
          quatW,
          opacity,
          r,
          g,
          b
        );
        if (sphericalHarmonicsDegree >= 1 && sh1) {
          for (const [i22, key] of sh1Index.entries()) {
            sh1[i22] = getSh(splatOffset, key);
          }
          if (sh2) {
            for (const [i22, key] of sh2Index.entries()) {
              sh2[i22] = getSh(splatOffset, key);
            }
          }
          if (sh3) {
            for (const [i22, key] of sh3Index.entries()) {
              sh3[i22] = getSh(splatOffset, key);
            }
          }
          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);
        }
      }
      sectionBase += storageSizeBytes;
    }
  }
  function unpackKsplat(fileBytes, splatEncoding) {
    var _a2;
    const HEADER_BYTES = 4096;
    const SECTION_BYTES = 1024;
    let headerOffset = 0;
    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);
    headerOffset += HEADER_BYTES;
    const versionMajor = header.getUint8(0);
    const versionMinor = header.getUint8(1);
    if (versionMajor !== 0 || versionMinor < 1) {
      throw new Error(
        \`Unsupported .ksplat version: \${versionMajor}.\${versionMinor}\`
      );
    }
    const maxSectionCount = header.getUint32(4, true);
    const splatCount = header.getUint32(16, true);
    const compressionLevel = header.getUint16(20, true);
    if (compressionLevel < 0 || compressionLevel > 2) {
      throw new Error(\`Invalid .ksplat compression level: \${compressionLevel}\`);
    }
    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;
    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;
    const numSplats = splatCount;
    const maxSplats = computeMaxSplats(numSplats);
    const packedArray = new Uint32Array(maxSplats * 4);
    const extra = {};
    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;
    for (let section = 0; section < maxSectionCount; ++section) {
      let getSh = function(splatOffset, component) {
        if (compressionLevel === 0) {
          return data.getFloat32(
            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,
            true
          );
        }
        if (compressionLevel === 1) {
          return fromHalf(
            data.getUint16(
              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,
              true
            )
          );
        }
        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;
        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);
      };
      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);
      headerOffset += SECTION_BYTES;
      const sectionSplatCount = section2.getUint32(0, true);
      const sectionMaxSplatCount = section2.getUint32(4, true);
      const bucketSize = section2.getUint32(8, true);
      const bucketCount = section2.getUint32(12, true);
      const bucketBlockSize = section2.getFloat32(16, true);
      const bucketStorageSizeBytes = section2.getUint16(20, true);
      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;
      const fullBucketCount = section2.getUint32(32, true);
      const fullBucketSplats = fullBucketCount * bucketSize;
      const partiallyFilledBucketCount = section2.getUint32(36, true);
      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;
      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;
      const sphericalHarmonicsDegree = section2.getUint16(40, true);
      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];
      const {
        bytesPerCenter,
        bytesPerScale,
        bytesPerRotation,
        bytesPerColor,
        bytesPerSphericalHarmonicsComponent,
        scaleOffsetBytes,
        rotationOffsetBytes,
        colorOffsetBytes,
        sphericalHarmonicsOffsetBytes
      } = KSPLAT_COMPRESSION[compressionLevel];
      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;
      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;
      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;
      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];
      const sh2Index = [
        9,
        14,
        19,
        10,
        15,
        20,
        11,
        16,
        21,
        12,
        17,
        22,
        13,
        18,
        23
      ];
      const sh3Index = [
        24,
        31,
        38,
        25,
        32,
        39,
        26,
        33,
        40,
        27,
        34,
        41,
        28,
        35,
        42,
        29,
        36,
        43,
        30,
        37,
        44
      ];
      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;
      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;
      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;
      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;
      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;
      const dataBase = sectionBase + bucketsStorageSizeBytes;
      const data = new DataView(
        fileBytes.buffer,
        dataBase,
        splatDataStorageSizeBytes
      );
      const bucketArray = new Float32Array(
        fileBytes.buffer,
        bucketsBase,
        bucketCount * 3
      );
      const partiallyFilledBucketLengths = new Uint32Array(
        fileBytes.buffer,
        sectionBase,
        partiallyFilledBucketCount
      );
      let partialBucketIndex = fullBucketCount;
      let partialBucketBase = fullBucketSplats;
      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {
        const splatOffset = i2 * bytesPerSplat;
        let bucketIndex;
        if (i2 < fullBucketSplats) {
          bucketIndex = Math.floor(i2 / bucketSize);
        } else {
          const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];
          if (i2 >= partialBucketBase + bucketLength) {
            partialBucketIndex += 1;
            partialBucketBase += bucketLength;
          }
          bucketIndex = partialBucketIndex;
        }
        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];
        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];
        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];
        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));
        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));
        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));
        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)
        );
        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)
        );
        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)
        );
        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(
          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)
        );
        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;
        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;
        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;
        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;
        setPackedSplat(
          packedArray,
          i2,
          x2,
          y,
          z,
          scaleX,
          scaleY,
          scaleZ,
          quatX,
          quatY,
          quatZ,
          quatW,
          opacity,
          r,
          g,
          b,
          splatEncoding
        );
        if (sphericalHarmonicsDegree >= 1) {
          if (sh1) {
            if (!extra.sh1) {
              extra.sh1 = new Uint32Array(numSplats * 2);
            }
            for (const [i22, key] of sh1Index.entries()) {
              sh1[i22] = getSh(splatOffset, key);
            }
            encodeSh1Rgb(extra.sh1, i2, sh1, splatEncoding);
          }
          if (sh2) {
            if (!extra.sh2) {
              extra.sh2 = new Uint32Array(numSplats * 4);
            }
            for (const [i22, key] of sh2Index.entries()) {
              sh2[i22] = getSh(splatOffset, key);
            }
            encodeSh2Rgb(extra.sh2, i2, sh2, splatEncoding);
          }
          if (sh3) {
            if (!extra.sh3) {
              extra.sh3 = new Uint32Array(numSplats * 4);
            }
            for (const [i22, key] of sh3Index.entries()) {
              sh3[i22] = getSh(splatOffset, key);
            }
            encodeSh3Rgb(extra.sh3, i2, sh3, splatEncoding);
          }
        }
      }
      sectionBase += storageSizeBytes;
    }
    return { packedArray, numSplats, extra };
  }
  const PLY_PROPERTY_TYPES = [
    "char",
    "uchar",
    "short",
    "ushort",
    "int",
    "uint",
    "float",
    "double"
  ];
  const _PlyReader = class _PlyReader {
    // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet
    constructor({ fileBytes }) {
      this.header = "";
      this.littleEndian = true;
      this.elements = {};
      this.comments = [];
      this.data = null;
      this.numSplats = 0;
      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;
    }
    // Identify and parse the PLY text header (assumed to be <64KB in size).
    // this.elements will contain all the elements in the file, typically
    // "vertex" contains the Gsplat data.
    async parseHeader() {
      const bufferStream = new ReadableStream({
        start: (controller) => {
          controller.enqueue(this.fileBytes.slice(0, 65536));
          controller.close();
        }
      });
      const decoder = bufferStream.pipeThrough(new TextDecoderStream()).getReader();
      this.header = "";
      const headerTerminator = "end_header\\n";
      while (true) {
        const { value, done } = await decoder.read();
        if (done) {
          throw new Error("Failed to read header");
        }
        this.header += value;
        const endHeader = this.header.indexOf(headerTerminator);
        if (endHeader >= 0) {
          this.header = this.header.slice(0, endHeader + headerTerminator.length);
          break;
        }
      }
      const headerLen = new TextEncoder().encode(this.header).length;
      this.data = new DataView(this.fileBytes.buffer, headerLen);
      this.elements = {};
      let curElement = null;
      this.comments = [];
      this.header.trim().split("\\n").forEach((line, lineIndex) => {
        const trimmedLine = line.trim();
        if (lineIndex === 0) {
          if (trimmedLine !== "ply") {
            throw new Error("Invalid PLY header");
          }
          return;
        }
        if (trimmedLine.length === 0) {
          return;
        }
        const fields = trimmedLine.split(" ");
        switch (fields[0]) {
          case "format":
            if (fields[1] === "binary_little_endian") {
              this.littleEndian = true;
            } else if (fields[1] === "binary_big_endian") {
              this.littleEndian = false;
            } else {
              throw new Error(\`Unsupported PLY format: \${fields[1]}\`);
            }
            if (fields[2] !== "1.0") {
              throw new Error(\`Unsupported PLY version: \${fields[2]}\`);
            }
            break;
          case "end_header":
            break;
          case "comment":
            this.comments.push(trimmedLine.slice("comment ".length));
            break;
          case "element": {
            const name = fields[1];
            curElement = {
              name,
              count: Number.parseInt(fields[2]),
              properties: {}
            };
            this.elements[name] = curElement;
            break;
          }
          case "property":
            if (curElement == null) {
              throw new Error("Property must be inside an element");
            }
            if (fields[1] === "list") {
              curElement.properties[fields[4]] = {
                isList: true,
                type: fields[3],
                countType: fields[2]
              };
            } else {
              curElement.properties[fields[2]] = {
                isList: false,
                type: fields[1]
              };
            }
            break;
        }
      });
      if (this.elements.vertex) {
        this.numSplats = this.elements.vertex.count;
      }
    }
    parseData(elementCallback) {
      let offset = 0;
      const data = this.data;
      if (data == null) {
        throw new Error("No data to parse");
      }
      for (const elementName in this.elements) {
        const element = this.elements[elementName];
        const { count, properties } = element;
        const item = createEmptyItem(properties);
        const parseFn = createParseFn(properties, this.littleEndian);
        const callback = elementCallback(element) ?? (() => {
        });
        for (let index = 0; index < count; index++) {
          offset = parseFn(data, offset, item);
          callback(index, item);
        }
      }
    }
    // Parse all the Gsplat data in the PLY file in go, invoking the given
    // callbacks for each Gsplat.
    parseSplats(splatCallback, shCallback) {
      if (this.elements.vertex == null) {
        throw new Error("No vertex element found");
      }
      let isSuperSplat = false;
      const ssChunks = [];
      let numSh = 0;
      let sh1Props = [];
      let sh2Props = [];
      let sh3Props = [];
      let sh1 = void 0;
      let sh2 = void 0;
      let sh3 = void 0;
      function prepareSh() {
        const num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];
        sh1Props = new Array(3).fill(null).flatMap((_, k) => [0, 1, 2].map((_2, d) => k + d * num_f_rest / 3));
        sh2Props = new Array(5).fill(null).flatMap(
          (_, k) => [0, 1, 2].map((_2, d) => 3 + k + d * num_f_rest / 3)
        );
        sh3Props = new Array(7).fill(null).flatMap(
          (_, k) => [0, 1, 2].map((_2, d) => 8 + k + d * num_f_rest / 3)
        );
        sh1 = numSh >= 1 ? new Float32Array(3 * 3) : void 0;
        sh2 = numSh >= 2 ? new Float32Array(5 * 3) : void 0;
        sh3 = numSh >= 3 ? new Float32Array(7 * 3) : void 0;
      }
      function ssShCallback(index, item) {
        if (!sh1) {
          throw new Error("Missing sh1");
        }
        const sh = item.f_rest;
        for (let i2 = 0; i2 < sh1Props.length; i2++) {
          sh1[i2] = sh[sh1Props[i2]] * 8 / 255 - 4;
        }
        if (sh2) {
          for (let i2 = 0; i2 < sh2Props.length; i2++) {
            sh2[i2] = sh[sh2Props[i2]] * 8 / 255 - 4;
          }
        }
        if (sh3) {
          for (let i2 = 0; i2 < sh3Props.length; i2++) {
            sh3[i2] = sh[sh3Props[i2]] * 8 / 255 - 4;
          }
        }
        shCallback == null ? void 0 : shCallback(index, sh1, sh2, sh3);
      }
      function initSuperSplat(element) {
        const {
          min_x,
          min_y,
          min_z,
          max_x,
          max_y,
          max_z,
          min_scale_x,
          min_scale_y,
          min_scale_z,
          max_scale_x,
          max_scale_y,
          max_scale_z
        } = element.properties;
        if (!min_x || !min_y || !min_z || !max_x || !max_y || !max_z || !min_scale_x || !min_scale_y || !min_scale_z || !max_scale_x || !max_scale_y || !max_scale_z) {
          throw new Error("Missing PLY chunk properties");
        }
        isSuperSplat = true;
        return (index, item) => {
          const {
            min_x: min_x2,
            min_y: min_y2,
            min_z: min_z2,
            max_x: max_x2,
            max_y: max_y2,
            max_z: max_z2,
            min_scale_x: min_scale_x2,
            min_scale_y: min_scale_y2,
            min_scale_z: min_scale_z2,
            max_scale_x: max_scale_x2,
            max_scale_y: max_scale_y2,
            max_scale_z: max_scale_z2,
            min_r,
            min_g,
            min_b,
            max_r,
            max_g,
            max_b
          } = item;
          ssChunks.push({
            min_x: min_x2,
            min_y: min_y2,
            min_z: min_z2,
            max_x: max_x2,
            max_y: max_y2,
            max_z: max_z2,
            min_scale_x: min_scale_x2,
            min_scale_y: min_scale_y2,
            min_scale_z: min_scale_z2,
            max_scale_x: max_scale_x2,
            max_scale_y: max_scale_y2,
            max_scale_z: max_scale_z2,
            min_r,
            min_g,
            min_b,
            max_r,
            max_g,
            max_b
          });
        };
      }
      function decodeSuperSplat(element) {
        if (shCallback && element.name === "sh") {
          numSh = getNumSh(element.properties);
          prepareSh();
          return ssShCallback;
        }
        if (element.name !== "vertex") {
          return null;
        }
        const { packed_position, packed_rotation, packed_scale, packed_color } = element.properties;
        if (!packed_position || !packed_rotation || !packed_scale || !packed_color) {
          throw new Error(
            "Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color"
          );
        }
        const SQRT2 = Math.sqrt(2);
        return (index, item) => {
          const chunk = ssChunks[index >>> 8];
          if (chunk == null) {
            throw new Error("Missing PLY chunk");
          }
          const {
            min_x,
            min_y,
            min_z,
            max_x,
            max_y,
            max_z,
            min_scale_x,
            min_scale_y,
            min_scale_z,
            max_scale_x,
            max_scale_y,
            max_scale_z,
            min_r,
            min_g,
            min_b,
            max_r,
            max_g,
            max_b
          } = chunk;
          const { packed_position: packed_position2, packed_rotation: packed_rotation2, packed_scale: packed_scale2, packed_color: packed_color2 } = item;
          const x2 = (packed_position2 >>> 21 & 2047) / 2047 * (max_x - min_x) + min_x;
          const y = (packed_position2 >>> 11 & 1023) / 1023 * (max_y - min_y) + min_y;
          const z = (packed_position2 & 2047) / 2047 * (max_z - min_z) + min_z;
          const r0 = ((packed_rotation2 >>> 20 & 1023) / 1023 - 0.5) * SQRT2;
          const r1 = ((packed_rotation2 >>> 10 & 1023) / 1023 - 0.5) * SQRT2;
          const r2 = ((packed_rotation2 & 1023) / 1023 - 0.5) * SQRT2;
          const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));
          const rOrder = packed_rotation2 >>> 30;
          const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;
          const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;
          const quatZ = rOrder <= 2 ? r2 : rr;
          const quatW = rOrder === 0 ? rr : r0;
          const scaleX = Math.exp(
            (packed_scale2 >>> 21 & 2047) / 2047 * (max_scale_x - min_scale_x) + min_scale_x
          );
          const scaleY = Math.exp(
            (packed_scale2 >>> 11 & 1023) / 1023 * (max_scale_y - min_scale_y) + min_scale_y
          );
          const scaleZ = Math.exp(
            (packed_scale2 & 2047) / 2047 * (max_scale_z - min_scale_z) + min_scale_z
          );
          const r = (packed_color2 >>> 24 & 255) / 255 * ((max_r ?? 1) - (min_r ?? 0)) + (min_r ?? 0);
          const g = (packed_color2 >>> 16 & 255) / 255 * ((max_g ?? 1) - (min_g ?? 0)) + (min_g ?? 0);
          const b = (packed_color2 >>> 8 & 255) / 255 * ((max_b ?? 1) - (min_b ?? 0)) + (min_b ?? 0);
          const opacity = (packed_color2 & 255) / 255;
          splatCallback(
            index,
            x2,
            y,
            z,
            scaleX,
            scaleY,
            scaleZ,
            quatX,
            quatY,
            quatZ,
            quatW,
            opacity,
            r,
            g,
            b
          );
        };
      }
      const elementCallback = (element) => {
        if (element.name === "chunk") {
          return initSuperSplat(element);
        }
        if (isSuperSplat) {
          return decodeSuperSplat(element);
        }
        if (element.name !== "vertex") {
          return null;
        }
        const {
          x: x2,
          y,
          z,
          scale_0,
          scale_1,
          scale_2,
          rot_0,
          rot_1,
          rot_2,
          rot_3,
          opacity,
          f_dc_0,
          f_dc_1,
          f_dc_2,
          red,
          green,
          blue,
          alpha
        } = element.properties;
        if (!x2 || !y || !z) {
          throw new Error("Missing PLY properties: x, y, z");
        }
        const hasScales = scale_0 && scale_1 && scale_2;
        const hasRots = rot_0 && rot_1 && rot_2 && rot_3;
        const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : 1;
        const redDiv = red != null ? FIELD_SCALE[red.type] : 1;
        const greenDiv = green != null ? FIELD_SCALE[green.type] : 1;
        const blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;
        numSh = getNumSh(element.properties);
        prepareSh();
        return (index, item) => {
          const scaleX = hasScales ? Math.exp(item.scale_0) : _PlyReader.defaultPointScale;
          const scaleY = hasScales ? Math.exp(item.scale_1) : _PlyReader.defaultPointScale;
          const scaleZ = hasScales ? Math.exp(item.scale_2) : _PlyReader.defaultPointScale;
          const quatX = hasRots ? item.rot_1 : 0;
          const quatY = hasRots ? item.rot_2 : 0;
          const quatZ = hasRots ? item.rot_3 : 0;
          const quatW = hasRots ? item.rot_0 : 1;
          const op = opacity != null ? 1 / (1 + Math.exp(-item.opacity)) : alpha != null ? item.alpha / alphaDiv : 1;
          const r = f_dc_0 != null ? item.f_dc_0 * SH_C0$1 + 0.5 : red != null ? item.red / redDiv : 1;
          const g = f_dc_1 != null ? item.f_dc_1 * SH_C0$1 + 0.5 : green != null ? item.green / greenDiv : 1;
          const b = f_dc_2 != null ? item.f_dc_2 * SH_C0$1 + 0.5 : blue != null ? item.blue / blueDiv : 1;
          splatCallback(
            index,
            item.x,
            item.y,
            item.z,
            scaleX,
            scaleY,
            scaleZ,
            quatX,
            quatY,
            quatZ,
            quatW,
            op,
            r,
            g,
            b
          );
          if (shCallback && sh1) {
            const sh = item.f_rest;
            if (sh1) {
              for (let i2 = 0; i2 < sh1Props.length; i2++) {
                sh1[i2] = sh[sh1Props[i2]];
              }
            }
            if (sh2) {
              for (let i2 = 0; i2 < sh2Props.length; i2++) {
                sh2[i2] = sh[sh2Props[i2]];
              }
            }
            if (sh3) {
              for (let i2 = 0; i2 < sh3Props.length; i2++) {
                sh3[i2] = sh[sh3Props[i2]];
              }
            }
            shCallback(index, sh1, sh2, sh3);
          }
        };
      };
      this.parseData(elementCallback);
    }
    // Inject RGBA values into original PLY file, which can be used to modify
    // the color/opacity of the Gsplats and write out the modified PLY file.
    injectRgba(rgba) {
      let offset = 0;
      const data = this.data;
      if (data == null) {
        throw new Error("No parsed data");
      }
      if (rgba.length !== this.numSplats * 4) {
        throw new Error("Invalid RGBA array length");
      }
      for (const elementName in this.elements) {
        const element = this.elements[elementName];
        const { count, properties } = element;
        const parsers = [];
        let rgbaOffset = 0;
        const isVertex = elementName === "vertex";
        if (isVertex) {
          for (const name of ["opacity", "f_dc_0", "f_dc_1", "f_dc_2"]) {
            if (!properties[name] || properties[name].type !== "float") {
              throw new Error(\`Can't injectRgba due to property: \${name}\`);
            }
          }
        }
        for (const [propertyName, property] of Object.entries(properties)) {
          if (!property.isList) {
            if (isVertex) {
              if (propertyName === "f_dc_0" || propertyName === "f_dc_1" || propertyName === "f_dc_2") {
                const component = Number.parseInt(
                  propertyName.slice("f_dc_".length)
                );
                parsers.push(() => {
                  const value = (rgba[rgbaOffset + component] / 255 - 0.5) / SH_C0$1;
                  SET_FIELD[property.type](
                    data,
                    offset,
                    this.littleEndian,
                    value
                  );
                });
              } else if (propertyName === "opacity") {
                parsers.push(() => {
                  const value = Math.max(
                    -100,
                    Math.min(
                      100,
                      -Math.log(1 / (rgba[rgbaOffset + 3] / 255) - 1)
                    )
                  );
                  SET_FIELD[property.type](
                    data,
                    offset,
                    this.littleEndian,
                    value
                  );
                });
              }
            }
            parsers.push(() => {
              offset += FIELD_BYTES[property.type];
            });
          } else {
            parsers.push(() => {
              const length = PARSE_FIELD[property.countType](
                data,
                offset,
                this.littleEndian
              );
              offset += FIELD_BYTES[property.countType];
              offset += length * FIELD_BYTES[property.type];
            });
          }
        }
        for (let index = 0; index < count; index++) {
          for (const parser of parsers) {
            parser();
          }
          if (isVertex) {
            rgbaOffset += 4;
          }
        }
      }
    }
  };
  _PlyReader.defaultPointScale = 1e-3;
  let PlyReader = _PlyReader;
  const SH_C0$1 = 0.28209479177387814;
  const PARSE_FIELD = {
    char: (data, offset, littleEndian) => {
      return data.getInt8(offset);
    },
    uchar: (data, offset, littleEndian) => {
      return data.getUint8(offset);
    },
    short: (data, offset, littleEndian) => {
      return data.getInt16(offset, littleEndian);
    },
    ushort: (data, offset, littleEndian) => {
      return data.getUint16(offset, littleEndian);
    },
    int: (data, offset, littleEndian) => {
      return data.getInt32(offset, littleEndian);
    },
    uint: (data, offset, littleEndian) => {
      return data.getUint32(offset, littleEndian);
    },
    float: (data, offset, littleEndian) => {
      return data.getFloat32(offset, littleEndian);
    },
    double: (data, offset, littleEndian) => {
      return data.getFloat64(offset, littleEndian);
    }
  };
  const SET_FIELD = {
    char: (data, offset, littleEndian, value) => {
      data.setInt8(offset, value);
    },
    uchar: (data, offset, littleEndian, value) => {
      data.setUint8(offset, value);
    },
    short: (data, offset, littleEndian, value) => {
      data.setInt16(offset, value, littleEndian);
    },
    ushort: (data, offset, littleEndian, value) => {
      data.setUint16(offset, value, littleEndian);
    },
    int: (data, offset, littleEndian, value) => {
      data.setInt32(offset, value, littleEndian);
    },
    uint: (data, offset, littleEndian, value) => {
      data.setUint32(offset, value, littleEndian);
    },
    float: (data, offset, littleEndian, value) => {
      data.setFloat32(offset, value, littleEndian);
    },
    double: (data, offset, littleEndian, value) => {
      data.setFloat64(offset, value, littleEndian);
    }
  };
  const FIELD_BYTES = {
    char: 1,
    uchar: 1,
    short: 2,
    ushort: 2,
    int: 4,
    uint: 4,
    float: 4,
    double: 8
  };
  const FIELD_SCALE = {
    char: 127,
    uchar: 255,
    short: 32767,
    ushort: 65535,
    int: 2147483647,
    uint: 4294967295,
    float: 1,
    double: 1
  };
  const NUM_F_REST_TO_NUM_SH = {
    0: 0,
    9: 1,
    24: 2,
    45: 3
  };
  const NUM_SH_TO_NUM_F_REST = {
    0: 0,
    1: 9,
    2: 24,
    3: 45
  };
  const F_REST_REGEX = /^f_rest_([0-9]{1,2})$/;
  function createEmptyItem(properties) {
    const item = {};
    for (const [propertyName, property] of Object.entries(properties)) {
      if (F_REST_REGEX.test(propertyName)) {
        item.f_rest = new Array(getNumSh(properties));
      } else {
        item[propertyName] = property.isList ? [] : 0;
      }
    }
    return item;
  }
  function createParseFn(properties, littleEndian) {
    if (safeToCompile(properties)) {
      return createCompiledParserFn(properties, littleEndian);
    }
    return createDynamicParserFn(properties, littleEndian);
  }
  const UNSAFE_EVAL_ALLOWED = (() => {
    try {
      new Function("return 42;");
    } catch (e) {
      return false;
    }
    return true;
  })();
  const PROPERTY_NAME_REGEX = /^[a-zA-Z0-9_]+$/;
  function safeToCompile(properties) {
    if (!UNSAFE_EVAL_ALLOWED) {
      return false;
    }
    for (const [propertyName, property] of Object.entries(properties)) {
      if (!PROPERTY_NAME_REGEX.test(propertyName)) {
        return false;
      }
      if (property.isList && !PLY_PROPERTY_TYPES.includes(property.countType)) {
        return false;
      }
      if (!PLY_PROPERTY_TYPES.includes(property.type)) {
        return false;
      }
    }
    return true;
  }
  function createCompiledParserFn(properties, littleEndian) {
    const parserSrc = ["let list;"];
    for (const [propertyName, property] of Object.entries(properties)) {
      const fRestMatch = propertyName.match(F_REST_REGEX);
      if (fRestMatch) {
        const fRestIndex = +fRestMatch[1];
        parserSrc.push(
          /*js*/
          \`
        item.f_rest[\${fRestIndex}] = PARSE_FIELD['\${property.type}'](data, offset, \${littleEndian});
        offset += \${FIELD_BYTES[property.type]};
      \`
        );
      } else if (!property.isList) {
        parserSrc.push(
          /*js*/
          \`
        item['\${propertyName}'] = PARSE_FIELD['\${property.type}'](data, offset, \${littleEndian});
        offset += \${FIELD_BYTES[property.type]};
      \`
        );
      } else {
        parserSrc.push(
          /*js*/
          \`
        list = item['\${propertyName}'];
        list.length = PARSE_FIELD['\${property.countType}'](data, offset, \${littleEndian});
        offset += \${FIELD_BYTES[property.countType]};
        for (let i = 0; i < list.length; i++) {
          list[i] = PARSE_FIELD['\${property.type}'](data, offset, \${littleEndian});
          offset += \${FIELD_BYTES[property.type]};
        }
      \`
        );
      }
    }
    parserSrc.push("return offset;");
    const fn = new Function(
      "data",
      "offset",
      "item",
      "PARSE_FIELD",
      parserSrc.join("\\n")
    );
    return (data, offset, item) => fn(data, offset, item, PARSE_FIELD);
  }
  function createDynamicParserFn(properties, littleEndian) {
    const parsers = [];
    for (const [propertyName, property] of Object.entries(properties)) {
      const fRestMatch = propertyName.match(F_REST_REGEX);
      if (fRestMatch) {
        const fRestIndex = +fRestMatch[1];
        parsers.push(
          (data, offset, item) => {
            item.f_rest[fRestIndex] = PARSE_FIELD[property.type](
              data,
              offset,
              littleEndian
            );
            return offset + FIELD_BYTES[property.type];
          }
        );
      } else if (!property.isList) {
        parsers.push(
          (data, offset, item) => {
            item[propertyName] = PARSE_FIELD[property.type](
              data,
              offset,
              littleEndian
            );
            return offset + FIELD_BYTES[property.type];
          }
        );
      } else {
        parsers.push(
          (data, offset, item) => {
            const list = item[propertyName];
            list.length = PARSE_FIELD[property.countType](
              data,
              offset,
              littleEndian
            );
            let currentOffset = offset + FIELD_BYTES[property.countType];
            for (let i2 = 0; i2 < list.length; i2++) {
              list[i2] = PARSE_FIELD[property.type](
                data,
                currentOffset,
                littleEndian
              );
              currentOffset += FIELD_BYTES[property.type];
            }
            return currentOffset;
          }
        );
      }
    }
    return (data, offset, item) => {
      let currentOffset = offset;
      for (let parserIndex = 0; parserIndex < parsers.length; parserIndex++) {
        currentOffset = parsers[parserIndex](data, currentOffset, item);
      }
      return currentOffset;
    };
  }
  function getNumSh(properties) {
    let num_f_rest = 0;
    while (properties[\`f_rest_\${num_f_rest}\`]) {
      num_f_rest += 1;
    }
    const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];
    if (numSh == null) {
      throw new Error(\`Unsupported number of SH coefficients: \${num_f_rest}\`);
    }
    return numSh;
  }
  var SplatFileType = /* @__PURE__ */ ((SplatFileType2) => {
    SplatFileType2["PLY"] = "ply";
    SplatFileType2["SPZ"] = "spz";
    SplatFileType2["SPLAT"] = "splat";
    SplatFileType2["KSPLAT"] = "ksplat";
    SplatFileType2["PCSOGS"] = "pcsogs";
    SplatFileType2["PCSOGSZIP"] = "pcsogszip";
    return SplatFileType2;
  })(SplatFileType || {});
  function getSplatFileType(fileBytes) {
    const view = new DataView(fileBytes.buffer);
    if ((view.getUint32(0, true) & 16777215) === 7957616) {
      return "ply";
    }
    if ((view.getUint32(0, true) & 16777215) === 559903) {
      const header = decompressPartialGzip(fileBytes, 4);
      const gView = new DataView(header.buffer);
      if (gView.getUint32(0, true) === 1347635022) {
        return "spz";
      }
      return void 0;
    }
    if (view.getUint32(0, true) === 67324752) {
      if (tryPcSogsZip(fileBytes)) {
        return "pcsogszip";
      }
      return void 0;
    }
    return void 0;
  }
  function getFileExtension(pathOrUrl) {
    const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];
    const lastSlash = Math.max(
      noTrailing.lastIndexOf("/"),
      noTrailing.lastIndexOf("\\\\")
    );
    const filename = noTrailing.slice(lastSlash + 1);
    const lastDot = filename.lastIndexOf(".");
    if (lastDot <= 0 || lastDot === filename.length - 1) {
      return "";
    }
    return filename.slice(lastDot + 1).toLowerCase();
  }
  function getSplatFileTypeFromPath(pathOrUrl) {
    const extension = getFileExtension(pathOrUrl);
    if (extension === "ply") {
      return "ply";
    }
    if (extension === "spz") {
      return "spz";
    }
    if (extension === "splat") {
      return "splat";
    }
    if (extension === "ksplat") {
      return "ksplat";
    }
    if (extension === "sog") {
      return "pcsogszip";
    }
    return void 0;
  }
  function tryPcSogs(input) {
    try {
      let text;
      if (typeof input === "string") {
        text = input;
      } else {
        const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;
        if (fileBytes.length > 65536) {
          return void 0;
        }
        text = new TextDecoder().decode(fileBytes);
      }
      const json = JSON.parse(text);
      if (!json || typeof json !== "object" || Array.isArray(json)) {
        return void 0;
      }
      const isVersion2 = json.version === 2;
      for (const key of ["means", "scales", "quats", "sh0"]) {
        if (!json[key] || typeof json[key] !== "object" || Array.isArray(json[key])) {
          return void 0;
        }
        if (isVersion2) {
          if (!json[key].files) {
            return void 0;
          }
          if ((key === "scales" || key === "sh0") && !json[key].codebook) {
            return void 0;
          }
          if (key === "means" && (!json[key].mins || !json[key].maxs)) {
            return void 0;
          }
        } else {
          if (!json[key].shape || !json[key].files) {
            return void 0;
          }
          if (key !== "quats" && (!json[key].mins || !json[key].maxs)) {
            return void 0;
          }
        }
      }
      return json;
    } catch {
      return void 0;
    }
  }
  function tryPcSogsZip(input) {
    try {
      const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;
      let metaFilename = null;
      const unzipped = unzipSync(fileBytes, {
        filter: ({ name }) => {
          const filename = name.split(/[\\\\/]/).pop();
          if (filename === "meta.json") {
            metaFilename = name;
            return true;
          }
          return false;
        }
      });
      if (!metaFilename) {
        return void 0;
      }
      const json = tryPcSogs(unzipped[metaFilename]);
      if (!json) {
        return void 0;
      }
      return { name: metaFilename, json };
    } catch {
      return void 0;
    }
  }
  class SplatData {
    constructor({ maxSplats = 1 } = {}) {
      this.numSplats = 0;
      this.maxSplats = getTextureSize(maxSplats).maxSplats;
      this.centers = new Float32Array(this.maxSplats * 3);
      this.scales = new Float32Array(this.maxSplats * 3);
      this.quaternions = new Float32Array(this.maxSplats * 4);
      this.opacities = new Float32Array(this.maxSplats);
      this.colors = new Float32Array(this.maxSplats * 3);
    }
    pushSplat() {
      const index = this.numSplats;
      this.ensureIndex(index);
      this.numSplats += 1;
      return index;
    }
    unpushSplat(index) {
      if (index === this.numSplats - 1) {
        this.numSplats -= 1;
      } else {
        throw new Error("Cannot unpush splat from non-last position");
      }
    }
    ensureCapacity(numSplats) {
      if (numSplats > this.maxSplats) {
        const targetSplats = Math.max(numSplats, this.maxSplats * 2);
        const newCenters = new Float32Array(targetSplats * 3);
        const newScales = new Float32Array(targetSplats * 3);
        const newQuaternions = new Float32Array(targetSplats * 4);
        const newOpacities = new Float32Array(targetSplats);
        const newColors = new Float32Array(targetSplats * 3);
        newCenters.set(this.centers);
        newScales.set(this.scales);
        newQuaternions.set(this.quaternions);
        newOpacities.set(this.opacities);
        newColors.set(this.colors);
        this.centers = newCenters;
        this.scales = newScales;
        this.quaternions = newQuaternions;
        this.opacities = newOpacities;
        this.colors = newColors;
        if (this.sh1) {
          const newSh1 = new Float32Array(targetSplats * 9);
          newSh1.set(this.sh1);
          this.sh1 = newSh1;
        }
        if (this.sh2) {
          const newSh2 = new Float32Array(targetSplats * 15);
          newSh2.set(this.sh2);
          this.sh2 = newSh2;
        }
        if (this.sh3) {
          const newSh3 = new Float32Array(targetSplats * 21);
          newSh3.set(this.sh3);
          this.sh3 = newSh3;
        }
        this.maxSplats = targetSplats;
      }
    }
    ensureIndex(index) {
      this.ensureCapacity(index + 1);
    }
    setCenter(index, x2, y, z) {
      this.centers[index * 3] = x2;
      this.centers[index * 3 + 1] = y;
      this.centers[index * 3 + 2] = z;
    }
    setScale(index, scaleX, scaleY, scaleZ) {
      this.scales[index * 3] = scaleX;
      this.scales[index * 3 + 1] = scaleY;
      this.scales[index * 3 + 2] = scaleZ;
    }
    setQuaternion(index, x2, y, z, w) {
      this.quaternions[index * 4] = x2;
      this.quaternions[index * 4 + 1] = y;
      this.quaternions[index * 4 + 2] = z;
      this.quaternions[index * 4 + 3] = w;
    }
    setOpacity(index, opacity) {
      this.opacities[index] = opacity;
    }
    setColor(index, r, g, b) {
      this.colors[index * 3] = r;
      this.colors[index * 3 + 1] = g;
      this.colors[index * 3 + 2] = b;
    }
    setSh1(index, sh1) {
      if (!this.sh1) {
        this.sh1 = new Float32Array(this.maxSplats * 9);
      }
      for (let j = 0; j < 9; ++j) {
        this.sh1[index * 9 + j] = sh1[j];
      }
    }
    setSh2(index, sh2) {
      if (!this.sh2) {
        this.sh2 = new Float32Array(this.maxSplats * 15);
      }
      for (let j = 0; j < 15; ++j) {
        this.sh2[index * 15 + j] = sh2[j];
      }
    }
    setSh3(index, sh3) {
      if (!this.sh3) {
        this.sh3 = new Float32Array(this.maxSplats * 21);
      }
      for (let j = 0; j < 21; ++j) {
        this.sh3[index * 21 + j] = sh3[j];
      }
    }
  }
  async function unpackPcSogs(json, extraFiles, splatEncoding) {
    const isVersion2 = "version" in json;
    if (!isVersion2 && json.quats.encoding !== "quaternion_packed") {
      throw new Error("Unsupported quaternion encoding");
    }
    const numSplats = isVersion2 ? json.count : json.means.shape[0];
    const maxSplats = computeMaxSplats(numSplats);
    const packedArray = new Uint32Array(maxSplats * 4);
    const extra = {};
    const meansPromise = Promise.all([
      decodeImageRgba(extraFiles[json.means.files[0]]),
      decodeImageRgba(extraFiles[json.means.files[1]])
    ]).then((means) => {
      for (let i2 = 0; i2 < numSplats; ++i2) {
        const i4 = i2 * 4;
        const fx = (means[0][i4 + 0] + (means[1][i4 + 0] << 8)) / 65535;
        const fy = (means[0][i4 + 1] + (means[1][i4 + 1] << 8)) / 65535;
        const fz = (means[0][i4 + 2] + (means[1][i4 + 2] << 8)) / 65535;
        let x2 = json.means.mins[0] + (json.means.maxs[0] - json.means.mins[0]) * fx;
        let y = json.means.mins[1] + (json.means.maxs[1] - json.means.mins[1]) * fy;
        let z = json.means.mins[2] + (json.means.maxs[2] - json.means.mins[2]) * fz;
        x2 = Math.sign(x2) * (Math.exp(Math.abs(x2)) - 1);
        y = Math.sign(y) * (Math.exp(Math.abs(y)) - 1);
        z = Math.sign(z) * (Math.exp(Math.abs(z)) - 1);
        setPackedSplatCenter(packedArray, i2, x2, y, z);
      }
    });
    const scalesPromise = decodeImageRgba(extraFiles[json.scales.files[0]]).then(
      (scales) => {
        let xLookup;
        let yLookup;
        let zLookup;
        if (isVersion2) {
          xLookup = yLookup = zLookup = json.scales.codebook.map((x2) => Math.exp(x2));
        } else {
          xLookup = new Array(256).fill(0).map(
            (_, i2) => json.scales.mins[0] + (json.scales.maxs[0] - json.scales.mins[0]) * (i2 / 255)
          ).map((x2) => Math.exp(x2));
          yLookup = new Array(256).fill(0).map(
            (_, i2) => json.scales.mins[1] + (json.scales.maxs[1] - json.scales.mins[1]) * (i2 / 255)
          ).map((x2) => Math.exp(x2));
          zLookup = new Array(256).fill(0).map(
            (_, i2) => json.scales.mins[2] + (json.scales.maxs[2] - json.scales.mins[2]) * (i2 / 255)
          ).map((x2) => Math.exp(x2));
        }
        for (let i2 = 0; i2 < numSplats; ++i2) {
          const i4 = i2 * 4;
          setPackedSplatScales(
            packedArray,
            i2,
            xLookup[scales[i4 + 0]],
            yLookup[scales[i4 + 1]],
            zLookup[scales[i4 + 2]],
            splatEncoding
          );
        }
      }
    );
    const quatsPromise = decodeImageRgba(extraFiles[json.quats.files[0]]).then(
      (quats) => {
        const SQRT2 = Math.sqrt(2);
        const lookup = new Array(256).fill(0).map((_, i2) => (i2 / 255 - 0.5) * SQRT2);
        for (let i2 = 0; i2 < numSplats; ++i2) {
          const i4 = i2 * 4;
          const r0 = lookup[quats[i4 + 0]];
          const r1 = lookup[quats[i4 + 1]];
          const r2 = lookup[quats[i4 + 2]];
          const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));
          const rOrder = quats[i4 + 3] - 252;
          const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;
          const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;
          const quatZ = rOrder <= 2 ? r2 : rr;
          const quatW = rOrder === 0 ? rr : r0;
          setPackedSplatQuat(packedArray, i2, quatX, quatY, quatZ, quatW);
        }
      }
    );
    const sh0Promise = decodeImageRgba(extraFiles[json.sh0.files[0]]).then(
      (sh0) => {
        const SH_C02 = 0.28209479177387814;
        let rLookup;
        let gLookup;
        let bLookup;
        let aLookup;
        if (isVersion2) {
          rLookup = gLookup = bLookup = json.sh0.codebook.map((x2) => SH_C02 * x2 + 0.5);
          aLookup = new Array(256).fill(0).map((_, i2) => i2 / 255);
        } else {
          rLookup = new Array(256).fill(0).map(
            (_, i2) => json.sh0.mins[0] + (json.sh0.maxs[0] - json.sh0.mins[0]) * (i2 / 255)
          ).map((x2) => SH_C02 * x2 + 0.5);
          gLookup = new Array(256).fill(0).map(
            (_, i2) => json.sh0.mins[1] + (json.sh0.maxs[1] - json.sh0.mins[1]) * (i2 / 255)
          ).map((x2) => SH_C02 * x2 + 0.5);
          bLookup = new Array(256).fill(0).map(
            (_, i2) => json.sh0.mins[2] + (json.sh0.maxs[2] - json.sh0.mins[2]) * (i2 / 255)
          ).map((x2) => SH_C02 * x2 + 0.5);
          aLookup = new Array(256).fill(0).map(
            (_, i2) => json.sh0.mins[3] + (json.sh0.maxs[3] - json.sh0.mins[3]) * (i2 / 255)
          ).map((x2) => 1 / (1 + Math.exp(-x2)));
        }
        for (let i2 = 0; i2 < numSplats; ++i2) {
          const i4 = i2 * 4;
          setPackedSplatRgba(
            packedArray,
            i2,
            rLookup[sh0[i4 + 0]],
            gLookup[sh0[i4 + 1]],
            bLookup[sh0[i4 + 2]],
            aLookup[sh0[i4 + 3]],
            splatEncoding
          );
        }
      }
    );
    const promises = [meansPromise, scalesPromise, quatsPromise, sh0Promise];
    if (json.shN) {
      const useSH3 = isVersion2 ? json.shN.bands >= 3 : json.shN.shape[1] >= 48 - 3;
      const useSH2 = isVersion2 ? json.shN.bands >= 2 : json.shN.shape[1] >= 27 - 3;
      const useSH1 = isVersion2 ? json.shN.bands >= 1 : json.shN.shape[1] >= 12 - 3;
      if (useSH1) extra.sh1 = new Uint32Array(numSplats * 2);
      if (useSH2) extra.sh2 = new Uint32Array(numSplats * 4);
      if (useSH3) extra.sh3 = new Uint32Array(numSplats * 4);
      const sh1 = new Float32Array(9);
      const sh2 = new Float32Array(15);
      const sh3 = new Float32Array(21);
      const shN = json.shN;
      const shNPromise = Promise.all([
        decodeImage(extraFiles[json.shN.files[0]]),
        decodeImage(extraFiles[json.shN.files[1]])
      ]).then(([centroids, labels]) => {
        const lookup = "codebook" in shN ? shN.codebook : new Array(256).fill(0).map((_, i2) => shN.mins + (shN.maxs - shN.mins) * (i2 / 255));
        for (let i2 = 0; i2 < numSplats; ++i2) {
          const i4 = i2 * 4;
          const label = labels.rgba[i4 + 0] + (labels.rgba[i4 + 1] << 8);
          const col = (label & 63) * 15;
          const row = label >>> 6;
          const offset = row * centroids.width + col;
          for (let d = 0; d < 3; ++d) {
            if (useSH1) {
              for (let k = 0; k < 3; ++k) {
                sh1[k * 3 + d] = lookup[centroids.rgba[(offset + k) * 4 + d]];
              }
            }
            if (useSH2) {
              for (let k = 0; k < 5; ++k) {
                sh2[k * 3 + d] = lookup[centroids.rgba[(offset + 3 + k) * 4 + d]];
              }
            }
            if (useSH3) {
              for (let k = 0; k < 7; ++k) {
                sh3[k * 3 + d] = lookup[centroids.rgba[(offset + 8 + k) * 4 + d]];
              }
            }
          }
          if (useSH1)
            encodeSh1Rgb(extra.sh1, i2, sh1, splatEncoding);
          if (useSH2)
            encodeSh2Rgb(extra.sh2, i2, sh2, splatEncoding);
          if (useSH3)
            encodeSh3Rgb(extra.sh3, i2, sh3, splatEncoding);
        }
      });
      promises.push(shNPromise);
    }
    await Promise.all(promises);
    return { packedArray, numSplats, extra };
  }
  let offscreenGlContext = null;
  async function decodeImage(fileBytes) {
    if (!offscreenGlContext) {
      const canvas = new OffscreenCanvas(1, 1);
      offscreenGlContext = canvas.getContext("webgl2");
      if (!offscreenGlContext) {
        throw new Error("Failed to create WebGL2 context");
      }
    }
    const imageBlob = new Blob([fileBytes]);
    const bitmap = await createImageBitmap(imageBlob, {
      premultiplyAlpha: "none"
    });
    const gl = offscreenGlContext;
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bitmap);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      texture,
      0
    );
    const data = new Uint8Array(bitmap.width * bitmap.height * 4);
    gl.readPixels(
      0,
      0,
      bitmap.width,
      bitmap.height,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      data
    );
    gl.deleteTexture(texture);
    gl.deleteFramebuffer(framebuffer);
    return { rgba: data, width: bitmap.width, height: bitmap.height };
  }
  async function decodeImageRgba(fileBytes) {
    const { rgba } = await decodeImage(fileBytes);
    return rgba;
  }
  async function unpackPcSogsZip(fileBytes, splatEncoding) {
    var _a2;
    const nameJson = tryPcSogsZip(fileBytes);
    if (!nameJson) {
      throw new Error("Invalid PC SOGS zip file");
    }
    const { name, json } = nameJson;
    const lastSlash = name.lastIndexOf("/");
    const lastBackslash = name.lastIndexOf("\\\\");
    const prefix = name.slice(0, Math.max(lastSlash, lastBackslash) + 1);
    const fileMap = /* @__PURE__ */ new Map();
    const refFiles = [
      ...json.means.files,
      ...json.scales.files,
      ...json.quats.files,
      ...json.sh0.files,
      ...((_a2 = json.shN) == null ? void 0 : _a2.files) ?? []
    ];
    for (const file of refFiles) {
      fileMap.set(prefix + file, file);
    }
    const unzipped = await new Promise(
      (resolve, reject) => {
        unzip(
          fileBytes,
          {
            filter: ({ name: name2 }) => {
              return fileMap.has(name2);
            }
          },
          (err2, files) => {
            if (err2) {
              reject(err2);
            } else {
              resolve(files);
            }
          }
        );
      }
    );
    const extraFiles = {};
    for (const [full, name2] of fileMap.entries()) {
      extraFiles[name2] = unzipped[full];
    }
    return await unpackPcSogs(json, extraFiles, splatEncoding);
  }
  class SpzReader {
    constructor({ fileBytes }) {
      this.version = -1;
      this.numSplats = 0;
      this.shDegree = 0;
      this.fractionalBits = 0;
      this.flags = 0;
      this.flagAntiAlias = false;
      this.reserved = 0;
      this.headerParsed = false;
      this.parsed = false;
      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;
      this.reader = new GunzipReader({ fileBytes: this.fileBytes });
    }
    async parseHeader() {
      if (this.headerParsed) {
        throw new Error("SPZ file header already parsed");
      }
      const header = new DataView((await this.reader.read(16)).buffer);
      if (header.getUint32(0, true) !== 1347635022) {
        throw new Error("Invalid SPZ file");
      }
      this.version = header.getUint32(4, true);
      if (this.version < 1 || this.version > 3) {
        throw new Error(\`Unsupported SPZ version: \${this.version}\`);
      }
      this.numSplats = header.getUint32(8, true);
      this.shDegree = header.getUint8(12);
      this.fractionalBits = header.getUint8(13);
      this.flags = header.getUint8(14);
      this.flagAntiAlias = (this.flags & 1) !== 0;
      this.reserved = header.getUint8(15);
      this.headerParsed = true;
      this.parsed = false;
    }
    async parseSplats(centerCallback, alphaCallback, rgbCallback, scalesCallback, quatCallback, shCallback) {
      if (!this.headerParsed) {
        throw new Error("SPZ file header must be parsed first");
      }
      if (this.parsed) {
        throw new Error("SPZ file already parsed");
      }
      this.parsed = true;
      if (this.version === 1) {
        const centerBytes = await this.reader.read(this.numSplats * 3 * 2);
        const centerUint16 = new Uint16Array(centerBytes.buffer);
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          const i3 = i2 * 3;
          const x2 = fromHalf(centerUint16[i3]);
          const y = fromHalf(centerUint16[i3 + 1]);
          const z = fromHalf(centerUint16[i3 + 2]);
          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);
        }
      } else if (this.version === 2 || this.version === 3) {
        const fixed = 1 << this.fractionalBits;
        const centerBytes = await this.reader.read(this.numSplats * 3 * 3);
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          const i9 = i2 * 9;
          const x2 = ((centerBytes[i9 + 2] << 24 | centerBytes[i9 + 1] << 16 | centerBytes[i9] << 8) >> 8) / fixed;
          const y = ((centerBytes[i9 + 5] << 24 | centerBytes[i9 + 4] << 16 | centerBytes[i9 + 3] << 8) >> 8) / fixed;
          const z = ((centerBytes[i9 + 8] << 24 | centerBytes[i9 + 7] << 16 | centerBytes[i9 + 6] << 8) >> 8) / fixed;
          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);
        }
      } else {
        throw new Error("Unreachable");
      }
      {
        const bytes = await this.reader.read(this.numSplats);
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          alphaCallback == null ? void 0 : alphaCallback(i2, bytes[i2] / 255);
        }
      }
      {
        const rgbBytes = await this.reader.read(this.numSplats * 3);
        const scale = SH_C0 / 0.15;
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          const i3 = i2 * 3;
          const r = (rgbBytes[i3] / 255 - 0.5) * scale + 0.5;
          const g = (rgbBytes[i3 + 1] / 255 - 0.5) * scale + 0.5;
          const b = (rgbBytes[i3 + 2] / 255 - 0.5) * scale + 0.5;
          rgbCallback == null ? void 0 : rgbCallback(i2, r, g, b);
        }
      }
      {
        const scalesBytes = await this.reader.read(this.numSplats * 3);
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          const i3 = i2 * 3;
          const scaleX = Math.exp(scalesBytes[i3] / 16 - 10);
          const scaleY = Math.exp(scalesBytes[i3 + 1] / 16 - 10);
          const scaleZ = Math.exp(scalesBytes[i3 + 2] / 16 - 10);
          scalesCallback == null ? void 0 : scalesCallback(i2, scaleX, scaleY, scaleZ);
        }
      }
      if (this.version === 3) {
        const maxValue = 1 / Math.sqrt(2);
        const quatBytes = await this.reader.read(this.numSplats * 4);
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          const i3 = i2 * 4;
          const quaternion = [0, 0, 0, 0];
          const values = [
            quatBytes[i3],
            quatBytes[i3 + 1],
            quatBytes[i3 + 2],
            quatBytes[i3 + 3]
          ];
          const combinedValues = values[0] + (values[1] << 8) + (values[2] << 16) + (values[3] << 24);
          const valueMask = (1 << 9) - 1;
          const largestIndex = combinedValues >>> 30;
          let remainingValues = combinedValues;
          let sumSquares = 0;
          for (let i22 = 3; i22 >= 0; --i22) {
            if (i22 !== largestIndex) {
              const value = remainingValues & valueMask;
              const sign = remainingValues >>> 9 & 1;
              remainingValues = remainingValues >>> 10;
              quaternion[i22] = maxValue * (value / valueMask);
              quaternion[i22] = sign === 0 ? quaternion[i22] : -quaternion[i22];
              sumSquares += quaternion[i22] * quaternion[i22];
            }
          }
          const square = 1 - sumSquares;
          quaternion[largestIndex] = Math.sqrt(Math.max(square, 0));
          quatCallback == null ? void 0 : quatCallback(
            i2,
            quaternion[0],
            quaternion[1],
            quaternion[2],
            quaternion[3]
          );
        }
      } else {
        const quatBytes = await this.reader.read(this.numSplats * 3);
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          const i3 = i2 * 3;
          const quatX = quatBytes[i3] / 127.5 - 1;
          const quatY = quatBytes[i3 + 1] / 127.5 - 1;
          const quatZ = quatBytes[i3 + 2] / 127.5 - 1;
          const quatW = Math.sqrt(
            Math.max(0, 1 - quatX * quatX - quatY * quatY - quatZ * quatZ)
          );
          quatCallback == null ? void 0 : quatCallback(i2, quatX, quatY, quatZ, quatW);
        }
      }
      if (shCallback && this.shDegree >= 1) {
        const sh1 = new Float32Array(3 * 3);
        const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0;
        const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0;
        const shBytes = await this.reader.read(
          this.numSplats * SH_DEGREE_TO_VECS[this.shDegree] * 3
        );
        let offset = 0;
        for (let i2 = 0; i2 < this.numSplats; i2++) {
          for (let j = 0; j < 9; ++j) {
            sh1[j] = (shBytes[offset + j] - 128) / 128;
          }
          offset += 9;
          if (sh2) {
            for (let j = 0; j < 15; ++j) {
              sh2[j] = (shBytes[offset + j] - 128) / 128;
            }
            offset += 15;
          }
          if (sh3) {
            for (let j = 0; j < 21; ++j) {
              sh3[j] = (shBytes[offset + j] - 128) / 128;
            }
            offset += 21;
          }
          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);
        }
      }
    }
  }
  const SH_DEGREE_TO_VECS = { 1: 3, 2: 8, 3: 15 };
  const SH_C0 = 0.28209479177387814;
  const SPZ_MAGIC = 1347635022;
  const SPZ_VERSION = 3;
  const FLAG_ANTIALIASED = 1;
  class SpzWriter {
    constructor({
      numSplats,
      shDegree,
      fractionalBits = 12,
      flagAntiAlias = true
    }) {
      this.clippedCount = 0;
      const splatSize = 9 + // Position
      1 + // Opacity
      3 + // Scale
      3 + // DC-rgb
      4 + // Rotation
      (shDegree >= 1 ? 9 : 0) + (shDegree >= 2 ? 15 : 0) + (shDegree >= 3 ? 21 : 0);
      const bufferSize = 16 + numSplats * splatSize;
      this.buffer = new ArrayBuffer(bufferSize);
      this.view = new DataView(this.buffer);
      this.view.setUint32(0, SPZ_MAGIC, true);
      this.view.setUint32(4, SPZ_VERSION, true);
      this.view.setUint32(8, numSplats, true);
      this.view.setUint8(12, shDegree);
      this.view.setUint8(13, fractionalBits);
      this.view.setUint8(14, flagAntiAlias ? FLAG_ANTIALIASED : 0);
      this.view.setUint8(15, 0);
      this.numSplats = numSplats;
      this.shDegree = shDegree;
      this.fractionalBits = fractionalBits;
      this.fraction = 1 << fractionalBits;
      this.flagAntiAlias = flagAntiAlias;
    }
    setCenter(index, x2, y, z) {
      const xRounded = Math.round(x2 * this.fraction);
      const xInt = Math.max(-8388607, Math.min(8388607, xRounded));
      const yRounded = Math.round(y * this.fraction);
      const yInt = Math.max(-8388607, Math.min(8388607, yRounded));
      const zRounded = Math.round(z * this.fraction);
      const zInt = Math.max(-8388607, Math.min(8388607, zRounded));
      const clipped = xRounded !== xInt || yRounded !== yInt || zRounded !== zInt;
      if (clipped) {
        this.clippedCount += 1;
      }
      const i9 = index * 9;
      const base = 16 + i9;
      this.view.setUint8(base, xInt & 255);
      this.view.setUint8(base + 1, xInt >> 8 & 255);
      this.view.setUint8(base + 2, xInt >> 16 & 255);
      this.view.setUint8(base + 3, yInt & 255);
      this.view.setUint8(base + 4, yInt >> 8 & 255);
      this.view.setUint8(base + 5, yInt >> 16 & 255);
      this.view.setUint8(base + 6, zInt & 255);
      this.view.setUint8(base + 7, zInt >> 8 & 255);
      this.view.setUint8(base + 8, zInt >> 16 & 255);
    }
    setAlpha(index, alpha) {
      const base = 16 + this.numSplats * 9 + index;
      this.view.setUint8(
        base,
        Math.max(0, Math.min(255, Math.round(alpha * 255)))
      );
    }
    static scaleRgb(r) {
      const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;
      return Math.max(0, Math.min(255, Math.round(v)));
    }
    setRgb(index, r, g, b) {
      const base = 16 + this.numSplats * 10 + index * 3;
      this.view.setUint8(base, SpzWriter.scaleRgb(r));
      this.view.setUint8(base + 1, SpzWriter.scaleRgb(g));
      this.view.setUint8(base + 2, SpzWriter.scaleRgb(b));
    }
    setScale(index, scaleX, scaleY, scaleZ) {
      const base = 16 + this.numSplats * 13 + index * 3;
      this.view.setUint8(
        base,
        Math.max(0, Math.min(255, Math.round((Math.log(scaleX) + 10) * 16)))
      );
      this.view.setUint8(
        base + 1,
        Math.max(0, Math.min(255, Math.round((Math.log(scaleY) + 10) * 16)))
      );
      this.view.setUint8(
        base + 2,
        Math.max(0, Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16)))
      );
    }
    setQuat(index, ...q) {
      const base = 16 + this.numSplats * 16 + index * 4;
      const quat = normalize(q);
      let iLargest = 0;
      for (let i2 = 1; i2 < 4; ++i2) {
        if (Math.abs(quat[i2]) > Math.abs(quat[iLargest])) {
          iLargest = i2;
        }
      }
      const negate = quat[iLargest] < 0 ? 1 : 0;
      let comp = iLargest;
      for (let i2 = 0; i2 < 4; ++i2) {
        if (i2 !== iLargest) {
          const negbit = (quat[i2] < 0 ? 1 : 0) ^ negate;
          const mag = Math.floor(
            ((1 << 9) - 1) * (Math.abs(quat[i2]) / Math.SQRT1_2) + 0.5
          );
          comp = comp << 10 | negbit << 9 | mag;
        }
      }
      this.view.setUint8(base, comp & 255);
      this.view.setUint8(base + 1, comp >> 8 & 255);
      this.view.setUint8(base + 2, comp >> 16 & 255);
      this.view.setUint8(base + 3, comp >>> 24 & 255);
    }
    static quantizeSh(sh, bits2) {
      const value = Math.round(sh * 128) + 128;
      const bucketSize = 1 << 8 - bits2;
      const quantized = Math.floor((value + bucketSize / 2) / bucketSize) * bucketSize;
      return Math.max(0, Math.min(255, quantized));
    }
    setSh(index, sh1, sh2, sh3) {
      const shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;
      const base1 = 16 + this.numSplats * 20 + index * shVecs * 3;
      for (let j = 0; j < 9; ++j) {
        this.view.setUint8(base1 + j, SpzWriter.quantizeSh(sh1[j], 5));
      }
      if (sh2) {
        const base2 = base1 + 9;
        for (let j = 0; j < 15; ++j) {
          this.view.setUint8(base2 + j, SpzWriter.quantizeSh(sh2[j], 4));
        }
        if (sh3) {
          const base3 = base2 + 15;
          for (let j = 0; j < 21; ++j) {
            this.view.setUint8(base3 + j, SpzWriter.quantizeSh(sh3[j], 4));
          }
        }
      }
    }
    async finalize() {
      const input = new Uint8Array(this.buffer);
      const stream = new ReadableStream({
        async start(controller) {
          controller.enqueue(input);
          controller.close();
        }
      });
      const compressed = stream.pipeThrough(new CompressionStream("gzip"));
      const response = new Response(compressed);
      const buffer = await response.arrayBuffer();
      console.log(
        "Compressed",
        input.length,
        "bytes to",
        buffer.byteLength,
        "bytes"
      );
      return new Uint8Array(buffer);
    }
  }
  async function transcodeSpz(input) {
    var _a2, _b2, _c;
    const splats = new SplatData();
    const {
      inputs,
      clipXyz,
      maxSh,
      fractionalBits = 12,
      opacityThreshold
    } = input;
    for (const input2 of inputs) {
      let transformPos = function(pos) {
        pos.multiplyScalar(scale);
        pos.applyQuaternion(quaternion);
        pos.add(translate);
        return pos;
      }, transformScales = function(scales) {
        scales.multiplyScalar(scale);
        return scales;
      }, transformQuaternion = function(quat) {
        quat.premultiply(quaternion);
        return quat;
      }, withinClip = function(p) {
        return !clip || clip.containsPoint(p);
      }, withinOpacity = function(opacity) {
        return opacityThreshold !== void 0 ? opacity >= opacityThreshold : true;
      };
      const scale = ((_a2 = input2.transform) == null ? void 0 : _a2.scale) ?? 1;
      const quaternion = new Quaternion().fromArray(
        ((_b2 = input2.transform) == null ? void 0 : _b2.quaternion) ?? [0, 0, 0, 1]
      );
      const translate = new Vector3().fromArray(
        ((_c = input2.transform) == null ? void 0 : _c.translate) ?? [0, 0, 0]
      );
      const clip = clipXyz ? new Box3(
        new Vector3().fromArray(clipXyz.min),
        new Vector3().fromArray(clipXyz.max)
      ) : void 0;
      let fileType = input2.fileType;
      if (!fileType) {
        fileType = getSplatFileType(input2.fileBytes);
        if (!fileType && input2.pathOrUrl) {
          fileType = getSplatFileTypeFromPath(input2.pathOrUrl);
        }
      }
      switch (fileType) {
        case SplatFileType.PLY: {
          const ply = new PlyReader({ fileBytes: input2.fileBytes });
          await ply.parseHeader();
          let lastIndex = null;
          ply.parseSplats(
            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
              const center = transformPos(new Vector3(x2, y, z));
              if (withinClip(center) && withinOpacity(opacity)) {
                lastIndex = splats.pushSplat();
                splats.setCenter(lastIndex, center.x, center.y, center.z);
                const scales = transformScales(
                  new Vector3(scaleX, scaleY, scaleZ)
                );
                splats.setScale(lastIndex, scales.x, scales.y, scales.z);
                const quaternion2 = transformQuaternion(
                  new Quaternion(quatX, quatY, quatZ, quatW)
                );
                splats.setQuaternion(
                  lastIndex,
                  quaternion2.x,
                  quaternion2.y,
                  quaternion2.z,
                  quaternion2.w
                );
                splats.setOpacity(lastIndex, opacity);
                splats.setColor(lastIndex, r, g, b);
              } else {
                lastIndex = null;
              }
            },
            (index, sh1, sh2, sh3) => {
              if (sh1 && lastIndex !== null) {
                splats.setSh1(lastIndex, sh1);
              }
              if (sh2 && lastIndex !== null) {
                splats.setSh2(lastIndex, sh2);
              }
              if (sh3 && lastIndex !== null) {
                splats.setSh3(lastIndex, sh3);
              }
            }
          );
          break;
        }
        case SplatFileType.SPZ: {
          const spz2 = new SpzReader({ fileBytes: input2.fileBytes });
          await spz2.parseHeader();
          const mapping = new Int32Array(spz2.numSplats);
          mapping.fill(-1);
          const centers = new Float32Array(spz2.numSplats * 3);
          const center = new Vector3();
          spz2.parseSplats(
            (index, x2, y, z) => {
              const center2 = transformPos(new Vector3(x2, y, z));
              centers[index * 3] = center2.x;
              centers[index * 3 + 1] = center2.y;
              centers[index * 3 + 2] = center2.z;
            },
            (index, alpha) => {
              center.fromArray(centers, index * 3);
              if (withinClip(center) && withinOpacity(alpha)) {
                mapping[index] = splats.pushSplat();
                splats.setCenter(mapping[index], center.x, center.y, center.z);
                splats.setOpacity(mapping[index], alpha);
              }
            },
            (index, r, g, b) => {
              if (mapping[index] >= 0) {
                splats.setColor(mapping[index], r, g, b);
              }
            },
            (index, scaleX, scaleY, scaleZ) => {
              if (mapping[index] >= 0) {
                const scales = transformScales(
                  new Vector3(scaleX, scaleY, scaleZ)
                );
                splats.setScale(mapping[index], scales.x, scales.y, scales.z);
              }
            },
            (index, quatX, quatY, quatZ, quatW) => {
              if (mapping[index] >= 0) {
                const quaternion2 = transformQuaternion(
                  new Quaternion(quatX, quatY, quatZ, quatW)
                );
                splats.setQuaternion(
                  mapping[index],
                  quaternion2.x,
                  quaternion2.y,
                  quaternion2.z,
                  quaternion2.w
                );
              }
            },
            (index, sh1, sh2, sh3) => {
              if (mapping[index] >= 0) {
                splats.setSh1(mapping[index], sh1);
                if (sh2) {
                  splats.setSh2(mapping[index], sh2);
                }
                if (sh3) {
                  splats.setSh3(mapping[index], sh3);
                }
              }
            }
          );
          break;
        }
        case SplatFileType.SPLAT:
          decodeAntiSplat(
            input2.fileBytes,
            (numSplats) => {
            },
            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
              const center = transformPos(new Vector3(x2, y, z));
              if (withinClip(center) && withinOpacity(opacity)) {
                const index2 = splats.pushSplat();
                splats.setCenter(index2, center.x, center.y, center.z);
                const scales = transformScales(
                  new Vector3(scaleX, scaleY, scaleZ)
                );
                splats.setScale(index2, scales.x, scales.y, scales.z);
                const quaternion2 = transformQuaternion(
                  new Quaternion(quatX, quatY, quatZ, quatW)
                );
                splats.setQuaternion(
                  index2,
                  quaternion2.x,
                  quaternion2.y,
                  quaternion2.z,
                  quaternion2.w
                );
                splats.setOpacity(index2, opacity);
                splats.setColor(index2, r, g, b);
              }
            }
          );
          break;
        case SplatFileType.KSPLAT: {
          let lastIndex = null;
          decodeKsplat(
            input2.fileBytes,
            (numSplats) => {
            },
            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
              const center = transformPos(new Vector3(x2, y, z));
              if (withinClip(center) && withinOpacity(opacity)) {
                lastIndex = splats.pushSplat();
                splats.setCenter(lastIndex, center.x, center.y, center.z);
                const scales = transformScales(
                  new Vector3(scaleX, scaleY, scaleZ)
                );
                splats.setScale(lastIndex, scales.x, scales.y, scales.z);
                const quaternion2 = transformQuaternion(
                  new Quaternion(quatX, quatY, quatZ, quatW)
                );
                splats.setQuaternion(
                  lastIndex,
                  quaternion2.x,
                  quaternion2.y,
                  quaternion2.z,
                  quaternion2.w
                );
                splats.setOpacity(lastIndex, opacity);
                splats.setColor(lastIndex, r, g, b);
              } else {
                lastIndex = null;
              }
            },
            (index, sh1, sh2, sh3) => {
              if (lastIndex !== null) {
                splats.setSh1(lastIndex, sh1);
                if (sh2) {
                  splats.setSh2(lastIndex, sh2);
                }
                if (sh3) {
                  splats.setSh3(lastIndex, sh3);
                }
              }
            }
          );
          break;
        }
        default:
          throw new Error(\`transcodeSpz not implemented for \${fileType}\`);
      }
    }
    const shDegree = Math.min(
      maxSh ?? 3,
      splats.sh3 ? 3 : splats.sh2 ? 2 : splats.sh1 ? 1 : 0
    );
    const spz = new SpzWriter({
      numSplats: splats.numSplats,
      shDegree,
      fractionalBits,
      flagAntiAlias: true
    });
    for (let i2 = 0; i2 < splats.numSplats; ++i2) {
      const i3 = i2 * 3;
      const i4 = i2 * 4;
      spz.setCenter(
        i2,
        splats.centers[i3],
        splats.centers[i3 + 1],
        splats.centers[i3 + 2]
      );
      spz.setScale(
        i2,
        splats.scales[i3],
        splats.scales[i3 + 1],
        splats.scales[i3 + 2]
      );
      spz.setQuat(
        i2,
        splats.quaternions[i4],
        splats.quaternions[i4 + 1],
        splats.quaternions[i4 + 2],
        splats.quaternions[i4 + 3]
      );
      spz.setAlpha(i2, splats.opacities[i2]);
      spz.setRgb(
        i2,
        splats.colors[i3],
        splats.colors[i3 + 1],
        splats.colors[i3 + 2]
      );
      if (splats.sh1 && shDegree >= 1) {
        spz.setSh(
          i2,
          splats.sh1.slice(i2 * 9, (i2 + 1) * 9),
          shDegree >= 2 && splats.sh2 ? splats.sh2.slice(i2 * 15, (i2 + 1) * 15) : void 0,
          shDegree >= 3 && splats.sh3 ? splats.sh3.slice(i2 * 21, (i2 + 1) * 21) : void 0
        );
      }
    }
    const spzBytes = await spz.finalize();
    return { fileBytes: spzBytes, clippedCount: spz.clippedCount };
  }
  async function onMessage(event) {
    const { name, args, id } = event.data;
    let result = void 0;
    let error = void 0;
    try {
      switch (name) {
        case "unpackPly": {
          const { packedArray, fileBytes, splatEncoding } = args;
          const decoded = await unpackPly({
            packedArray,
            fileBytes,
            splatEncoding
          });
          result = {
            id,
            numSplats: decoded.numSplats,
            packedArray: decoded.packedArray,
            extra: decoded.extra
          };
          break;
        }
        case "decodeSpz": {
          const { fileBytes, splatEncoding } = args;
          const decoded = await unpackSpz(fileBytes, splatEncoding);
          result = {
            id,
            numSplats: decoded.numSplats,
            packedArray: decoded.packedArray,
            extra: decoded.extra
          };
          break;
        }
        case "decodeAntiSplat": {
          const { fileBytes, splatEncoding } = args;
          const decoded = unpackAntiSplat(fileBytes, splatEncoding);
          result = {
            id,
            numSplats: decoded.numSplats,
            packedArray: decoded.packedArray
          };
          break;
        }
        case "decodeKsplat": {
          const { fileBytes, splatEncoding } = args;
          const decoded = unpackKsplat(fileBytes, splatEncoding);
          result = {
            id,
            numSplats: decoded.numSplats,
            packedArray: decoded.packedArray,
            extra: decoded.extra
          };
          break;
        }
        case "decodePcSogs": {
          const { fileBytes, extraFiles, splatEncoding } = args;
          const json = JSON.parse(
            new TextDecoder().decode(fileBytes)
          );
          const decoded = await unpackPcSogs(json, extraFiles, splatEncoding);
          result = {
            id,
            numSplats: decoded.numSplats,
            packedArray: decoded.packedArray,
            extra: decoded.extra
          };
          break;
        }
        case "decodePcSogsZip": {
          const { fileBytes, splatEncoding } = args;
          const decoded = await unpackPcSogsZip(fileBytes, splatEncoding);
          result = {
            id,
            numSplats: decoded.numSplats,
            packedArray: decoded.packedArray,
            extra: decoded.extra
          };
          break;
        }
        case "sortSplats": {
          const { totalSplats, readback, ordering } = args;
          result = {
            id,
            readback,
            ...sortSplats({ totalSplats, readback, ordering })
          };
          break;
        }
        case "sortDoubleSplats": {
          const { numSplats, readback, ordering } = args;
          {
            result = {
              id,
              readback,
              ordering,
              activeSplats: sort_splats(numSplats, readback, ordering)
            };
          }
          break;
        }
        case "sort32Splats": {
          const { numSplats, readback, ordering } = args;
          {
            result = {
              id,
              readback,
              ordering,
              activeSplats: sort32_splats(numSplats, readback, ordering)
            };
          }
          break;
        }
        case "transcodeSpz": {
          const input = args;
          const spzBytes = await transcodeSpz(input);
          result = {
            id,
            fileBytes: spzBytes,
            input
          };
          break;
        }
        default: {
          throw new Error(\`Unknown name: \${name}\`);
        }
      }
    } catch (e) {
      error = e;
      console.error(error);
    }
    self.postMessage(
      { id, result, error },
      { transfer: getArrayBuffers(result) }
    );
  }
  async function unpackPly({
    packedArray,
    fileBytes,
    splatEncoding
  }) {
    const ply = new PlyReader({ fileBytes });
    await ply.parseHeader();
    const numSplats = ply.numSplats;
    const extra = {};
    ply.parseSplats(
      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
        setPackedSplat(
          packedArray,
          index,
          x2,
          y,
          z,
          scaleX,
          scaleY,
          scaleZ,
          quatX,
          quatY,
          quatZ,
          quatW,
          opacity,
          r,
          g,
          b,
          splatEncoding
        );
      },
      (index, sh1, sh2, sh3) => {
        if (sh1) {
          if (!extra.sh1) {
            extra.sh1 = new Uint32Array(numSplats * 2);
          }
          encodeSh1Rgb(extra.sh1, index, sh1, splatEncoding);
        }
        if (sh2) {
          if (!extra.sh2) {
            extra.sh2 = new Uint32Array(numSplats * 4);
          }
          encodeSh2Rgb(extra.sh2, index, sh2, splatEncoding);
        }
        if (sh3) {
          if (!extra.sh3) {
            extra.sh3 = new Uint32Array(numSplats * 4);
          }
          encodeSh3Rgb(extra.sh3, index, sh3, splatEncoding);
        }
      }
    );
    return { packedArray, numSplats, extra };
  }
  async function unpackSpz(fileBytes, splatEncoding) {
    const spz = new SpzReader({ fileBytes });
    await spz.parseHeader();
    const numSplats = spz.numSplats;
    const maxSplats = computeMaxSplats(numSplats);
    const packedArray = new Uint32Array(maxSplats * 4);
    const extra = {};
    await spz.parseSplats(
      (index, x2, y, z) => {
        setPackedSplatCenter(packedArray, index, x2, y, z);
      },
      (index, alpha) => {
        setPackedSplatOpacity(packedArray, index, alpha);
      },
      (index, r, g, b) => {
        setPackedSplatRgb(packedArray, index, r, g, b, splatEncoding);
      },
      (index, scaleX, scaleY, scaleZ) => {
        setPackedSplatScales(
          packedArray,
          index,
          scaleX,
          scaleY,
          scaleZ,
          splatEncoding
        );
      },
      (index, quatX, quatY, quatZ, quatW) => {
        setPackedSplatQuat(packedArray, index, quatX, quatY, quatZ, quatW);
      },
      (index, sh1, sh2, sh3) => {
        if (sh1) {
          if (!extra.sh1) {
            extra.sh1 = new Uint32Array(numSplats * 2);
          }
          encodeSh1Rgb(extra.sh1, index, sh1, splatEncoding);
        }
        if (sh2) {
          if (!extra.sh2) {
            extra.sh2 = new Uint32Array(numSplats * 4);
          }
          encodeSh2Rgb(extra.sh2, index, sh2, splatEncoding);
        }
        if (sh3) {
          if (!extra.sh3) {
            extra.sh3 = new Uint32Array(numSplats * 4);
          }
          encodeSh3Rgb(extra.sh3, index, sh3, splatEncoding);
        }
      }
    );
    return { packedArray, numSplats, extra };
  }
  const DEPTH_INFINITY_F16 = 31744;
  const DEPTH_SIZE_16 = DEPTH_INFINITY_F16 + 1;
  let depthArray16 = null;
  function sortSplats({
    totalSplats,
    readback,
    ordering
  }) {
    if (!depthArray16) {
      depthArray16 = new Uint32Array(DEPTH_SIZE_16);
    }
    depthArray16.fill(0);
    const readbackUint32 = readback.map((layer) => new Uint32Array(layer.buffer));
    const layerSize = readbackUint32[0].length;
    const numLayers = Math.ceil(totalSplats / layerSize);
    let layerBase = 0;
    for (let layer = 0; layer < numLayers; ++layer) {
      const readbackLayer = readbackUint32[layer];
      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);
      for (let i2 = 0; i2 < layerSplats; ++i2) {
        const pri = readbackLayer[i2] & 32767;
        if (pri < DEPTH_INFINITY_F16) {
          depthArray16[pri] += 1;
        }
      }
      layerBase += layerSplats;
    }
    let activeSplats = 0;
    for (let j = 0; j < DEPTH_SIZE_16; ++j) {
      const nextIndex = activeSplats + depthArray16[j];
      depthArray16[j] = activeSplats;
      activeSplats = nextIndex;
    }
    layerBase = 0;
    for (let layer = 0; layer < numLayers; ++layer) {
      const readbackLayer = readbackUint32[layer];
      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);
      for (let i2 = 0; i2 < layerSplats; ++i2) {
        const pri = readbackLayer[i2] & 32767;
        if (pri < DEPTH_INFINITY_F16) {
          ordering[depthArray16[pri]] = layerBase + i2;
          depthArray16[pri] += 1;
        }
      }
      layerBase += layerSplats;
    }
    if (depthArray16[DEPTH_SIZE_16 - 1] !== activeSplats) {
      throw new Error(
        \`Expected \${activeSplats} active splats but got \${depthArray16[DEPTH_SIZE_16 - 1]}\`
      );
    }
    return { activeSplats, ordering };
  }
  const messageBuffer = [];
  function bufferMessage(event) {
    messageBuffer.push(event);
  }
  async function initialize() {
    self.addEventListener("message", bufferMessage);
    await __wbg_init();
    self.removeEventListener("message", bufferMessage);
    self.addEventListener("message", onMessage);
    for (const event of messageBuffer) {
      onMessage(event);
    }
    messageBuffer.length = 0;
  }
  initialize().catch(console.error);
})();
//# sourceMappingURL=worker-CaMzlx2k.js.map
`,UB=typeof self<"u"&&self.Blob&&new Blob([hT],{type:"text/javascript;charset=utf-8"});function J8(s){let t;try{if(t=UB&&(self.URL||self.webkitURL).createObjectURL(UB),!t)throw"";const e=new Worker(t,{name:s?.name});return e.addEventListener("error",()=>{(self.URL||self.webkitURL).revokeObjectURL(t)}),e}catch{return new Worker("data:text/javascript;charset=utf-8,"+encodeURIComponent(hT),{name:s?.name})}finally{t&&(self.URL||self.webkitURL).revokeObjectURL(t)}}class Z8{constructor(){this.messages={},this.messageIdNext=0,this.worker=new J8,this.worker.onmessage=t=>this.onMessage(t)}makeMessageId(){return++this.messageIdNext}makeMessagePromiseId(){const t=this.makeMessageId(),e=new Promise((n,i)=>{this.messages[t]={resolve:n,reject:i}});return{id:t,promise:e}}onMessage(t){const{id:e,result:n,error:i}=t.data,r=this.messages[e];r&&(delete this.messages[e],i?r.reject(i):r.resolve(n))}async call(t,e){const{id:n,promise:i}=this.makeMessagePromiseId();return this.worker.postMessage({name:t,args:e,id:n},{transfer:DP(e)}),i}}let fT=4,aE=0;const AT=[],dT=[];async function W8(){const s=AT.shift();if(s)return s;if(aE<fT){const t=new Z8;return aE+=1,t}return new Promise(t=>{dT.push(t)})}function j8(s){if(aE>fT){aE-=1;return}const t=dT.shift();if(t){t(s);return}AT.push(s)}async function wf(s){const t=await W8();try{return await s(t)}finally{j8(t)}}class K8 extends tr{constructor(t){super(t),this.fileLoader=new ac(t)}load(t,e,n,i){const r=this.manager.resolveURL((this.path??"")+(t??"")),l=new Headers(this.requestHeader),u=this.withCredentials?"include":"same-origin",A=new Request(r,{headers:l,credentials:u});let d=this.fileType;this.manager.itemStart(r),LB(A,n).then(async m=>{var g;const y=[new ProgressEvent("progress",{lengthComputable:!0,loaded:m.byteLength,total:m.byteLength})];function v(){if(n){const E=y.every(Q=>Q.lengthComputable||Q.loaded===0&&Q.total===0),B=y.reduce((Q,R)=>Q+R.loaded,0),w=y.reduce((Q,R)=>Q+R.total,0);n(new ProgressEvent("progress",{lengthComputable:E,loaded:B,total:w}))}}const C={},I=[],S=pT(m);if(d==="pcsogs"&&S===void 0)throw new Error("Invalid PC SOGS file");if(S!==void 0){d="pcsogs";for(const E of["means","scales","quats","sh0","shN"]){const B=S[E];if(B)for(const w of B.files){const Q=new URL(w,r).toString(),R=y.length;y.push(new ProgressEvent("progress")),this.manager.itemStart(Q);const D=new Request(Q,{headers:l,credentials:u}),U=LB(D,P=>{y[R]=P,v()}).then(P=>{C[w]=P}).catch(P=>{throw this.manager.itemError(Q),P}).finally(()=>{this.manager.itemEnd(Q)});I.push(U)}}}if(await Promise.all(I),e){const E=((g=this.packedSplats)==null?void 0:g.splatEncoding)??JE,B=await gT({input:m,extraFiles:C,fileType:d,pathOrUrl:r,splatEncoding:E});this.packedSplats?(this.packedSplats.initialize(B),e(this.packedSplats)):e(new Wf(B))}}).catch(m=>{this.manager.itemError(r),i?.(m)}).finally(()=>{this.manager.itemEnd(r)})}async loadAsync(t,e){return new Promise((n,i)=>{this.load(t,r=>{n(r)},e,i)})}parse(t){return new lI({packedSplats:t})}}async function LB(s,t){const e=await fetch(s);if(!e.ok)throw new Error(`${e.status} "${e.statusText}" fetching URL: ${s.url}`);if(!e.body)throw new Error(`Response body is null for URL: ${s.url}`);const n=e.body.getReader(),i=Number.parseInt(e.headers.get("Content-Length")||"0"),r=Number.isNaN(i)?0:i;let l=0;const u=[];for(;;){const{done:m,value:g}=await n.read();if(m)break;u.push(g),l+=g.length,t&&t(new ProgressEvent("progress",{lengthComputable:r!==0,loaded:l,total:r}))}const A=new Uint8Array(l);let d=0;for(const m of u)A.set(m,d),d+=m.length;return A.buffer}function $8(s){const t=new DataView(s.buffer);if((t.getUint32(0,!0)&16777215)===7957616)return"ply";if((t.getUint32(0,!0)&16777215)===559903){const e=JP(s,4);return new DataView(e.buffer).getUint32(0,!0)===1347635022?"spz":void 0}if(t.getUint32(0,!0)===67324752)return nG(s)?"pcsogszip":void 0}function tG(s){const t=s.split(/[?#]/,1)[0],e=Math.max(t.lastIndexOf("/"),t.lastIndexOf("\\")),n=t.slice(e+1),i=n.lastIndexOf(".");return i<=0||i===n.length-1?"":n.slice(i+1).toLowerCase()}function eG(s){const t=tG(s);if(t==="ply")return"ply";if(t==="spz")return"spz";if(t==="splat")return"splat";if(t==="ksplat")return"ksplat";if(t==="sog")return"pcsogszip"}function pT(s){try{let t;if(typeof s=="string")t=s;else{const i=s instanceof ArrayBuffer?new Uint8Array(s):s;if(i.length>65536)return;t=new TextDecoder().decode(i)}const e=JSON.parse(t);if(!e||typeof e!="object"||Array.isArray(e))return;const n=e.version===2;for(const i of["means","scales","quats","sh0"]){if(!e[i]||typeof e[i]!="object"||Array.isArray(e[i]))return;if(n){if(!e[i].files||(i==="scales"||i==="sh0")&&!e[i].codebook||i==="means"&&(!e[i].mins||!e[i].maxs))return}else if(!e[i].shape||!e[i].files||i!=="quats"&&(!e[i].mins||!e[i].maxs))return}return e}catch{return}}function nG(s){try{const t=s instanceof ArrayBuffer?new Uint8Array(s):s;let e=null;const n=tP(t,{filter:({name:r})=>r.split(/[\\/]/).pop()==="meta.json"?(e=r,!0):!1});if(!e)return;const i=pT(n[e]);return i?{name:e,json:i}:void 0}catch{return}}async function gT({input:s,extraFiles:t,fileType:e,pathOrUrl:n,splatEncoding:i}){const r=s instanceof ArrayBuffer?new Uint8Array(s):s;let l=e;switch(e||(l=$8(r),!l&&n&&(l=eG(n))),l){case"ply":{const u=new O8({fileBytes:r});await u.parseHeader();const A=u.numSplats,d=vo(A).maxSplats,m={fileBytes:r,packedArray:new Uint32Array(d*4),splatEncoding:i};return await wf(async g=>{const{packedArray:y,numSplats:v,extra:C}=await g.call("unpackPly",m);return{packedArray:y,numSplats:v,extra:C}})}case"spz":return await wf(async u=>{const{packedArray:A,numSplats:d,extra:m}=await u.call("decodeSpz",{fileBytes:r,splatEncoding:i});return{packedArray:A,numSplats:d,extra:m}});case"splat":return await wf(async u=>{const{packedArray:A,numSplats:d}=await u.call("decodeAntiSplat",{fileBytes:r,splatEncoding:i});return{packedArray:A,numSplats:d}});case"ksplat":return await wf(async u=>{const{packedArray:A,numSplats:d,extra:m}=await u.call("decodeKsplat",{fileBytes:r,splatEncoding:i});return{packedArray:A,numSplats:d,extra:m}});case"pcsogs":return await wf(async u=>{const{packedArray:A,numSplats:d,extra:m}=await u.call("decodePcSogs",{fileBytes:r,extraFiles:t,splatEncoding:i});return{packedArray:A,numSplats:d,extra:m}});case"pcsogszip":return await wf(async u=>{const{packedArray:A,numSplats:d,extra:m}=await u.call("decodePcSogsZip",{fileBytes:r,splatEncoding:i});return{packedArray:A,numSplats:d,extra:m}});default:throw new Error(`Unknown splat file type: ${l}`)}}var iG=`precision highp float;
precision highp int;
precision highp sampler2D;
precision highp usampler2D;
precision highp isampler2D;
precision highp sampler2DArray;
precision highp usampler2DArray;
precision highp isampler2DArray;
precision highp sampler3D;
precision highp usampler3D;
precision highp isampler3D;

#include <splatDefines>

uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;

out uvec4 target;

{{ GLOBALS }}

void produceSplat(int index) {
    {{ STATEMENTS }}
}

void main() {
    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);
    int index = targetIndex - targetBase;

    if ((index >= 0) && (index < targetCount)) {
        produceSplat(index);
    } else {
        target = uvec4(0u, 0u, 0u, 0u);
    }
}`;const JE={rgbMin:0,rgbMax:1,lnScaleMin:iu,lnScaleMax:su,sh1Min:-1,sh1Max:1,sh2Min:-1,sh2Max:1,sh3Min:-1,sh3Max:1},m0=class xa{constructor(t={}){this.maxSplats=0,this.numSplats=0,this.packedArray=null,this.isInitialized=!1,this.target=null,this.source=null,this.needsUpdate=!0,this.extra={},this.dyno=new uI({packedSplats:this}),this.dynoRgbMinMaxLnScaleMinMax=new qE({key:"rgbMinMaxLnScaleMinMax",value:new We(0,1,iu,su),update:e=>{var n,i,r,l;return e.set(((n=this.splatEncoding)==null?void 0:n.rgbMin)??0,((i=this.splatEncoding)==null?void 0:i.rgbMax)??1,((r=this.splatEncoding)==null?void 0:r.lnScaleMin)??iu,((l=this.splatEncoding)==null?void 0:l.lnScaleMax)??su),e}}),this.dynoSh1MinMax=new ab({key:"sh1MinMax",value:new Dt(-1,1),update:e=>{var n,i;return e.set(((n=this.splatEncoding)==null?void 0:n.sh1Min)??-1,((i=this.splatEncoding)==null?void 0:i.sh1Max)??1),e}}),this.dynoSh2MinMax=new ab({key:"sh2MinMax",value:new Dt(-1,1),update:e=>{var n,i;return e.set(((n=this.splatEncoding)==null?void 0:n.sh2Min)??-1,((i=this.splatEncoding)==null?void 0:i.sh2Max)??1),e}}),this.dynoSh3MinMax=new ab({key:"sh3MinMax",value:new Dt(-1,1),update:e=>{var n,i;return e.set(((n=this.splatEncoding)==null?void 0:n.sh3Min)??-1,((i=this.splatEncoding)==null?void 0:i.sh3Max)??1),e}}),this.initialized=Promise.resolve(this),this.reinitialize(t)}reinitialize(t){this.isInitialized=!1,this.extra={},this.splatEncoding=t.splatEncoding,t.url||t.fileBytes||t.construct?this.initialized=this.asyncInitialize(t).then(()=>(this.isInitialized=!0,this)):(this.initialize(t),this.isInitialized=!0,this.initialized=Promise.resolve(this))}initialize(t){t.packedArray?(this.packedArray=t.packedArray,this.maxSplats=Math.floor(this.packedArray.length/4),this.maxSplats=Math.floor(this.maxSplats/vi)*vi,this.numSplats=Math.min(this.maxSplats,t.numSplats??Number.POSITIVE_INFINITY)):(this.maxSplats=t.maxSplats??0,this.numSplats=0),this.extra=t.extra??{}}async asyncInitialize(t){const{url:e,fileBytes:n,construct:i}=t;if(e){const r=new K8;r.packedSplats=this,await r.loadAsync(e)}else if(n){const r=await gT({input:n,fileType:t.fileType,pathOrUrl:t.fileName??e,splatEncoding:t.splatEncoding??JE});this.initialize(r)}if(i){const r=i(this);r instanceof Promise&&await r}}dispose(){this.target&&(this.target.dispose(),this.target=null),this.source&&(this.source.dispose(),this.source=null)}ensureSplats(t){const e=t<=this.maxSplats?this.maxSplats:Math.max(t,2*this.maxSplats),n=this.packedArray?this.packedArray.length/4:0;if(!this.packedArray||e>n){this.maxSplats=vo(e).maxSplats;const i=new Uint32Array(this.maxSplats*4);this.packedArray&&i.set(this.packedArray),this.packedArray=i}return this.packedArray}ensureSplatsSh(t,e){let n,i;if(t===0)return this.ensureSplats(e);if(t===1)n=2,i="sh1";else if(t===2)n=4,i="sh2";else if(t===3)n=4,i="sh3";else throw new Error(`Invalid level: ${t}`);let r=this.extra[i]?this.extra[i].length/n:0;const l=e<=r?r:Math.max(e,2*r);if(!this.extra[i]||l>r){r=vo(l).maxSplats;const u=new Uint32Array(r*n);this.extra[i]&&u.set(this.extra[i]),this.extra[i]=u}return this.extra[i]}getSplat(t){if(!this.packedArray||t>=this.numSplats)throw new Error("Invalid index");return wB(this.packedArray,t,this.splatEncoding)}setSplat(t,e,n,i,r,l){const u=this.ensureSplats(t+1);MB(u,t,e.x,e.y,e.z,n.x,n.y,n.z,i.x,i.y,i.z,i.w,r,l.r,l.g,l.b),this.numSplats=Math.max(this.numSplats,t+1)}pushSplat(t,e,n,i,r){const l=this.ensureSplats(this.numSplats+1);MB(l,this.numSplats,t.x,t.y,t.z,e.x,e.y,e.z,n.x,n.y,n.z,n.w,i,r.r,r.g,r.b),++this.numSplats}forEachSplat(t){if(!(!this.packedArray||!this.numSplats))for(let e=0;e<this.numSplats;++e){const n=wB(this.packedArray,e,this.splatEncoding);t(e,n.center,n.scales,n.quaternion,n.opacity,n.color)}}ensureGenerate(t){if(this.target&&(t??1)<=this.maxSplats)return!1;this.dispose();const e=vo(t??1),{width:n,height:i,depth:r}=e;return this.maxSplats=e.maxSplats,this.target=new bS(n,i,r,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:rs,minFilter:rs}),this.target.texture.format=sc,this.target.texture.type=Ca,this.target.texture.internalFormat="RGBA32UI",this.target.scissorTest=!0,!0}generateMapping(t){let e=0;const n=t.map(i=>{const r=e,l=Math.ceil(i/vi)*vi;return e+=l,{base:r,count:i}});return{maxSplats:e,mapping:n}}getTexture(){return this.target?this.target.texture:this.source||this.packedArray?this.maybeUpdateSource():xa.getEmpty()}maybeUpdateSource(){if(!this.packedArray)throw new Error("No packed splats");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:t,height:e,depth:n}=this.source.image;this.maxSplats!==t*e*n&&(this.source.dispose(),this.source=null)}if(this.source)this.packedArray.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.packedArray.buffer));else{const{width:t,height:e,depth:n}=vo(this.maxSplats);this.source=new hl(this.packedArray,t,e,n),this.source.format=sc,this.source.type=Ca,this.source.internalFormat="RGBA32UI",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}static getEmpty(){if(!xa.emptySource){const{width:t,height:e,depth:n,maxSplats:i}=vo(1),r=new Uint32Array(i*4);xa.emptySource=new hl(r,t,e,n),xa.emptySource.format=sc,xa.emptySource.type=Ca,xa.emptySource.internalFormat="RGBA32UI",xa.emptySource.needsUpdate=!0}return xa.emptySource}prepareProgramMaterial(t){let e=xa.generatorProgram.get(t);if(!e){const i=au({index:"int"},{output:"uvec4"},({index:r})=>{t.inputs.index=r;const l=t.outputs.gsplat;return{output:SP(l,this.dynoRgbMinMaxLnScaleMinMax)}});xa.programTemplate||(xa.programTemplate=new $3(iG)),e=new K3({graph:i,inputs:{index:"index"},outputs:{output:"target"},template:xa.programTemplate}),Object.assign(e.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),xa.generatorProgram.set(t,e)}const n=e.prepareMaterial();return xa.fullScreenQuad.material=n,{program:e,material:n}}saveRenderState(t){return{xrEnabled:t.xr.enabled,autoClear:t.autoClear}}resetRenderState(t,e){t.setRenderTarget(null),t.xr.enabled=e.xrEnabled,t.autoClear=e.autoClear}generate({generator:t,base:e,count:n,renderer:i}){if(!this.target)throw new Error("Target must be initialized with ensureSplats");if(e+n>this.maxSplats)throw new Error("Base + count exceeds maxSplats");const{program:r,material:l}=this.prepareProgramMaterial(t);r.update();const u=this.saveRenderState(i),A=Math.ceil((e+n)/vi)*vi,d=vi*zf;for(l.uniforms.targetBase.value=e,l.uniforms.targetCount.value=n;e<A;){const m=Math.floor(e/d);l.uniforms.targetLayer.value=m;const g=m*d,y=Math.floor((e-g)/vi),v=Math.min(zf,Math.ceil((A-g)/vi));this.target.scissor.set(0,y,vi,v-y),i.setRenderTarget(this.target,m),i.xr.enabled=!1,i.autoClear=!1,xa.fullScreenQuad.render(i),e+=vi*(v-y)}return this.resetRenderState(i,u),{nextBase:A}}};m0.emptySource=null;m0.programTemplate=null;m0.generatorProgram=new Map;m0.fullScreenQuad=new U3(new l0({visible:!1}));let Wf=m0;class uI extends Al{constructor({packedSplats:t}={}){super({key:"packedSplats",type:YE,globals:()=>[sI],value:{texture:Wf.getEmpty(),numSplats:0,rgbMinMaxLnScaleMinMax:new We(0,1,iu,su)},update:e=>{var n,i,r,l,u,A,d,m,g,y;return e.texture=((n=this.packedSplats)==null?void 0:n.getTexture())??Wf.getEmpty(),e.numSplats=((i=this.packedSplats)==null?void 0:i.numSplats)??0,e.rgbMinMaxLnScaleMinMax.set(((l=(r=this.packedSplats)==null?void 0:r.splatEncoding)==null?void 0:l.rgbMin)??0,((A=(u=this.packedSplats)==null?void 0:u.splatEncoding)==null?void 0:A.rgbMax)??1,((m=(d=this.packedSplats)==null?void 0:d.splatEncoding)==null?void 0:m.lnScaleMin)??iu,((y=(g=this.packedSplats)==null?void 0:g.splatEncoding)==null?void 0:y.lnScaleMax)??su),e}}),this.packedSplats=t}}class Kb extends WS{constructor(t,e){super(),this.ordering=t,this.setAttribute("position",new Qn(sG,3)),this.setIndex(new Qn(aG,1)),this._maxInstanceCount=t.length,this.instanceCount=e,this.attribute=new Xf(t,1,!1,1),this.attribute.setUsage(iw),this.setAttribute("splatIndex",this.attribute)}update(t,e){this.ordering=t,this.attribute.array=t,this.instanceCount=e,this.attribute.addUpdateRange(0,e),this.attribute.needsUpdate=!0}}const sG=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,1,0]),aG=new Uint16Array([0,1,2,0,2,3]),hI=class Am{constructor(t){if(this.lastTime=null,this.encodeLinear=!1,this.superXY=1,this.display=null,this.sorting=null,this.pending=null,this.sortingCheck=!1,this.readback16=new Uint16Array(0),this.readback32=new Uint32Array(0),this.spark=t.spark,this.camera=t.camera,this.viewToWorld=t.viewToWorld??new he,t.target){const{width:e,height:n,doubleBuffer:i}=t.target,r=Math.max(1,Math.min(4,t.target.superXY??1));if(this.superXY=r,e*r>8192||n*r>8192)throw new Error("Target size too large");this.target=new Io(e*r,n*r,{format:Ki,type:ea,colorSpace:ks}),i&&(this.back=new Io(e*r,n*r,{format:Ki,type:ea,colorSpace:ks})),this.encodeLinear=!0}this.onTextureUpdated=t.onTextureUpdated,this.sortRadial=t.sortRadial??!0,this.sortDistance=t.sortDistance,this.sortCoorient=t.sortCoorient,this.depthBias=t.depthBias,this.sort360=t.sort360,this.sort32=t.sort32,this.stochastic=t.stochastic??!1,this.orderingFreelist=new RP({allocate:e=>new Uint32Array(e),valid:(e,n)=>e.length===n}),this.autoUpdate=!1,this.setAutoUpdate(t.autoUpdate??!1)}dispose(){var t;this.setAutoUpdate(!1),this.target&&(this.target.dispose(),this.target=void 0),this.back&&(this.back.dispose(),this.back=void 0),this.display&&(this.spark.releaseAccumulator(this.display.accumulator),this.display.geometry.dispose(),this.display=null),(t=this.pending)!=null&&t.accumulator&&(this.spark.releaseAccumulator(this.pending.accumulator),this.pending=null)}setAutoUpdate(t){!this.autoUpdate&&t?this.spark.autoViewpoints.push(this):this.autoUpdate&&!t&&(this.spark.autoViewpoints=this.spark.autoViewpoints.filter(e=>e!==this)),this.autoUpdate=t}async prepare({scene:t,camera:e,viewToWorld:n,update:i,forceOrigin:r}){var l;for(n?this.viewToWorld=n:(this.camera=e??this.camera,this.camera&&(this.camera.updateMatrixWorld(),this.viewToWorld=this.camera.matrixWorld.clone()));i??!0;){const A=r?this.viewToWorld:void 0;if(this.spark.updateInternal({scene:t,originToWorld:A}))break;await new Promise(m=>setTimeout(m,10))}const u=this.spark.active;u!==((l=this.display)==null?void 0:l.accumulator)&&(this.spark.active.refCount+=1),await this.sortUpdate({accumulator:u,viewToWorld:this.viewToWorld})}renderTarget({scene:t,camera:e}){var n;const i=this.back??this.target;if(!i)throw new Error("Must initialize SparkViewpoint with target");if(e=e??this.camera,!e)throw new Error("Must provide camera");if(e instanceof As){const r=new As().copy(e,!1);r.aspect=i.width/i.height,r.updateProjectionMatrix(),e=r}this.viewToWorld=e.matrixWorld.clone();try{this.spark.renderer.setRenderTarget(i),this.spark.prepareViewpoint(this),this.spark.renderer.render(t,e)}finally{this.spark.prepareViewpoint(this.spark.defaultView),this.spark.renderer.setRenderTarget(null)}i!==this.target&&([this.target,this.back]=[this.back,this.target]),(n=this.onTextureUpdated)==null||n.call(this,i.texture)}async readTarget(){if(!this.target)throw new Error("Must initialize SparkViewpoint with target");const{width:t,height:e}=this.target,n=t*e*4;(!this.superPixels||this.superPixels.length<n)&&(this.superPixels=new Uint8Array(n)),await this.spark.renderer.readRenderTargetPixelsAsync(this.target,0,0,t,e,this.superPixels);const{superXY:i}=this;if(i===1)return this.superPixels;const r=t/i,l=e/i,u=r*l*4;(!this.pixels||this.pixels.length<u)&&(this.pixels=new Uint8Array(u));const{superPixels:A,pixels:d}=this,m=i*i;for(let g=0;g<l;g++){const y=g*r;for(let v=0;v<r;v++){const C=v*i;let I=0,S=0,E=0,B=0;for(let Q=0;Q<i;Q++){const R=(g*i+Q)*this.target.width;for(let D=0;D<i;D++){const U=(R+C+D)*4;I+=A[U],S+=A[U+1],E+=A[U+2],B+=A[U+3]}}const w=(y+v)*4;d[w]=I/m,d[w+1]=S/m,d[w+2]=E/m,d[w+3]=B/m}}return d}async prepareRenderPixels({scene:t,camera:e,viewToWorld:n,update:i,forceOrigin:r}){return await this.prepare({scene:t,camera:e,viewToWorld:n,update:i,forceOrigin:r}),this.renderTarget({scene:t,camera:e}),this.readTarget()}autoPoll({accumulator:t}){var e,n,i;this.camera&&(this.camera.updateMatrixWorld(),this.viewToWorld=this.camera.matrixWorld.clone());let r=!1,l=!1;if(!this.display)r=!0;else if(t){r=!0;const{mappingVersion:A}=this.display.accumulator;t.mappingVersion===A&&(t.refCount+=1,this.spark.releaseAccumulator(this.display.accumulator),this.display.accumulator=t,this.display.viewToWorld.copy(this.viewToWorld),l=!0,this.spark.viewpoint===this&&this.spark.prepareViewpoint(this))}const u=((e=this.sorting)==null?void 0:e.viewToWorld)??((n=this.display)==null?void 0:n.viewToWorld);u&&!Xb({matrix1:this.viewToWorld,matrix2:u,maxDistance:this.sortDistance??.01,minCoorient:this.sortCoorient??this.sortRadial?.99:.999})&&(r=!0),r&&(t&&(t.refCount+=1),(i=this.pending)!=null&&i.accumulator&&this.spark.releaseAccumulator(this.pending.accumulator),this.pending={accumulator:t,viewToWorld:this.viewToWorld,displayed:l},this.driveSort())}async driveSort(){for(var t;;){if(this.sorting||!this.pending)return;const{viewToWorld:e,displayed:n}=this.pending;let i=this.pending.accumulator;if(i||(i=((t=this.display)==null?void 0:t.accumulator)??this.spark.active,i.refCount+=1),this.pending=null,!i)throw new Error("No accumulator to sort");this.sorting={viewToWorld:e},await this.sortUpdate({accumulator:i,viewToWorld:e,displayed:n}),this.sorting=null,this.spark.releaseAccumulator(i)}}async sortUpdate({accumulator:t,viewToWorld:e,displayed:n=!1}){if(this.sortingCheck)throw new Error("Only one sort at a time");this.sortingCheck=!0,t=t??this.spark.active;const{numSplats:i,maxSplats:r}=t.splats;let l=0,u=this.orderingFreelist.alloc(r);if(this.stochastic){l=i;for(let A=0;A<i;++A)u[A]=A}else if(i>0){const{reader:A,doubleSortReader:d,sort32Reader:m,dynoSortRadial:g,dynoOrigin:y,dynoDirection:v,dynoDepthBias:C,dynoSort360:I,dynoSplats:S}=Am.makeSorter(),E=this.sort32??!1;let B;if(E)this.readback32=A.ensureBuffer(r,this.readback32),B=this.readback32;else{const P=Math.ceil(r/2);this.readback16=A.ensureBuffer(P,this.readback16),B=this.readback16}const w=t.toWorld.clone().invert(),Q=e.clone().premultiply(w);g.value=this.sort360?!0:this.sortRadial,y.value.set(0,0,0).applyMatrix4(Q),v.value.set(0,0,-1).applyMatrix4(Q).sub(y.value).normalize(),C.value=this.depthBias??1,I.value=this.sort360??!1,S.packedSplats=t.splats;const R=E?m:d,D=E?i:Math.ceil(i/2);await A.renderReadback({renderer:this.spark.renderer,reader:R,count:D,readback:B});const U=await wf(async P=>{const z=E?"sort32Splats":"sortDoubleSplats";return P.call(z,{maxSplats:r,numSplats:i,readback:B,ordering:u})});E?this.readback32=U.readback:this.readback16=U.readback,u=U.ordering,l=U.activeSplats}this.updateDisplay({accumulator:t,viewToWorld:e,ordering:u,activeSplats:l,displayed:n}),this.sortingCheck=!1}updateDisplay({accumulator:t,viewToWorld:e,ordering:n,activeSplats:i,displayed:r=!1}){if(!this.display)t.refCount+=1,this.display={accumulator:t,viewToWorld:e,geometry:new Kb(n,i)};else{!r&&t!==this.display.accumulator&&(t.refCount+=1,this.spark.releaseAccumulator(this.display.accumulator),this.display.accumulator=t),this.display.viewToWorld=e;const l=this.display.geometry.ordering;l.length===n.length?this.display.geometry.update(n,i):(this.display.geometry.dispose(),this.display.geometry=new Kb(n,i)),this.orderingFreelist.free(l)}this.spark.viewpoint===this&&this.spark.prepareViewpoint(this)}static makeSorter(){if(!Am.dynos){const t=new BB({value:!0}),e=new iE({value:new F}),n=new iE({value:new F}),i=new t0({value:1}),r=new BB({value:!1}),l=new uI,u=new eT,A=au({index:"int"},{rgba8:"vec4"},({index:m})=>{if(!m)throw new Error("No index");const g={sortRadial:t,sortOrigin:e,sortDirection:n,sortDepthBias:i,sort360:r},y=fm(m,Mm("int",2)),v=wm(l,y),C=cb({gsplat:v,...g}),I=wm(l,Qf(y,Mm("int",1))),S=cb({gsplat:I,...g}),E=l8({vectorType:"vec2",x:C,y:S});return{rgba8:DB(n8(E))}}),d=au({index:"int"},{rgba8:"vec4"},({index:m})=>{if(!m)throw new Error("No index");const g={sortRadial:t,sortOrigin:e,sortDirection:n,sortDepthBias:i,sort360:r},y=wm(l,m),v=cb({gsplat:y,...g});return{rgba8:DB(e8(v))}});Am.dynos={dynoSortRadial:t,dynoOrigin:e,dynoDirection:n,dynoDepthBias:i,dynoSort360:r,dynoSplats:l,reader:u,doubleSortReader:A,sort32Reader:d}}return Am.dynos}};hI.EMPTY_TEXTURE=new wi;hI.dynos=null;let zB=hI;const rG=Cr(`
  float computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 sortDirection, float sortDepthBias, bool sort360) {
    if (!isGsplatActive(gsplat.flags)) {
      return INFINITY;
    }

    vec3 center = gsplat.center - sortOrigin;
    float biasedDepth = dot(center, sortDirection) + sortDepthBias;
    if (!sort360 && (biasedDepth <= 0.0)) {
      return INFINITY;
    }

    return sortRadial ? length(center) : biasedDepth;
  }
`);function cb({gsplat:s,sortRadial:t,sortOrigin:e,sortDirection:n,sortDepthBias:i,sort360:r}){return kE({inTypes:{gsplat:Ts,sortRadial:"bool",sortOrigin:"vec3",sortDirection:"vec3",sortDepthBias:"float",sort360:"bool"},outTypes:{metric:"float"},globals:()=>[cc,rG],inputs:{gsplat:s,sortRadial:t,sortOrigin:e,sortDirection:n,sortDepthBias:i,sort360:r},statements:({inputs:l,outputs:u})=>{const{gsplat:A,sortRadial:d,sortOrigin:m,sortDirection:g,sortDepthBias:y,sort360:v}=l;return lc(`
        ${u.metric} = computeSort(${A}, ${d}, ${m}, ${g}, ${y}, ${v});
      `)}}).outputs.metric}class ub{constructor(){this.splats=new Wf,this.toWorld=new he,this.mapping=[],this.refCount=0,this.splatsVersion=-1,this.mappingVersion=-1}ensureGenerate(t){this.splats.ensureGenerate(t)&&(this.mapping=[])}generateSplats({renderer:t,modifier:e,generators:n,forceUpdate:i,originToWorld:r}){const l=this.mapping.reduce((d,m)=>(d.set(m.node,m),d),new Map);let u=0,A=0;for(const{node:d,generator:m,version:g,base:y,count:v}of n){const C=l.get(d);if((i||m!==C?.generator||g!==C?.version||y!==C?.base||v!==C?.count)&&m&&v>0){const I=e.apply(m);try{this.splats.generate({generator:I,base:y,count:v,renderer:t})}catch(S){d.generator=void 0,d.generatorError=S}u+=1}A=Math.max(A,y+v)}return this.splats.numSplats=A,this.toWorld.copy(r),this.mapping=n,u!==0}hasCorrespondence(t){return this.mapping.length!==t.mapping.length?!1:this.mapping.every(({node:e,base:n,count:i},r)=>{const{node:l,base:u,count:A}=t.mapping[r];return e===l&&n===u&&i===A})}}var oG=`const float LN_SCALE_MIN = -12.0;
const float LN_SCALE_MAX = 9.0;

const uint SPLAT_TEX_WIDTH_BITS = 11u;
const uint SPLAT_TEX_HEIGHT_BITS = 11u;
const uint SPLAT_TEX_DEPTH_BITS = 11u;
const uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;

const uint SPLAT_TEX_WIDTH = 1u << SPLAT_TEX_WIDTH_BITS;
const uint SPLAT_TEX_HEIGHT = 1u << SPLAT_TEX_HEIGHT_BITS;
const uint SPLAT_TEX_DEPTH = 1u << SPLAT_TEX_DEPTH_BITS;

const uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1u;
const uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;
const uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;

const uint F16_INF = 0x7c00u;
const float PI = 3.1415926535897932384626433832795;

const float INFINITY = 1.0 / 0.0;
const float NEG_INFINITY = -INFINITY;

float sqr(float x) {
    return x * x;
}

float pow4(float x) {
    float x2 = x * x;
    return x2 * x2;
}

float pow8(float x) {
    float x4 = pow4(x);
    return x4 * x4;
}

vec3 srgbToLinear(vec3 rgb) {
    return pow(rgb, vec3(2.2));
}

vec3 linearToSrgb(vec3 rgb) {
    return pow(rgb, vec3(1.0 / 2.2));
}

uint encodeQuatOctXy88R8(vec4 q) {
    
    if (q.w < 0.0) {
        q = -q;
    }
    
    float theta = 2.0 * acos(q.w);
    float halfTheta = theta * 0.5;
    float s = sin(halfTheta);
    
    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;
    
    
    
    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);
    vec2 p = vec2(axis.x, axis.y) / sum;
    
    if (axis.z < 0.0) {
        float oldPx = p.x;
        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);
        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);
    }
    
    float u_f = p.x * 0.5 + 0.5;
    float v_f = p.y * 0.5 + 0.5;
    
    uint quantU = uint(clamp(round(u_f * 255.0), 0.0, 255.0));
    uint quantV = uint(clamp(round(v_f * 255.0), 0.0, 255.0));
    
    
    
    uint angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, 255.0));
    
    
    return (angleInt << 16u) | (quantV << 8u) | quantU;
}

vec4 decodeQuatOctXy88R8(uint encoded) {
    
    uint quantU = encoded & uint(0xFFu);               
    uint quantV = (encoded >> 8u) & uint(0xFFu);         
    uint angleInt = encoded >> 16u;                      

    
    float u_f = float(quantU) / 255.0;
    float v_f = float(quantV) / 255.0;
    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);

    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));
    float t = max(-axis.z, 0.0);
    axis.x += (axis.x >= 0.0) ? -t : t;
    axis.y += (axis.y >= 0.0) ? -t : t;
    axis = normalize(axis);
    
    
    float theta = (float(angleInt) / 255.0) * 3.14159265359;
    float halfTheta = theta * 0.5;
    float s = sin(halfTheta);
    float w = cos(halfTheta);
    
    return vec4(axis * s, w);
}

    

    

    

    

    

    

    

    

    

    

uvec4 packSplatEncoding(
    vec3 center, vec3 scales, vec4 quaternion, vec4 rgba, vec4 rgbMinMaxLnScaleMinMax
) {
    float rgbMin = rgbMinMaxLnScaleMinMax.x;
    float rgbMax = rgbMinMaxLnScaleMinMax.y;
    vec3 encRgb = (rgba.rgb - vec3(rgbMin)) / (rgbMax - rgbMin);
    uvec4 uRgba = uvec4(round(clamp(vec4(encRgb, rgba.a) * 255.0, 0.0, 255.0)));

    uint uQuat = encodeQuatOctXy88R8(quaternion);
    
    
    uvec3 uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & 0xffu);

    
    float lnScaleMin = rgbMinMaxLnScaleMinMax.z;
    float lnScaleMax = rgbMinMaxLnScaleMinMax.w;
    float lnScaleScale = 254.0 / (lnScaleMax - lnScaleMin);
    uvec3 uScales = uvec3(
        (scales.x == 0.0) ? 0u : uint(round(clamp((log(scales.x) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u,
        (scales.y == 0.0) ? 0u : uint(round(clamp((log(scales.y) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u,
        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u
    );

    
    uint word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);
    uint word1 = packHalf2x16(center.xy);
    uint word2 = packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);
    uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | (uQuat3.z << 24u);
    return uvec4(word0, word1, word2, word3);
}

uvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba) {
    return packSplatEncoding(center, scales, quaternion, rgba, vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));
}

void unpackSplatEncoding(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba, vec4 rgbMinMaxLnScaleMinMax) {
    uint word0 = packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;

    uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & 0xffu, (word0 >> 24u) & 0xffu);
    float rgbMin = rgbMinMaxLnScaleMinMax.x;
    float rgbMax = rgbMinMaxLnScaleMinMax.y;
    rgba = (vec4(uRgba) / 255.0);
    rgba.rgb = rgba.rgb * (rgbMax - rgbMin) + rgbMin;

    center = vec4(
        unpackHalf2x16(word1),
        unpackHalf2x16(word2 & 0xffffu)
    ).xyz;

    uvec3 uScales = uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);
    float lnScaleMin = rgbMinMaxLnScaleMinMax.z;
    float lnScaleMax = rgbMinMaxLnScaleMinMax.w;
    float lnScaleScale = (lnScaleMax - lnScaleMin) / 254.0;
    scales = vec3(
        (uScales.x == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.x - 1u) * lnScaleScale),
        (uScales.y == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.y - 1u) * lnScaleScale),
        (uScales.z == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.z - 1u) * lnScaleScale)
    );

    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | ((word3 >> 8u) & 0xFF0000u);
    quaternion = decodeQuatOctXy88R8(uQuat);
    
    
}

void unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) {
    unpackSplatEncoding(packed, center, scales, quaternion, rgba, vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));
}

vec3 quatVec(vec4 q, vec3 v) {
    
    vec3 t = 2.0 * cross(q.xyz, v);
    return v + q.w * t + cross(q.xyz, t);
}

vec4 quatQuat(vec4 q1, vec4 q2) {
    return vec4(
        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,
        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z
    );
}

mat3 scaleQuaternionToMatrix(vec3 s, vec4 q) {
    
    return mat3(
        s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),
        s.x * (2.0 * (q.x * q.y + q.w * q.z)),
        s.x * (2.0 * (q.x * q.z - q.w * q.y)),
        s.y * (2.0 * (q.x * q.y - q.w * q.z)),
        s.y * (1.0 - 2.0 * (q.x * q.x + q.z * q.z)),
        s.y * (2.0 * (q.y * q.z + q.w * q.x)),
        s.z * (2.0 * (q.x * q.z + q.w * q.y)),
        s.z * (2.0 * (q.y * q.z - q.w * q.x)),
        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))
    );
}

vec4 slerp(vec4 q1, vec4 q2, float t) {
    
    float cosHalfTheta = dot(q1, q2);

    
    if (abs(cosHalfTheta) >= 0.999) {
        return q1;
    }
    
    
    
    if (cosHalfTheta < 0.0) {
        q2 = -q2;
        cosHalfTheta = -cosHalfTheta;
    }

    
    float halfTheta = acos(cosHalfTheta);
    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);

    
    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;
    float ratioB = sin(t * halfTheta) / sinHalfTheta;

    
    return q1 * ratioA + q2 * ratioB;
}

ivec3 splatTexCoord(int index) {
    uint x = uint(index) & SPLAT_TEX_WIDTH_MASK;
    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK;
    uint z = uint(index) >> SPLAT_TEX_LAYER_BITS;
    return ivec3(x, y, z);
}`,lG=`precision highp float;
precision highp int;

#include <splatDefines>
#include <logdepthbuf_pars_fragment>

uniform float near;
uniform float far;
uniform bool encodeLinear;
uniform float time;
uniform bool debugFlag;
uniform float maxStdDev;
uniform float minAlpha;
uniform bool stochastic;
uniform bool disableFalloff;
uniform float falloff;

uniform bool splatTexEnable;
uniform sampler3D splatTexture;
uniform mat2 splatTexMul;
uniform vec2 splatTexAdd;
uniform float splatTexNear;
uniform float splatTexFar;
uniform float splatTexMid;

out vec4 fragColor;

in vec4 vRgba;
in vec2 vSplatUv;
in vec3 vNdc;
flat in uint vSplatIndex;

void main() {
    vec4 rgba = vRgba;

    float z = dot(vSplatUv, vSplatUv);
    if (!splatTexEnable) {
        if (z > (maxStdDev * maxStdDev)) {
            discard;
        }
    } else {
        vec2 uv = splatTexMul * vSplatUv + splatTexAdd;
        float ndcZ = vNdc.z;
        float depth = (2.0 * near * far) / (far + near - ndcZ * (far - near));
        float clampedFar = max(splatTexFar, splatTexNear);
        float clampedDepth = clamp(depth, splatTexNear, clampedFar);
        float logDepth = log2(clampedDepth + 1.0);
        float logNear = log2(splatTexNear + 1.0);
        float logFar = log2(clampedFar + 1.0);

        float texZ;
        if (splatTexMid > 0.0) {
            float clampedMid = clamp(splatTexMid, splatTexNear, clampedFar);
            float logMid = log2(clampedMid + 1.0);
            texZ = (clampedDepth <= clampedMid) ?
                (0.5 * ((logDepth - logNear) / (logMid - logNear))) :
                (0.5 * ((logDepth - logMid) / (logFar - logMid)) + 0.5);
        } else {
            texZ = (logDepth - logNear) / (logFar - logNear);
        }

        vec4 modulate = texture(splatTexture, vec3(uv, 1.0 - texZ));
        rgba *= modulate;
    }

    rgba.a *= mix(1.0, exp(-0.5 * z), falloff);

    if (rgba.a < minAlpha) {
        discard;
    }
    if (encodeLinear) {
        rgba.rgb = srgbToLinear(rgba.rgb);
    }

    if (stochastic) {
        const bool STEADY = false;
        uint uTime = STEADY ? 0u : floatBitsToUint(time);
        uvec2 coord = uvec2(gl_FragCoord.xy);
        uint state = uTime + 0x9e3779b9u * coord.x + 0x85ebca6bu * coord.y + 0xc2b2ae35u * uint(vSplatIndex);
        state = state * 747796405u + 2891336453u;
        uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
        hash = (hash >> 22u) ^ hash;
        float rand = float(hash) / 4294967296.0;
        if (rand < rgba.a) {
            fragColor = vec4(rgba.rgb, 1.0);
        } else {
            discard;
        }
    } else {
        #ifdef PREMULTIPLIED_ALPHA
            fragColor = vec4(rgba.rgb * rgba.a, rgba.a);
        #else
            fragColor = rgba;
        #endif
    }
    #include <logdepthbuf_fragment>
}`,cG=`precision highp float;
precision highp int;
precision highp usampler2DArray;

#include <splatDefines>
#include <logdepthbuf_pars_vertex>

attribute uint splatIndex;

out vec4 vRgba;
out vec2 vSplatUv;
out vec3 vNdc;
flat out uint vSplatIndex;

uniform vec2 renderSize;
uniform uint numSplats;
uniform vec4 renderToViewQuat;
uniform vec3 renderToViewPos;
uniform float maxStdDev;
uniform float minPixelRadius;
uniform float maxPixelRadius;
uniform float time;
uniform float deltaTime;
uniform bool debugFlag;
uniform float minAlpha;
uniform bool stochastic;
uniform bool enable2DGS;
uniform float blurAmount;
uniform float preBlurAmount;
uniform float focalDistance;
uniform float apertureAngle;
uniform float clipXY;
uniform float focalAdjustment;

uniform usampler2DArray packedSplats;
uniform vec4 rgbMinMaxLnScaleMinMax;

#ifdef USE_LOGDEPTHBUF
    bool isPerspectiveMatrix( mat4 m ) {
      return m[ 2 ][ 3 ] == - 1.0;
    }
#endif

void main() {
    
    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);

    if (uint(gl_InstanceID) >= numSplats) {
        return;
    }

    ivec3 texCoord;
    if (stochastic) {
        texCoord = ivec3(
            uint(gl_InstanceID) & SPLAT_TEX_WIDTH_MASK,
            (uint(gl_InstanceID) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,
            (uint(gl_InstanceID) >> SPLAT_TEX_LAYER_BITS)
        );
    } else {
        if (splatIndex == 0xffffffffu) {
            
            return;
        }
        texCoord = ivec3(
            splatIndex & SPLAT_TEX_WIDTH_MASK,
            (splatIndex >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,
            splatIndex >> SPLAT_TEX_LAYER_BITS
        );
    }
    uvec4 packed = texelFetch(packedSplats, texCoord, 0);

    vec3 center, scales;
    vec4 quaternion, rgba;
    unpackSplatEncoding(packed, center, scales, quaternion, rgba, rgbMinMaxLnScaleMinMax);

    if (rgba.a < minAlpha) {
        return;
    }
    bvec3 zeroScales = equal(scales, vec3(0.0));
    if (all(zeroScales)) {
        return;
    }

    
    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;

    
    if (viewCenter.z >= 0.0) {
        return;
    }

    
    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);

    
    if (abs(clipCenter.z) >= clipCenter.w) {
        return;
    }

    
    float clip = clipXY * clipCenter.w;
    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {
        return;
    }

    
    vSplatIndex = splatIndex;

    
    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);

    if (enable2DGS && any(zeroScales)) {
        vRgba = rgba;
        vSplatUv = position.xy * maxStdDev;

        vec3 offset;
        if (zeroScales.z) {
            offset = vec3(vSplatUv.xy * scales.xy, 0.0);
        } else if (zeroScales.y) {
            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);
        } else {
            offset = vec3(0.0, vSplatUv.xy * scales.yz);
        }

        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);
        gl_Position = projectionMatrix * vec4(viewPos, 1.0);
        vNdc = gl_Position.xyz / gl_Position.w;
        return;
    }

    
    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;

    
    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);
    mat3 cov3D = RS * transpose(RS);

    
    vec2 scaledRenderSize = renderSize * focalAdjustment;
    vec2 focal = 0.5 * scaledRenderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);

    mat3 J;
    if(isOrthographic) {
        J = mat3(
            focal.x, 0.0, 0.0,
            0.0, focal.y, 0.0,
            0.0, 0.0, 0.0
        );
    } else {
        float invZ = 1.0 / viewCenter.z;
        vec2 J1 = focal * invZ;
        vec2 J2 = -(J1 * viewCenter.xy) * invZ;
        J = mat3(
            J1.x, 0.0, J2.x,
            0.0, J1.y, J2.y,
            0.0, 0.0, 0.0
        );
    }

    
    
    
    
    
    
    
    mat3 cov2D = transpose(J) * cov3D * J;
    float a = cov2D[0][0];
    float d = cov2D[1][1];
    float b = cov2D[0][1];

    
    a += preBlurAmount;
    d += preBlurAmount;

    float fullBlurAmount = blurAmount;
    if ((focalDistance > 0.0) && (apertureAngle > 0.0)) {
        float focusRadius = maxPixelRadius;
        if (viewCenter.z < 0.0) {
            float focusBlur = abs((-viewCenter.z - focalDistance) / viewCenter.z);
            float apertureRadius = focal.x * tan(0.5 * apertureAngle);
            focusRadius = focusBlur * apertureRadius;
        }
        fullBlurAmount = clamp(sqr(focusRadius), blurAmount, sqr(maxPixelRadius));
    }

    
    float detOrig = a * d - b * b;
    a += fullBlurAmount;
    d += fullBlurAmount;
    float det = a * d - b * b;

    
    float blurAdjust = sqrt(max(0.0, detOrig / det));
    rgba.a *= blurAdjust;
    if (rgba.a < minAlpha) {
        return;
    }

    
    float eigenAvg = 0.5 * (a + d);
    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));
    float eigen1 = eigenAvg + eigenDelta;
    float eigen2 = eigenAvg - eigenDelta;

    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));
    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);

    float scale1 = min(maxPixelRadius, maxStdDev * sqrt(eigen1));
    float scale2 = min(maxPixelRadius, maxStdDev * sqrt(eigen2));
    if (scale1 < minPixelRadius && scale2 < minPixelRadius) {
        return;
    }

    
    vec2 pixelOffset = position.x * eigenVec1 * scale1 + position.y * eigenVec2 * scale2;
    vec2 ndcOffset = (2.0 / scaledRenderSize) * pixelOffset;
    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);

    vRgba = rgba;
    vSplatUv = position.xy * maxStdDev;
    vNdc = ndc;
    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);
    #include <logdepthbuf_vertex>
}`;let hb=null;function uG(){return hb||(An.splatDefines=oG,hb={splatVertex:cG,splatFragment:lG}),hb}const OB=5,ZE=class va extends oe{constructor(t){const e=va.makeUniforms(),n=uG(),i=t.premultipliedAlpha??!0,r=new $a({glslVersion:Gm,vertexShader:n.splatVertex,fragmentShader:n.splatFragment,uniforms:e,premultipliedAlpha:i,transparent:!0,depthTest:!0,depthWrite:!1,side:gr});super(FB,r),this.splatTexture=null,this.autoViewpoints=[],this.rotateToAccumulator=new qE({value:new Ge}),this.translateToAccumulator=new iE({value:new F}),this.lastFrame=-1,this.lastUpdateTime=null,this.defaultCameras=[],this.lastStochastic=null,this.pendingUpdate={scene:null,originToWorld:new he,timeoutId:-1},this.envViewpoint=null,this.frustumCulled=!1,this.renderer=t.renderer,this.material=r,this.uniforms=e;const l=au({gsplat:Ts},{gsplat:Ts},({gsplat:u})=>{if(!u)throw new Error("gsplat not defined");return u=J3(u,{rotate:this.rotateToAccumulator,translate:this.translateToAccumulator}),{gsplat:u}});this.modifier=new M8(l),this.premultipliedAlpha=i,this.autoUpdate=t.autoUpdate??!0,this.preUpdate=t.preUpdate??!1,this.needsUpdate=!1,this.originDistance=t.originDistance??1,this.maxStdDev=t.maxStdDev??Math.sqrt(8),this.minPixelRadius=t.minPixelRadius??0,this.maxPixelRadius=t.maxPixelRadius??512,this.minAlpha=t.minAlpha??.5*(1/255),this.enable2DGS=t.enable2DGS??!1,this.preBlurAmount=t.preBlurAmount??0,this.blurAmount=t.blurAmount??.3,this.focalDistance=t.focalDistance??0,this.apertureAngle=t.apertureAngle??0,this.falloff=t.falloff??1,this.clipXY=t.clipXY??1.4,this.focalAdjustment=t.focalAdjustment??1,this.splatEncoding=t.splatEncoding??{...JE},this.active=new ub,this.active.refCount=1,this.accumulatorCount=1,this.freeAccumulators=[];for(let u=0;u<1;++u)this.freeAccumulators.push(new ub),this.accumulatorCount+=1;this.defaultView=new zB({...t.view,autoUpdate:!0,spark:this}),this.viewpoint=this.defaultView,this.prepareViewpoint(this.viewpoint),this.clock=t.clock?PP(t.clock):new h0}static makeUniforms(){return{renderSize:{value:new Dt},near:{value:.1},far:{value:1e3},numSplats:{value:0},renderToViewQuat:{value:new Ge},renderToViewPos:{value:new F},maxStdDev:{value:1},minPixelRadius:{value:0},maxPixelRadius:{value:512},minAlpha:{value:.00196078431372549},stochastic:{value:!1},enable2DGS:{value:!1},preBlurAmount:{value:0},blurAmount:{value:.3},focalDistance:{value:0},apertureAngle:{value:0},falloff:{value:1},clipXY:{value:1.4},focalAdjustment:{value:1},splatTexEnable:{value:!1},splatTexture:{type:"t",value:va.EMPTY_SPLAT_TEXTURE},splatTexMul:{value:new A0},splatTexAdd:{value:new Dt},splatTexNear:{value:.1},splatTexFar:{value:1e3},splatTexMid:{value:0},packedSplats:{type:"t",value:Wf.getEmpty()},rgbMinMaxLnScaleMinMax:{value:new We},time:{value:0},deltaTime:{value:0},encodeLinear:{value:!1},debugFlag:{value:!1}}}canAllocAccumulator(){return this.freeAccumulators.length>0||this.accumulatorCount<OB}maybeAllocAccumulator(){let t=this.freeAccumulators.pop();if(t===void 0){if(this.accumulatorCount>=OB)return null;t=new ub,this.accumulatorCount+=1}return t.refCount=1,t}releaseAccumulator(t){t.refCount-=1,t.refCount===0&&this.freeAccumulators.push(t)}newViewpoint(t){return new zB({...t,spark:this})}onBeforeRender(t,e,n){var i,r;const l=this.time??this.clock.getElapsedTime(),u=l-(this.viewpoint.lastTime??l);this.viewpoint.lastTime=l;const A=t.info.render.frame,d=A!==this.lastFrame;this.lastFrame=A;const m=this.viewpoint;if(m===this.defaultView){if(d)if(!t.xr.isPresenting)this.defaultView.viewToWorld=n.matrixWorld.clone(),this.defaultCameras=[this.defaultView.viewToWorld];else{const I=t.xr.getCamera().cameras;this.defaultCameras=I.map(S=>S.matrixWorld),this.defaultView.viewToWorld=hG(this.defaultCameras)??new he}this.autoUpdate&&this.update({scene:e,viewToWorld:this.defaultView.viewToWorld})}if(d&&(this.material.premultipliedAlpha!==this.premultipliedAlpha&&(this.material.premultipliedAlpha=this.premultipliedAlpha,this.material.needsUpdate=!0),this.uniforms.time.value=l,this.uniforms.deltaTime.value=u,this.uniforms.debugFlag.value=performance.now()/1e3%2<1,m.display&&m.stochastic&&(this.geometry.instanceCount=this.uniforms.numSplats.value)),m.target)this.uniforms.renderSize.value.set(m.target.width,m.target.height);else{const I=t.getDrawingBufferSize(this.uniforms.renderSize.value);if(I.x===1&&I.y===1){const S=(i=t.xr.getSession())==null?void 0:i.renderState.baseLayer;S&&(I.x=S.framebufferWidth,I.y=S.framebufferHeight)}}const g=n;if(this.uniforms.near.value=g.near,this.uniforms.far.value=g.far,this.uniforms.encodeLinear.value=m.encodeLinear,this.uniforms.maxStdDev.value=this.maxStdDev,this.uniforms.minPixelRadius.value=this.minPixelRadius,this.uniforms.maxPixelRadius.value=this.maxPixelRadius,this.uniforms.minAlpha.value=this.minAlpha,this.uniforms.stochastic.value=m.stochastic,this.uniforms.enable2DGS.value=this.enable2DGS,this.uniforms.preBlurAmount.value=this.preBlurAmount,this.uniforms.blurAmount.value=this.blurAmount,this.uniforms.focalDistance.value=this.focalDistance,this.uniforms.apertureAngle.value=this.apertureAngle,this.uniforms.falloff.value=this.falloff,this.uniforms.clipXY.value=this.clipXY,this.uniforms.focalAdjustment.value=this.focalAdjustment,this.lastStochastic!==!m.stochastic&&(this.lastStochastic=!m.stochastic,this.material.transparent=!m.stochastic,this.material.depthWrite=m.stochastic,this.material.needsUpdate=!0),this.splatTexture){const{enable:I,texture:S,multiply:E,add:B,near:w,far:Q,mid:R}=this.splatTexture;I&&S?(this.uniforms.splatTexEnable.value=!0,this.uniforms.splatTexture.value=S,E?this.uniforms.splatTexMul.value.fromArray(E.elements):this.uniforms.splatTexMul.value.set(.5/this.maxStdDev,0,0,.5/this.maxStdDev),this.uniforms.splatTexAdd.value.set(B?.x??.5,B?.y??.5),this.uniforms.splatTexNear.value=w??this.uniforms.near.value,this.uniforms.splatTexFar.value=Q??this.uniforms.far.value,this.uniforms.splatTexMid.value=R??0):(this.uniforms.splatTexEnable.value=!1,this.uniforms.splatTexture.value=va.EMPTY_SPLAT_TEXTURE)}else this.uniforms.splatTexEnable.value=!1,this.uniforms.splatTexture.value=va.EMPTY_SPLAT_TEXTURE;const y=((r=m.display)==null?void 0:r.accumulator.toWorld)??new he,v=n.matrixWorld.clone().invert();y.clone().premultiply(v).decompose(this.uniforms.renderToViewPos.value,this.uniforms.renderToViewQuat.value,new F)}prepareViewpoint(t){var e,n,i,r;if(this.viewpoint=t??this.viewpoint,this.viewpoint.display){const{accumulator:l,geometry:u}=this.viewpoint.display;this.uniforms.numSplats.value=l.splats.numSplats,this.uniforms.packedSplats.value=l.splats.getTexture(),this.uniforms.rgbMinMaxLnScaleMinMax.value.set(((e=l.splats.splatEncoding)==null?void 0:e.rgbMin)??0,((n=l.splats.splatEncoding)==null?void 0:n.rgbMax)??1,((i=l.splats.splatEncoding)==null?void 0:i.lnScaleMin)??iu,((r=l.splats.splatEncoding)==null?void 0:r.lnScaleMax)??su),this.geometry=u,this.material.transparent=!this.viewpoint.stochastic,this.material.depthWrite=this.viewpoint.stochastic,this.material.needsUpdate=!0}else this.uniforms.numSplats.value=0,this.uniforms.packedSplats.value=Wf.getEmpty(),this.geometry=FB}update({scene:t,viewToWorld:e}){const n=this.matrixWorld;this.preUpdate?this.updateInternal({scene:t,originToWorld:n.clone(),viewToWorld:e}):(this.pendingUpdate.scene=t,this.pendingUpdate.originToWorld.copy(n),this.pendingUpdate.timeoutId===-1&&(this.pendingUpdate.timeoutId=setTimeout(()=>{const{scene:i,originToWorld:r}=this.pendingUpdate;this.pendingUpdate.scene=null,this.pendingUpdate.timeoutId=-1,this.updateInternal({scene:i,originToWorld:r,viewToWorld:e})&&this.renderer.getContext().flush()},1)))}updateInternal({scene:t,originToWorld:e,viewToWorld:n}){var i;if(!this.canAllocAccumulator())return!1;e||(e=this.active.toWorld),n=n??e.clone();const r=this.time??this.clock.getElapsedTime(),l=r-(this.lastUpdateTime??r);this.lastUpdateTime=r;const u=this.active.mapping.reduce((I,S)=>(I.set(S.node,S),I),new Map),{generators:A,visibleGenerators:d,globalEdits:m}=this.compileScene(t);for(const I of A)(i=I.frameUpdate)==null||i.call(I,{object:I,time:r,deltaTime:l,viewToWorld:n,globalEdits:m});const g=new Set(d.map(I=>I.uuid));for(const I of A){const S=u.get(I),B=I.generator&&g.has(I.uuid)?I.numSplats:0;(this.needsUpdate||I.generator!==S?.generator||B!==S?.count)&&I.updateVersion()}const y=!Xb({matrix1:e,matrix2:this.active.toWorld,maxDistance:this.originDistance}),v=this.needsUpdate||y||A.length!==u.size||A.some(I=>{var S;return I.version!==((S=u.get(I))==null?void 0:S.version)});this.needsUpdate=!1;let C=null;if(v){if(C=this.maybeAllocAccumulator(),!C)throw new Error("Unreachable");const I=!Xb({matrix1:e,matrix2:C.toWorld,maxDistance:1e-5,minCoorient:.99999}),E=d.map((U,P)=>{const z=u.get(U);return z?[U.version-z.version,z.base,U]:[Number.POSITIVE_INFINITY,U.version,U]}).sort((U,P)=>U[0]!==P[0]?U[0]-P[0]:U[1]-P[1]).map(([U,P,z])=>z),B=E.map(U=>U.numSplats),{maxSplats:w,mapping:Q}=C.splats.generateMapping(B),R=E.map((U,P)=>{const{base:z,count:L}=Q[P];return{node:U,generator:U.generator,version:U.version,base:z,count:L}});e.clone().invert().decompose(this.translateToAccumulator.value,this.rotateToAccumulator.value,new F),C.ensureGenerate(w),C.splats.splatEncoding={...this.splatEncoding},C.generateSplats({renderer:this.renderer,modifier:this.modifier,generators:R,forceUpdate:I,originToWorld:e}),C.splatsVersion=this.active.splatsVersion+1;const D=C.hasCorrespondence(this.active);C.mappingVersion=this.active.mappingVersion+(D?0:1),this.releaseAccumulator(this.active),this.active=C,this.prepareViewpoint()}return setTimeout(()=>{for(const I of this.autoViewpoints)I.autoPoll({accumulator:C??void 0})},1),!0}compileScene(t){const e=[];t.traverse(r=>{r instanceof Zb&&e.push(r)});const n=[];t.traverseVisible(r=>{r instanceof Zb&&n.push(r)});const i=new Set;return t.traverseVisible(r=>{if(r instanceof rT){let l=r.parent;for(;l!=null&&!(l instanceof lI);)l=l.parent;l==null&&i.add(r)}}),{generators:e,visibleGenerators:n,globalEdits:Array.from(i)}}async renderEnvMap({renderer:t,scene:e,worldCenter:n,size:i=256,near:r=.1,far:l=1e3,hideObjects:u=[],update:A=!1}){var d,m;if(this.envViewpoint||(this.envViewpoint=this.newViewpoint({sort360:!0})),!va.cubeRender||va.cubeRender.target.width!==i||va.cubeRender.near!==r||va.cubeRender.far!==l){va.cubeRender&&va.cubeRender.target.dispose();const I=new wS(i,{format:Ki,generateMipmaps:!0,minFilter:HM}),S=new MS(r,l,I);va.cubeRender={target:I,camera:S,near:r,far:l}}va.pmrem||(va.pmrem=new Kv(t??this.renderer));const g=new he().setPosition(n);await((d=this.envViewpoint)==null?void 0:d.prepare({scene:e,viewToWorld:g,update:A}));const{target:y,camera:v}=va.cubeRender;v.position.copy(n);const C=new Map;for(const I of u)C.set(I,I.visible),I.visible=!1;this.prepareViewpoint(this.envViewpoint),v.update(t??this.renderer,e),this.prepareViewpoint(this.defaultView);for(const[I,S]of C.entries())I.visible=S;return(m=va.pmrem)==null?void 0:m.fromCubemap(y.texture).texture}recurseSetEnvMap(t,e){t.traverse(n=>{if(n instanceof oe)if(Array.isArray(n.material))for(const i of n.material)i instanceof Xm&&(i.envMap=e);else n.material instanceof Xm&&(n.material.envMap=e)})}getRgba({generator:t,rgba:e}){const n=this.active.mapping.find(({node:i})=>i===t);if(!n)throw new Error("Generator not found");return e=e??new E8,e.fromPackedSplats({packedSplats:this.active.splats,base:n.base,count:n.count,renderer:this.renderer}),e}async readRgba({generator:t,rgba:e}){return e=this.getRgba({generator:t,rgba:e}),e.read()}};ZE.cubeRender=null;ZE.pmrem=null;ZE.EMPTY_SPLAT_TEXTURE=new a0;let $b=ZE;const FB=new Kb(new Uint32Array(1),0);au({packedSplats:YE,index:"int"},{gsplat:Ts},({packedSplats:s,index:t})=>{if(!s||!t)throw new Error("Invalid input");return{gsplat:wm(s,t)}});function hG(s){if(s.length===0)return null;const t=new F,e=new Ge,n=new F,i=[],r=[];for(const l of s)l.decompose(t,e,n),i.push(t),r.push(e);return new he().compose(kP(i),HP(r),new F(1,1,1))}Cr(`
  struct GsplatSkinning {
    int numSplats;
    int numBones;
    usampler2DArray skinTexture;
    sampler2D boneTexture;
  };
`);Cr(`
  void applyGsplatSkinning(
    int numSplats, int numBones,
    usampler2DArray skinTexture, sampler2D boneTexture,
    int splatIndex, inout vec3 center, inout vec4 quaternion
  ) {
    if ((splatIndex < 0) || (splatIndex >= numSplats)) {
      return;
    }

    uvec4 skinData = texelFetch(skinTexture, splatTexCoord(splatIndex), 0);

    float weights[4];
    weights[0] = float(skinData.x & 0xffu) / 255.0;
    weights[1] = float(skinData.y & 0xffu) / 255.0;
    weights[2] = float(skinData.z & 0xffu) / 255.0;
    weights[3] = float(skinData.w & 0xffu) / 255.0;

    uint boneIndices[4];
    boneIndices[0] = (skinData.x >> 8u) & 0xffu;
    boneIndices[1] = (skinData.y >> 8u) & 0xffu;
    boneIndices[2] = (skinData.z >> 8u) & 0xffu;
    boneIndices[3] = (skinData.w >> 8u) & 0xffu;

    vec4 quat = vec4(0.0);
    vec4 dual = vec4(0.0);
    for (int i = 0; i < 4; i++) {
      if (weights[i] > 0.0) {
        int boneIndex = int(boneIndices[i]);
        vec4 boneQuat = vec4(0.0, 0.0, 0.0, 1.0);
        vec4 boneDual = vec4(0.0);
        if (boneIndex < numBones) {
          boneQuat = texelFetch(boneTexture, ivec2(2, boneIndex), 0);
          boneDual = texelFetch(boneTexture, ivec2(3, boneIndex), 0);
        }

        if ((i > 0) && (dot(quat, boneQuat) < 0.0)) {
          // Flip sign if next blend is pointing in the opposite direction
          boneQuat = -boneQuat;
          boneDual = -boneDual;
        }
        quat += weights[i] * boneQuat;
        dual += weights[i] * boneDual;
      }
    }

    // Normalize dual quaternion
    float norm = length(quat);
    quat /= norm;
    dual /= norm;
    vec3 translate = vec3(
      2.0 * (-dual.w * quat.x + dual.x * quat.w - dual.y * quat.z + dual.z * quat.y),
      2.0 * (-dual.w * quat.y + dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),
      2.0 * (-dual.w * quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)
    );

    center = quatVec(quat, center) + translate;
    quaternion = quatQuat(quat, quaternion);
  }
`);new kn(new F(-1,-1,-1),new F(1,1,1)),new F(-1,-3,1).normalize(),new le(1,1,1),new le(.5,.5,1),new F(1,1,1);new kn(new F(-2,-1,-2),new F(2,5,2)),new F(0,-1,0),new le(1,1,1),new le(.25,.25,.5),new F(.1,1,.1);const mT=class tS{static createButton(t,e={}){const n=navigator.xr;if(!n)return null;const i=n,r=document.createElement("button");t.xr.enabled=!0,t.xr.setReferenceSpaceType("local");function l(){let g=null;async function y(I){console.log("onSessionStarted"),I.addEventListener("end",v),await t.xr.setSession(I),r.textContent="EXIT VR",g=I}function v(){console.log("onSessionEnded"),g?.removeEventListener("end",v),r.textContent="ENTER VR",g=null}r.style.display="",r.style.cursor="pointer",r.style.left="calc(50% - 100px)",r.style.width="200px",r.style.height="100px",r.textContent="ENTER VR";const C={...e,optionalFeatures:[...e.optionalFeatures||[]]};r.onmouseenter=()=>{r.style.opacity="1.0"},r.onmouseleave=()=>{r.style.opacity="0.5"},r.onclick=()=>{g===null?(console.log("requesting session"),i.requestSession("immersive-vr",C).then(y)):(console.log("ending session"),g.end())}}function u(){r.style.display="none",r.style.cursor="auto",r.style.left="calc(50% - 75px)",r.style.width="150px",r.onmouseenter=null,r.onmouseleave=null,r.onclick=null}function A(){u(),r.textContent="VR NOT SUPPORTED"}function d(g){u(),console.warn("Exception when trying to call xr.isSessionSupported",g),r.textContent="VR NOT ALLOWED"}function m(g){g.style.position="absolute",g.style.bottom="20px",g.style.padding="12px 6px",g.style.border="1px solid #fff",g.style.borderRadius="4px",g.style.background="rgba(0,0,0,0.1)",g.style.color="#fff",g.style.font="normal 13px sans-serif",g.style.textAlign="center",g.style.opacity="0.5",g.style.outline="none",g.style.zIndex="999"}return r.id="VRButton",r.style.display="none",m(r),i.isSessionSupported("immersive-vr").then(g=>{g?l():A(),g&&tS.xrSessionIsGranted&&r.click()}).catch(d),r}static registerSessionGrantedListener(){const t=navigator.xr;if(!t)return null;const e=t;/WebXRViewer\//i.test(navigator.userAgent)||e.addEventListener("sessiongranted",()=>{tS.xrSessionIsGranted=!0})}};mT.xrSessionIsGranted=!1;let fG=mT;fG.registerSessionGrantedListener();var yT=(s=>(s.w="wrist",s.t0="thumb-metacarpal",s.t1="thumb-phalanx-proximal",s.t2="thumb-phalanx-distal",s.t3="thumb-tip",s.i0="index-finger-metacarpal",s.i1="index-finger-phalanx-proximal",s.i2="index-finger-phalanx-intermediate",s.i3="index-finger-phalanx-distal",s.i4="index-finger-tip",s.m0="middle-finger-metacarpal",s.m1="middle-finger-phalanx-proximal",s.m2="middle-finger-phalanx-intermediate",s.m3="middle-finger-phalanx-distal",s.m4="middle-finger-tip",s.r0="ring-finger-metacarpal",s.r1="ring-finger-phalanx-proximal",s.r2="ring-finger-phalanx-intermediate",s.r3="ring-finger-phalanx-distal",s.r4="ring-finger-tip",s.p0="pinky-finger-metacarpal",s.p1="pinky-finger-phalanx-proximal",s.p2="pinky-finger-phalanx-intermediate",s.p3="pinky-finger-phalanx-distal",s.p4="pinky-finger-tip",s))(yT||{});const AG=Object.keys(yT);AG.length;new F(0,0,-1),new F(0,0,1),new F(-1,0,0),new F(1,0,0),new F(0,1,0),new F(0,-1,0);new F(0,0,-1),new F(0,0,1),new F(-1,0,0),new F(1,0,0),new F(0,1,0),new F(0,-1,0);new F(0,0,1),new F(0,0,-1);new F(0,-1,0),new F(0,1,0),new F(-1,0,0),new F(1,0,0);const dG=GE($b),pG=()=>{const s=et.useMemo(()=>new lI({url:"/still-life-with-a-skull-and-writing-quill/still-life.sog"}),[]);return pn.jsx(pn.Fragment,{children:pn.jsx("primitive",{object:s})})},gG=()=>{const s=ss(e=>e.gl),t=et.useMemo(()=>({renderer:s,maxStdDev:Math.sqrt(5)}),[s]);return pn.jsxs(pn.Fragment,{children:[pn.jsx("color",{attach:"background",args:[0,0,0]}),pn.jsx(D5,{distance:1}),pn.jsx("group",{position:[0,1,-1],rotation:[0,0,0],scale:[1,1,1],children:pn.jsx(I5,{url:"still-life.jpg"})}),pn.jsx(dG,{args:[t],children:pn.jsx("group",{position:[0,0,0],rotation:[Math.PI,Math.PI*.5,0],children:pn.jsx(pG,{})})})]})},mG=s=>({status:"intro",isMobile:"ontouchstart"in window||navigator.maxTouchPoints>0,start:()=>s(()=>({status:"playing"})),pause:()=>s(()=>({status:"paused"})),resume:()=>s(()=>({status:"playing"}))}),Tm=fp()((...s)=>({...mG(...s)})),yG=()=>{const s=Tm(r=>r.status),t=Tm(r=>r.start),e=Tm(r=>r.resume),n=()=>{s==="intro"?t():e()},i=s==="intro"?"Click to Start":"Resume";return pn.jsx(pn.Fragment,{children:pn.jsx("div",{className:"absolute inset-0 z-10 flex flex-col items-center justify-center gap-6 bg-black/80 text-white",children:pn.jsx("button",{id:"playButton",className:"px-8 py-4 text-xl font-bold text-white bg-blue-600 rounded-lg hover:bg-blue-700 focus:outline-none cursor-pointer",onClick:n,children:i})})})};function xT(s,t,e){return Math.max(t,Math.min(e,s))}const vT=0,xG=1,WE=2,PB=2,fb=1.25,GB=1,Qm=32,jE=65535,vG=Math.pow(2,-24),Ab=Symbol("SKIP_GENERATION");function EG(s){return s.index?s.index.count:s.attributes.position.count}function Ap(s){return EG(s)/3}function _G(s,t=ArrayBuffer){return s>65535?new Uint32Array(new t(4*s)):new Uint16Array(new t(2*s))}function CG(s,t){if(!s.index){const e=s.attributes.position.count,n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=_G(e,n);s.setIndex(new Qn(i,1));for(let r=0;r<e;r++)i[r]=r}}function ET(s,t){const e=Ap(s),n=t||s.drawRange,i=n.start/3,r=(n.start+n.count)/3,l=Math.max(0,i),u=Math.min(e,r)-l;return[{offset:Math.floor(l),count:Math.floor(u)}]}function kB(s,t){if(!s.groups||!s.groups.length)return ET(s,t);const e=[],n=t||s.drawRange,i=n.start/3,r=(n.start+n.count)/3,l=[];for(const d of s.groups){const m=d.start/3,g=(d.start+d.count)/3;m<r&&g>i&&(l.push({pos:Math.max(i,m),isStart:!0}),l.push({pos:Math.min(r,g),isStart:!1}))}l.sort((d,m)=>d.pos!==m.pos?d.pos-m.pos:d.type==="end"?-1:1);let u=0,A=null;for(const d of l){const m=d.pos;u!==0&&m!==A&&e.push({offset:A,count:m-A}),u+=d.isStart?1:-1,A=m}return e}function db(s,t,e,n,i){let r=1/0,l=1/0,u=1/0,A=-1/0,d=-1/0,m=-1/0,g=1/0,y=1/0,v=1/0,C=-1/0,I=-1/0,S=-1/0;const E=s.offset||0;for(let B=(t-E)*6,w=(t+e-E)*6;B<w;B+=6){const Q=s[B+0],R=s[B+1],D=Q-R,U=Q+R;D<r&&(r=D),U>A&&(A=U),Q<g&&(g=Q),Q>C&&(C=Q);const P=s[B+2],z=s[B+3],L=P-z,k=P+z;L<l&&(l=L),k>d&&(d=k),P<y&&(y=P),P>I&&(I=P);const Y=s[B+4],W=s[B+5],K=Y-W,nt=Y+W;K<u&&(u=K),nt>m&&(m=nt),Y<v&&(v=Y),Y>S&&(S=Y)}n[0]=r,n[1]=l,n[2]=u,n[3]=A,n[4]=d,n[5]=m,i[0]=g,i[1]=y,i[2]=v,i[3]=C,i[4]=I,i[5]=S}function HB(s,t,e=null,n=null,i=null){const r=s.attributes.position,l=s.index?s.index.array:null,u=r.normalized;if(i===null)i=new Float32Array(e*6),i.offset=t;else if(t<0||e+t>i.length/6)throw new Error("MeshBVH: compute triangle bounds range is invalid.");const A=r.array,d=r.offset||0;let m=3;r.isInterleavedBufferAttribute&&(m=r.data.stride);const g=["getX","getY","getZ"],y=i.offset;for(let v=t,C=t+e;v<C;v++){const S=(n?n[v]:v)*3,E=(v-y)*6;let B=S+0,w=S+1,Q=S+2;l&&(B=l[B],w=l[w],Q=l[Q]),u||(B=B*m+d,w=w*m+d,Q=Q*m+d);for(let R=0;R<3;R++){let D,U,P;u?(D=r[g[R]](B),U=r[g[R]](w),P=r[g[R]](Q)):(D=A[B+R],U=A[w+R],P=A[Q+R]);let z=D;U<z&&(z=U),P<z&&(z=P);let L=D;U>L&&(L=U),P>L&&(L=P);const k=(L-z)/2,Y=R*2;i[E+Y+0]=z+k,i[E+Y+1]=k+(Math.abs(z)+k)*vG}}return i}function qi(s,t,e){return e.min.x=t[s],e.min.y=t[s+1],e.min.z=t[s+2],e.max.x=t[s+3],e.max.y=t[s+4],e.max.z=t[s+5],e}function VB(s){let t=-1,e=-1/0;for(let n=0;n<3;n++){const i=s[n+3]-s[n];i>e&&(e=i,t=n)}return t}function YB(s,t){t.set(s)}function qB(s,t,e){let n,i;for(let r=0;r<3;r++){const l=r+3;n=s[r],i=t[r],e[r]=n<i?n:i,n=s[l],i=t[l],e[l]=n>i?n:i}}function zx(s,t,e){for(let n=0;n<3;n++){const i=t[s+2*n],r=t[s+2*n+1],l=i-r,u=i+r;l<e[n]&&(e[n]=l),u>e[n+3]&&(e[n+3]=u)}}function tm(s){const t=s[3]-s[0],e=s[4]-s[1],n=s[5]-s[2];return 2*(t*e+e*n+n*t)}const Jc=32,bG=(s,t)=>s.candidate-t.candidate,nh=new Array(Jc).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Ox=new Float32Array(6);function SG(s,t,e,n,i,r){let l=-1,u=0;if(r===vT)l=VB(t),l!==-1&&(u=(t[l]+t[l+3])/2);else if(r===xG)l=VB(s),l!==-1&&(u=IG(e,n,i,l));else if(r===WE){const A=tm(s);let d=fb*i;const m=e.offset||0,g=(n-m)*6,y=(n+i-m)*6;for(let v=0;v<3;v++){const C=t[v],E=(t[v+3]-C)/Jc;if(i<Jc/4){const B=[...nh];B.length=i;let w=0;for(let R=g;R<y;R+=6,w++){const D=B[w];D.candidate=e[R+2*v],D.count=0;const{bounds:U,leftCacheBounds:P,rightCacheBounds:z}=D;for(let L=0;L<3;L++)z[L]=1/0,z[L+3]=-1/0,P[L]=1/0,P[L+3]=-1/0,U[L]=1/0,U[L+3]=-1/0;zx(R,e,U)}B.sort(bG);let Q=i;for(let R=0;R<Q;R++){const D=B[R];for(;R+1<Q&&B[R+1].candidate===D.candidate;)B.splice(R+1,1),Q--}for(let R=g;R<y;R+=6){const D=e[R+2*v];for(let U=0;U<Q;U++){const P=B[U];D>=P.candidate?zx(R,e,P.rightCacheBounds):(zx(R,e,P.leftCacheBounds),P.count++)}}for(let R=0;R<Q;R++){const D=B[R],U=D.count,P=i-D.count,z=D.leftCacheBounds,L=D.rightCacheBounds;let k=0;U!==0&&(k=tm(z)/A);let Y=0;P!==0&&(Y=tm(L)/A);const W=GB+fb*(k*U+Y*P);W<d&&(l=v,d=W,u=D.candidate)}}else{for(let Q=0;Q<Jc;Q++){const R=nh[Q];R.count=0,R.candidate=C+E+Q*E;const D=R.bounds;for(let U=0;U<3;U++)D[U]=1/0,D[U+3]=-1/0}for(let Q=g;Q<y;Q+=6){let U=~~((e[Q+2*v]-C)/E);U>=Jc&&(U=Jc-1);const P=nh[U];P.count++,zx(Q,e,P.bounds)}const B=nh[Jc-1];YB(B.bounds,B.rightCacheBounds);for(let Q=Jc-2;Q>=0;Q--){const R=nh[Q],D=nh[Q+1];qB(R.bounds,D.rightCacheBounds,R.rightCacheBounds)}let w=0;for(let Q=0;Q<Jc-1;Q++){const R=nh[Q],D=R.count,U=R.bounds,z=nh[Q+1].rightCacheBounds;D!==0&&(w===0?YB(U,Ox):qB(U,Ox,Ox)),w+=D;let L=0,k=0;w!==0&&(L=tm(Ox)/A);const Y=i-w;Y!==0&&(k=tm(z)/A);const W=GB+fb*(L*w+k*Y);W<d&&(l=v,d=W,u=R.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:l,pos:u}}function IG(s,t,e,n){let i=0;const r=s.offset;for(let l=t,u=t+e;l<u;l++)i+=s[(l-r)*6+n*2];return i/e}class pb{constructor(){this.boundingData=new Float32Array(6)}}function BG(s,t,e,n,i,r){let l=n,u=n+i-1;const A=r.pos,d=r.axis*2,m=e.offset||0;for(;;){for(;l<=u&&e[(l-m)*6+d]<A;)l++;for(;l<=u&&e[(u-m)*6+d]>=A;)u--;if(l<u){for(let g=0;g<3;g++){let y=t[l*3+g];t[l*3+g]=t[u*3+g],t[u*3+g]=y}for(let g=0;g<6;g++){const y=l-m,v=u-m,C=e[y*6+g];e[y*6+g]=e[v*6+g],e[v*6+g]=C}l++,u--}else return l}}function MG(s,t,e,n,i,r){let l=n,u=n+i-1;const A=r.pos,d=r.axis*2,m=e.offset||0;for(;;){for(;l<=u&&e[(l-m)*6+d]<A;)l++;for(;l<=u&&e[(u-m)*6+d]>=A;)u--;if(l<u){let g=s[l];s[l]=s[u],s[u]=g;for(let y=0;y<6;y++){const v=l-m,C=u-m,I=e[v*6+y];e[v*6+y]=e[C*6+y],e[C*6+y]=I}l++,u--}else return l}}function mr(s,t){return t[s+15]===65535}function Vr(s,t){return t[s+6]}function Eo(s,t){return t[s+14]}function _o(s){return s+8}function Co(s,t){return t[s+6]}function _T(s,t){return t[s+7]}let CT,dm,cv,bT;const wG=Math.pow(2,32);function eS(s){return"count"in s?1:1+eS(s.left)+eS(s.right)}function TG(s,t,e){return CT=new Float32Array(e),dm=new Uint32Array(e),cv=new Uint16Array(e),bT=new Uint8Array(e),nS(s,t)}function nS(s,t){const e=s/4,n=s/2,i="count"in t,r=t.boundingData;for(let l=0;l<6;l++)CT[e+l]=r[l];if(i)if(t.buffer){const l=t.buffer;bT.set(new Uint8Array(l),s);for(let u=s,A=s+l.byteLength;u<A;u+=Qm){const d=u/2;mr(d,cv)||(dm[u/4+6]+=e)}return s+l.byteLength}else{const l=t.offset,u=t.count;return dm[e+6]=l,cv[n+14]=u,cv[n+15]=jE,s+Qm}else{const l=t.left,u=t.right,A=t.splitAxis;let d;if(d=nS(s+Qm,l),d/4>wG)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return dm[e+6]=d/4,d=nS(d,u),dm[e+7]=A,d}}function QG(s,t,e){const i=(s.index?s.index.count:s.attributes.position.count)/3>2**16,r=e.reduce((m,g)=>m+g.count,0),l=i?4:2,u=t?new SharedArrayBuffer(r*l):new ArrayBuffer(r*l),A=i?new Uint32Array(u):new Uint16Array(u);let d=0;for(let m=0;m<e.length;m++){const{offset:g,count:y}=e[m];for(let v=0;v<y;v++)A[d+v]=g+v;d+=y}return A}function DG(s,t,e,n,i){const{maxDepth:r,verbose:l,maxLeafTris:u,strategy:A,onProgress:d,indirect:m}=i,g=s._indirectBuffer,y=s.geometry,v=y.index?y.index.array:null,C=m?MG:BG,I=Ap(y),S=new Float32Array(6);let E=!1;const B=new pb;return db(t,e,n,B.boundingData,S),Q(B,e,n,S),B;function w(R){d&&d(R/I)}function Q(R,D,U,P=null,z=0){if(!E&&z>=r&&(E=!0,l&&(console.warn(`MeshBVH: Max depth of ${r} reached when generating BVH. Consider increasing maxDepth.`),console.warn(y))),U<=u||z>=r)return w(D+U),R.offset=D,R.count=U,R;const L=SG(R.boundingData,P,t,D,U,A);if(L.axis===-1)return w(D+U),R.offset=D,R.count=U,R;const k=C(g,v,t,D,U,L);if(k===D||k===D+U)w(D+U),R.offset=D,R.count=U;else{R.splitAxis=L.axis;const Y=new pb,W=D,K=k-D;R.left=Y,db(t,W,K,Y.boundingData,S),Q(Y,W,K,S,z+1);const nt=new pb,H=k,tt=U-K;R.right=nt,db(t,H,tt,nt.boundingData,S),Q(nt,H,tt,S,z+1)}return R}}function RG(s,t){const e=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,n=s.geometry;let i,r;if(t.indirect){const l=kB(n,t.range),u=QG(n,t.useSharedArrayBuffer,l);s._indirectBuffer=u,i=HB(n,0,u.length,u),r=[{offset:0,count:u.length}]}else{CG(n,t);const l=ET(n,t.range)[0];i=HB(n,l.offset,l.count),r=kB(n,t.range)}s._roots=r.map(l=>{const u=DG(s,i,l.offset,l.count,t),A=eS(u),d=new e(Qm*A);return TG(0,u,d),d})}class ru{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,i=-1/0;for(let r=0,l=t.length;r<l;r++){const A=t[r][e];n=A<n?A:n,i=A>i?A:i}this.min=n,this.max=i}setFromPoints(t,e){let n=1/0,i=-1/0;for(let r=0,l=e.length;r<l;r++){const u=e[r],A=t.dot(u);n=A<n?A:n,i=A>i?A:i}this.min=n,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}ru.prototype.setFromBox=(function(){const s=new F;return function(e,n){const i=n.min,r=n.max;let l=1/0,u=-1/0;for(let A=0;A<=1;A++)for(let d=0;d<=1;d++)for(let m=0;m<=1;m++){s.x=i.x*A+r.x*(1-A),s.y=i.y*d+r.y*(1-d),s.z=i.z*m+r.z*(1-m);const g=e.dot(s);l=Math.min(g,l),u=Math.max(g,u)}this.min=l,this.max=u}})();const NG=(function(){const s=new F,t=new F,e=new F;return function(i,r,l){const u=i.start,A=s,d=r.start,m=t;e.subVectors(u,d),s.subVectors(i.end,i.start),t.subVectors(r.end,r.start);const g=e.dot(m),y=m.dot(A),v=m.dot(m),C=e.dot(A),S=A.dot(A)*v-y*y;let E,B;S!==0?E=(g*y-C*v)/S:E=0,B=(g+E*y)/v,l.x=E,l.y=B}})(),fI=(function(){const s=new Dt,t=new F,e=new F;return function(i,r,l,u){NG(i,r,s);let A=s.x,d=s.y;if(A>=0&&A<=1&&d>=0&&d<=1){i.at(A,l),r.at(d,u);return}else if(A>=0&&A<=1){d<0?r.at(0,u):r.at(1,u),i.closestPointToPoint(u,!0,l);return}else if(d>=0&&d<=1){A<0?i.at(0,l):i.at(1,l),r.closestPointToPoint(l,!0,u);return}else{let m;A<0?m=i.start:m=i.end;let g;d<0?g=r.start:g=r.end;const y=t,v=e;if(i.closestPointToPoint(g,!0,t),r.closestPointToPoint(m,!0,e),y.distanceToSquared(g)<=v.distanceToSquared(m)){l.copy(y),u.copy(g);return}else{l.copy(m),u.copy(v);return}}}})(),UG=(function(){const s=new F,t=new F,e=new Kl,n=new vr;return function(r,l){const{radius:u,center:A}=r,{a:d,b:m,c:g}=l;if(n.start=d,n.end=m,n.closestPointToPoint(A,!0,s).distanceTo(A)<=u||(n.start=d,n.end=g,n.closestPointToPoint(A,!0,s).distanceTo(A)<=u)||(n.start=m,n.end=g,n.closestPointToPoint(A,!0,s).distanceTo(A)<=u))return!0;const I=l.getPlane(e);if(Math.abs(I.distanceToPoint(A))<=u){const E=I.projectPoint(A,t);if(l.containsPoint(E))return!0}return!1}})(),LG=["x","y","z"],Zc=1e-15,XB=Zc*Zc;function yo(s){return Math.abs(s)<Zc}class dl extends ds{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new F),this.satBounds=new Array(4).fill().map(()=>new ru),this.points=[this.a,this.b,this.c],this.plane=new Kl,this.isDegenerateIntoSegment=!1,this.isDegenerateIntoPoint=!1,this.degenerateSegment=new vr,this.needsUpdate=!0}intersectsSphere(t){return UG(t,this)}update(){const t=this.a,e=this.b,n=this.c,i=this.points,r=this.satAxes,l=this.satBounds,u=r[0],A=l[0];this.getNormal(u),A.setFromPoints(u,i);const d=r[1],m=l[1];d.subVectors(t,e),m.setFromPoints(d,i);const g=r[2],y=l[2];g.subVectors(e,n),y.setFromPoints(g,i);const v=r[3],C=l[3];v.subVectors(n,t),C.setFromPoints(v,i);const I=d.length(),S=g.length(),E=v.length();this.isDegenerateIntoPoint=!1,this.isDegenerateIntoSegment=!1,I<Zc?S<Zc||E<Zc?this.isDegenerateIntoPoint=!0:(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(t),this.degenerateSegment.end.copy(n)):S<Zc?E<Zc?this.isDegenerateIntoPoint=!0:(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(e),this.degenerateSegment.end.copy(t)):E<Zc&&(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(n),this.degenerateSegment.end.copy(e)),this.plane.setFromNormalAndCoplanarPoint(u,t),this.needsUpdate=!1}}dl.prototype.closestPointToSegment=(function(){const s=new F,t=new F,e=new vr;return function(i,r=null,l=null){const{start:u,end:A}=i,d=this.points;let m,g=1/0;for(let y=0;y<3;y++){const v=(y+1)%3;e.start.copy(d[y]),e.end.copy(d[v]),fI(e,i,s,t),m=s.distanceToSquared(t),m<g&&(g=m,r&&r.copy(s),l&&l.copy(t))}return this.closestPointToPoint(u,s),m=u.distanceToSquared(s),m<g&&(g=m,r&&r.copy(s),l&&l.copy(u)),this.closestPointToPoint(A,s),m=A.distanceToSquared(s),m<g&&(g=m,r&&r.copy(s),l&&l.copy(A)),Math.sqrt(g)}})();dl.prototype.intersectsTriangle=(function(){const s=new dl,t=new ru,e=new ru,n=new F,i=new F,r=new F,l=new F,u=new vr,A=new vr,d=new F,m=new Dt,g=new Dt;function y(w,Q,R,D){const U=n;!w.isDegenerateIntoPoint&&!w.isDegenerateIntoSegment?U.copy(w.plane.normal):U.copy(Q.plane.normal);const P=w.satBounds,z=w.satAxes;for(let Y=1;Y<4;Y++){const W=P[Y],K=z[Y];if(t.setFromPoints(K,Q.points),W.isSeparated(t)||(l.copy(U).cross(K),t.setFromPoints(l,w.points),e.setFromPoints(l,Q.points),t.isSeparated(e)))return!1}const L=Q.satBounds,k=Q.satAxes;for(let Y=1;Y<4;Y++){const W=L[Y],K=k[Y];if(t.setFromPoints(K,w.points),W.isSeparated(t)||(l.crossVectors(U,K),t.setFromPoints(l,w.points),e.setFromPoints(l,Q.points),t.isSeparated(e)))return!1}return R&&(D||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),R.start.set(0,0,0),R.end.set(0,0,0)),!0}function v(w,Q,R,D,U,P,z,L,k,Y,W){let K=z/(z-L);Y.x=D+(U-D)*K,W.start.subVectors(Q,w).multiplyScalar(K).add(w),K=z/(z-k),Y.y=D+(P-D)*K,W.end.subVectors(R,w).multiplyScalar(K).add(w)}function C(w,Q,R,D,U,P,z,L,k,Y,W){if(U>0)v(w.c,w.a,w.b,D,Q,R,k,z,L,Y,W);else if(P>0)v(w.b,w.a,w.c,R,Q,D,L,z,k,Y,W);else if(L*k>0||z!=0)v(w.a,w.b,w.c,Q,R,D,z,L,k,Y,W);else if(L!=0)v(w.b,w.a,w.c,R,Q,D,L,z,k,Y,W);else if(k!=0)v(w.c,w.a,w.b,D,Q,R,k,z,L,Y,W);else return!0;return!1}function I(w,Q,R,D){const U=Q.degenerateSegment,P=w.plane.distanceToPoint(U.start),z=w.plane.distanceToPoint(U.end);return yo(P)?yo(z)?y(w,Q,R,D):(R&&(R.start.copy(U.start),R.end.copy(U.start)),w.containsPoint(U.start)):yo(z)?(R&&(R.start.copy(U.end),R.end.copy(U.end)),w.containsPoint(U.end)):w.plane.intersectLine(U,n)!=null?(R&&(R.start.copy(n),R.end.copy(n)),w.containsPoint(n)):!1}function S(w,Q,R){const D=Q.a;return yo(w.plane.distanceToPoint(D))&&w.containsPoint(D)?(R&&(R.start.copy(D),R.end.copy(D)),!0):!1}function E(w,Q,R){const D=w.degenerateSegment,U=Q.a;return D.closestPointToPoint(U,!0,n),U.distanceToSquared(n)<XB?(R&&(R.start.copy(U),R.end.copy(U)),!0):!1}function B(w,Q,R,D){if(w.isDegenerateIntoSegment)if(Q.isDegenerateIntoSegment){const U=w.degenerateSegment,P=Q.degenerateSegment,z=i,L=r;U.delta(z),P.delta(L);const k=n.subVectors(P.start,U.start),Y=z.x*L.y-z.y*L.x;if(yo(Y))return!1;const W=(k.x*L.y-k.y*L.x)/Y,K=-(z.x*k.y-z.y*k.x)/Y;if(W<0||W>1||K<0||K>1)return!1;const nt=U.start.z+z.z*W,H=P.start.z+L.z*K;return yo(nt-H)?(R&&(R.start.copy(U.start).addScaledVector(z,W),R.end.copy(U.start).addScaledVector(z,W)),!0):!1}else return Q.isDegenerateIntoPoint?E(w,Q,R):I(Q,w,R,D);else{if(w.isDegenerateIntoPoint)return Q.isDegenerateIntoPoint?Q.a.distanceToSquared(w.a)<XB?(R&&(R.start.copy(w.a),R.end.copy(w.a)),!0):!1:Q.isDegenerateIntoSegment?E(Q,w,R):S(Q,w,R);if(Q.isDegenerateIntoPoint)return S(w,Q,R);if(Q.isDegenerateIntoSegment)return I(w,Q,R,D)}}return function(Q,R=null,D=!1){this.needsUpdate&&this.update(),Q.isExtendedTriangle?Q.needsUpdate&&Q.update():(s.copy(Q),s.update(),Q=s);const U=B(this,Q,R,D);if(U!==void 0)return U;const P=this.plane,z=Q.plane;let L=z.distanceToPoint(this.a),k=z.distanceToPoint(this.b),Y=z.distanceToPoint(this.c);yo(L)&&(L=0),yo(k)&&(k=0),yo(Y)&&(Y=0);const W=L*k,K=L*Y;if(W>0&&K>0)return!1;let nt=P.distanceToPoint(Q.a),H=P.distanceToPoint(Q.b),tt=P.distanceToPoint(Q.c);yo(nt)&&(nt=0),yo(H)&&(H=0),yo(tt)&&(tt=0);const it=nt*H,ot=nt*tt;if(it>0&&ot>0)return!1;i.copy(P.normal),r.copy(z.normal);const At=i.cross(r);let V=0,st=Math.abs(At.x);const xt=Math.abs(At.y);xt>st&&(st=xt,V=1),Math.abs(At.z)>st&&(V=2);const Rt=LG[V],dt=this.a[Rt],pt=this.b[Rt],qt=this.c[Rt],Wt=Q.a[Rt],ce=Q.b[Rt],Ie=Q.c[Rt];if(C(this,dt,pt,qt,W,K,L,k,Y,m,u))return y(this,Q,R,D);if(C(Q,Wt,ce,Ie,it,ot,nt,H,tt,g,A))return y(this,Q,R,D);if(m.y<m.x){const He=m.y;m.y=m.x,m.x=He,d.copy(u.start),u.start.copy(u.end),u.end.copy(d)}if(g.y<g.x){const He=g.y;g.y=g.x,g.x=He,d.copy(A.start),A.start.copy(A.end),A.end.copy(d)}return m.y<g.x||g.y<m.x?!1:(R&&(g.x>m.x?R.start.copy(A.start):R.start.copy(u.start),g.y<m.y?R.end.copy(A.end):R.end.copy(u.end)),!0)}})();dl.prototype.distanceToPoint=(function(){const s=new F;return function(e){return this.closestPointToPoint(e,s),e.distanceTo(s)}})();dl.prototype.distanceToTriangle=(function(){const s=new F,t=new F,e=["a","b","c"],n=new vr,i=new vr;return function(l,u=null,A=null){const d=u||A?n:null;if(this.intersectsTriangle(l,d))return(u||A)&&(u&&d.getCenter(u),A&&d.getCenter(A)),0;let m=1/0;for(let g=0;g<3;g++){let y;const v=e[g],C=l[v];this.closestPointToPoint(C,s),y=C.distanceToSquared(s),y<m&&(m=y,u&&u.copy(s),A&&A.copy(C));const I=this[v];l.closestPointToPoint(I,s),y=I.distanceToSquared(s),y<m&&(m=y,u&&u.copy(I),A&&A.copy(s))}for(let g=0;g<3;g++){const y=e[g],v=e[(g+1)%3];n.set(this[y],this[v]);for(let C=0;C<3;C++){const I=e[C],S=e[(C+1)%3];i.set(l[I],l[S]),fI(n,i,s,t);const E=s.distanceToSquared(t);E<m&&(m=E,u&&u.copy(s),A&&A.copy(t))}}return Math.sqrt(m)}})();class er{constructor(t,e,n){this.isOrientedBox=!0,this.min=new F,this.max=new F,this.matrix=new he,this.invMatrix=new he,this.points=new Array(8).fill().map(()=>new F),this.satAxes=new Array(3).fill().map(()=>new F),this.satBounds=new Array(3).fill().map(()=>new ru),this.alignedSatBounds=new Array(3).fill().map(()=>new ru),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}er.prototype.update=(function(){return function(){const t=this.matrix,e=this.min,n=this.max,i=this.points;for(let d=0;d<=1;d++)for(let m=0;m<=1;m++)for(let g=0;g<=1;g++){const y=1*d|2*m|4*g,v=i[y];v.x=d?n.x:e.x,v.y=m?n.y:e.y,v.z=g?n.z:e.z,v.applyMatrix4(t)}const r=this.satBounds,l=this.satAxes,u=i[0];for(let d=0;d<3;d++){const m=l[d],g=r[d],y=1<<d,v=i[y];m.subVectors(u,v),g.setFromPoints(m,i)}const A=this.alignedSatBounds;A[0].setFromPointsField(i,"x"),A[1].setFromPointsField(i,"y"),A[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}})();er.prototype.intersectsBox=(function(){const s=new ru;return function(e){this.needsUpdate&&this.update();const n=e.min,i=e.max,r=this.satBounds,l=this.satAxes,u=this.alignedSatBounds;if(s.min=n.x,s.max=i.x,u[0].isSeparated(s)||(s.min=n.y,s.max=i.y,u[1].isSeparated(s))||(s.min=n.z,s.max=i.z,u[2].isSeparated(s)))return!1;for(let A=0;A<3;A++){const d=l[A],m=r[A];if(s.setFromBox(d,e),m.isSeparated(s))return!1}return!0}})();er.prototype.intersectsTriangle=(function(){const s=new dl,t=new Array(3),e=new ru,n=new ru,i=new F;return function(l){this.needsUpdate&&this.update(),l.isExtendedTriangle?l.needsUpdate&&l.update():(s.copy(l),s.update(),l=s);const u=this.satBounds,A=this.satAxes;t[0]=l.a,t[1]=l.b,t[2]=l.c;for(let y=0;y<3;y++){const v=u[y],C=A[y];if(e.setFromPoints(C,t),v.isSeparated(e))return!1}const d=l.satBounds,m=l.satAxes,g=this.points;for(let y=0;y<3;y++){const v=d[y],C=m[y];if(e.setFromPoints(C,g),v.isSeparated(e))return!1}for(let y=0;y<3;y++){const v=A[y];for(let C=0;C<4;C++){const I=m[C];if(i.crossVectors(v,I),e.setFromPoints(i,t),n.setFromPoints(i,g),e.isSeparated(n))return!1}}return!0}})();er.prototype.closestPointToPoint=(function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}})();er.prototype.distanceToPoint=(function(){const s=new F;return function(e){return this.closestPointToPoint(e,s),e.distanceTo(s)}})();er.prototype.distanceToBox=(function(){const s=["x","y","z"],t=new Array(12).fill().map(()=>new vr),e=new Array(12).fill().map(()=>new vr),n=new F,i=new F;return function(l,u=0,A=null,d=null){if(this.needsUpdate&&this.update(),this.intersectsBox(l))return(A||d)&&(l.getCenter(i),this.closestPointToPoint(i,n),l.closestPointToPoint(n,i),A&&A.copy(n),d&&d.copy(i)),0;const m=u*u,g=l.min,y=l.max,v=this.points;let C=1/0;for(let S=0;S<8;S++){const E=v[S];i.copy(E).clamp(g,y);const B=E.distanceToSquared(i);if(B<C&&(C=B,A&&A.copy(E),d&&d.copy(i),B<m))return Math.sqrt(B)}let I=0;for(let S=0;S<3;S++)for(let E=0;E<=1;E++)for(let B=0;B<=1;B++){const w=(S+1)%3,Q=(S+2)%3,R=E<<w|B<<Q,D=1<<S|E<<w|B<<Q,U=v[R],P=v[D];t[I].set(U,P);const L=s[S],k=s[w],Y=s[Q],W=e[I],K=W.start,nt=W.end;K[L]=g[L],K[k]=E?g[k]:y[k],K[Y]=B?g[Y]:y[k],nt[L]=y[L],nt[k]=E?g[k]:y[k],nt[Y]=B?g[Y]:y[k],I++}for(let S=0;S<=1;S++)for(let E=0;E<=1;E++)for(let B=0;B<=1;B++){i.x=S?y.x:g.x,i.y=E?y.y:g.y,i.z=B?y.z:g.z,this.closestPointToPoint(i,n);const w=i.distanceToSquared(n);if(w<C&&(C=w,A&&A.copy(n),d&&d.copy(i),w<m))return Math.sqrt(w)}for(let S=0;S<12;S++){const E=t[S];for(let B=0;B<12;B++){const w=e[B];fI(E,w,n,i);const Q=n.distanceToSquared(i);if(Q<C&&(C=Q,A&&A.copy(n),d&&d.copy(i),Q<m))return Math.sqrt(Q)}}return Math.sqrt(C)}})();class AI{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class zG extends AI{constructor(){super(()=>new dl)}}const bo=new zG;class OG{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const Ti=new OG;let hh,Yd;const Nd=[],Fx=new AI(()=>new kn);function FG(s,t,e,n,i,r){hh=Fx.getPrimitive(),Yd=Fx.getPrimitive(),Nd.push(hh,Yd),Ti.setBuffer(s._roots[t]);const l=iS(0,s.geometry,e,n,i,r);Ti.clearBuffer(),Fx.releasePrimitive(hh),Fx.releasePrimitive(Yd),Nd.pop(),Nd.pop();const u=Nd.length;return u>0&&(Yd=Nd[u-1],hh=Nd[u-2]),l}function iS(s,t,e,n,i=null,r=0,l=0){const{float32Array:u,uint16Array:A,uint32Array:d}=Ti;let m=s*2;if(mr(m,A)){const y=Vr(s,d),v=Eo(m,A);return qi(s,u,hh),n(y,v,!1,l,r+s,hh)}else{let L=function(Y){const{uint16Array:W,uint32Array:K}=Ti;let nt=Y*2;for(;!mr(nt,W);)Y=_o(Y),nt=Y*2;return Vr(Y,K)},k=function(Y){const{uint16Array:W,uint32Array:K}=Ti;let nt=Y*2;for(;!mr(nt,W);)Y=Co(Y,K),nt=Y*2;return Vr(Y,K)+Eo(nt,W)};const y=_o(s),v=Co(s,d);let C=y,I=v,S,E,B,w;if(i&&(B=hh,w=Yd,qi(C,u,B),qi(I,u,w),S=i(B),E=i(w),E<S)){C=v,I=y;const Y=S;S=E,E=Y,B=w}B||(B=hh,qi(C,u,B));const Q=mr(C*2,A),R=e(B,Q,S,l+1,r+C);let D;if(R===PB){const Y=L(C),K=k(C)-Y;D=n(Y,K,!0,l+1,r+C,B)}else D=R&&iS(C,t,e,n,i,r,l+1);if(D)return!0;w=Yd,qi(I,u,w);const U=mr(I*2,A),P=e(w,U,E,l+1,r+I);let z;if(P===PB){const Y=L(I),K=k(I)-Y;z=n(Y,K,!0,l+1,r+I,w)}else z=P&&iS(I,t,e,n,i,r,l+1);return!!z}}const em=new F,gb=new F;function PG(s,t,e={},n=0,i=1/0){const r=n*n,l=i*i;let u=1/0,A=null;if(s.shapecast({boundsTraverseOrder:m=>(em.copy(t).clamp(m.min,m.max),em.distanceToSquared(t)),intersectsBounds:(m,g,y)=>y<u&&y<l,intersectsTriangle:(m,g)=>{m.closestPointToPoint(t,em);const y=t.distanceToSquared(em);return y<u&&(gb.copy(em),u=y,A=g),y<r}}),u===1/0)return null;const d=Math.sqrt(u);return e.point?e.point.copy(gb):e.point=gb.clone(),e.distance=d,e.faceIndex=A,e}const Px=parseInt(Kf)>=169,GG=parseInt(Kf)<=161,_f=new F,Cf=new F,bf=new F,Gx=new Dt,kx=new Dt,Hx=new Dt,JB=new F,ZB=new F,WB=new F,nm=new F;function kG(s,t,e,n,i,r,l,u){let A;if(r===_a?A=s.intersectTriangle(n,e,t,!0,i):A=s.intersectTriangle(t,e,n,r!==gr,i),A===null)return null;const d=s.origin.distanceTo(i);return d<l||d>u?null:{distance:d,point:i.clone()}}function jB(s,t,e,n,i,r,l,u,A,d,m){_f.fromBufferAttribute(t,r),Cf.fromBufferAttribute(t,l),bf.fromBufferAttribute(t,u);const g=kG(s,_f,Cf,bf,nm,A,d,m);if(g){if(n){Gx.fromBufferAttribute(n,r),kx.fromBufferAttribute(n,l),Hx.fromBufferAttribute(n,u),g.uv=new Dt;const v=ds.getInterpolation(nm,_f,Cf,bf,Gx,kx,Hx,g.uv);Px||(g.uv=v)}if(i){Gx.fromBufferAttribute(i,r),kx.fromBufferAttribute(i,l),Hx.fromBufferAttribute(i,u),g.uv1=new Dt;const v=ds.getInterpolation(nm,_f,Cf,bf,Gx,kx,Hx,g.uv1);Px||(g.uv1=v),GG&&(g.uv2=g.uv1)}if(e){JB.fromBufferAttribute(e,r),ZB.fromBufferAttribute(e,l),WB.fromBufferAttribute(e,u),g.normal=new F;const v=ds.getInterpolation(nm,_f,Cf,bf,JB,ZB,WB,g.normal);g.normal.dot(s.direction)>0&&g.normal.multiplyScalar(-1),Px||(g.normal=v)}const y={a:r,b:l,c:u,normal:new F,materialIndex:0};if(ds.getNormal(_f,Cf,bf,y.normal),g.face=y,g.faceIndex=r,Px){const v=new F;ds.getBarycoord(nm,_f,Cf,bf,v),g.barycoord=v}}return g}function KB(s){return s&&s.isMaterial?s.side:s}function KE(s,t,e,n,i,r,l){const u=n*3;let A=u+0,d=u+1,m=u+2;const{index:g,groups:y}=s;s.index&&(A=g.getX(A),d=g.getX(d),m=g.getX(m));const{position:v,normal:C,uv:I,uv1:S}=s.attributes;if(Array.isArray(t)){const E=n*3;for(let B=0,w=y.length;B<w;B++){const{start:Q,count:R,materialIndex:D}=y[B];if(E>=Q&&E<Q+R){const U=KB(t[D]),P=jB(e,v,C,I,S,A,d,m,U,r,l);if(P)if(P.faceIndex=n,P.face.materialIndex=D,i)i.push(P);else return P}}}else{const E=KB(t),B=jB(e,v,C,I,S,A,d,m,E,r,l);if(B)if(B.faceIndex=n,B.face.materialIndex=0,i)i.push(B);else return B}return null}function ps(s,t,e,n){const i=s.a,r=s.b,l=s.c;let u=t,A=t+1,d=t+2;e&&(u=e.getX(u),A=e.getX(A),d=e.getX(d)),i.x=n.getX(u),i.y=n.getY(u),i.z=n.getZ(u),r.x=n.getX(A),r.y=n.getY(A),r.z=n.getZ(A),l.x=n.getX(d),l.y=n.getY(d),l.z=n.getZ(d)}function HG(s,t,e,n,i,r,l,u){const{geometry:A,_indirectBuffer:d}=s;for(let m=n,g=n+i;m<g;m++)KE(A,t,e,m,r,l,u)}function VG(s,t,e,n,i,r,l){const{geometry:u,_indirectBuffer:A}=s;let d=1/0,m=null;for(let g=n,y=n+i;g<y;g++){let v;v=KE(u,t,e,g,null,r,l),v&&v.distance<d&&(m=v,d=v.distance)}return m}function YG(s,t,e,n,i,r,l){const{geometry:u}=e,{index:A}=u,d=u.attributes.position;for(let m=s,g=t+s;m<g;m++){let y;if(y=m,ps(l,y*3,A,d),l.needsUpdate=!0,n(l,y,i,r))return!0}return!1}function qG(s,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=s.geometry,n=e.index?e.index.array:null,i=e.attributes.position;let r,l,u,A,d=0;const m=s._roots;for(let y=0,v=m.length;y<v;y++)r=m[y],l=new Uint32Array(r),u=new Uint16Array(r),A=new Float32Array(r),g(0,d),d+=r.byteLength;function g(y,v,C=!1){const I=y*2;if(u[I+15]===jE){const E=l[y+6],B=u[I+14];let w=1/0,Q=1/0,R=1/0,D=-1/0,U=-1/0,P=-1/0;for(let z=3*E,L=3*(E+B);z<L;z++){let k=n[z];const Y=i.getX(k),W=i.getY(k),K=i.getZ(k);Y<w&&(w=Y),Y>D&&(D=Y),W<Q&&(Q=W),W>U&&(U=W),K<R&&(R=K),K>P&&(P=K)}return A[y+0]!==w||A[y+1]!==Q||A[y+2]!==R||A[y+3]!==D||A[y+4]!==U||A[y+5]!==P?(A[y+0]=w,A[y+1]=Q,A[y+2]=R,A[y+3]=D,A[y+4]=U,A[y+5]=P,!0):!1}else{const E=y+8,B=l[y+6],w=E+v,Q=B+v;let R=C,D=!1,U=!1;t?R||(D=t.has(w),U=t.has(Q),R=!D&&!U):(D=!0,U=!0);const P=R||D,z=R||U;let L=!1;P&&(L=g(E,v,R));let k=!1;z&&(k=g(B,v,R));const Y=L||k;if(Y)for(let W=0;W<3;W++){const K=E+W,nt=B+W,H=A[K],tt=A[K+3],it=A[nt],ot=A[nt+3];A[y+W]=H<it?H:it,A[y+W+3]=tt>ot?tt:ot}return Y}}}function ph(s,t,e,n,i){let r,l,u,A,d,m;const g=1/e.direction.x,y=1/e.direction.y,v=1/e.direction.z,C=e.origin.x,I=e.origin.y,S=e.origin.z;let E=t[s],B=t[s+3],w=t[s+1],Q=t[s+3+1],R=t[s+2],D=t[s+3+2];return g>=0?(r=(E-C)*g,l=(B-C)*g):(r=(B-C)*g,l=(E-C)*g),y>=0?(u=(w-I)*y,A=(Q-I)*y):(u=(Q-I)*y,A=(w-I)*y),r>A||u>l||((u>r||isNaN(r))&&(r=u),(A<l||isNaN(l))&&(l=A),v>=0?(d=(R-S)*v,m=(D-S)*v):(d=(D-S)*v,m=(R-S)*v),r>m||d>l)?!1:((d>r||r!==r)&&(r=d),(m<l||l!==l)&&(l=m),r<=i&&l>=n)}function XG(s,t,e,n,i,r,l,u){const{geometry:A,_indirectBuffer:d}=s;for(let m=n,g=n+i;m<g;m++){let y=d?d[m]:m;KE(A,t,e,y,r,l,u)}}function JG(s,t,e,n,i,r,l){const{geometry:u,_indirectBuffer:A}=s;let d=1/0,m=null;for(let g=n,y=n+i;g<y;g++){let v;v=KE(u,t,e,A?A[g]:g,null,r,l),v&&v.distance<d&&(m=v,d=v.distance)}return m}function ZG(s,t,e,n,i,r,l){const{geometry:u}=e,{index:A}=u,d=u.attributes.position;for(let m=s,g=t+s;m<g;m++){let y;if(y=e.resolveTriangleIndex(m),ps(l,y*3,A,d),l.needsUpdate=!0,n(l,y,i,r))return!0}return!1}function WG(s,t,e,n,i,r,l){Ti.setBuffer(s._roots[t]),sS(0,s,e,n,i,r,l),Ti.clearBuffer()}function sS(s,t,e,n,i,r,l){const{float32Array:u,uint16Array:A,uint32Array:d}=Ti,m=s*2;if(mr(m,A)){const y=Vr(s,d),v=Eo(m,A);HG(t,e,n,y,v,i,r,l)}else{const y=_o(s);ph(y,u,n,r,l)&&sS(y,t,e,n,i,r,l);const v=Co(s,d);ph(v,u,n,r,l)&&sS(v,t,e,n,i,r,l)}}const jG=["x","y","z"];function KG(s,t,e,n,i,r){Ti.setBuffer(s._roots[t]);const l=aS(0,s,e,n,i,r);return Ti.clearBuffer(),l}function aS(s,t,e,n,i,r){const{float32Array:l,uint16Array:u,uint32Array:A}=Ti;let d=s*2;if(mr(d,u)){const g=Vr(s,A),y=Eo(d,u);return VG(t,e,n,g,y,i,r)}else{const g=_T(s,A),y=jG[g],C=n.direction[y]>=0;let I,S;C?(I=_o(s),S=Co(s,A)):(I=Co(s,A),S=_o(s));const B=ph(I,l,n,i,r)?aS(I,t,e,n,i,r):null;if(B){const R=B.point[y];if(C?R<=l[S+g]:R>=l[S+g+3])return B}const Q=ph(S,l,n,i,r)?aS(S,t,e,n,i,r):null;return B&&Q?B.distance<=Q.distance?B:Q:B||Q||null}}const Vx=new kn,Ud=new dl,Ld=new dl,im=new he,$B=new er,Yx=new er;function $G(s,t,e,n){Ti.setBuffer(s._roots[t]);const i=rS(0,s,e,n);return Ti.clearBuffer(),i}function rS(s,t,e,n,i=null){const{float32Array:r,uint16Array:l,uint32Array:u}=Ti;let A=s*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),$B.set(e.boundingBox.min,e.boundingBox.max,n),i=$B),mr(A,l)){const m=t.geometry,g=m.index,y=m.attributes.position,v=e.index,C=e.attributes.position,I=Vr(s,u),S=Eo(A,l);if(im.copy(n).invert(),e.boundsTree)return qi(s,r,Yx),Yx.matrix.copy(im),Yx.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:B=>Yx.intersectsBox(B),intersectsTriangle:B=>{B.a.applyMatrix4(n),B.b.applyMatrix4(n),B.c.applyMatrix4(n),B.needsUpdate=!0;for(let w=I*3,Q=(S+I)*3;w<Q;w+=3)if(ps(Ld,w,g,y),Ld.needsUpdate=!0,B.intersectsTriangle(Ld))return!0;return!1}});{const E=Ap(e);for(let B=I*3,w=(S+I)*3;B<w;B+=3){ps(Ud,B,g,y),Ud.a.applyMatrix4(im),Ud.b.applyMatrix4(im),Ud.c.applyMatrix4(im),Ud.needsUpdate=!0;for(let Q=0,R=E*3;Q<R;Q+=3)if(ps(Ld,Q,v,C),Ld.needsUpdate=!0,Ud.intersectsTriangle(Ld))return!0}}}else{const m=s+8,g=u[s+6];return qi(m,r,Vx),!!(i.intersectsBox(Vx)&&rS(m,t,e,n,i)||(qi(g,r,Vx),i.intersectsBox(Vx)&&rS(g,t,e,n,i)))}}const qx=new he,mb=new er,sm=new er,tk=new F,ek=new F,nk=new F,ik=new F;function sk(s,t,e,n={},i={},r=0,l=1/0){t.boundingBox||t.computeBoundingBox(),mb.set(t.boundingBox.min,t.boundingBox.max,e),mb.needsUpdate=!0;const u=s.geometry,A=u.attributes.position,d=u.index,m=t.attributes.position,g=t.index,y=bo.getPrimitive(),v=bo.getPrimitive();let C=tk,I=ek,S=null,E=null;i&&(S=nk,E=ik);let B=1/0,w=null,Q=null;return qx.copy(e).invert(),sm.matrix.copy(qx),s.shapecast({boundsTraverseOrder:R=>mb.distanceToBox(R),intersectsBounds:(R,D,U)=>U<B&&U<l?(D&&(sm.min.copy(R.min),sm.max.copy(R.max),sm.needsUpdate=!0),!0):!1,intersectsRange:(R,D)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:P=>sm.distanceToBox(P),intersectsBounds:(P,z,L)=>L<B&&L<l,intersectsRange:(P,z)=>{for(let L=P,k=P+z;L<k;L++){ps(v,3*L,g,m),v.a.applyMatrix4(e),v.b.applyMatrix4(e),v.c.applyMatrix4(e),v.needsUpdate=!0;for(let Y=R,W=R+D;Y<W;Y++){ps(y,3*Y,d,A),y.needsUpdate=!0;const K=y.distanceToTriangle(v,C,S);if(K<B&&(I.copy(C),E&&E.copy(S),B=K,w=Y,Q=L),K<r)return!0}}}});{const U=Ap(t);for(let P=0,z=U;P<z;P++){ps(v,3*P,g,m),v.a.applyMatrix4(e),v.b.applyMatrix4(e),v.c.applyMatrix4(e),v.needsUpdate=!0;for(let L=R,k=R+D;L<k;L++){ps(y,3*L,d,A),y.needsUpdate=!0;const Y=y.distanceToTriangle(v,C,S);if(Y<B&&(I.copy(C),E&&E.copy(S),B=Y,w=L,Q=P),Y<r)return!0}}}}}),bo.releasePrimitive(y),bo.releasePrimitive(v),B===1/0?null:(n.point?n.point.copy(I):n.point=I.clone(),n.distance=B,n.faceIndex=w,i&&(i.point?i.point.copy(E):i.point=E.clone(),i.point.applyMatrix4(qx),I.applyMatrix4(qx),i.distance=I.sub(i.point).length(),i.faceIndex=Q),n)}function ak(s,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=s.geometry,n=e.index?e.index.array:null,i=e.attributes.position;let r,l,u,A,d=0;const m=s._roots;for(let y=0,v=m.length;y<v;y++)r=m[y],l=new Uint32Array(r),u=new Uint16Array(r),A=new Float32Array(r),g(0,d),d+=r.byteLength;function g(y,v,C=!1){const I=y*2;if(u[I+15]===jE){const E=l[y+6],B=u[I+14];let w=1/0,Q=1/0,R=1/0,D=-1/0,U=-1/0,P=-1/0;for(let z=E,L=E+B;z<L;z++){const k=3*s.resolveTriangleIndex(z);for(let Y=0;Y<3;Y++){let W=k+Y;W=n?n[W]:W;const K=i.getX(W),nt=i.getY(W),H=i.getZ(W);K<w&&(w=K),K>D&&(D=K),nt<Q&&(Q=nt),nt>U&&(U=nt),H<R&&(R=H),H>P&&(P=H)}}return A[y+0]!==w||A[y+1]!==Q||A[y+2]!==R||A[y+3]!==D||A[y+4]!==U||A[y+5]!==P?(A[y+0]=w,A[y+1]=Q,A[y+2]=R,A[y+3]=D,A[y+4]=U,A[y+5]=P,!0):!1}else{const E=y+8,B=l[y+6],w=E+v,Q=B+v;let R=C,D=!1,U=!1;t?R||(D=t.has(w),U=t.has(Q),R=!D&&!U):(D=!0,U=!0);const P=R||D,z=R||U;let L=!1;P&&(L=g(E,v,R));let k=!1;z&&(k=g(B,v,R));const Y=L||k;if(Y)for(let W=0;W<3;W++){const K=E+W,nt=B+W,H=A[K],tt=A[K+3],it=A[nt],ot=A[nt+3];A[y+W]=H<it?H:it,A[y+W+3]=tt>ot?tt:ot}return Y}}}function rk(s,t,e,n,i,r,l){Ti.setBuffer(s._roots[t]),oS(0,s,e,n,i,r,l),Ti.clearBuffer()}function oS(s,t,e,n,i,r,l){const{float32Array:u,uint16Array:A,uint32Array:d}=Ti,m=s*2;if(mr(m,A)){const y=Vr(s,d),v=Eo(m,A);XG(t,e,n,y,v,i,r,l)}else{const y=_o(s);ph(y,u,n,r,l)&&oS(y,t,e,n,i,r,l);const v=Co(s,d);ph(v,u,n,r,l)&&oS(v,t,e,n,i,r,l)}}const ok=["x","y","z"];function lk(s,t,e,n,i,r){Ti.setBuffer(s._roots[t]);const l=lS(0,s,e,n,i,r);return Ti.clearBuffer(),l}function lS(s,t,e,n,i,r){const{float32Array:l,uint16Array:u,uint32Array:A}=Ti;let d=s*2;if(mr(d,u)){const g=Vr(s,A),y=Eo(d,u);return JG(t,e,n,g,y,i,r)}else{const g=_T(s,A),y=ok[g],C=n.direction[y]>=0;let I,S;C?(I=_o(s),S=Co(s,A)):(I=Co(s,A),S=_o(s));const B=ph(I,l,n,i,r)?lS(I,t,e,n,i,r):null;if(B){const R=B.point[y];if(C?R<=l[S+g]:R>=l[S+g+3])return B}const Q=ph(S,l,n,i,r)?lS(S,t,e,n,i,r):null;return B&&Q?B.distance<=Q.distance?B:Q:B||Q||null}}const Xx=new kn,zd=new dl,Od=new dl,am=new he,tM=new er,Jx=new er;function ck(s,t,e,n){Ti.setBuffer(s._roots[t]);const i=cS(0,s,e,n);return Ti.clearBuffer(),i}function cS(s,t,e,n,i=null){const{float32Array:r,uint16Array:l,uint32Array:u}=Ti;let A=s*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),tM.set(e.boundingBox.min,e.boundingBox.max,n),i=tM),mr(A,l)){const m=t.geometry,g=m.index,y=m.attributes.position,v=e.index,C=e.attributes.position,I=Vr(s,u),S=Eo(A,l);if(am.copy(n).invert(),e.boundsTree)return qi(s,r,Jx),Jx.matrix.copy(am),Jx.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:B=>Jx.intersectsBox(B),intersectsTriangle:B=>{B.a.applyMatrix4(n),B.b.applyMatrix4(n),B.c.applyMatrix4(n),B.needsUpdate=!0;for(let w=I,Q=S+I;w<Q;w++)if(ps(Od,3*t.resolveTriangleIndex(w),g,y),Od.needsUpdate=!0,B.intersectsTriangle(Od))return!0;return!1}});{const E=Ap(e);for(let B=I,w=S+I;B<w;B++){const Q=t.resolveTriangleIndex(B);ps(zd,3*Q,g,y),zd.a.applyMatrix4(am),zd.b.applyMatrix4(am),zd.c.applyMatrix4(am),zd.needsUpdate=!0;for(let R=0,D=E*3;R<D;R+=3)if(ps(Od,R,v,C),Od.needsUpdate=!0,zd.intersectsTriangle(Od))return!0}}}else{const m=s+8,g=u[s+6];return qi(m,r,Xx),!!(i.intersectsBox(Xx)&&cS(m,t,e,n,i)||(qi(g,r,Xx),i.intersectsBox(Xx)&&cS(g,t,e,n,i)))}}const Zx=new he,yb=new er,rm=new er,uk=new F,hk=new F,fk=new F,Ak=new F;function dk(s,t,e,n={},i={},r=0,l=1/0){t.boundingBox||t.computeBoundingBox(),yb.set(t.boundingBox.min,t.boundingBox.max,e),yb.needsUpdate=!0;const u=s.geometry,A=u.attributes.position,d=u.index,m=t.attributes.position,g=t.index,y=bo.getPrimitive(),v=bo.getPrimitive();let C=uk,I=hk,S=null,E=null;i&&(S=fk,E=Ak);let B=1/0,w=null,Q=null;return Zx.copy(e).invert(),rm.matrix.copy(Zx),s.shapecast({boundsTraverseOrder:R=>yb.distanceToBox(R),intersectsBounds:(R,D,U)=>U<B&&U<l?(D&&(rm.min.copy(R.min),rm.max.copy(R.max),rm.needsUpdate=!0),!0):!1,intersectsRange:(R,D)=>{if(t.boundsTree){const U=t.boundsTree;return U.shapecast({boundsTraverseOrder:P=>rm.distanceToBox(P),intersectsBounds:(P,z,L)=>L<B&&L<l,intersectsRange:(P,z)=>{for(let L=P,k=P+z;L<k;L++){const Y=U.resolveTriangleIndex(L);ps(v,3*Y,g,m),v.a.applyMatrix4(e),v.b.applyMatrix4(e),v.c.applyMatrix4(e),v.needsUpdate=!0;for(let W=R,K=R+D;W<K;W++){const nt=s.resolveTriangleIndex(W);ps(y,3*nt,d,A),y.needsUpdate=!0;const H=y.distanceToTriangle(v,C,S);if(H<B&&(I.copy(C),E&&E.copy(S),B=H,w=W,Q=L),H<r)return!0}}}})}else{const U=Ap(t);for(let P=0,z=U;P<z;P++){ps(v,3*P,g,m),v.a.applyMatrix4(e),v.b.applyMatrix4(e),v.c.applyMatrix4(e),v.needsUpdate=!0;for(let L=R,k=R+D;L<k;L++){const Y=s.resolveTriangleIndex(L);ps(y,3*Y,d,A),y.needsUpdate=!0;const W=y.distanceToTriangle(v,C,S);if(W<B&&(I.copy(C),E&&E.copy(S),B=W,w=L,Q=P),W<r)return!0}}}}}),bo.releasePrimitive(y),bo.releasePrimitive(v),B===1/0?null:(n.point?n.point.copy(I):n.point=I.clone(),n.distance=B,n.faceIndex=w,i&&(i.point?i.point.copy(E):i.point=E.clone(),i.point.applyMatrix4(Zx),I.applyMatrix4(Zx),i.distance=I.sub(i.point).length(),i.faceIndex=Q),n)}function pk(){return typeof SharedArrayBuffer<"u"}const Dm=new Ti.constructor,rE=new Ti.constructor,ah=new AI(()=>new kn),Fd=new kn,Pd=new kn,xb=new kn,vb=new kn;let Eb=!1;function gk(s,t,e,n){if(Eb)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Eb=!0;const i=s._roots,r=t._roots;let l,u=0,A=0;const d=new he().copy(e).invert();for(let m=0,g=i.length;m<g;m++){Dm.setBuffer(i[m]),A=0;const y=ah.getPrimitive();qi(0,Dm.float32Array,y),y.applyMatrix4(d);for(let v=0,C=r.length;v<C&&(rE.setBuffer(r[v]),l=al(0,0,e,d,n,u,A,0,0,y),rE.clearBuffer(),A+=r[v].byteLength,!l);v++);if(ah.releasePrimitive(y),Dm.clearBuffer(),u+=i[m].byteLength,l)break}return Eb=!1,l}function al(s,t,e,n,i,r=0,l=0,u=0,A=0,d=null,m=!1){let g,y;m?(g=rE,y=Dm):(g=Dm,y=rE);const v=g.float32Array,C=g.uint32Array,I=g.uint16Array,S=y.float32Array,E=y.uint32Array,B=y.uint16Array,w=s*2,Q=t*2,R=mr(w,I),D=mr(Q,B);let U=!1;if(D&&R)m?U=i(Vr(t,E),Eo(t*2,B),Vr(s,C),Eo(s*2,I),A,l+t,u,r+s):U=i(Vr(s,C),Eo(s*2,I),Vr(t,E),Eo(t*2,B),u,r+s,A,l+t);else if(D){const P=ah.getPrimitive();qi(t,S,P),P.applyMatrix4(e);const z=_o(s),L=Co(s,C);qi(z,v,Fd),qi(L,v,Pd);const k=P.intersectsBox(Fd),Y=P.intersectsBox(Pd);U=k&&al(t,z,n,e,i,l,r,A,u+1,P,!m)||Y&&al(t,L,n,e,i,l,r,A,u+1,P,!m),ah.releasePrimitive(P)}else{const P=_o(t),z=Co(t,E);qi(P,S,xb),qi(z,S,vb);const L=d.intersectsBox(xb),k=d.intersectsBox(vb);if(L&&k)U=al(s,P,e,n,i,r,l,u,A+1,d,m)||al(s,z,e,n,i,r,l,u,A+1,d,m);else if(L)if(R)U=al(s,P,e,n,i,r,l,u,A+1,d,m);else{const Y=ah.getPrimitive();Y.copy(xb).applyMatrix4(e);const W=_o(s),K=Co(s,C);qi(W,v,Fd),qi(K,v,Pd);const nt=Y.intersectsBox(Fd),H=Y.intersectsBox(Pd);U=nt&&al(P,W,n,e,i,l,r,A,u+1,Y,!m)||H&&al(P,K,n,e,i,l,r,A,u+1,Y,!m),ah.releasePrimitive(Y)}else if(k)if(R)U=al(s,z,e,n,i,r,l,u,A+1,d,m);else{const Y=ah.getPrimitive();Y.copy(vb).applyMatrix4(e);const W=_o(s),K=Co(s,C);qi(W,v,Fd),qi(K,v,Pd);const nt=Y.intersectsBox(Fd),H=Y.intersectsBox(Pd);U=nt&&al(z,W,n,e,i,l,r,A,u+1,Y,!m)||H&&al(z,K,n,e,i,l,r,A,u+1,Y,!m),ah.releasePrimitive(Y)}}return U}const Wx=new er,eM=new kn,mk={strategy:vT,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class $E{static serialize(t,e={}){e={cloneBuffers:!0,...e};const n=t.geometry,i=t._roots,r=t._indirectBuffer,l=n.getIndex();let u;return e.cloneBuffers?u={roots:i.map(A=>A.slice()),index:l?l.array.slice():null,indirectBuffer:r?r.slice():null}:u={roots:i,index:l?l.array:null,indirectBuffer:r},u}static deserialize(t,e,n={}){n={setIndex:!0,indirect:!!t.indirectBuffer,...n};const{index:i,roots:r,indirectBuffer:l}=t,u=new $E(e,{...n,[Ab]:!0});if(u._roots=r,u._indirectBuffer=l||null,n.setIndex){const A=e.getIndex();if(A===null){const d=new Qn(t.index,1,!1);e.setIndex(d)}else A.array!==i&&(A.array.set(i),A.needsUpdate=!0)}return u}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({...mk,[Ab]:!1},e),e.useSharedArrayBuffer&&!pk())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[Ab]||(RG(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new kn))),this.resolveTriangleIndex=e.indirect?n=>this._indirectBuffer[n]:n=>n}refit(t=null){return(this.indirect?ak:qG)(this,t)}traverse(t,e=0){const n=this._roots[e],i=new Uint32Array(n),r=new Uint16Array(n);l(0);function l(u,A=0){const d=u*2,m=r[d+15]===jE;if(m){const g=i[u+6],y=r[d+14];t(A,m,new Float32Array(n,u*4,6),g,y)}else{const g=u+Qm/4,y=i[u+6],v=i[u+7];t(A,m,new Float32Array(n,u*4,6),v)||(l(g,A+1),l(y,A+1))}}}raycast(t,e=fl,n=0,i=1/0){const r=this._roots,l=[],u=this.indirect?rk:WG;for(let A=0,d=r.length;A<d;A++)u(this,A,e,t,l,n,i);return l}raycastFirst(t,e=fl,n=0,i=1/0){const r=this._roots;let l=null;const u=this.indirect?lk:KG;for(let A=0,d=r.length;A<d;A++){const m=u(this,A,e,t,n,i);m!=null&&(l==null||m.distance<l.distance)&&(l=m)}return l}intersectsGeometry(t,e){let n=!1;const i=this._roots,r=this.indirect?ck:$G;for(let l=0,u=i.length;l<u&&(n=r(this,l,t,e),!n);l++);return n}shapecast(t){const e=bo.getPrimitive(),n=this.indirect?ZG:YG;let{boundsTraverseOrder:i,intersectsBounds:r,intersectsRange:l,intersectsTriangle:u}=t;if(l&&u){const g=l;l=(y,v,C,I,S)=>g(y,v,C,I,S)?!0:n(y,v,this,u,C,I,e)}else l||(u?l=(g,y,v,C)=>n(g,y,this,u,v,C,e):l=(g,y,v)=>v);let A=!1,d=0;const m=this._roots;for(let g=0,y=m.length;g<y;g++){const v=m[g];if(A=FG(this,g,r,l,i,d),A)break;d+=v.byteLength}return bo.releasePrimitive(e),A}bvhcast(t,e,n){let{intersectsRanges:i,intersectsTriangles:r}=n;const l=bo.getPrimitive(),u=this.geometry.index,A=this.geometry.attributes.position,d=this.indirect?C=>{const I=this.resolveTriangleIndex(C);ps(l,I*3,u,A)}:C=>{ps(l,C*3,u,A)},m=bo.getPrimitive(),g=t.geometry.index,y=t.geometry.attributes.position,v=t.indirect?C=>{const I=t.resolveTriangleIndex(C);ps(m,I*3,g,y)}:C=>{ps(m,C*3,g,y)};if(r){const C=(I,S,E,B,w,Q,R,D)=>{for(let U=E,P=E+B;U<P;U++){v(U),m.a.applyMatrix4(e),m.b.applyMatrix4(e),m.c.applyMatrix4(e),m.needsUpdate=!0;for(let z=I,L=I+S;z<L;z++)if(d(z),l.needsUpdate=!0,r(l,m,z,U,w,Q,R,D))return!0}return!1};if(i){const I=i;i=function(S,E,B,w,Q,R,D,U){return I(S,E,B,w,Q,R,D,U)?!0:C(S,E,B,w,Q,R,D,U)}}else i=C}return gk(this,t,e,i)}intersectsBox(t,e){return Wx.set(t.min,t.max,e),Wx.needsUpdate=!0,this.shapecast({intersectsBounds:n=>Wx.intersectsBox(n),intersectsTriangle:n=>Wx.intersectsTriangle(n)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},i={},r=0,l=1/0){return(this.indirect?dk:sk)(this,t,e,n,i,r,l)}closestPointToPoint(t,e={},n=0,i=1/0){return PG(this,t,e,n,i)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(n=>{qi(0,new Float32Array(n),eM),t.union(eM)}),t}}const nM=new kn,iM=new he;class yk extends gn{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}getVertexPosition(...t){return oe.prototype.getVertexPosition.call(this,...t)}constructor(t,e,n=10,i=0){super(),this.material=e,this.geometry=new Fe,this.name="MeshBVHRootHelper",this.depth=n,this.displayParents=!1,this.bvh=t,this.displayEdges=!0,this._group=i}raycast(){}update(){const t=this.geometry,e=this.bvh,n=this._group;if(t.dispose(),this.visible=!1,e){const i=this.depth-1,r=this.displayParents;let l=0;e.traverse((y,v)=>{if(y>=i||v)return l++,!0;r&&l++},n);let u=0;const A=new Float32Array(24*l);e.traverse((y,v,C)=>{const I=y>=i||v;if(I||r){qi(0,C,nM);const{min:S,max:E}=nM;for(let B=-1;B<=1;B+=2){const w=B<0?S.x:E.x;for(let Q=-1;Q<=1;Q+=2){const R=Q<0?S.y:E.y;for(let D=-1;D<=1;D+=2){const U=D<0?S.z:E.z;A[u+0]=w,A[u+1]=R,A[u+2]=U,u+=3}}}return I}},n);let d,m;this.displayEdges?m=new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):m=new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),A.length>65535?d=new Uint32Array(m.length*l):d=new Uint16Array(m.length*l);const g=m.length;for(let y=0;y<l;y++){const v=y*8,C=y*g;for(let I=0;I<g;I++)d[C+I]=v+m[I]}t.setIndex(new Qn(d,1,!1)),t.setAttribute("position",new Qn(A,3,!1)),this.visible=!0}}}class y0 extends Nf{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t=null,e=null,n=10){t instanceof $E&&(n=e||10,e=t,t=null),typeof e=="number"&&(n=e,e=null),super(),this.name="MeshBVHHelper",this.depth=n,this.mesh=t,this.bvh=e,this.displayParents=!1,this.displayEdges=!0,this.objectIndex=0,this._roots=[];const i=new na({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),r=new pl({color:65416,transparent:!0,opacity:.3,depthWrite:!1});r.color=i.color,this.edgeMaterial=i,this.meshMaterial=r,this.update()}update(){const t=this.mesh;let e=this.bvh||t.geometry.boundsTree||null;if(t&&t.isBatchedMesh&&t.boundsTrees&&!e){const i=t._drawInfo[this.objectIndex];i&&(e=t.boundsTrees[i.geometryIndex]||e)}const n=e?e._roots.length:0;for(;this._roots.length>n;){const i=this._roots.pop();i.geometry.dispose(),this.remove(i)}for(let i=0;i<n;i++){const{depth:r,edgeMaterial:l,meshMaterial:u,displayParents:A,displayEdges:d}=this;if(i>=this._roots.length){const g=new yk(e,l,r,i);this.add(g),this._roots.push(g)}const m=this._roots[i];m.bvh=e,m.depth=r,m.displayParents=A,m.displayEdges=d,m.material=d?l:u,m.update()}}updateMatrixWorld(...t){const e=this.mesh,n=this.parent;e!==null&&(e.updateWorldMatrix(!0,!1),n?this.matrix.copy(n.matrixWorld).invert().multiply(e.matrixWorld):this.matrix.copy(e.matrixWorld),(e.isInstancedMesh||e.isBatchedMesh)&&(e.getMatrixAt(this.objectIndex,iM),this.matrix.multiply(iM)),this.matrix.decompose(this.position,this.quaternion,this.scale)),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh,this.bvh=t.bvh,this.opacity=t.opacity,this.color.copy(t.color)}clone(){return new y0(this.mesh,this.bvh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].geometry.dispose()}}function sM(s,t,e){return s===null?null:(s.point.applyMatrix4(t.matrixWorld),s.distance=s.point.distanceTo(e.ray.origin),s.object=t,s)}const jx=new tA,aM=new F,rM=new he,xk=oe.prototype.raycast,vk=RS.prototype.raycast,oM=new F,ta=new oe,Kx=[];function ST(s,t){this.isBatchedMesh?Ek.call(this,s,t):_k.call(this,s,t)}function Ek(s,t){if(this.boundsTrees){const e=this.boundsTrees,n=this._drawInfo||this._instanceInfo,i=this._drawRanges||this._geometryInfo,r=this.matrixWorld;ta.material=this.material,ta.geometry=this.geometry;const l=ta.geometry.boundsTree,u=ta.geometry.drawRange;ta.geometry.boundingSphere===null&&(ta.geometry.boundingSphere=new Bs);for(let A=0,d=n.length;A<d;A++){if(!this.getVisibleAt(A))continue;const m=n[A].geometryIndex;if(ta.geometry.boundsTree=e[m],this.getMatrixAt(A,ta.matrixWorld).premultiply(r),!ta.geometry.boundsTree){this.getBoundingBoxAt(m,ta.geometry.boundingBox),this.getBoundingSphereAt(m,ta.geometry.boundingSphere);const g=i[m];ta.geometry.setDrawRange(g.start,g.count)}ta.raycast(s,Kx);for(let g=0,y=Kx.length;g<y;g++){const v=Kx[g];v.object=this,v.batchId=A,t.push(v)}Kx.length=0}ta.geometry.boundsTree=l,ta.geometry.drawRange=u,ta.material=null,ta.geometry=null}else vk.call(this,s,t)}function _k(s,t){if(this.geometry.boundsTree){if(this.material===void 0)return;rM.copy(this.matrixWorld).invert(),jx.copy(s.ray).applyMatrix4(rM),oM.setFromMatrixScale(this.matrixWorld),aM.copy(jx.direction).multiply(oM);const e=aM.length(),n=s.near/e,i=s.far/e,r=this.geometry.boundsTree;if(s.firstHitOnly===!0){const l=sM(r.raycastFirst(jx,this.material,n,i),this,s);l&&t.push(l)}else{const l=r.raycast(jx,this.material,n,i);for(let u=0,A=l.length;u<A;u++){const d=sM(l[u],this,s);d&&t.push(d)}}}else xk.call(this,s,t)}function dI(s={}){return this.boundsTree=new $E(this,s),this.boundsTree}function pI(){this.boundsTree=null}const Sf=new F,If=new F,Bf=new F,lM=new We,$x=new F,_b=new F,cM=new We,uM=new We,tv=new he,hM=new he;function om(s,t){if(!s&&!t)return;const e=s.count===t.count,n=s.normalized===t.normalized,i=s.array.constructor===t.array.constructor,r=s.itemSize===t.itemSize;if(!e||!n||!i||!r)throw new Error}function pm(s,t=null){const e=s.array.constructor,n=s.normalized,i=s.itemSize,r=t===null?s.count:t;return new Qn(new e(i*r),i,n)}function IT(s,t,e=0){if(s.isInterleavedBufferAttribute){const n=s.itemSize;for(let i=0,r=s.count;i<r;i++){const l=i+e;t.setX(l,s.getX(i)),n>=2&&t.setY(l,s.getY(i)),n>=3&&t.setZ(l,s.getZ(i)),n>=4&&t.setW(l,s.getW(i))}}else{const n=t.array,i=n.constructor,r=n.BYTES_PER_ELEMENT*s.itemSize*e;new i(n.buffer,r,s.array.length).set(s.array)}}function Ck(s,t,e){const n=s.elements,i=t.elements;for(let r=0,l=i.length;r<l;r++)n[r]+=i[r]*e}function fM(s,t,e){const n=s.skeleton,i=s.geometry,r=n.bones,l=n.boneInverses;cM.fromBufferAttribute(i.attributes.skinIndex,t),uM.fromBufferAttribute(i.attributes.skinWeight,t),tv.elements.fill(0);for(let u=0;u<4;u++){const A=uM.getComponent(u);if(A!==0){const d=cM.getComponent(u);hM.multiplyMatrices(r[d].matrixWorld,l[d]),Ck(tv,hM,A)}}return tv.multiply(s.bindMatrix).premultiply(s.bindMatrixInverse),e.transformDirection(tv),e}function Cb(s,t,e,n,i){$x.set(0,0,0);for(let r=0,l=s.length;r<l;r++){const u=t[r],A=s[r];u!==0&&(_b.fromBufferAttribute(A,n),e?$x.addScaledVector(_b,u):$x.addScaledVector(_b.sub(i),u))}i.add($x)}function bk(s,t={useGroups:!1,updateIndex:!1,skipAttributes:[]},e=new Fe){const n=s[0].index!==null,{useGroups:i=!1,updateIndex:r=!1,skipAttributes:l=[]}=t,u=new Set(Object.keys(s[0].attributes)),A={};let d=0;e.clearGroups();for(let m=0;m<s.length;++m){const g=s[m];let y=0;if(n!==(g.index!==null))throw new Error("StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");for(const v in g.attributes){if(!u.has(v))throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure "'+v+'" attribute exists among all geometries, or in none of them.');A[v]===void 0&&(A[v]=[]),A[v].push(g.attributes[v]),y++}if(y!==u.size)throw new Error("StaticGeometryGenerator: Make sure all geometries have the same number of attributes.");if(i){let v;if(n)v=g.index.count;else if(g.attributes.position!==void 0)v=g.attributes.position.count;else throw new Error("StaticGeometryGenerator: The geometry must have either an index or a position attribute");e.addGroup(d,v,m),d+=v}}if(n){let m=!1;if(!e.index){let g=0;for(let y=0;y<s.length;++y)g+=s[y].index.count;e.setIndex(new Qn(new Uint32Array(g),1,!1)),m=!0}if(r||m){const g=e.index;let y=0,v=0;for(let C=0;C<s.length;++C){const I=s[C],S=I.index;if(l[C]!==!0)for(let E=0;E<S.count;++E)g.setX(y,S.getX(E)+v),y++;v+=I.attributes.position.count}}}for(const m in A){const g=A[m];if(!(m in e.attributes)){let C=0;for(const I in g)C+=g[I].count;e.setAttribute(m,pm(A[m][0],C))}const y=e.attributes[m];let v=0;for(let C=0,I=g.length;C<I;C++){const S=g[C];l[C]!==!0&&IT(S,y,v),v+=S.count}}return e}function Sk(s,t){if(s===null||t===null)return s===t;if(s.length!==t.length)return!1;for(let e=0,n=s.length;e<n;e++)if(s[e]!==t[e])return!1;return!0}function Ik(s){const{index:t,attributes:e}=s;if(t)for(let n=0,i=t.count;n<i;n+=3){const r=t.getX(n),l=t.getX(n+2);t.setX(n,l),t.setX(n+2,r)}else for(const n in e){const i=e[n],r=i.itemSize;for(let l=0,u=i.count;l<u;l+=3)for(let A=0;A<r;A++){const d=i.getComponent(l,A),m=i.getComponent(l+2,A);i.setComponent(l,A,m),i.setComponent(l+2,A,d)}}return s}class Bk{constructor(t){this.matrixWorld=new he,this.geometryHash=null,this.boneMatrices=null,this.primitiveCount=-1,this.mesh=t,this.update()}update(){const t=this.mesh,e=t.geometry,n=t.skeleton,i=(e.index?e.index.count:e.attributes.position.count)/3;if(this.matrixWorld.copy(t.matrixWorld),this.geometryHash=e.attributes.position.version,this.primitiveCount=i,n){n.boneTexture||n.computeBoneTexture(),n.update();const r=n.boneMatrices;!this.boneMatrices||this.boneMatrices.length!==r.length?this.boneMatrices=r.slice():this.boneMatrices.set(r)}else this.boneMatrices=null}didChange(){const t=this.mesh,e=t.geometry,n=(e.index?e.index.count:e.attributes.position.count)/3;return!(this.matrixWorld.equals(t.matrixWorld)&&this.geometryHash===e.attributes.position.version&&Sk(t.skeleton&&t.skeleton.boneMatrices||null,this.boneMatrices)&&this.primitiveCount===n)}}class BT{constructor(t){Array.isArray(t)||(t=[t]);const e=[];t.forEach(n=>{n.traverseVisible(i=>{i.isMesh&&e.push(i)})}),this.meshes=e,this.useGroups=!0,this.applyWorldTransforms=!0,this.attributes=["position","normal","color","tangent","uv","uv2"],this._intermediateGeometry=new Array(e.length).fill().map(()=>new Fe),this._diffMap=new WeakMap}getMaterials(){const t=[];return this.meshes.forEach(e=>{Array.isArray(e.material)?t.push(...e.material):t.push(e.material)}),t}generate(t=new Fe){let e=[];const{meshes:n,useGroups:i,_intermediateGeometry:r,_diffMap:l}=this;for(let u=0,A=n.length;u<A;u++){const d=n[u],m=r[u],g=l.get(d);!g||g.didChange(d)?(this._convertToStaticGeometry(d,m),e.push(!1),g?g.update():l.set(d,new Bk(d))):e.push(!0)}if(r.length===0){t.setIndex(null);const u=t.attributes;for(const A in u)t.deleteAttribute(A);for(const A in this.attributes)t.setAttribute(this.attributes[A],new Qn(new Float32Array(0),4,!1))}else bk(r,{useGroups:i,skipAttributes:e},t);for(const u in t.attributes)t.attributes[u].needsUpdate=!0;return t}_convertToStaticGeometry(t,e=new Fe){const n=t.geometry,i=this.applyWorldTransforms,r=this.attributes.includes("normal"),l=this.attributes.includes("tangent"),u=n.attributes,A=e.attributes;!e.index&&n.index&&(e.index=n.index.clone()),A.position||e.setAttribute("position",pm(u.position)),r&&!A.normal&&u.normal&&e.setAttribute("normal",pm(u.normal)),l&&!A.tangent&&u.tangent&&e.setAttribute("tangent",pm(u.tangent)),om(n.index,e.index),om(u.position,A.position),r&&om(u.normal,A.normal),l&&om(u.tangent,A.tangent);const d=u.position,m=r?u.normal:null,g=l?u.tangent:null,y=n.morphAttributes.position,v=n.morphAttributes.normal,C=n.morphAttributes.tangent,I=n.morphTargetsRelative,S=t.morphTargetInfluences,E=new Ze;E.getNormalMatrix(t.matrixWorld),n.index&&e.index.array.set(n.index.array);for(let B=0,w=u.position.count;B<w;B++)Sf.fromBufferAttribute(d,B),m&&If.fromBufferAttribute(m,B),g&&(lM.fromBufferAttribute(g,B),Bf.fromBufferAttribute(g,B)),S&&(y&&Cb(y,S,I,B,Sf),v&&Cb(v,S,I,B,If),C&&Cb(C,S,I,B,Bf)),t.isSkinnedMesh&&(t.applyBoneTransform(B,Sf),m&&fM(t,B,If),g&&fM(t,B,Bf)),i&&Sf.applyMatrix4(t.matrixWorld),A.position.setXYZ(B,Sf.x,Sf.y,Sf.z),m&&(i&&If.applyNormalMatrix(E),A.normal.setXYZ(B,If.x,If.y,If.z)),g&&(i&&Bf.transformDirection(t.matrixWorld),A.tangent.setXYZW(B,Bf.x,Bf.y,Bf.z,lM.w));for(const B in this.attributes){const w=this.attributes[B];w==="position"||w==="tangent"||w==="normal"||!(w in u)||(A[w]||e.setAttribute(w,pm(u[w])),om(u[w],A[w]),IT(u[w],A[w]))}return t.matrixWorld.determinant()<0&&Ik(e),e}}const Mk=et.forwardRef(({children:s,debug:t=!1,colliderCapsuleArgs:e=[.3,.6,4,8],paused:n=!1,delay:i=1.5,gravity:r=9.81,fallGravityFactor:l=4,maxFallSpeed:u=50,mass:A=1,sleepTimeout:d=10,slowMotionFactor:m=1,turnSpeed:g=15,maxWalkSpeed:y=3,maxRunSpeed:v=5,acceleration:C=30,deceleration:I=20,counterAccFactor:S=.5,airDragFactor:E=.3,jumpVel:B=5,floatCheckType:w="BOTH",maxSlope:Q=1,floatHeight:R=.2,floatPullBackHeight:D=.25,floatSensorRadius:U=.12,floatSpringK:P=600,floatDampingC:z=28,collisionCheckIteration:L=3,collisionPushBackVelocity:k=3,collisionPushBackDamping:Y=.1,collisionPushBackThreshold:W=.05,...K},nt)=>{const{camera:H}=ss(),tt=et.useMemo(()=>e[0],[]),it=et.useMemo(()=>e[1],[]),ot=et.useRef(null),At=et.useRef(null),V=et.useRef(null);et.useRef(null);const st=et.useRef(null),xt=et.useRef(null);et.useRef(null);const j=et.useRef(null),Rt=et.useRef(null),dt=et.useRef(null),pt=et.useRef(null),qt=et.useRef(null),Wt=et.useRef(null);function ce(){try{return!!gB()}catch{return!1}}const Ie=ce(),[He,be]=Ie?gB():[null],zt={forward:!1,backward:!1,leftward:!1,rightward:!1,jump:!1,run:!1};et.useEffect(()=>MT.subscribe(({joystickX:$e,joystickY:bn})=>Jt.current.set($e,bn)),[]);const Z=et.useRef(new F(0,1,0)),Ot=et.useRef(new F),Vt=et.useRef(new F(0,-1,0)),Pt=et.useRef(new F);et.useRef(new F),et.useRef(new F);const kt=et.useRef(new F),Zt=et.useRef(!1),$t=et.useRef(0),fe=et.useRef(!1),$=et.useRef(new F),G=et.useRef(new F),ft=et.useRef(new F),Tt=et.useRef(new F),Ht=et.useRef(new F),Bt=et.useRef(new F);et.useRef(new F);const Se=et.useRef(new F),ae=et.useRef(!1),we=et.useRef(!1),Ee=et.useRef(!1),Gt=et.useRef(!1),Jt=et.useRef(new Dt),Be=et.useRef(!1),ve=et.useRef(!1),te=et.useRef(!1),Ue=et.useRef(!1),lt=et.useRef("IDLE"),re=et.useRef(new Ge),ee=et.useRef(new he),ie=et.useMemo(()=>new F(0,0,0),[]),Xt=et.useRef(0),Lt=et.useRef(new F),Ae=et.useRef(new F),Oe=et.useRef(new F),In=et.useRef(0),ln=et.useRef(0),Ei=et.useRef(new F),$i=et.useRef(new F),Mo=et.useRef(new F),br=et.useRef(new F),qr=et.useRef(new kn),ei=et.useRef(new vr),Sa=et.useRef(new kn),gs=et.useRef(new vr),Qs=et.useRef(new he),Fi=et.useRef(new F),an=et.useRef(new F),_i=et.useRef(new F),Ys=et.useRef(new F),Xr=et.useRef(new he),ou=et.useRef(new F),xh=et.useRef(new Ge),Sr=et.useRef(new F),ia=et.useRef(new F),Ir=et.useRef(new F),pi=et.useRef(0),q=et.useRef(1/0),ut=et.useRef(new F),Ct=et.useRef(new F),vt=et.useRef(new F),ht=et.useRef(1/0),Kt=et.useRef(new F),se=et.useRef(new F),me=et.useRef(new F),ye=et.useRef(new F),Te=et.useRef(new F),_e=et.useRef(null),Qe=et.useRef(.8),je=et.useRef(new kn),En=et.useRef(new F),Ke=et.useRef(new vr),cn=et.useRef(new kn),Un=et.useRef(new F),De=et.useRef(new vr),Ln=et.useRef(new he),mn=et.useRef(new Ze),ri=et.useRef(new Ze),Ia=et.useRef(new f0);Ia.current.far=tt+R+D;const Vn=et.useRef(new F),Ba=et.useRef(new F),Xn=et.useRef(new Ge),oi=et.useRef(new F),Ci=et.useRef(!1),Qi=et.useRef(new he),bi=et.useRef(new F),Ma=et.useRef(new Ge),ms=et.useRef(new F),Jr=et.useRef(new F),ml=et.useRef(new F),Zr=jf.getState().colliderMeshesArray,vh=et.useMemo(()=>Zr.filter(ue=>ue.geometry.boundsTree&&!(ue instanceof Hf)),[Zr]),iA=et.useCallback(ue=>{Vt.current.copy(Z.current).negate();const $e=Pt.current.dot(Vt.current);Zt.current=$e>0,$e<u&&Pt.current.addScaledVector(Vt.current,r*(Zt.current?l:1)*ue)},[r,l,u]),uc=et.useCallback((ue,$e)=>{const bn=Pt.current.lengthSq()>1e-6,fn=oi.current.lengthSq()>1e-6;!bn&&te.current&&!ue&&!Ci.current&&!fn?($t.current+=$e,$t.current>d&&(fe.current=!0)):($t.current=0,fe.current=!1)},[]),nr=et.useCallback(ue=>{ft.current.set(0,0,0),H.getWorldDirection($.current),$.current.projectOnPlane(Z.current).normalize(),G.current.crossVectors($.current,Z.current).normalize(),ue.joystick&&ue.joystick.lengthSq()>0?ft.current.addScaledVector($.current,ue.joystick.y).addScaledVector(G.current,ue.joystick.x):(ue.forward&&ft.current.add($.current),ue.backward&&ft.current.sub($.current),ue.leftward&&ft.current.sub(G.current),ue.rightward&&ft.current.add(G.current)),ft.current.normalize()},[]),hc=et.useCallback((ue,$e)=>{const bn=xT(Qe.current,0,1);if(ft.current.lengthSq()>0){V.current&&(Tt.current.copy(ft.current).projectOnPlane(Z.current),ee.current.lookAt(Tt.current,ie,Z.current),re.current.setFromRotationMatrix(ee.current),V.current.quaternion.slerp(re.current,$e*g));const fn=ue?v:y;Se.current.copy(ft.current).multiplyScalar(fn);const rn=Ht.current.dot(ft.current);Bt.current.subVectors(Se.current,kt.current),Bt.current.clampLength(0,(rn<=0?1+S:1)*C*bn*$e*(te.current?1:E)),Pt.current.add(Bt.current)}else te.current&&(Bt.current.copy(kt.current).clampLength(0,I*bn*$e),Pt.current.sub(Bt.current))},[C,I,E,S,v,y,g]),lu=et.useCallback(()=>{ot.current&&(ei.current.start.set(0,it/2,0).add(ot.current.position),ei.current.end.set(0,-it/2,0).add(ot.current.position),qr.current.makeEmpty().expandByPoint(ei.current.start).expandByPoint(ei.current.end).expandByScalar(tt),Ke.current.start.copy(ei.current.end),Ke.current.end.copy(Ke.current.start).addScaledVector(Vt.current,R+tt),En.current.copy(Ke.current.end).addScaledVector(Vt.current,D),je.current.makeEmpty().expandByPoint(Ke.current.start).expandByPoint(En.current).expandByScalar(U))},[tt,it,R,D,U]),Br=et.useCallback((ue,$e,bn)=>{if(!(!ue.visible||!ue.geometry.boundsTree||ue.userData.excludeCollisionCheck)&&($e.decompose(ou.current,xh.current,Sr.current),Qs.current.copy($e).invert(),gs.current.copy(ei.current).applyMatrix4(Qs.current),ia.current.set(tt/Sr.current.x,tt/Sr.current.y,tt/Sr.current.z),Sa.current.makeEmpty().expandByPoint(gs.current.start).expandByPoint(gs.current.end),Sa.current.min.addScaledVector(ia.current,-1),Sa.current.max.add(ia.current),Xt.current=0,Lt.current.set(0,0,0),Mo.current.set(0,0,0),br.current.set(0,0,0),Ys.current.set(0,0,0),In.current=0,ln.current=0,Ei.current.set(0,0,0),$i.current.set(0,0,0),ue.geometry.boundsTree.shapecast({intersectsBounds:fn=>fn.intersectsBox(Sa.current),intersectsTriangle:fn=>{fn.closestPointToSegment(gs.current,Ae.current,Oe.current),Ir.current.copy(Ae.current).sub(Oe.current),Ir.current.divide(ia.current),Ir.current.lengthSq()<1&&(Ae.current.applyMatrix4($e),Oe.current.applyMatrix4($e),Lt.current.copy(Oe.current).sub(Ae.current).normalize(),Xt.current=tt-Oe.current.distanceTo(Ae.current),Ei.current.addScaledVector(Lt.current,Xt.current),$i.current.add(Ae.current),In.current+=Xt.current,ln.current+=1)}}),ln.current>0)){Ei.current.normalize(),$i.current.divideScalar(ln.current);const fn=In.current/ln.current,rn=ue.userData.type==="STATIC",_n=ue.userData.type==="KINEMATIC",Hn=ue.userData.active===!0;rn||_n&&!Hn?Fi.current.copy(Pt.current):_n&&Hn&&(an.current.copy($i.current).sub(ue.userData.center),_i.current.crossVectors(ue.userData.angularVelocity,an.current),Ys.current.copy(ue.userData.linearVelocity).add(_i.current),Fi.current.copy(Pt.current).sub(Ys.current));const li=Fi.current.dot(Ei.current);if(li<0&&(Mo.current.copy(Ei.current).multiplyScalar(-li*(1+ue.userData.restitution)),Pt.current.add(Mo.current)),fn>W){const Ds=Y/bn*fn;br.current.copy(Ei.current).multiplyScalar(Ds),Pt.current.add(br.current)}}},[tt,W,Y,k,t]),Wr=et.useCallback((ue,$e)=>{if(ue.length!==0)for(let bn=0;bn<L;bn++)for(const fn of ue)if(fn instanceof Hf)for(let rn=0;rn<fn.count;rn++)fn.getMatrixAt(rn,Xr.current),Br(fn,Xr.current,$e);else Br(fn,fn.matrixWorld,$e)},[L,Br]),fc=et.useCallback((ue,$e)=>{var bn;$e.decompose(bi.current,Ma.current,ms.current),Ln.current.copy($e).invert(),mn.current.getNormalMatrix(Ln.current),ri.current.getNormalMatrix($e),De.current.copy(Ke.current).applyMatrix4(Ln.current),Un.current.copy(En.current).applyMatrix4(Ln.current),Jr.current.set(U/ms.current.x,U/ms.current.y,U/ms.current.z),cn.current.makeEmpty().expandByPoint(De.current.start).expandByPoint(Un.current),cn.current.min.addScaledVector(Jr.current,-1),cn.current.max.add(Jr.current),q.current=1/0,ut.current.set(1/0,1/0,1/0),(bn=ue.geometry.boundsTree)==null||bn.shapecast({intersectsBounds:fn=>fn.intersectsBox(cn.current),intersectsTriangle:fn=>{fn.closestPointToSegment(De.current,se.current,me.current),Ot.current.copy(Z.current).applyMatrix3(mn.current).normalize(),ml.current.subVectors(se.current,De.current.start),ml.current.divide(Jr.current);const rn=ml.current.lengthSq(),_n=ml.current.dot(Ot.current),Hn=Math.abs(_n)/((tt+R+D)/U);if(Math.sqrt(Math.max(0,rn-_n*_n))<1&&Hn<1){fn.getNormal(vt.current),vt.current.applyMatrix3(ri.current).normalize(),se.current.applyMatrix4($e);const Ds=vt.current.angleTo(Z.current);Hn<q.current&&Ds<Q&&(q.current=Hn,ut.current.copy(se.current),Ct.current.copy(vt.current))}}}),q.current<ht.current&&(ht.current=q.current,Kt.current.copy(ut.current),Te.current.copy(Ct.current),pi.current=Te.current.angleTo(Z.current),Qe.current=ue.userData.friction,_e.current=ue)},[U,tt,R,D,Q]),cu=et.useCallback((ue,$e,bn)=>{if(ue.length===0)return;ht.current=1/0,Kt.current.set(1/0,1/0,1/0);const fn=()=>{Ia.current.set(Ke.current.start,Vt.current);const _n=Ia.current.intersectObjects(vh,!1);if(_n.length>0){const Hn=_n.find(li=>(ri.current.getNormalMatrix(li.object.matrixWorld),Te.current.copy(li.normal).applyMatrix3(ri.current).normalize(),Te.current.angleTo(Z.current)<Q&&li.object.visible&&!li.object.userData.excludeFloatHit));return Hn&&(ht.current=Hn.distance,Kt.current.copy(Hn.point),ri.current.getNormalMatrix(Hn.object.matrixWorld),Te.current.copy(Hn.normal).applyMatrix3(ri.current).normalize(),pi.current=Te.current.angleTo(Z.current),Qe.current=Hn.object.userData.friction,_e.current=Hn.object),!!Hn}return!1},rn=()=>{for(const _n of ue)if(!(!_n.visible||!_n.geometry.boundsTree||_n.userData.excludeFloatHit))if(_n instanceof Hf)for(let Hn=0;Hn<_n.count;Hn++)_n.getMatrixAt(Hn,Qi.current),fc(_n,Qi.current);else fc(_n,_n.matrixWorld)};switch(w){case"RAYCAST":fn();break;case"SHAPECAST":rn();break;case"BOTH":fn()||rn();break}if(ht.current<1/0)if(ht.current<R+tt&&(te.current=!0,Zt.current=!1,$e=!1),$e)te.current=!1;else{ye.current.subVectors(Ke.current.start,Kt.current);const _n=R+tt-ye.current.dot(Z.current),Hn=P*_n,li=z*Pt.current.dot(Z.current),Ds=Hn-li;te.current&&Pt.current.addScaledVector(Z.current,Ds*bn/A)}else te.current=!1,pi.current=0},[fc,tt,R,P,z,A,vh]),Eh=et.useCallback(()=>{if(!ot.current||!V.current)return;if(te.current&&_e.current&&(_e.current.userData.type==="STATIC"||_e.current.userData.type==="KINEMATIC"&&_e.current.userData.active===!1)&&oi.current.lengthSq()>0){oi.current.set(0,0,0);return}if(!te.current&&oi.current.lengthSq()>0&&ot.current.position.add(oi.current),!te.current||!_e.current||_e.current.userData.type!=="KINEMATIC"||_e.current.userData.type==="KINEMATIC"&&_e.current.userData.active===!1){Ci.current=!1;return}const ue=_e.current.userData.center,$e=_e.current.userData.deltaPos,bn=_e.current.userData.deltaQuat,fn=_e.current.userData.rotationAxis,rn=_e.current.userData.rotationAngle;if(Ci.current=!0,Vn.current.copy(Kt.current).sub(ue),Ba.current.copy(Vn.current).applyQuaternion(bn).sub(Vn.current),oi.current.copy(Ba.current).add($e),ot.current.position.add(oi.current),rn>1e-6){const _n=fn.dot(Z.current);Math.abs(_n)>.9&&(Xn.current.setFromAxisAngle(Z.current,rn*_n),V.current.quaternion.premultiply(Xn.current))}},[]),wo=et.useCallback((ue,$e)=>te.current?Ue.current?ft.current.lengthSq()===0?"IDLE":ue?"RUN":"WALK":"JUMP_LAND":Ue.current&&$e?"JUMP_START":Zt.current?"JUMP_FALL":"JUMP_IDLE",[]),ir=et.useCallback((ue,$e)=>{var bn,fn;(bn=V.current)==null||bn.getWorldPosition(il.position),(fn=V.current)==null||fn.getWorldQuaternion(il.quaternion),il.linvel.copy(Pt.current),il.inputDir.copy(ft.current),il.movingDir.copy(Ht.current),il.isOnGround=te.current,il.isOnMovingPlatform=Ci.current,il.animationStatus=wo(ue,$e),lt.current!==il.animationStatus&&(Pk.getState().setAnimationStatus(il.animationStatus),lt.current=il.animationStatus)},[]),Ac=et.useCallback(()=>Pt.current.set(0,0,0),[]),yl=et.useCallback(ue=>Pt.current.add(ue),[]),Mr=et.useCallback(ue=>Pt.current.copy(ue),[]),dc=et.useCallback(ue=>{ue.forward!==void 0&&(ae.current=ue.forward),ue.backward!==void 0&&(we.current=ue.backward),ue.leftward!==void 0&&(Ee.current=ue.leftward),ue.rightward!==void 0&&(Gt.current=ue.rightward),ue.joystick&&Jt.current.set(ue.joystick.x,ue.joystick.y),ue.run!==void 0&&(Be.current=ue.run),ue.jump!==void 0&&(ve.current=ue.jump)},[]);et.useImperativeHandle(nt,()=>({get group(){return ot.current},get model(){return V.current},resetLinVel:Ac,addLinVel:yl,setLinVel:Mr,setMovement:dc}),[Ac,yl,Mr,dc]);const jr=et.useCallback(()=>{var ue,$e,bn,fn,rn,_n,Hn,li,Ds,Kr,wa,To,xl,_h;(ue=st.current)==null||ue.position.copy(ei.current.start),($e=xt.current)==null||$e.position.copy(ei.current.end),(bn=j.current)==null||bn.position.copy(Ke.current.start),(fn=Rt.current)==null||fn.position.copy(Ke.current.end),(rn=dt.current)==null||rn.position.copy(Kt.current),ot.current&&((_n=pt.current)==null||_n.position.copy(ot.current.position).addScaledVector(Z.current,.7)),(li=pt.current)==null||li.lookAt((Hn=pt.current)==null?void 0:Hn.position.clone().add($.current)),(Ds=qt.current)==null||Ds.position.copy(ei.current.end),(Kr=qt.current)==null||Kr.setDirection(ft.current),(wa=qt.current)==null||wa.setLength(ft.current.lengthSq()),(To=Wt.current)==null||To.position.copy(ei.current.end),(xl=Wt.current)==null||xl.setDirection(Pt.current),(_h=Wt.current)==null||_h.setLength(Pt.current.length()/y)},[]);return FE((ue,$e)=>{if(n||ue.clock.elapsedTime<i)return;const bn=Math.min(1/45,$e)*m,{buttons:fn}=wT.getState(),rn=Ie&&be?be():zt,_n=ae.current||rn.forward,Hn=we.current||rn.backward,li=Ee.current||rn.leftward,Ds=Gt.current||rn.rightward,Kr=Be.current||rn.run||fn.run,wa=ve.current||rn.jump||fn.jump;nr({forward:_n,backward:Hn,leftward:li,rightward:Ds,joystick:Jt.current}),hc(Kr,bn),wa&&te.current&&(Pt.current.y=B),Ht.current.copy(Pt.current).normalize(),kt.current.copy(Pt.current).projectOnPlane(Z.current),uc(wa,bn),fe.current||(te.current||iA(bn),lu(),Wr(Zr,bn),cu(Zr,wa,bn),Eh(),ot.current&&ot.current.position.addScaledVector(Pt.current,bn),ir(Kr,wa),Ue.current=te.current),t&&jr()}),Xe.createElement(et.Suspense,{fallback:null},Xe.createElement("group",{...K,ref:ot,dispose:null},t&&Xe.createElement("mesh",{ref:At},Xe.createElement("capsuleGeometry",{args:e}),Xe.createElement("meshNormalMaterial",{wireframe:!0})),Xe.createElement("group",{name:"BVHEcctrl-Model",ref:V},s)),t&&Xe.createElement("group",null,Xe.createElement(B5,{object:ot.current}),Xe.createElement("box3Helper",{args:[qr.current]}),Xe.createElement("mesh",{ref:st},Xe.createElement("octahedronGeometry",{args:[.05,0]}),Xe.createElement("meshNormalMaterial",null)),Xe.createElement("mesh",{ref:xt},Xe.createElement("octahedronGeometry",{args:[.05,0]}),Xe.createElement("meshNormalMaterial",null)),Xe.createElement("box3Helper",{args:[je.current]}),Xe.createElement("mesh",{ref:j},Xe.createElement("octahedronGeometry",{args:[.1,0]}),Xe.createElement("meshBasicMaterial",{color:"yellow",wireframe:!0})),Xe.createElement("mesh",{ref:Rt},Xe.createElement("octahedronGeometry",{args:[.1,0]}),Xe.createElement("meshBasicMaterial",{color:"yellow",wireframe:!0})),Xe.createElement("mesh",{scale:[1,.5,4],ref:pt},Xe.createElement("octahedronGeometry",{args:[.1,0]}),Xe.createElement("meshNormalMaterial",null)),Xe.createElement("arrowHelper",{ref:qt,args:[void 0,void 0,void 0,"#00f"]}),Xe.createElement("arrowHelper",{ref:Wt,args:[void 0,void 0,void 0,"#f00"]}),Xe.createElement("mesh",{ref:dt},Xe.createElement("octahedronGeometry",{args:[.12,0]}),Xe.createElement("meshBasicMaterial",{color:"red",transparent:!0,opacity:.2}))))});Xe.memo(Mk);const il={position:new F,linvel:new F,quaternion:new Ge,inputDir:new F,movingDir:new F,isOnGround:!1,isOnMovingPlatform:!1,animationStatus:"IDLE"};const jf=fp(s=>({colliderMeshesArray:[],setColliderMeshesArray:t=>s(e=>e.colliderMeshesArray.includes(t)?e:{colliderMeshesArray:[...e.colliderMeshesArray,t]}),removeColliderMesh:t=>s(e=>({colliderMeshesArray:e.colliderMeshesArray.filter(n=>n!==t)}))}));const wk=et.forwardRef(({children:s,debug:t=!1,debugVisualizeDepth:e=10,bvhName:n="",restitution:i=.05,friction:r=.8,excludeFloatHit:l=!1,excludeCollisionCheck:u=!1,BVHOptions:A={strategy:WE,verbose:!1,setBoundingBox:!0,maxDepth:40,maxLeafTris:10,indirect:!1},...d},m)=>{const g=et.useRef(null),y=et.useRef(null);return et.useImperativeHandle(m,()=>y.current,[]),et.useEffect(()=>{if(!y.current)return;y.current.updateMatrixWorld(!0);const v=[];if(y.current.traverse(S=>{if(!("isMesh"in S&&S.isMesh))return;const E=S,B=E.geometry,w=B.getAttribute("position"),Q=B.getAttribute("normal");if(!w||!Q)return;const R=B.index?B.toNonIndexed():B.clone(),D=new Fe;D.setAttribute("position",R.getAttribute("position").clone()),D.setAttribute("normal",R.getAttribute("normal").clone()),D.applyMatrix4(E.matrixWorld),v.push(new oe(D))}),v.length===0){console.warn("No compatible meshes found for static geometry generation.");return}const C=new BT(v);C.attributes=["position","normal"];const I=C.generate();return I.computeBoundsTree=dI,I.disposeBoundsTree=pI,I.computeBoundsTree(A),g.current=new oe(I),g.current.raycast=ST,g.current.name=n,g.current.userData={restitution:i,friction:r,excludeFloatHit:l,excludeCollisionCheck:u,type:"STATIC"},jf.getState().setColliderMeshesArray(g.current),()=>{var S,E;g.current&&(jf.getState().removeColliderMesh(g.current),(E=(S=g.current.geometry).disposeBoundsTree)==null||E.call(S),g.current.geometry.dispose(),Array.isArray(g.current.material)?g.current.material.forEach(B=>B.dispose()):g.current.material.dispose(),g.current.raycast=oe.prototype.raycast);for(const B of v)B.raycast=oe.prototype.raycast,B.geometry.dispose(),Array.isArray(B.material)?B.material.forEach(w=>w.dispose()):B.material.dispose()}},[]),et.useEffect(()=>{var v;g.current&&(g.current.visible=(v=d.visible)!=null?v:!0,g.current.name=n,g.current.userData.friction=r,g.current.userData.restitution=i,g.current.userData.excludeFloatHit=l,g.current.userData.excludeCollisionCheck=u)},[d.visible,n,r,i,l,u]),N3(t&&g,y0),Xe.createElement("group",{ref:y,...d,dispose:null},s)});Xe.memo(wk);const Tk=et.forwardRef(({children:s,debug:t=!1,debugVisualizeDepth:e=10,bvhName:n="",active:i=!0,restitution:r=.05,friction:l=.8,excludeFloatHit:u=!1,excludeCollisionCheck:A=!1,BVHOptions:d={strategy:WE,verbose:!1,setBoundingBox:!0,maxDepth:40,maxLeafTris:10,indirect:!1},...m},g)=>{const y=et.useRef(null),v=et.useRef(null);et.useImperativeHandle(g,()=>v.current,[]);const C=et.useRef(new F),I=et.useRef(new Ge),S=et.useRef(new Ge),E=et.useRef(new F),B=et.useRef(new Ge),w=et.useRef(new F),Q=et.useRef(new F),R=et.useRef(new F),D=et.useRef(new F),U=et.useRef(new F),P=et.useRef(new Ge);return et.useEffect(()=>{if(!v.current)return;v.current.updateMatrixWorld(!0);const z=[];if(v.current.traverse(Y=>{if(!("isMesh"in Y&&Y.isMesh))return;const W=Y,K=W.geometry,nt=K.getAttribute("position"),H=K.getAttribute("normal");if(!nt||!H)return;const tt=K.index?K.toNonIndexed():K.clone(),it=new Fe;it.setAttribute("position",tt.getAttribute("position").clone()),it.setAttribute("normal",tt.getAttribute("normal").clone()),it.applyMatrix4(W.matrixWorld),z.push(new oe(it))}),z.length===0){console.warn("No compatible meshes found for static geometry generation.");return}const L=new BT(z);L.attributes=["position","normal"];const k=L.generate();return k.computeBoundsTree=dI,k.disposeBoundsTree=pI,k.computeBoundsTree(d),y.current=new oe(k),y.current.raycast=ST,y.current.name=n,y.current.userData={active:i,restitution:r,friction:l,excludeFloatHit:u,excludeCollisionCheck:A,type:"KINEMATIC",deltaPos:new F,deltaQuat:new Ge,rotationAxis:new F,rotationAngle:0,linearVelocity:new F,angularVelocity:new F,center:new F},jf.getState().setColliderMeshesArray(y.current),()=>{var Y,W;y.current&&(jf.getState().removeColliderMesh(y.current),(W=(Y=y.current.geometry).disposeBoundsTree)==null||W.call(Y),y.current.geometry.dispose(),Array.isArray(y.current.material)?y.current.material.forEach(K=>K.dispose()):y.current.material.dispose(),y.current.raycast=oe.prototype.raycast);for(const K of z)K.raycast=oe.prototype.raycast,K.geometry.dispose(),Array.isArray(K.material)?K.material.forEach(nt=>nt.dispose()):K.material.dispose()}},[]),et.useEffect(()=>{var z;y.current&&(y.current.visible=(z=m.visible)!=null?z:!0,y.current.name=n,y.current.userData.active=i,y.current.userData.friction=l,y.current.userData.restitution=r,y.current.userData.excludeFloatHit=u,y.current.userData.excludeCollisionCheck=A)},[m.visible,n,i,l,r,u,A]),N3(t&&y,y0),FE((z,L)=>{if(!y.current||!v.current||!i)return;C.current.copy(E.current),I.current.copy(B.current),v.current.updateMatrixWorld(!0),y.current.matrix.copy(v.current.matrixWorld),y.current.matrix.decompose(y.current.position,y.current.quaternion,y.current.scale),y.current.updateMatrixWorld(!0),y.current.getWorldPosition(E.current),y.current.getWorldQuaternion(B.current),U.current.copy(E.current).sub(C.current),w.current.copy(U.current).divideScalar(L),S.current.copy(I.current).invert(),P.current.copy(B.current).multiply(S.current),P.current.w<0&&(P.current.x*=-1,P.current.y*=-1,P.current.z*=-1,P.current.w*=-1),P.current.normalize();const k=2*Math.acos(xT(P.current.w,-1,1));if(k>1e-6){const Y=Math.sin(k/2);D.current.set(P.current.x/Y,P.current.y/Y,P.current.z/Y).normalize()}else D.current.set(0,0,0);Q.current.copy(D.current).multiplyScalar(k/L).lerp(R.current,.3),R.current.copy(Q.current),y.current.userData.deltaPos=U.current,y.current.userData.deltaQuat=P.current,y.current.userData.rotationAxis=D.current,y.current.userData.rotationAngle=k,y.current.userData.linearVelocity=w.current,y.current.userData.angularVelocity=Q.current,y.current.userData.center=E.current}),Xe.createElement("group",{ref:v,...m,dispose:null},s)});Xe.memo(Tk);const Qk=et.forwardRef(({children:s,debug:t=!1,debugVisualizeDepth:e=10,restitution:n=.05,friction:i=.8,excludeFloatHit:r=!1,excludeCollisionCheck:l=!1,BVHOptions:u={strategy:WE,verbose:!1,setBoundingBox:!0,maxDepth:40,maxLeafTris:10,indirect:!1},...A},d)=>{const{scene:m,gl:g}=ss(),y=et.useRef(null),v=et.useRef(null),C=d??et.useRef(null),I=et.useRef(new he);return et.useEffect(()=>{if(C.current)return C.current.updateMatrixWorld(!0),C.current.traverse(S=>{if(!(S instanceof Hf))return;const E=S,B=E.geometry,w=B.getAttribute("position"),Q=B.getAttribute("normal");if(!w||!Q)return;const R=B.index?B.toNonIndexed():B.clone(),D=new Fe;D.setAttribute("position",R.getAttribute("position").clone()),D.setAttribute("normal",R.getAttribute("normal").clone()),D.applyMatrix4(E.matrixWorld),D.computeBoundsTree=dI,D.disposeBoundsTree=pI,D.computeBoundsTree(u),y.current=new Hf(D,void 0,E.count);for(let U=0;U<E.count;U++)E.getMatrixAt(U,I.current),I.current.premultiply(E.matrix),y.current.setMatrixAt(U,I.current);y.current.instanceMatrix.needsUpdate=!0,y.current.userData={restitution:n,friction:i,excludeFloatHit:r,excludeCollisionCheck:l,type:"STATIC"},jf.getState().setColliderMeshesArray(y.current)}),()=>{var S,E,B,w;y.current&&(jf.getState().removeColliderMesh(y.current),(E=(S=y.current.geometry).disposeBoundsTree)==null||E.call(S),y.current.geometry.dispose(),Array.isArray(y.current.material)?y.current.material.forEach(Q=>Q.dispose()):y.current.material.dispose(),y.current=null),v.current&&(m.remove(v.current),(w=(B=v.current).dispose)==null||w.call(B),v.current=null)}},[]),et.useEffect(()=>{var S;y.current&&(y.current.visible=(S=A.visible)!=null?S:!0,y.current.userData.friction=i,y.current.userData.restitution=n,y.current.userData.excludeFloatHit=r,y.current.userData.excludeCollisionCheck=l)},[A.visible,i,n,r,l]),et.useEffect(()=>{y.current&&(v.current?v.current.visible=t:(v.current=new y0(y.current,20),v.current.visible=t,m.add(v.current)))},[t]),Xe.createElement("group",{ref:C,...A,dispose:null},s)});Xe.memo(Qk);const MT=fp(Q3(s=>({joystickActive:!1,joystickX:0,joystickY:0,setJoystick:(t,e)=>s({joystickActive:!(t===0&&e===0),joystickX:t,joystickY:e}),resetJoystick:()=>s({joystickActive:!1,joystickX:0,joystickY:0})})));const Dk={userSelect:"none",MozUserSelect:"none",WebkitUserSelect:"none",msUserSelect:"none",touchAction:"none",overscrollBehavior:"none",position:"fixed",zIndex:"10",height:"200px",width:"200px",left:"0",bottom:"0",borderRadius:"50%"},Rk={width:"100px",height:"100px",background:"rgba(0, 0, 0, 0.1)",border:"2px solid white",borderRadius:"50%",position:"absolute",top:"50%",left:"50%",transform:"translate(-50%, -50%)",touchAction:"none"},Nk={width:"70px",height:"70px",background:"rgba(255, 255, 255, 0.8)",borderRadius:"50%",position:"absolute",top:"50%",left:"50%",transform:"translate(-50%, -50%)",transition:"transform 0.2s cubic-bezier(0.25, 1.5, 0.5, 1)",willChange:"transform",pointerEvents:"none"},Uk=s=>{var t;const e=(t=s.joystickMaxRadius)!=null?t:50,n=et.useRef(null),i=et.useRef(null),[r,l]=et.useState(!1),{setJoystick:u,resetJoystick:A}=MT(),d={...Dk,...s.joystickWrapperStyle},m={...Rk,...s.joystickBaseStyle},g={...Nk,...s.joystickKnobStyle},y=et.useCallback((C,I)=>{if(!i.current||!n.current)return;const S=n.current.getBoundingClientRect(),E=S.left+S.width/2,B=S.top+S.height/2;let w=C-E,Q=I-B;const R=Math.hypot(w,Q);R>e&&(w*=e/R,Q*=e/R),i.current.style.transform=`translate(calc(-50% + ${w}px), calc(-50% + ${Q}px))`,u(w/e,-Q/e)},[u]),v=et.useCallback(()=>{l(!1),i.current&&(i.current.style.transform="translate(-50%, -50%)"),A()},[A]);return et.useEffect(()=>()=>A(),[]),Xe.createElement("div",{id:"ecctrl-joystick",style:d,onContextMenu:C=>C.preventDefault(),onPointerDown:C=>{C.preventDefault(),C.stopPropagation(),y(C.clientX,C.clientY),l(!0)},onPointerMove:C=>r&&y(C.clientX,C.clientY),onPointerUp:v,onPointerLeave:v},Xe.createElement("div",{id:"joystick-base",style:m,ref:n},Xe.createElement("div",{id:"joystick-knob",style:g,ref:i})))},Lk=Xe.memo(Uk);const zk={userSelect:"none",MozUserSelect:"none",WebkitUserSelect:"none",msUserSelect:"none",touchAction:"none",overscrollBehavior:"none",position:"fixed",zIndex:"10",height:"60px",width:"60px",right:"0",bottom:"0",background:"rgba(0, 0, 0, 0.1)",borderRadius:"50%"},Ok={width:"45px",height:"45px",background:"rgba(255, 255, 255, 0.8)",borderRadius:"50%",position:"absolute",top:"50%",left:"50%",transform:"translate(-50%, -50%)",transition:"transform 0.2s cubic-bezier(0.25, 1.5, 0.5, 1)",willChange:"transform",display:"flex",justifyContent:"center",alignItems:"center",fontSize:"12px",fontWeight:"bold",fontFamily:"Arial, sans-serif",color:"LightGray",userSelect:"none",pointerEvents:"none"},Fk=s=>{const t=et.useRef(null),{setButtonActive:e,resetAllButtons:n}=wT(),i={...zk,...s.buttonWrapperStyle},r={...Ok,...s.buttonCapStyle},l=et.useCallback(A=>{A.preventDefault(),A.stopPropagation(),e(s.id,!0),t.current&&(t.current.style.transform="translate(-50%, -50%) scale(1.3)",t.current.style.opacity="0.5")},[s.id]),u=et.useCallback(()=>{e(s.id,!1),t.current&&(t.current.style.transform="translate(-50%, -50%) scale(1)",t.current.style.opacity="0.8")},[s.id]);return et.useEffect(()=>()=>n(),[]),Xe.createElement("div",{id:"ecctrl-virtual-button",style:i,onContextMenu:A=>A.preventDefault(),onPointerDown:A=>l(A),onPointerUp:u,onPointerLeave:u},Xe.createElement("div",{id:"virtual-button-cap",style:r,ref:t},s.label))};Xe.memo(Fk);const wT=fp(Q3(s=>({buttons:{},setButtonActive:(t,e)=>s(n=>({buttons:{...n.buttons,[t]:e}})),resetAllButtons:()=>s(()=>({buttons:{}}))})));const Pk=fp(s=>({animationStatus:"IDLE",setAnimationStatus:t=>s({animationStatus:t})})),Gk=()=>pn.jsx(pn.Fragment,{children:pn.jsx(Lk,{})});function kk(){const s=Tm(e=>e.isMobile),t=Tm(e=>e.status);return pn.jsxs(pn.Fragment,{children:[t!=="playing"&&pn.jsx(yG,{}),pn.jsxs("div",{className:"flex h-screen w-screen",children:[s&&t==="playing"&&pn.jsx(Gk,{}),pn.jsx(l5,{gl:{antialias:!1},dpr:1,camera:{position:[0,1.5,5],rotation:[0,0,0]},children:pn.jsx(gG,{})}),pn.jsx(A5,{})]})]})}wQ.createRoot(document.getElementById("root")).render(pn.jsx(et.StrictMode,{children:pn.jsx(kk,{})}));
